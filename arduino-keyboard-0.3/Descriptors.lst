   1               		.file	"Descriptors.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.init_vars,"ax",@progbits
  11               	.global	init_vars
  13               	init_vars:
  14               	.LFB66:
  15               		.file 1 "Descriptors.c"
   1:Descriptors.c **** /*
   2:Descriptors.c ****              LUFA Library
   3:Descriptors.c ****      Copyright (C) Dean Camera, 2010.
   4:Descriptors.c ****               
   5:Descriptors.c ****   dean [at] fourwalledcubicle [dot] com
   6:Descriptors.c ****       www.fourwalledcubicle.com
   7:Descriptors.c **** */
   8:Descriptors.c **** 
   9:Descriptors.c **** /*
  10:Descriptors.c ****   Copyright 2010  Dean Camera (dean [at] fourwalledcubicle [dot] com)
  11:Descriptors.c **** 	  
  12:Descriptors.c ****   Permission to use, copy, modify, distribute, and sell this 
  13:Descriptors.c ****   software and its documentation for any purpose is hereby granted
  14:Descriptors.c ****   without fee, provided that the above copyright notice appear in 
  15:Descriptors.c ****   all copies and that both that the copyright notice and this
  16:Descriptors.c ****   permission notice and warranty disclaimer appear in supporting 
  17:Descriptors.c ****   documentation, and that the name of the author not be used in 
  18:Descriptors.c ****   advertising or publicity pertaining to distribution of the 
  19:Descriptors.c ****   software without specific, written prior permission.
  20:Descriptors.c **** 
  21:Descriptors.c ****   The author disclaim all warranties with regard to this
  22:Descriptors.c ****   software, including all implied warranties of merchantability
  23:Descriptors.c ****   and fitness.  In no event shall the author be liable for any
  24:Descriptors.c ****   special, indirect or consequential damages or any damages
  25:Descriptors.c ****   whatsoever resulting from loss of use, data or profits, whether
  26:Descriptors.c ****   in an action of contract, negligence or other tortious action,
  27:Descriptors.c ****   arising out of or in connection with the use or performance of
  28:Descriptors.c ****   this software.
  29:Descriptors.c **** */
  30:Descriptors.c **** 
  31:Descriptors.c **** /** \file
  32:Descriptors.c ****  *
  33:Descriptors.c ****  *  USB Device Descriptors, for library use when in USB device mode. Descriptors are special 
  34:Descriptors.c ****  *  computer-readable structures which the host requests upon device enumeration, to determine
  35:Descriptors.c ****  *  the device's capabilities and functions.  
  36:Descriptors.c ****  */
  37:Descriptors.c **** 
  38:Descriptors.c **** #include "Descriptors.h"
  39:Descriptors.c ****   
  40:Descriptors.c **** uint8_t is_windows;
  41:Descriptors.c **** 
  42:Descriptors.c **** /** HID class report descriptor. This is a special descriptor constructed with values from the
  43:Descriptors.c ****  *  USBIF HID class specification to describe the reports and capabilities of the HID device. This
  44:Descriptors.c ****  *  descriptor is parsed by the host and its contents used to determine what data (and in what enco
  45:Descriptors.c ****  *  the device will send, and what it may be sent back from the host. Refer to the HID specificatio
  46:Descriptors.c ****  *  more details on HID report descriptors.
  47:Descriptors.c ****  */
  48:Descriptors.c **** const USB_Descriptor_HIDReport_Datatype_t PROGMEM KeyboardReport[] =
  49:Descriptors.c **** {
  50:Descriptors.c **** 	0x05, 0x01,          /* Usage Page (Generic Desktop)                    */
  51:Descriptors.c **** 	0x09, 0x06,          /* Usage (Keyboard)                                */
  52:Descriptors.c **** 	0xa1, 0x01,          /* Collection (Application)                        */
  53:Descriptors.c **** 	0x75, 0x01,          /*   Report Size (1)                               */
  54:Descriptors.c **** 	0x95, 0x08,          /*   Report Count (8)                              */
  55:Descriptors.c **** 	0x05, 0x07,          /*   Usage Page (Key Codes)                        */
  56:Descriptors.c **** 	0x19, 0xe0,          /*   Usage Minimum (Keyboard LeftControl)          */
  57:Descriptors.c **** 	0x29, 0xe7,          /*   Usage Maximum (Keyboard Right GUI)            */
  58:Descriptors.c **** 	0x15, 0x00,          /*   Logical Minimum (0)                           */
  59:Descriptors.c **** 	0x25, 0x01,          /*   Logical Maximum (1)                           */
  60:Descriptors.c **** 	0x81, 0x02,          /*   Input (Data, Variable, Absolute)              */
  61:Descriptors.c **** 	0x95, 0x01,          /*   Report Count (1)                              */
  62:Descriptors.c **** 	0x75, 0x08,          /*   Report Size (8)                               */
  63:Descriptors.c **** 	0x81, 0x03,          /*   Input (Const, Variable, Absolute)             */
  64:Descriptors.c **** 	0x95, 0x05,          /*   Report Count (5)                              */
  65:Descriptors.c **** 	0x75, 0x01,          /*   Report Size (1)                               */
  66:Descriptors.c **** 	0x05, 0x08,          /*   Usage Page (LEDs)                             */
  67:Descriptors.c **** 	0x19, 0x01,          /*   Usage Minimum (Num Lock)                      */
  68:Descriptors.c **** 	0x29, 0x05,          /*   Usage Maximum (Kana)                          */
  69:Descriptors.c **** 	0x91, 0x02,          /*   Output (Data, Variable, Absolute)             */
  70:Descriptors.c **** 	0x95, 0x01,          /*   Report Count (1)                              */
  71:Descriptors.c **** 	0x75, 0x03,          /*   Report Size (3)                               */
  72:Descriptors.c **** 	0x91, 0x03,          /*   Output (Const, Variable, Absolute)            */
  73:Descriptors.c **** 	0x95, 0x06,          /*   Report Count (6)                              */
  74:Descriptors.c **** 	0x75, 0x08,          /*   Report Size (8)                               */
  75:Descriptors.c **** 	0x15, 0x00,          /*   Logical Minimum (0)                           */
  76:Descriptors.c **** 	0x26, 231, 0,        /*   Logical Maximum (231)                         */
  77:Descriptors.c **** 	0x05, 0x07,          /*   Usage Page (Keyboard)                         */
  78:Descriptors.c **** 	0x19, 0x00,          /*   Usage Minimum (Reserved (no event indicated)) */
  79:Descriptors.c **** 	0x29, 231,           /*   Usage Maximum (Keyboard Application)          */
  80:Descriptors.c **** 	0x81, 0x00,          /*   Input (Data, Array, Absolute)                 */
  81:Descriptors.c **** 	0xc0                 /* End Collection                                  */
  82:Descriptors.c **** };
  83:Descriptors.c **** 
  84:Descriptors.c **** /** Device descriptor structure. This descriptor, located in FLASH memory, describes the overall
  85:Descriptors.c ****  *  device characteristics, including the supported USB version, control endpoint size and the
  86:Descriptors.c ****  *  number of device configurations. The descriptor is read out by the USB host when the enumeratio
  87:Descriptors.c ****  *  process begins.
  88:Descriptors.c ****  */
  89:Descriptors.c **** const USB_Descriptor_Device_t PROGMEM DeviceDescriptor =
  90:Descriptors.c **** {
  91:Descriptors.c **** 	.Header                 = {.Size = sizeof(USB_Descriptor_Device_t), .Type = DTYPE_Device},
  92:Descriptors.c **** 		
  93:Descriptors.c **** 	.USBSpecification       = VERSION_BCD(2.0),
  94:Descriptors.c **** 	.Class                  = 0x00,
  95:Descriptors.c **** 	.SubClass               = 0x00,
  96:Descriptors.c **** 	.Protocol               = 0x00,
  97:Descriptors.c **** 				
  98:Descriptors.c **** 	.Endpoint0Size          = FIXED_CONTROL_ENDPOINT_SIZE,
  99:Descriptors.c **** 		
 100:Descriptors.c **** 	.VendorID               = 0x03EB,
 101:Descriptors.c **** 	.ProductID              = 0x2042,
 102:Descriptors.c **** 	.ReleaseNumber          = 0x0000,
 103:Descriptors.c **** 		
 104:Descriptors.c **** 	.ManufacturerStrIndex   = 0x01,
 105:Descriptors.c **** 	.ProductStrIndex        = 0x02,
 106:Descriptors.c **** 	.SerialNumStrIndex      = NO_DESCRIPTOR,
 107:Descriptors.c **** 		
 108:Descriptors.c **** 	.NumberOfConfigurations = FIXED_NUM_CONFIGURATIONS
 109:Descriptors.c **** };
 110:Descriptors.c **** 
 111:Descriptors.c **** /** Configuration descriptor structure. This descriptor, located in FLASH memory, describes the usa
 112:Descriptors.c ****  *  of the device in one of its supported configurations, including information about any device in
 113:Descriptors.c ****  *  and endpoints. The descriptor is read out by the USB host during the enumeration process when s
 114:Descriptors.c ****  *  a configuration so that the host may correctly communicate with the USB device.
 115:Descriptors.c ****  */
 116:Descriptors.c **** const USB_Descriptor_Configuration_t PROGMEM ConfigurationDescriptor =
 117:Descriptors.c **** {
 118:Descriptors.c **** 	.Config = 
 119:Descriptors.c **** 		{
 120:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Configuration_Header_t), .Type = DTYPE_
 121:Descriptors.c **** 
 122:Descriptors.c **** 			.TotalConfigurationSize = sizeof(USB_Descriptor_Configuration_t),
 123:Descriptors.c **** 			.TotalInterfaces        = 1,
 124:Descriptors.c **** 				
 125:Descriptors.c **** 			.ConfigurationNumber    = 1,
 126:Descriptors.c **** 			.ConfigurationStrIndex  = NO_DESCRIPTOR,
 127:Descriptors.c **** 				
 128:Descriptors.c **** 			.ConfigAttributes       = (USB_CONFIG_ATTR_BUSPOWERED | USB_CONFIG_ATTR_SELFPOWERED),
 129:Descriptors.c **** 			
 130:Descriptors.c **** 			.MaxPowerConsumption    = USB_CONFIG_POWER_MA(100)
 131:Descriptors.c **** 		},
 132:Descriptors.c **** 		
 133:Descriptors.c **** 	.HID_Interface = 
 134:Descriptors.c **** 		{
 135:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Interface_t), .Type = DTYPE_Interface},
 136:Descriptors.c **** 
 137:Descriptors.c **** 			.InterfaceNumber        = 0x00,
 138:Descriptors.c **** 			.AlternateSetting       = 0x00,
 139:Descriptors.c **** 			
 140:Descriptors.c **** 			.TotalEndpoints         = 1,
 141:Descriptors.c **** 				
 142:Descriptors.c **** 			.Class                  = 0x03,
 143:Descriptors.c **** 			.SubClass               = 0x01,
 144:Descriptors.c **** 			.Protocol               = HID_BOOT_KEYBOARD_PROTOCOL,
 145:Descriptors.c **** 				
 146:Descriptors.c **** 			.InterfaceStrIndex      = NO_DESCRIPTOR
 147:Descriptors.c **** 		},
 148:Descriptors.c **** 
 149:Descriptors.c **** 	.HID_KeyboardHID = 
 150:Descriptors.c **** 		{  
 151:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_HID_Descriptor_t), .Type = DTYPE_HID},
 152:Descriptors.c **** 			
 153:Descriptors.c **** 			.HIDSpec                = VERSION_BCD(2.0),
 154:Descriptors.c **** 			.CountryCode            = 0x00,
 155:Descriptors.c **** 			.TotalReportDescriptors = 1,
 156:Descriptors.c **** 			.HIDReportType          = DTYPE_Report,
 157:Descriptors.c **** 			.HIDReportLength        = sizeof(KeyboardReport)
 158:Descriptors.c **** 		},
 159:Descriptors.c **** 		
 160:Descriptors.c **** 	.HID_ReportINEndpoint = 
 161:Descriptors.c **** 		{
 162:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Endpoint_t), .Type = DTYPE_Endpoint},
 163:Descriptors.c **** 
 164:Descriptors.c **** 			.EndpointAddress        = (ENDPOINT_DESCRIPTOR_DIR_IN | KEYBOARD_EPNUM),
 165:Descriptors.c **** 			.Attributes             = (EP_TYPE_INTERRUPT | ENDPOINT_ATTR_NO_SYNC | ENDPOINT_USAGE_DATA),
 166:Descriptors.c **** 			.EndpointSize           = KEYBOARD_EPSIZE,
 167:Descriptors.c **** 			.PollingIntervalMS      = 0x0A
 168:Descriptors.c **** 		},
 169:Descriptors.c **** };
 170:Descriptors.c **** 
 171:Descriptors.c **** /** Language descriptor structure. This descriptor, located in FLASH memory, is returned when the h
 172:Descriptors.c ****  *  the string descriptor with index 0 (the first index). It is actually an array of 16-bit integer
 173:Descriptors.c ****  *  via the language ID table available at USB.org what languages the device supports for its strin
 174:Descriptors.c ****  */
 175:Descriptors.c **** const USB_Descriptor_String_t PROGMEM LanguageString =
 176:Descriptors.c **** {
 177:Descriptors.c **** 	.Header                 = {.Size = USB_STRING_LEN(1), .Type = DTYPE_String},
 178:Descriptors.c **** 		
 179:Descriptors.c **** 	.UnicodeString          = {LANGUAGE_ID_ENG}
 180:Descriptors.c **** };
 181:Descriptors.c **** 
 182:Descriptors.c **** /** Manufacturer descriptor string. This is a Unicode string containing the manufacturer's details 
 183:Descriptors.c ****  *  form, and is read out upon request by the host when the appropriate string ID is requested, lis
 184:Descriptors.c ****  *  Descriptor.
 185:Descriptors.c ****  */
 186:Descriptors.c **** const USB_Descriptor_String_t PROGMEM ManufacturerString =
 187:Descriptors.c **** {
 188:Descriptors.c **** 	.Header                 = {.Size = USB_STRING_LEN(7), .Type = DTYPE_String},
 189:Descriptors.c **** 		
 190:Descriptors.c **** 	.UnicodeString          = L"Arduino"
 191:Descriptors.c **** };
 192:Descriptors.c **** 
 193:Descriptors.c **** /** Product descriptor string. This is a Unicode string containing the product's details in human r
 194:Descriptors.c ****  *  and is read out upon request by the host when the appropriate string ID is requested, listed in
 195:Descriptors.c ****  *  Descriptor.
 196:Descriptors.c ****  */
 197:Descriptors.c **** const USB_Descriptor_String_t PROGMEM ProductString =
 198:Descriptors.c **** {
 199:Descriptors.c **** 	.Header                 = {.Size = USB_STRING_LEN(8), .Type = DTYPE_String},
 200:Descriptors.c **** 		
 201:Descriptors.c **** 	.UnicodeString          = L"Keyboard"
 202:Descriptors.c **** };
 203:Descriptors.c **** 
 204:Descriptors.c **** /** This function is called by the library when in device mode, and must be overridden (see library
 205:Descriptors.c ****  *  documentation) by the application code so that the address and size of a requested descriptor c
 206:Descriptors.c ****  *  to the USB library. When the device receives a Get Descriptor request on the control endpoint, 
 207:Descriptors.c ****  *  is called so that the descriptor details can be passed back and the appropriate descriptor sent
 208:Descriptors.c ****  *  USB host.
 209:Descriptors.c ****  */
 210:Descriptors.c **** void init_vars()
 211:Descriptors.c **** {
  16               		.loc 1 211 0
  17               		.cfi_startproc
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
 212:Descriptors.c **** 	is_windows = 0;
  22               		.loc 1 212 0
  23 0000 1092 0000 		sts is_windows,__zero_reg__
  24 0004 0895      		ret
  25               		.cfi_endproc
  26               	.LFE66:
  28               		.section	.text.check_windows,"ax",@progbits
  29               	.global	check_windows
  31               	check_windows:
  32               	.LFB67:
 213:Descriptors.c **** }
 214:Descriptors.c **** uint8_t check_windows()
 215:Descriptors.c **** {
  33               		.loc 1 215 0
  34               		.cfi_startproc
  35               	/* prologue: function */
  36               	/* frame size = 0 */
  37               	/* stack size = 0 */
  38               	.L__stack_usage = 0
 216:Descriptors.c **** 	return is_windows;
 217:Descriptors.c **** }
  39               		.loc 1 217 0
  40 0000 8091 0000 		lds r24,is_windows
  41 0004 0895      		ret
  42               		.cfi_endproc
  43               	.LFE67:
  45               		.section	.text.CALLBACK_USB_GetDescriptor,"ax",@progbits
  46               	.global	CALLBACK_USB_GetDescriptor
  48               	CALLBACK_USB_GetDescriptor:
  49               	.LFB68:
 218:Descriptors.c **** uint16_t CALLBACK_USB_GetDescriptor(const uint16_t wValue, const uint8_t wIndex, void** const Descr
 219:Descriptors.c **** {
  50               		.loc 1 219 0
  51               		.cfi_startproc
  52               	.LVL0:
  53               	/* prologue: function */
  54               	/* frame size = 0 */
  55               	/* stack size = 0 */
  56               	.L__stack_usage = 0
 220:Descriptors.c **** 	const uint8_t  DescriptorType   = (wValue >> 8);
  57               		.loc 1 220 0
  58 0000 292F      		mov r18,r25
  59 0002 3327      		clr r19
  60               	.LVL1:
 221:Descriptors.c **** 	const uint8_t  DescriptorNumber = (wValue & 0xFF);
 222:Descriptors.c **** 
 223:Descriptors.c **** 	void*    Address = NULL;
 224:Descriptors.c **** 	uint16_t Size    = NO_DESCRIPTOR;
 225:Descriptors.c **** 	if(wValue == 0x03EE) /*the wValue unique only to windows OS on USB 2.0 and above*/
  61               		.loc 1 225 0
  62 0004 8E3E      		cpi r24,-18
  63 0006 63E0      		ldi r22,3
  64 0008 9607      		cpc r25,r22
  65               	.LVL2:
  66 000a 01F4      		brne .L4
 226:Descriptors.c **** 		is_windows = 1;
  67               		.loc 1 226 0
  68 000c 61E0      		ldi r22,lo8(1)
  69 000e 6093 0000 		sts is_windows,r22
  70               	.L4:
 227:Descriptors.c **** 	switch (DescriptorType)
  71               		.loc 1 227 0
  72 0012 2330      		cpi r18,3
  73 0014 3105      		cpc r19,__zero_reg__
  74 0016 01F0      		breq .L6
  75 0018 04F4      		brge .L7
  76 001a 2130      		cpi r18,1
  77 001c 3105      		cpc r19,__zero_reg__
  78 001e 01F0      		breq .L17
  79 0020 2230      		cpi r18,2
  80 0022 3105      		cpc r19,__zero_reg__
  81 0024 01F4      		brne .L18
  82               	.LVL3:
 228:Descriptors.c **** 	{
 229:Descriptors.c **** 		case DTYPE_Device: 
 230:Descriptors.c **** 			Address = (void*)&DeviceDescriptor;
 231:Descriptors.c **** 			Size    = sizeof(USB_Descriptor_Device_t);
 232:Descriptors.c **** 			break;
 233:Descriptors.c **** 		case DTYPE_Configuration: 
 234:Descriptors.c **** 			Address = (void*)&ConfigurationDescriptor;
 235:Descriptors.c **** 			Size    = sizeof(USB_Descriptor_Configuration_t);
  83               		.loc 1 235 0
  84 0026 82E2      		ldi r24,lo8(34)
  85 0028 90E0      		ldi r25,0
  86               	.LVL4:
 234:Descriptors.c **** 			Address = (void*)&ConfigurationDescriptor;
  87               		.loc 1 234 0
  88 002a 20E0      		ldi r18,lo8(ConfigurationDescriptor)
  89 002c 30E0      		ldi r19,hi8(ConfigurationDescriptor)
  90               	.LVL5:
 236:Descriptors.c **** 			break;
  91               		.loc 1 236 0
  92 002e 00C0      		rjmp .L8
  93               	.LVL6:
  94               	.L7:
 227:Descriptors.c **** 	switch (DescriptorType)
  95               		.loc 1 227 0
  96 0030 2132      		cpi r18,33
  97 0032 3105      		cpc r19,__zero_reg__
  98 0034 01F0      		breq .L10
  99 0036 2232      		cpi r18,34
 100 0038 3105      		cpc r19,__zero_reg__
 101 003a 01F4      		brne .L18
 102               	.LVL7:
 237:Descriptors.c **** 		case DTYPE_String: 
 238:Descriptors.c **** 			switch (DescriptorNumber)
 239:Descriptors.c **** 			{
 240:Descriptors.c **** 				case 0x00: 
 241:Descriptors.c **** 					Address = (void*)&LanguageString;
 242:Descriptors.c **** 					Size    = pgm_read_byte(&LanguageString.Header.Size);
 243:Descriptors.c **** 					break;
 244:Descriptors.c **** 				case 0x01: 
 245:Descriptors.c **** 					Address = (void*)&ManufacturerString;
 246:Descriptors.c **** 					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
 247:Descriptors.c **** 					break;
 248:Descriptors.c **** 				case 0x02: 
 249:Descriptors.c **** 					Address = (void*)&ProductString;
 250:Descriptors.c **** 					Size    = pgm_read_byte(&ProductString.Header.Size);
 251:Descriptors.c **** 					break;
 252:Descriptors.c **** 				case 0xEE:
 253:Descriptors.c **** 					is_windows = 1;
 254:Descriptors.c **** 					break;
 255:Descriptors.c **** 			}
 256:Descriptors.c **** 			
 257:Descriptors.c **** 			break;
 258:Descriptors.c **** 		case DTYPE_HID: 
 259:Descriptors.c **** 			Address = (void*)&ConfigurationDescriptor.HID_KeyboardHID;
 260:Descriptors.c **** 			Size    = sizeof(USB_HID_Descriptor_t);
 261:Descriptors.c **** 			break;
 262:Descriptors.c **** 		case DTYPE_Report: 
 263:Descriptors.c **** 			Address = (void*)&KeyboardReport;
 264:Descriptors.c **** 			Size    = sizeof(KeyboardReport);
 103               		.loc 1 264 0
 104 003c 80E4      		ldi r24,lo8(64)
 105 003e 90E0      		ldi r25,0
 106               	.LVL8:
 263:Descriptors.c **** 			Address = (void*)&KeyboardReport;
 107               		.loc 1 263 0
 108 0040 20E0      		ldi r18,lo8(KeyboardReport)
 109 0042 30E0      		ldi r19,hi8(KeyboardReport)
 110               	.LVL9:
 265:Descriptors.c **** 			break;
 111               		.loc 1 265 0
 112 0044 00C0      		rjmp .L8
 113               	.LVL10:
 114               	.L6:
 115 0046 9927      		clr r25
 116               	.LVL11:
 238:Descriptors.c **** 			switch (DescriptorNumber)
 117               		.loc 1 238 0
 118 0048 8130      		cpi r24,1
 119 004a 9105      		cpc r25,__zero_reg__
 120 004c 01F0      		breq .L12
 121 004e 04F4      		brge .L13
 122 0050 892B      		or r24,r25
 123 0052 01F4      		brne .L18
 124               	.LVL12:
 125               	.LBB2:
 242:Descriptors.c **** 					Size    = pgm_read_byte(&LanguageString.Header.Size);
 126               		.loc 1 242 0
 127 0054 E0E0      		ldi r30,lo8(LanguageString)
 128 0056 F0E0      		ldi r31,hi8(LanguageString)
 129 0058 00C0      		rjmp .L19
 130               	.LVL13:
 131               	.L13:
 132               	.LBE2:
 238:Descriptors.c **** 			switch (DescriptorNumber)
 133               		.loc 1 238 0
 134 005a 8230      		cpi r24,2
 135 005c 9105      		cpc r25,__zero_reg__
 136 005e 01F0      		breq .L15
 137 0060 8E3E      		cpi r24,-18
 138 0062 9105      		cpc r25,__zero_reg__
 139 0064 01F4      		brne .L18
 253:Descriptors.c **** 					is_windows = 1;
 140               		.loc 1 253 0
 141 0066 81E0      		ldi r24,lo8(1)
 142 0068 8093 0000 		sts is_windows,r24
 143 006c 00C0      		rjmp .L18
 144               	.L12:
 145               	.LVL14:
 146               	.LBB3:
 246:Descriptors.c **** 					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
 147               		.loc 1 246 0
 148 006e E0E0      		ldi r30,lo8(ManufacturerString)
 149 0070 F0E0      		ldi r31,hi8(ManufacturerString)
 150 0072 00C0      		rjmp .L19
 151               	.LVL15:
 152               	.L15:
 153               	.LBE3:
 154               	.LBB4:
 250:Descriptors.c **** 					Size    = pgm_read_byte(&ProductString.Header.Size);
 155               		.loc 1 250 0
 156 0074 E0E0      		ldi r30,lo8(ProductString)
 157 0076 F0E0      		ldi r31,hi8(ProductString)
 158               	.LVL16:
 159               	.L19:
 160               	/* #APP */
 161               	 ;  250 "Descriptors.c" 1
 162 0078 8491      		lpm r24, Z
 163               		
 164               	 ;  0 "" 2
 165               	.LVL17:
 166               	/* #NOAPP */
 167               	.LBE4:
 168 007a 90E0      		ldi r25,0
 169               	.LVL18:
 249:Descriptors.c **** 					Address = (void*)&ProductString;
 170               		.loc 1 249 0
 171 007c 9F01      		movw r18,r30
 172               	.LVL19:
 251:Descriptors.c **** 					break;
 173               		.loc 1 251 0
 174 007e 00C0      		rjmp .L8
 175               	.LVL20:
 176               	.L10:
 260:Descriptors.c **** 			Size    = sizeof(USB_HID_Descriptor_t);
 177               		.loc 1 260 0
 178 0080 89E0      		ldi r24,lo8(9)
 179 0082 90E0      		ldi r25,0
 180               	.LVL21:
 259:Descriptors.c **** 			Address = (void*)&ConfigurationDescriptor.HID_KeyboardHID;
 181               		.loc 1 259 0
 182 0084 20E0      		ldi r18,lo8(ConfigurationDescriptor+18)
 183 0086 30E0      		ldi r19,hi8(ConfigurationDescriptor+18)
 184               	.LVL22:
 261:Descriptors.c **** 			break;
 185               		.loc 1 261 0
 186 0088 00C0      		rjmp .L8
 187               	.LVL23:
 188               	.L17:
 231:Descriptors.c **** 			Size    = sizeof(USB_Descriptor_Device_t);
 189               		.loc 1 231 0
 190 008a 82E1      		ldi r24,lo8(18)
 191 008c 90E0      		ldi r25,0
 192               	.LVL24:
 230:Descriptors.c **** 			Address = (void*)&DeviceDescriptor;
 193               		.loc 1 230 0
 194 008e 20E0      		ldi r18,lo8(DeviceDescriptor)
 195 0090 30E0      		ldi r19,hi8(DeviceDescriptor)
 196               	.LVL25:
 197 0092 00C0      		rjmp .L8
 198               	.LVL26:
 199               	.L18:
 224:Descriptors.c **** 	uint16_t Size    = NO_DESCRIPTOR;
 200               		.loc 1 224 0
 201 0094 80E0      		ldi r24,0
 202 0096 90E0      		ldi r25,0
 223:Descriptors.c **** 	void*    Address = NULL;
 203               		.loc 1 223 0
 204 0098 20E0      		ldi r18,0
 205 009a 30E0      		ldi r19,0
 206               	.LVL27:
 207               	.L8:
 266:Descriptors.c **** 	}
 267:Descriptors.c **** 	
 268:Descriptors.c **** 	*DescriptorAddress = Address;
 208               		.loc 1 268 0
 209 009c FA01      		movw r30,r20
 210 009e 3183      		std Z+1,r19
 211 00a0 2083      		st Z,r18
 269:Descriptors.c **** 	return Size;
 270:Descriptors.c **** }
 212               		.loc 1 270 0
 213 00a2 0895      		ret
 214               		.cfi_endproc
 215               	.LFE68:
 217               	.global	ProductString
 218               		.section	.progmem.data,"a",@progbits
 221               	ProductString:
 222 0000 12        		.byte	18
 223 0001 03        		.byte	3
 224 0002 4B00      		.string	"K"
 225 0004 6500      		.string	"e"
 226 0006 7900      		.string	"y"
 227 0008 6200      		.string	"b"
 228 000a 6F00      		.string	"o"
 229 000c 6100      		.string	"a"
 230 000e 7200      		.string	"r"
 231 0010 6400      		.string	"d"
 232 0012 00        		.string	""
 233 0013 00        		.string	""
 234               	.global	ManufacturerString
 237               	ManufacturerString:
 238 0014 10        		.byte	16
 239 0015 03        		.byte	3
 240 0016 4100      		.string	"A"
 241 0018 7200      		.string	"r"
 242 001a 6400      		.string	"d"
 243 001c 7500      		.string	"u"
 244 001e 6900      		.string	"i"
 245 0020 6E00      		.string	"n"
 246 0022 6F00      		.string	"o"
 247 0024 00        		.string	""
 248 0025 00        		.string	""
 249               	.global	LanguageString
 252               	LanguageString:
 253 0026 04        		.byte	4
 254 0027 03        		.byte	3
 255 0028 0904      		.word	1033
 256               	.global	ConfigurationDescriptor
 259               	ConfigurationDescriptor:
 260 002a 09        		.byte	9
 261 002b 02        		.byte	2
 262 002c 2200      		.word	34
 263 002e 01        		.byte	1
 264 002f 01        		.byte	1
 265 0030 00        		.byte	0
 266 0031 C0        		.byte	-64
 267 0032 32        		.byte	50
 268 0033 09        		.byte	9
 269 0034 04        		.byte	4
 270 0035 00        		.byte	0
 271 0036 00        		.byte	0
 272 0037 01        		.byte	1
 273 0038 03        		.byte	3
 274 0039 01        		.byte	1
 275 003a 01        		.byte	1
 276 003b 00        		.byte	0
 277 003c 09        		.byte	9
 278 003d 21        		.byte	33
 279 003e 0002      		.word	512
 280 0040 00        		.byte	0
 281 0041 01        		.byte	1
 282 0042 22        		.byte	34
 283 0043 4000      		.word	64
 284 0045 07        		.byte	7
 285 0046 05        		.byte	5
 286 0047 81        		.byte	-127
 287 0048 03        		.byte	3
 288 0049 0800      		.word	8
 289 004b 0A        		.byte	10
 290               	.global	DeviceDescriptor
 293               	DeviceDescriptor:
 294 004c 12        		.byte	18
 295 004d 01        		.byte	1
 296 004e 0002      		.word	512
 297 0050 00        		.byte	0
 298 0051 00        		.byte	0
 299 0052 00        		.byte	0
 300 0053 08        		.byte	8
 301 0054 EB03      		.word	1003
 302 0056 4220      		.word	8258
 303 0058 0000      		.word	0
 304 005a 01        		.byte	1
 305 005b 02        		.byte	2
 306 005c 00        		.byte	0
 307 005d 01        		.byte	1
 308               	.global	KeyboardReport
 311               	KeyboardReport:
 312 005e 05        		.byte	5
 313 005f 01        		.byte	1
 314 0060 09        		.byte	9
 315 0061 06        		.byte	6
 316 0062 A1        		.byte	-95
 317 0063 01        		.byte	1
 318 0064 75        		.byte	117
 319 0065 01        		.byte	1
 320 0066 95        		.byte	-107
 321 0067 08        		.byte	8
 322 0068 05        		.byte	5
 323 0069 07        		.byte	7
 324 006a 19        		.byte	25
 325 006b E0        		.byte	-32
 326 006c 29        		.byte	41
 327 006d E7        		.byte	-25
 328 006e 15        		.byte	21
 329 006f 00        		.byte	0
 330 0070 25        		.byte	37
 331 0071 01        		.byte	1
 332 0072 81        		.byte	-127
 333 0073 02        		.byte	2
 334 0074 95        		.byte	-107
 335 0075 01        		.byte	1
 336 0076 75        		.byte	117
 337 0077 08        		.byte	8
 338 0078 81        		.byte	-127
 339 0079 03        		.byte	3
 340 007a 95        		.byte	-107
 341 007b 05        		.byte	5
 342 007c 75        		.byte	117
 343 007d 01        		.byte	1
 344 007e 05        		.byte	5
 345 007f 08        		.byte	8
 346 0080 19        		.byte	25
 347 0081 01        		.byte	1
 348 0082 29        		.byte	41
 349 0083 05        		.byte	5
 350 0084 91        		.byte	-111
 351 0085 02        		.byte	2
 352 0086 95        		.byte	-107
 353 0087 01        		.byte	1
 354 0088 75        		.byte	117
 355 0089 03        		.byte	3
 356 008a 91        		.byte	-111
 357 008b 03        		.byte	3
 358 008c 95        		.byte	-107
 359 008d 06        		.byte	6
 360 008e 75        		.byte	117
 361 008f 08        		.byte	8
 362 0090 15        		.byte	21
 363 0091 00        		.byte	0
 364 0092 26        		.byte	38
 365 0093 E7        		.byte	-25
 366 0094 00        		.byte	0
 367 0095 05        		.byte	5
 368 0096 07        		.byte	7
 369 0097 19        		.byte	25
 370 0098 00        		.byte	0
 371 0099 29        		.byte	41
 372 009a E7        		.byte	-25
 373 009b 81        		.byte	-127
 374 009c 00        		.byte	0
 375 009d C0        		.byte	-64
 376               		.comm	is_windows,1,1
 377               		.text
 378               	.Letext0:
 379               		.file 2 "/usr/lib/avr/include/stdint.h"
 380               		.file 3 "/usr/lib/gcc/avr/4.8.2/include/stddef.h"
 381               		.file 4 "../lufa-LUFA/LUFA/Drivers/USB/HighLevel/../LowLevel/../HighLevel/StdDescriptors.h"
 382               		.file 5 "../lufa-LUFA/LUFA/Drivers/USB/Class/Device/../Common/HID.h"
 383               		.file 6 "Descriptors.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 Descriptors.c
     /tmp/cc8ppy6H.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc8ppy6H.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc8ppy6H.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc8ppy6H.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc8ppy6H.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc8ppy6H.s:13     .text.init_vars:0000000000000000 init_vars
                            *COM*:0000000000000001 is_windows
     /tmp/cc8ppy6H.s:31     .text.check_windows:0000000000000000 check_windows
     /tmp/cc8ppy6H.s:48     .text.CALLBACK_USB_GetDescriptor:0000000000000000 CALLBACK_USB_GetDescriptor
     /tmp/cc8ppy6H.s:259    .progmem.data:000000000000002a ConfigurationDescriptor
     /tmp/cc8ppy6H.s:311    .progmem.data:000000000000005e KeyboardReport
     /tmp/cc8ppy6H.s:252    .progmem.data:0000000000000026 LanguageString
     /tmp/cc8ppy6H.s:237    .progmem.data:0000000000000014 ManufacturerString
     /tmp/cc8ppy6H.s:221    .progmem.data:0000000000000000 ProductString
     /tmp/cc8ppy6H.s:293    .progmem.data:000000000000004c DeviceDescriptor

UNDEFINED SYMBOLS
__do_clear_bss
