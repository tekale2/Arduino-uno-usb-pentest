
Webserver.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000001c4  00800100  00007b94  00007c28  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00007b94  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000b20  008002c4  008002c4  00007dec  2**0
                  ALLOC
  3 .stab         00002fe8  00000000  00000000  00007dec  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00001342  00000000  00000000  0000add4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  0000c116  2**0
                  CONTENTS, READONLY
  6 .debug_aranges 00000f08  00000000  00000000  0000c127  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00021f62  00000000  00000000  0000d02f  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 0000773b  00000000  00000000  0002ef91  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000aba2  00000000  00000000  000366cc  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00002e30  00000000  00000000  00041270  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00008467  00000000  00000000  000440a0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00014ad0  00000000  00000000  0004c507  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 000012f0  00000000  00000000  00060fd7  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
#include "HIDParser.h"

uint8_t USB_ProcessHIDReport(const uint8_t* ReportData,
                             uint16_t ReportSize,
                             HID_ReportInfo_t* const ParserData)
{
       0:	07 c2       	rjmp	.+1038   	; 0x410 <__ctors_end>
       2:	00 00       	nop
       4:	23 c2       	rjmp	.+1094   	; 0x44c <__bad_interrupt>
       6:	00 00       	nop
       8:	21 c2       	rjmp	.+1090   	; 0x44c <__bad_interrupt>
       a:	00 00       	nop
       c:	1f c2       	rjmp	.+1086   	; 0x44c <__bad_interrupt>
       e:	00 00       	nop
      10:	1d c2       	rjmp	.+1082   	; 0x44c <__bad_interrupt>
      12:	00 00       	nop
      14:	1b c2       	rjmp	.+1078   	; 0x44c <__bad_interrupt>
      16:	00 00       	nop
      18:	19 c2       	rjmp	.+1074   	; 0x44c <__bad_interrupt>
      1a:	00 00       	nop
      1c:	17 c2       	rjmp	.+1070   	; 0x44c <__bad_interrupt>
      1e:	00 00       	nop
      20:	15 c2       	rjmp	.+1066   	; 0x44c <__bad_interrupt>
      22:	00 00       	nop
      24:	13 c2       	rjmp	.+1062   	; 0x44c <__bad_interrupt>
      26:	00 00       	nop
      28:	0c 94 d3 2b 	jmp	0x57a6	; 0x57a6 <__vector_10>
      2c:	0c 94 31 2d 	jmp	0x5a62	; 0x5a62 <__vector_11>
      30:	0d c2       	rjmp	.+1050   	; 0x44c <__bad_interrupt>
      32:	00 00       	nop
      34:	0b c2       	rjmp	.+1046   	; 0x44c <__bad_interrupt>
      36:	00 00       	nop
	HID_StateTable_t      StateTable[HID_STATETABLE_STACK_DEPTH];
	HID_StateTable_t*     CurrStateTable     = &StateTable[0];
	HID_CollectionPath_t* CurrCollectionPath = NULL;
	HID_ReportSizeInfo_t* CurrReportIDInfo   = &ParserData->ReportIDSizes[0];
      38:	09 c2       	rjmp	.+1042   	; 0x44c <__bad_interrupt>
      3a:	00 00       	nop
      3c:	07 c2       	rjmp	.+1038   	; 0x44c <__bad_interrupt>
      3e:	00 00       	nop
      40:	05 c2       	rjmp	.+1034   	; 0x44c <__bad_interrupt>
      42:	00 00       	nop
      44:	0c 94 2e 1b 	jmp	0x365c	; 0x365c <__vector_17>
	uint16_t              UsageList[HID_USAGE_STACK_DEPTH];
	uint8_t               UsageListSize      = 0;
	HID_MinMax_t          UsageMinMax        = {0, 0};

	memset(ParserData,       0x00, sizeof(HID_ReportInfo_t));
      48:	01 c2       	rjmp	.+1026   	; 0x44c <__bad_interrupt>
      4a:	00 00       	nop
      4c:	ff c1       	rjmp	.+1022   	; 0x44c <__bad_interrupt>
      4e:	00 00       	nop
      50:	fd c1       	rjmp	.+1018   	; 0x44c <__bad_interrupt>
      52:	00 00       	nop
	memset(CurrStateTable,   0x00, sizeof(HID_StateTable_t));
      54:	fb c1       	rjmp	.+1014   	; 0x44c <__bad_interrupt>
      56:	00 00       	nop
      58:	f9 c1       	rjmp	.+1010   	; 0x44c <__bad_interrupt>
      5a:	00 00       	nop
      5c:	f7 c1       	rjmp	.+1006   	; 0x44c <__bad_interrupt>
      5e:	00 00       	nop
      60:	f5 c1       	rjmp	.+1002   	; 0x44c <__bad_interrupt>
	memset(CurrReportIDInfo, 0x00, sizeof(HID_ReportSizeInfo_t));
      62:	00 00       	nop
      64:	f3 c1       	rjmp	.+998    	; 0x44c <__bad_interrupt>
      66:	00 00       	nop
      68:	f1 c1       	rjmp	.+994    	; 0x44c <__bad_interrupt>
      6a:	00 00       	nop

	ParserData->TotalDeviceReports = 1;
      6c:	ef c1       	rjmp	.+990    	; 0x44c <__bad_interrupt>
      6e:	00 00       	nop
      70:	ed c1       	rjmp	.+986    	; 0x44c <__bad_interrupt>
      72:	00 00       	nop
      74:	eb c1       	rjmp	.+982    	; 0x44c <__bad_interrupt>
      76:	00 00       	nop
      78:	e9 c1       	rjmp	.+978    	; 0x44c <__bad_interrupt>
      7a:	00 00       	nop
      7c:	e7 c1       	rjmp	.+974    	; 0x44c <__bad_interrupt>
      7e:	00 00       	nop
	HID_StateTable_t*     CurrStateTable     = &StateTable[0];
	HID_CollectionPath_t* CurrCollectionPath = NULL;
	HID_ReportSizeInfo_t* CurrReportIDInfo   = &ParserData->ReportIDSizes[0];
	uint16_t              UsageList[HID_USAGE_STACK_DEPTH];
	uint8_t               UsageListSize      = 0;
	HID_MinMax_t          UsageMinMax        = {0, 0};
      80:	e5 c1       	rjmp	.+970    	; 0x44c <__bad_interrupt>
      82:	00 00       	nop
      84:	e3 c1       	rjmp	.+966    	; 0x44c <__bad_interrupt>
      86:	00 00       	nop
      88:	e1 c1       	rjmp	.+962    	; 0x44c <__bad_interrupt>
      8a:	00 00       	nop
	HID_StateTable_t      StateTable[HID_STATETABLE_STACK_DEPTH];
	HID_StateTable_t*     CurrStateTable     = &StateTable[0];
	HID_CollectionPath_t* CurrCollectionPath = NULL;
	HID_ReportSizeInfo_t* CurrReportIDInfo   = &ParserData->ReportIDSizes[0];
	uint16_t              UsageList[HID_USAGE_STACK_DEPTH];
	uint8_t               UsageListSize      = 0;
      8c:	df c1       	rjmp	.+958    	; 0x44c <__bad_interrupt>
      8e:	00 00       	nop
      90:	dd c1       	rjmp	.+954    	; 0x44c <__bad_interrupt>
                             uint16_t ReportSize,
                             HID_ReportInfo_t* const ParserData)
{
	HID_StateTable_t      StateTable[HID_STATETABLE_STACK_DEPTH];
	HID_StateTable_t*     CurrStateTable     = &StateTable[0];
	HID_CollectionPath_t* CurrCollectionPath = NULL;
      92:	00 00       	nop
      94:	db c1       	rjmp	.+950    	; 0x44c <__bad_interrupt>
      96:	00 00       	nop

00000098 <ProductString>:
      98:	1e 03 4c 00 55 00 46 00 41 00 20 00 57 00 65 00     ..L.U.F.A. .W.e.

					NewReportItem.BitOffset = CurrReportIDInfo->ReportSizeBits[NewReportItem.ItemType];

					CurrReportIDInfo->ReportSizeBits[NewReportItem.ItemType] += CurrStateTable->Attributes.BitSize;

					ParserData->LargestReportSizeBits = MAX(ParserData->LargestReportSizeBits, CurrReportIDInfo->ReportSizeBits[NewReportItem.ItemType]);
      a8:	62 00 73 00 65 00 72 00 76 00 65 00 72 00 00 00     b.s.e.r.v.e.r...

000000b8 <ManufacturerString>:

					CurrCollectionPath = &ParserData->CollectionPaths[1];

					while (CurrCollectionPath->Parent != NULL)
					{
						if (CurrCollectionPath == &ParserData->CollectionPaths[HID_MAX_COLLECTIONS - 1])
      b8:	18 03 44 00 65 00 61 00 6e 00 20 00 43 00 61 00     ..D.e.a.n. .C.a.
				break;

			case HID_RI_REPORT_ID(0):
				CurrStateTable->ReportID                    = ReportItemData;

				if (ParserData->UsingReportIDs)
      c8:	6d 00 65 00 72 00 61 00 00 00                       m.e.r.a...

000000d2 <LanguageString>:
				{
					CurrReportIDInfo = NULL;

					for (uint8_t i = 0; i < ParserData->TotalDeviceReports; i++)
      d2:	04 03 09 04                                         ....

000000d6 <ConfigurationDescriptor>:
	memset(CurrStateTable,   0x00, sizeof(HID_StateTable_t));
	memset(CurrReportIDInfo, 0x00, sizeof(HID_ReportSizeInfo_t));

	ParserData->TotalDeviceReports = 1;

	while (ReportSize)
      d6:	09 02 5d 00 03 01 00 80 32 08 0b 00 02 02 02 ff     ..].....2.......
	{
		uint8_t  HIDReportItem  = *ReportData;
      e6:	00 09 04 00 00 01 02 02 ff 00 05 24 00 10 01 04     ...........$....
		uint32_t ReportItemData;

		ReportData++;
		ReportSize--;

		switch (HIDReportItem & HID_RI_DATA_SIZE_MASK)
      f6:	24 02 00 05 24 06 00 01 07 05 85 03 08 00 ff 09     $...$...........
				ReportSize     -= 1;
				ReportData     += 1;
				break;

			default:
				ReportItemData  = 0;
     106:	04 01 00 02 0a 00 00 00 07 05 02 02 40 00 05 07     ............@...
		ReportSize--;

		switch (HIDReportItem & HID_RI_DATA_SIZE_MASK)
		{
			case HID_RI_DATA_BITS_32:
				ReportItemData  = (((uint32_t)ReportData[3] << 24) | ((uint32_t)ReportData[2] << 16) |
     116:	05 81 02 40 00 05 09 04 02 00 02 08 06 50 00 07     ...@.........P..
			                       ((uint16_t)ReportData[1] << 8)  | ReportData[0]);
     126:	05 83 02 40 00 05 07 05 04 02 40 00 05              ...@......@..

00000133 <DeviceDescriptor>:
     133:	12 01 10 01 ef 02 01 08 eb 03 69 20 01 00 01 02     ..........i ....
		ReportSize--;

		switch (HIDReportItem & HID_RI_DATA_SIZE_MASK)
		{
			case HID_RI_DATA_BITS_32:
				ReportItemData  = (((uint32_t)ReportData[3] << 24) | ((uint32_t)ReportData[2] << 16) |
     143:	dc 01                                               ..

00000145 <__c.2318>:
			                       ((uint16_t)ReportData[1] << 8)  | ReportData[0]);
				ReportSize     -= 4;
     145:	0d 0a 0d 0a 00                                      .....

0000014a <__c.2304>:
				ReportData     += 4;
     14a:	47 45 54 00                                         GET.

0000014e <DefaultMIMEType>:
				break;
     14e:	74 65 78 74 2f 70 6c 61 69 6e 00                    text/plain.

00000159 <DefaultDirFileName>:

			case HID_RI_DATA_BITS_16:
				ReportItemData  = (((uint16_t)ReportData[1] << 8) | (ReportData[0]));
     159:	69 6e 64 65 78 2e 68 74 6d 00                       index.htm.

00000163 <HTTP404Header>:
				ReportSize     -= 2;
     163:	48 54 54 50 2f 31 2e 31 20 34 30 34 20 4e 6f 74     HTTP/1.1 404 Not
				ReportData     += 2;
				break;

			case HID_RI_DATA_BITS_8:
				ReportItemData  = ReportData[0];
     173:	20 46 6f 75 6e 64 0d 0a 53 65 72 76 65 72 3a 20      Found..Server: 
				ReportSize     -= 1;
				ReportData     += 1;
     183:	4c 55 46 41 20 31 34 30 39 32 38 0d 0a 43 6f 6e     LUFA 140928..Con
			default:
				ReportItemData  = 0;
				break;
		}

		switch (HIDReportItem & (HID_RI_TYPE_MASK | HID_RI_TAG_MASK))
     193:	6e 65 63 74 69 6f 6e 3a 20 63 6c 6f 73 65 0d 0a     nection: close..
     1a3:	4d 49 4d 45 2d 76 65 72 73 69 6f 6e 3a 20 31 2e     MIME-version: 1.

			case HID_RI_USAGE_PAGE(0):
				if ((HIDReportItem & HID_RI_DATA_SIZE_MASK) == HID_RI_DATA_BITS_32)
				  CurrStateTable->Attributes.Usage.Page = (ReportItemData >> 16);

				CurrStateTable->Attributes.Usage.Page       = ReportItemData;
     1b3:	30 0d 0a 43 6f 6e 74 65 6e 74 2d 54 79 70 65 3a     0..Content-Type:
			default:
				ReportItemData  = 0;
				break;
		}

		switch (HIDReportItem & (HID_RI_TYPE_MASK | HID_RI_TAG_MASK))
     1c3:	20 74 65 78 74 2f 70 6c 61 69 6e 0d 0a 0d 0a 45      text/plain....E
     1d3:	72 72 6f 72 20 34 30 34 3a 20 46 69 6c 65 20 4e     rror 404: File N
     1e3:	6f 74 20 46 6f 75 6e 64 3a 20 2f 00                 ot Found: /.

000001ef <HTTP200Header>:
     1ef:	48 54 54 50 2f 31 2e 31 20 32 30 30 20 4f 4b 0d     HTTP/1.1 200 OK.
     1ff:	0a 53 65 72 76 65 72 3a 20 4c 55 46 41 20 31 34     .Server: LUFA 14
     20f:	30 39 32 38 0d 0a 43 6f 6e 6e 65 63 74 69 6f 6e     0928..Connection
     21f:	3a 20 63 6c 6f 73 65 0d 0a 4d 49 4d 45 2d 76 65     : close..MIME-ve
     22f:	72 73 69 6f 6e 3a 20 31 2e 30 0d 0a 43 6f 6e 74     rsion: 1.0..Cont
					  return HID_PARSE_InsufficientReportItems;

					memcpy(&ParserData->ReportItems[ParserData->TotalReportItems],
					       &NewReportItem, sizeof(HID_ReportItem_t));

					if (!(ReportItemData & HID_IOF_CONSTANT) && CALLBACK_HIDParser_FilterHIDReportItem(&NewReportItem))
     23f:	65 6e 74 2d 54 79 70 65 3a 20 00                    ent-Type: .

0000024a <__c.2454>:
     24a:	25 75 29 20 25 64 2e 25 64 2e 25 64 2e 25 64 20     %u) %d.%d.%d.%d 
		}

		switch (HIDReportItem & (HID_RI_TYPE_MASK | HID_RI_TAG_MASK))
		{
			case HID_RI_PUSH(0):
				if (CurrStateTable == &StateTable[HID_STATETABLE_STACK_DEPTH - 1])
     25a:	28 4c 6f 63 61 6c 20 50 6f 72 74 20 25 75 20 3c     (Local Port %u <
				  return HID_PARSE_HIDStackOverflow;

				memcpy((CurrStateTable + 1),
     26a:	3d 3e 20 52 65 6d 6f 74 65 20 50 6f 72 74 20 25     => Remote Port %

				CurrStateTable++;
				break;

			case HID_RI_POP(0):
				if (CurrStateTable == &StateTable[0])
     27a:	75 29 0d 0a 00                                      u)...

0000027f <__c.2444>:
     27f:	49 6e 76 61 6c 69 64 20 43 6f 6d 6d 61 6e 64 2e     Invalid Command.

				CurrStateTable->Attributes.Usage.Page       = ReportItemData;
				break;

			case HID_RI_LOGICAL_MINIMUM(0):
				CurrStateTable->Attributes.Logical.Minimum  = ReportItemData;
     28f:	0d 0a 00                                            ...

00000292 <CurrentConnectionsHeader>:
				break;

			case HID_RI_LOGICAL_MAXIMUM(0):
				CurrStateTable->Attributes.Logical.Maximum  = ReportItemData;
     292:	0d 0a 2a 20 43 75 72 72 65 6e 74 20 54 43 50 20     ..* Current TCP 
				break;

			case HID_RI_PHYSICAL_MINIMUM(0):
				CurrStateTable->Attributes.Physical.Minimum = ReportItemData;
     2a2:	43 6f 6e 6e 65 63 74 69 6f 6e 73 3a 20 2a 0d 0a     Connections: *..
				break;

			case HID_RI_PHYSICAL_MAXIMUM(0):
				CurrStateTable->Attributes.Physical.Maximum = ReportItemData;
     2b2:	00                                                  .

000002b3 <TELNETMenu>:
     2b3:	0d 0a 20 20 3d 3d 20 41 76 61 69 6c 61 62 6c 65     ..  == Available
			case HID_RI_UNIT_EXPONENT(0):
				CurrStateTable->Attributes.Unit.Exponent    = ReportItemData;
				break;

			case HID_RI_UNIT(0):
				CurrStateTable->Attributes.Unit.Type        = ReportItemData;
     2c3:	20 43 6f 6d 6d 61 6e 64 73 3a 20 3d 3d 0d 0a 20      Commands: ==.. 
			case HID_RI_REPORT_SIZE(0):
				CurrStateTable->Attributes.BitSize          = ReportItemData;
				break;

			case HID_RI_REPORT_COUNT(0):
				CurrStateTable->ReportCount                 = ReportItemData;
     2d3:	20 20 20 20 63 29 20 4c 69 73 74 20 41 63 74 69         c) List Acti
				break;

			case HID_RI_REPORT_ID(0):
				CurrStateTable->ReportID                    = ReportItemData;

				if (ParserData->UsingReportIDs)
     2e3:	76 65 20 54 43 50 20 43 6f 6e 6e 65 63 74 69 6f     ve TCP Connectio
				{
					CurrReportIDInfo = NULL;

					for (uint8_t i = 0; i < ParserData->TotalDeviceReports; i++)
     2f3:	6e 73 0d 0a 20 20 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d     ns..  ==========
     303:	3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 0d     ===============.
					{
						if (ParserData->ReportIDSizes[i].ReportID == CurrStateTable->ReportID)
     313:	0a 0d 0a 3e 00                                      ...>.

00000318 <WelcomeHeader>:
						{
							CurrReportIDInfo = &ParserData->ReportIDSizes[i];
     318:	2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a     ****************
     328:	2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a     ****************
						}
					}

					if (CurrReportIDInfo == NULL)
					{
						if (ParserData->TotalDeviceReports == HID_MAX_REPORT_IDS)
     338:	2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 0d 0a 2a 20     ************..* 
						  return HID_PARSE_InsufficientReportIDItems;

						CurrReportIDInfo = &ParserData->ReportIDSizes[ParserData->TotalDeviceReports++];
     348:	20 20 20 20 20 20 4c 55 46 41 20 75 49 50 20 57           LUFA uIP W
     358:	65 62 73 65 72 76 65 72 20 28 54 45 4c 4e 45 54     ebserver (TELNET
						memset(CurrReportIDInfo, 0x00, sizeof(HID_ReportSizeInfo_t));
     368:	29 20 20 20 20 20 20 20 20 2a 0d 0a 2a 2a 2a 2a     )        *..****
					}
				}

				ParserData->UsingReportIDs = true;

				CurrReportIDInfo->ReportID = CurrStateTable->ReportID;
     378:	2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a     ****************
				break;
     388:	2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a     ****************

			case HID_RI_USAGE(0):
				if (UsageListSize == HID_USAGE_STACK_DEPTH)
				  return HID_PARSE_UsageListOverflow;

				UsageList[UsageListSize++] = ReportItemData;
     398:	2a 2a 2a 2a 2a 2a 2a 2a 0d 0a 00                    ********...

000003a3 <AdapterSupportedOIDList>:
     3a3:	01 01 01 00 02 02 01 00 02 01 01 00 03 01 01 00     ................
			case HID_RI_USAGE_MAXIMUM(0):
				UsageMinMax.Maximum = ReportItemData;
				break;

			case HID_RI_COLLECTION(0):
				if (CurrCollectionPath == NULL)
     3b3:	04 01 01 00 06 01 01 00 11 01 01 00 07 01 01 00     ................
				{
					CurrCollectionPath = &ParserData->CollectionPaths[0];
     3c3:	0a 01 01 00 0b 01 01 00 0c 01 01 00 0d 01 01 00     ................
				}
				else
				{
					HID_CollectionPath_t* ParentCollectionPath = CurrCollectionPath;

					CurrCollectionPath = &ParserData->CollectionPaths[1];
     3d3:	0e 01 01 00 11 01 01 00 14 01 01 00 01 01 02 00     ................

					while (CurrCollectionPath->Parent != NULL)
					{
						if (CurrCollectionPath == &ParserData->CollectionPaths[HID_MAX_COLLECTIONS - 1])
     3e3:	02 01 02 00 03 01 02 00 04 01 02 00 05 01 02 00     ................
						  return HID_PARSE_InsufficientCollectionPaths;

						CurrCollectionPath++;
     3f3:	01 01 01 01 02 01 01 01 03 01 01 01 04 01 01 01     ................
					}

					CurrCollectionPath->Parent = ParentCollectionPath;
     403:	01 01 02 01 02 01 02 01 03 01 02 01 00              .............

00000410 <__ctors_end>:
				}

				CurrCollectionPath->Type       = ReportItemData;
     410:	11 24       	eor	r1, r1
				CurrCollectionPath->Usage.Page = CurrStateTable->Attributes.Usage.Page;
     412:	1f be       	out	0x3f, r1	; 63
     414:	cf ef       	ldi	r28, 0xFF	; 255
     416:	d0 e2       	ldi	r29, 0x20	; 32
     418:	de bf       	out	0x3e, r29	; 62
     41a:	cd bf       	out	0x3d, r28	; 61

0000041c <__do_copy_data>:
     41c:	12 e0       	ldi	r17, 0x02	; 2
     41e:	a0 e0       	ldi	r26, 0x00	; 0

				if (UsageListSize)
     420:	b1 e0       	ldi	r27, 0x01	; 1
     422:	e4 e9       	ldi	r30, 0x94	; 148
     424:	fb e7       	ldi	r31, 0x7B	; 123
     426:	00 e0       	ldi	r16, 0x00	; 0
     428:	0b bf       	out	0x3b, r16	; 59
				{
					CurrCollectionPath->Usage.Usage = UsageList[0];
     42a:	02 c0       	rjmp	.+4      	; 0x430 <__do_copy_data+0x14>
     42c:	07 90       	elpm	r0, Z+
     42e:	0d 92       	st	X+, r0
     430:	a4 3c       	cpi	r26, 0xC4	; 196
     432:	b1 07       	cpc	r27, r17
     434:	d9 f7       	brne	.-10     	; 0x42c <__do_copy_data+0x10>

00000436 <__do_clear_bss>:
     436:	1d e0       	ldi	r17, 0x0D	; 13
     438:	a4 ec       	ldi	r26, 0xC4	; 196
     43a:	b2 e0       	ldi	r27, 0x02	; 2
     43c:	01 c0       	rjmp	.+2      	; 0x440 <.do_clear_bss_start>

0000043e <.do_clear_bss_loop>:
     43e:	1d 92       	st	X+, r1

00000440 <.do_clear_bss_start>:

					for (uint8_t i = 1; i < UsageListSize; i++)
     440:	a4 3e       	cpi	r26, 0xE4	; 228
     442:	b1 07       	cpc	r27, r17
     444:	e1 f7       	brne	.-8      	; 0x43e <.do_clear_bss_loop>
     446:	33 d0       	rcall	.+102    	; 0x4ae <main>
     448:	0c 94 c8 3d 	jmp	0x7b90	; 0x7b90 <_exit>

0000044c <__bad_interrupt>:
					  UsageList[i - 1] = UsageList[i];
     44c:	d9 cd       	rjmp	.-1102   	; 0x0 <__vectors>

0000044e <SetupHardware>:
     44e:	84 b7       	in	r24, 0x34	; 52
     450:	87 7f       	andi	r24, 0xF7	; 247
     452:	84 bf       	out	0x34, r24	; 52

				if (UsageListSize)
				{
					CurrCollectionPath->Usage.Usage = UsageList[0];

					for (uint8_t i = 1; i < UsageListSize; i++)
     454:	88 e1       	ldi	r24, 0x18	; 24
     456:	0f b6       	in	r0, 0x3f	; 63
					  UsageList[i - 1] = UsageList[i];

					UsageListSize--;
     458:	f8 94       	cli
     45a:	80 93 60 00 	sts	0x0060, r24
     45e:	10 92 60 00 	sts	0x0060, r1
				}
				else if (UsageMinMax.Minimum <= UsageMinMax.Maximum)
     462:	0f be       	out	0x3f, r0	; 63
     464:	90 e0       	ldi	r25, 0x00	; 0
     466:	80 e8       	ldi	r24, 0x80	; 128
     468:	0f b6       	in	r0, 0x3f	; 63
     46a:	f8 94       	cli
     46c:	80 93 61 00 	sts	0x0061, r24
				{
					CurrCollectionPath->Usage.Usage = UsageMinMax.Minimum++;
     470:	90 93 61 00 	sts	0x0061, r25
     474:	0f be       	out	0x3f, r0	; 63
     476:	8d b1       	in	r24, 0x0d	; 13
     478:	83 60       	ori	r24, 0x03	; 3
     47a:	8d b9       	out	0x0d, r24	; 13
     47c:	8e b1       	in	r24, 0x0e	; 14
     47e:	83 60       	ori	r24, 0x03	; 3
     480:	8e b9       	out	0x0e, r24	; 14
     482:	20 9a       	sbi	0x04, 0	; 4
     484:	28 9a       	sbi	0x05, 0	; 5
     486:	84 b1       	in	r24, 0x04	; 4
     488:	86 60       	ori	r24, 0x06	; 6
				}

				break;

			case HID_RI_END_COLLECTION(0):
				if (CurrCollectionPath == NULL)
     48a:	84 b9       	out	0x04, r24	; 4
     48c:	23 98       	cbi	0x04, 3	; 4
     48e:	2b 9a       	sbi	0x05, 3	; 5
     490:	8d b5       	in	r24, 0x2d	; 45
     492:	81 60       	ori	r24, 0x01	; 1
     494:	8d bd       	out	0x2d, r24	; 45
     496:	20 98       	cbi	0x04, 0	; 4
     498:	8c e5       	ldi	r24, 0x5C	; 92
				  return HID_PARSE_UnexpectedEndCollection;

				CurrCollectionPath = CurrCollectionPath->Parent;
     49a:	8c bd       	out	0x2c, r24	; 44
     49c:	8a b1       	in	r24, 0x0a	; 10
     49e:	80 6f       	ori	r24, 0xF0	; 240
     4a0:	8a b9       	out	0x0a, r24	; 10
     4a2:	8b b1       	in	r24, 0x0b	; 11
     4a4:	8f 70       	andi	r24, 0x0F	; 15
     4a6:	8b b9       	out	0x0b, r24	; 11
     4a8:	83 e0       	ldi	r24, 0x03	; 3
     4aa:	0c 94 95 2b 	jmp	0x572a	; 0x572a <USB_Init>

000004ae <main>:
					ParserData->LargestReportSizeBits = MAX(ParserData->LargestReportSizeBits, CurrReportIDInfo->ReportSizeBits[NewReportItem.ItemType]);

					if (ParserData->TotalReportItems == HID_MAX_REPORTITEMS)
					  return HID_PARSE_InsufficientReportItems;

					memcpy(&ParserData->ReportItems[ParserData->TotalReportItems],
     4ae:	cf df       	rcall	.-98     	; 0x44e <SetupHardware>
     4b0:	8b b1       	in	r24, 0x0b	; 11
     4b2:	8f 70       	andi	r24, 0x0F	; 15
     4b4:	80 61       	ori	r24, 0x10	; 16
     4b6:	8b b9       	out	0x0b, r24	; 11
     4b8:	78 94       	sei
     4ba:	80 91 07 04 	lds	r24, 0x0407
     4be:	82 30       	cpi	r24, 0x02	; 2
     4c0:	11 f4       	brne	.+4      	; 0x4c6 <main+0x18>
     4c2:	7d d0       	rcall	.+250    	; 0x5be <USBHostMode_USBTask>
     4c4:	01 c0       	rjmp	.+2      	; 0x4c8 <main+0x1a>
     4c6:	3a d0       	rcall	.+116    	; 0x53c <USBDeviceMode_USBTask>
     4c8:	0e 94 b8 30 	call	0x6170	; 0x6170 <USB_USBTask>
					       &NewReportItem, sizeof(HID_ReportItem_t));

					if (!(ReportItemData & HID_IOF_CONSTANT) && CALLBACK_HIDParser_FilterHIDReportItem(&NewReportItem))
     4cc:	f6 cf       	rjmp	.-20     	; 0x4ba <main+0xc>

000004ce <CALLBACK_USB_GetDescriptor>:
     4ce:	29 2f       	mov	r18, r25
     4d0:	33 27       	eor	r19, r19
     4d2:	22 30       	cpi	r18, 0x02	; 2
     4d4:	31 05       	cpc	r19, r1
     4d6:	59 f0       	breq	.+22     	; 0x4ee <CALLBACK_USB_GetDescriptor+0x20>
     4d8:	23 30       	cpi	r18, 0x03	; 3
     4da:	31 05       	cpc	r19, r1
     4dc:	69 f0       	breq	.+26     	; 0x4f8 <CALLBACK_USB_GetDescriptor+0x2a>
     4de:	21 30       	cpi	r18, 0x01	; 1
     4e0:	31 05       	cpc	r19, r1
     4e2:	f9 f4       	brne	.+62     	; 0x522 <CALLBACK_USB_GetDescriptor+0x54>
				break;

			case HID_RI_INPUT(0):
			case HID_RI_OUTPUT(0):
			case HID_RI_FEATURE(0):
				for (uint8_t ReportItemNum = 0; ReportItemNum < CurrStateTable->ReportCount; ReportItemNum++)
     4e4:	82 e1       	ldi	r24, 0x12	; 18
     4e6:	90 e0       	ldi	r25, 0x00	; 0
     4e8:	23 e3       	ldi	r18, 0x33	; 51
     4ea:	31 e0       	ldi	r19, 0x01	; 1
     4ec:	1e c0       	rjmp	.+60     	; 0x52a <CALLBACK_USB_GetDescriptor+0x5c>
     4ee:	8d e5       	ldi	r24, 0x5D	; 93
				{
					HID_ReportItem_t NewReportItem;

					memcpy(&NewReportItem.Attributes,
     4f0:	90 e0       	ldi	r25, 0x00	; 0
     4f2:	26 ed       	ldi	r18, 0xD6	; 214
     4f4:	30 e0       	ldi	r19, 0x00	; 0
     4f6:	19 c0       	rjmp	.+50     	; 0x52a <CALLBACK_USB_GetDescriptor+0x5c>
     4f8:	99 27       	eor	r25, r25
     4fa:	81 30       	cpi	r24, 0x01	; 1
     4fc:	91 05       	cpc	r25, r1
     4fe:	41 f0       	breq	.+16     	; 0x510 <CALLBACK_USB_GetDescriptor+0x42>
     500:	82 30       	cpi	r24, 0x02	; 2
					       &CurrStateTable->Attributes,
					       sizeof(HID_ReportItem_Attributes_t));

					NewReportItem.ItemFlags      = ReportItemData;
     502:	91 05       	cpc	r25, r1
     504:	41 f0       	breq	.+16     	; 0x516 <CALLBACK_USB_GetDescriptor+0x48>
					NewReportItem.CollectionPath = CurrCollectionPath;
     506:	89 2b       	or	r24, r25
     508:	61 f4       	brne	.+24     	; 0x522 <CALLBACK_USB_GetDescriptor+0x54>
     50a:	e2 ed       	ldi	r30, 0xD2	; 210
     50c:	f0 e0       	ldi	r31, 0x00	; 0
     50e:	05 c0       	rjmp	.+10     	; 0x51a <CALLBACK_USB_GetDescriptor+0x4c>
     510:	e8 eb       	ldi	r30, 0xB8	; 184
     512:	f0 e0       	ldi	r31, 0x00	; 0
     514:	02 c0       	rjmp	.+4      	; 0x51a <CALLBACK_USB_GetDescriptor+0x4c>
					NewReportItem.ReportID       = CurrStateTable->ReportID;
     516:	e8 e9       	ldi	r30, 0x98	; 152
     518:	f0 e0       	ldi	r31, 0x00	; 0
     51a:	84 91       	lpm	r24, Z
     51c:	90 e0       	ldi	r25, 0x00	; 0

					if (UsageListSize)
     51e:	9f 01       	movw	r18, r30
     520:	04 c0       	rjmp	.+8      	; 0x52a <CALLBACK_USB_GetDescriptor+0x5c>
     522:	80 e0       	ldi	r24, 0x00	; 0
     524:	90 e0       	ldi	r25, 0x00	; 0
     526:	20 e0       	ldi	r18, 0x00	; 0
					{
						NewReportItem.Attributes.Usage.Usage = UsageList[0];
     528:	30 e0       	ldi	r19, 0x00	; 0
     52a:	fa 01       	movw	r30, r20
     52c:	31 83       	std	Z+1, r19	; 0x01
     52e:	20 83       	st	Z, r18
     530:	08 95       	ret

00000532 <LEDs_SetAllLEDs>:
     532:	9b b1       	in	r25, 0x0b	; 11
     534:	9f 70       	andi	r25, 0x0F	; 15
     536:	98 2b       	or	r25, r24
     538:	9b b9       	out	0x0b, r25	; 11
     53a:	08 95       	ret

0000053c <USBDeviceMode_USBTask>:
     53c:	80 91 07 04 	lds	r24, 0x0407

						for (uint8_t i = 1; i < UsageListSize; i++)
     540:	81 30       	cpi	r24, 0x01	; 1
     542:	49 f4       	brne	.+18     	; 0x556 <USBDeviceMode_USBTask+0x1a>
     544:	e5 d5       	rcall	.+3018   	; 0x1110 <uIPManagement_ManageNetwork>
     546:	89 e3       	ldi	r24, 0x39	; 57
     548:	91 e0       	ldi	r25, 0x01	; 1
						  UsageList[i - 1] = UsageList[i];
     54a:	0e 94 0a 35 	call	0x6a14	; 0x6a14 <RNDIS_Device_USBTask>
     54e:	80 e0       	ldi	r24, 0x00	; 0
     550:	91 e0       	ldi	r25, 0x01	; 1

					if (UsageListSize)
					{
						NewReportItem.Attributes.Usage.Usage = UsageList[0];

						for (uint8_t i = 1; i < UsageListSize; i++)
     552:	0c 94 47 31 	jmp	0x628e	; 0x628e <MS_Device_USBTask>
						  UsageList[i - 1] = UsageList[i];

						UsageListSize--;
     556:	08 95       	ret

00000558 <EVENT_USB_Device_Connect>:
     558:	80 e3       	ldi	r24, 0x30	; 48
     55a:	eb df       	rcall	.-42     	; 0x532 <LEDs_SetAllLEDs>
     55c:	7d c5       	rjmp	.+2810   	; 0x1058 <uIPManagement_Init>

0000055e <EVENT_USB_Device_Disconnect>:
     55e:	80 e1       	ldi	r24, 0x10	; 16
					}
					else if (UsageMinMax.Minimum <= UsageMinMax.Maximum)
     560:	e8 cf       	rjmp	.-48     	; 0x532 <LEDs_SetAllLEDs>

00000562 <EVENT_USB_Device_ConfigurationChanged>:
     562:	cf 93       	push	r28
     564:	89 e3       	ldi	r24, 0x39	; 57
     566:	91 e0       	ldi	r25, 0x01	; 1
     568:	0e 94 d9 34 	call	0x69b2	; 0x69b2 <RNDIS_Device_ConfigureEndpoints>
					{
						NewReportItem.Attributes.Usage.Usage = UsageMinMax.Minimum++;
     56c:	c8 2f       	mov	r28, r24
     56e:	80 e0       	ldi	r24, 0x00	; 0
     570:	91 e0       	ldi	r25, 0x01	; 1
     572:	0e 94 28 31 	call	0x6250	; 0x6250 <MS_Device_ConfigureEndpoints>
     576:	88 23       	and	r24, r24
     578:	21 f0       	breq	.+8      	; 0x582 <EVENT_USB_Device_ConfigurationChanged+0x20>
     57a:	cc 23       	and	r28, r28
					}

					uint8_t ItemTypeTag = (HIDReportItem & (HID_RI_TYPE_MASK | HID_RI_TAG_MASK));

					if (ItemTypeTag == HID_RI_INPUT(0))
     57c:	11 f0       	breq	.+4      	; 0x582 <EVENT_USB_Device_ConfigurationChanged+0x20>
     57e:	80 e2       	ldi	r24, 0x20	; 32
					  NewReportItem.ItemType = HID_REPORT_ITEM_In;
     580:	01 c0       	rjmp	.+2      	; 0x584 <EVENT_USB_Device_ConfigurationChanged+0x22>
     582:	80 e9       	ldi	r24, 0x90	; 144
					else if (ItemTypeTag == HID_RI_OUTPUT(0))
     584:	cf 91       	pop	r28
     586:	d5 cf       	rjmp	.-86     	; 0x532 <LEDs_SetAllLEDs>

00000588 <EVENT_USB_Device_ControlRequest>:
					  NewReportItem.ItemType = HID_REPORT_ITEM_Out;
     588:	89 e3       	ldi	r24, 0x39	; 57
     58a:	91 e0       	ldi	r25, 0x01	; 1
     58c:	0e 94 61 32 	call	0x64c2	; 0x64c2 <RNDIS_Device_ProcessControlRequest>
					else
					  NewReportItem.ItemType = HID_REPORT_ITEM_Feature;
     590:	80 e0       	ldi	r24, 0x00	; 0

					NewReportItem.BitOffset = CurrReportIDInfo->ReportSizeBits[NewReportItem.ItemType];
     592:	91 e0       	ldi	r25, 0x01	; 1
     594:	0c 94 e7 30 	jmp	0x61ce	; 0x61ce <MS_Device_ProcessControlRequest>

00000598 <CALLBACK_MS_Device_SCSICommandReceived>:
     598:	cf 93       	push	r28
     59a:	df 93       	push	r29
     59c:	ec 01       	movw	r28, r24
     59e:	80 ed       	ldi	r24, 0xD0	; 208
     5a0:	c8 df       	rcall	.-112    	; 0x532 <LEDs_SetAllLEDs>
     5a2:	ce 01       	movw	r24, r28
     5a4:	d5 d0       	rcall	.+426    	; 0x750 <SCSI_DecodeSCSICommand>
     5a6:	c8 2f       	mov	r28, r24
     5a8:	80 e2       	ldi	r24, 0x20	; 32
     5aa:	c3 df       	rcall	.-122    	; 0x532 <LEDs_SetAllLEDs>

					CurrReportIDInfo->ReportSizeBits[NewReportItem.ItemType] += CurrStateTable->Attributes.BitSize;
     5ac:	8c 2f       	mov	r24, r28
     5ae:	df 91       	pop	r29
     5b0:	cf 91       	pop	r28
     5b2:	08 95       	ret

000005b4 <LEDs_SetAllLEDs>:
     5b4:	9b b1       	in	r25, 0x0b	; 11
     5b6:	9f 70       	andi	r25, 0x0F	; 15
     5b8:	98 2b       	or	r25, r24
     5ba:	9b b9       	out	0x0b, r25	; 11

					ParserData->LargestReportSizeBits = MAX(ParserData->LargestReportSizeBits, CurrReportIDInfo->ReportSizeBits[NewReportItem.ItemType]);
     5bc:	08 95       	ret

000005be <USBHostMode_USBTask>:
     5be:	80 91 07 04 	lds	r24, 0x0407
     5c2:	82 30       	cpi	r24, 0x02	; 2
     5c4:	09 f4       	brne	.+2      	; 0x5c8 <USBHostMode_USBTask+0xa>
     5c6:	a4 c5       	rjmp	.+2888   	; 0x1110 <uIPManagement_ManageNetwork>
     5c8:	08 95       	ret

000005ca <EVENT_USB_Host_DeviceAttached>:
     5ca:	80 e3       	ldi	r24, 0x30	; 48
     5cc:	f3 cf       	rjmp	.-26     	; 0x5b4 <LEDs_SetAllLEDs>

000005ce <EVENT_USB_Host_DeviceUnattached>:
     5ce:	80 e1       	ldi	r24, 0x10	; 16
     5d0:	f1 cf       	rjmp	.-30     	; 0x5b4 <LEDs_SetAllLEDs>

000005d2 <EVENT_USB_Host_DeviceEnumerationComplete>:
     5d2:	0f 93       	push	r16
     5d4:	1f 93       	push	r17
     5d6:	cf 93       	push	r28
     5d8:	df 93       	push	r29
     5da:	cd b7       	in	r28, 0x3d	; 61
     5dc:	de b7       	in	r29, 0x3e	; 62
     5de:	c6 50       	subi	r28, 0x06	; 6
     5e0:	d2 40       	sbci	r29, 0x02	; 2
     5e2:	0f b6       	in	r0, 0x3f	; 63
     5e4:	f8 94       	cli
     5e6:	de bf       	out	0x3e, r29	; 62
     5e8:	0f be       	out	0x3f, r0	; 63
     5ea:	cd bf       	out	0x3d, r28	; 61
     5ec:	80 e3       	ldi	r24, 0x30	; 48
     5ee:	e2 df       	rcall	.-60     	; 0x5b4 <LEDs_SetAllLEDs>
     5f0:	20 e0       	ldi	r18, 0x00	; 0
     5f2:	32 e0       	ldi	r19, 0x02	; 2

					if (ParserData->TotalReportItems == HID_MAX_REPORTITEMS)
     5f4:	ae 01       	movw	r20, r28
     5f6:	4f 5f       	subi	r20, 0xFF	; 255
     5f8:	5f 4f       	sbci	r21, 0xFF	; 255
     5fa:	be 01       	movw	r22, r28
     5fc:	6b 5f       	subi	r22, 0xFB	; 251
					  return HID_PARSE_InsufficientReportItems;
     5fe:	7d 4f       	sbci	r23, 0xFD	; 253
     600:	81 e0       	ldi	r24, 0x01	; 1

					memcpy(&ParserData->ReportItems[ParserData->TotalReportItems],
					       &NewReportItem, sizeof(HID_ReportItem_t));

					if (!(ReportItemData & HID_IOF_CONSTANT) && CALLBACK_HIDParser_FilterHIDReportItem(&NewReportItem))
     602:	0e 94 8c 2d 	call	0x5b18	; 0x5b18 <USB_Host_GetDeviceConfigDescriptor>
     606:	88 23       	and	r24, r24
     608:	11 f0       	breq	.+4      	; 0x60e <EVENT_USB_Host_DeviceEnumerationComplete+0x3c>
     60a:	80 e9       	ldi	r24, 0x90	; 144
     60c:	4b c0       	rjmp	.+150    	; 0x6a4 <EVENT_USB_Host_DeviceEnumerationComplete+0xd2>
     60e:	cb 5f       	subi	r28, 0xFB	; 251
     610:	dd 4f       	sbci	r29, 0xFD	; 253
     612:	68 81       	ld	r22, Y
     614:	79 81       	ldd	r23, Y+1	; 0x01
     616:	c5 50       	subi	r28, 0x05	; 5
     618:	d2 40       	sbci	r29, 0x02	; 2
     61a:	ae 01       	movw	r20, r28
     61c:	4f 5f       	subi	r20, 0xFF	; 255
     61e:	5f 4f       	sbci	r21, 0xFF	; 255
     620:	8b e5       	ldi	r24, 0x5B	; 91
     622:	91 e0       	ldi	r25, 0x01	; 1
     624:	0e 94 8b 36 	call	0x6d16	; 0x6d16 <RNDIS_Host_ConfigurePipes>
     628:	81 11       	cpse	r24, r1
     62a:	ef cf       	rjmp	.-34     	; 0x60a <EVENT_USB_Host_DeviceEnumerationComplete+0x38>
     62c:	81 e0       	ldi	r24, 0x01	; 1
     62e:	0e 94 92 30 	call	0x6124	; 0x6124 <USB_Host_SetDeviceConfiguration>
     632:	81 11       	cpse	r24, r1
     634:	ea cf       	rjmp	.-44     	; 0x60a <EVENT_USB_Host_DeviceEnumerationComplete+0x38>
     636:	8b e5       	ldi	r24, 0x5B	; 91
     638:	91 e0       	ldi	r25, 0x01	; 1
     63a:	0e 94 5b 37 	call	0x6eb6	; 0x6eb6 <RNDIS_Host_InitializeDevice>
     63e:	88 23       	and	r24, r24
     640:	31 f0       	breq	.+12     	; 0x64e <EVENT_USB_Host_DeviceEnumerationComplete+0x7c>
     642:	80 e9       	ldi	r24, 0x90	; 144
     644:	b7 df       	rcall	.-146    	; 0x5b4 <LEDs_SetAllLEDs>
     646:	80 e0       	ldi	r24, 0x00	; 0
     648:	0e 94 92 30 	call	0x6124	; 0x6124 <USB_Host_SetDeviceConfiguration>
     64c:	2c c0       	rjmp	.+88     	; 0x6a6 <EVENT_USB_Host_DeviceEnumerationComplete+0xd4>
     64e:	89 e0       	ldi	r24, 0x09	; 9
     650:	90 e0       	ldi	r25, 0x00	; 0
     652:	a0 e0       	ldi	r26, 0x00	; 0
     654:	b0 e0       	ldi	r27, 0x00	; 0
     656:	cf 5f       	subi	r28, 0xFF	; 255
     658:	dd 4f       	sbci	r29, 0xFD	; 253
     65a:	88 83       	st	Y, r24
     65c:	99 83       	std	Y+1, r25	; 0x01
     65e:	aa 83       	std	Y+2, r26	; 0x02
     660:	bb 83       	std	Y+3, r27	; 0x03
     662:	c1 50       	subi	r28, 0x01	; 1
     664:	d2 40       	sbci	r29, 0x02	; 2
     666:	04 e0       	ldi	r16, 0x04	; 4
     668:	10 e0       	ldi	r17, 0x00	; 0
     66a:	9e 01       	movw	r18, r28
     66c:	2f 5f       	subi	r18, 0xFF	; 255
     66e:	3d 4f       	sbci	r19, 0xFD	; 253
     670:	4e e0       	ldi	r20, 0x0E	; 14
     672:	51 e0       	ldi	r21, 0x01	; 1
     674:	61 e0       	ldi	r22, 0x01	; 1
     676:	70 e0       	ldi	r23, 0x00	; 0
     678:	8b e5       	ldi	r24, 0x5B	; 91
     67a:	91 e0       	ldi	r25, 0x01	; 1
     67c:	0e 94 d9 37 	call	0x6fb2	; 0x6fb2 <RNDIS_Host_SetRNDISProperty>
     680:	81 11       	cpse	r24, r1
     682:	df cf       	rjmp	.-66     	; 0x642 <EVENT_USB_Host_DeviceEnumerationComplete+0x70>
     684:	06 e0       	ldi	r16, 0x06	; 6
     686:	10 e0       	ldi	r17, 0x00	; 0
					  ParserData->TotalReportItems++;
     688:	2a e0       	ldi	r18, 0x0A	; 10
     68a:	34 e0       	ldi	r19, 0x04	; 4
     68c:	42 e0       	ldi	r20, 0x02	; 2
     68e:	51 e0       	ldi	r21, 0x01	; 1
     690:	61 e0       	ldi	r22, 0x01	; 1

			default:
				break;
		}

		if ((HIDReportItem & HID_RI_TYPE_MASK) == HID_RI_TYPE_MAIN)
     692:	71 e0       	ldi	r23, 0x01	; 1
     694:	8b e5       	ldi	r24, 0x5B	; 91
     696:	91 e0       	ldi	r25, 0x01	; 1
     698:	0e 94 7e 38 	call	0x70fc	; 0x70fc <RNDIS_Host_QueryRNDISProperty>
     69c:	81 11       	cpse	r24, r1
		{
			UsageMinMax.Minimum = 0;
			UsageMinMax.Maximum = 0;
     69e:	d1 cf       	rjmp	.-94     	; 0x642 <EVENT_USB_Host_DeviceEnumerationComplete+0x70>
     6a0:	db d4       	rcall	.+2486   	; 0x1058 <uIPManagement_Init>
     6a2:	80 e2       	ldi	r24, 0x20	; 32
				break;
		}

		if ((HIDReportItem & HID_RI_TYPE_MASK) == HID_RI_TYPE_MAIN)
		{
			UsageMinMax.Minimum = 0;
     6a4:	87 df       	rcall	.-242    	; 0x5b4 <LEDs_SetAllLEDs>
     6a6:	ca 5f       	subi	r28, 0xFA	; 250
     6a8:	dd 4f       	sbci	r29, 0xFD	; 253
			UsageMinMax.Maximum = 0;
			UsageListSize       = 0;
     6aa:	0f b6       	in	r0, 0x3f	; 63
     6ac:	f8 94       	cli
     6ae:	de bf       	out	0x3e, r29	; 62
     6b0:	0f be       	out	0x3f, r0	; 63
		}
	}

	if (!(ParserData->TotalReportItems))
     6b2:	cd bf       	out	0x3d, r28	; 61
     6b4:	df 91       	pop	r29
     6b6:	cf 91       	pop	r28
     6b8:	1f 91       	pop	r17
	  return HID_PARSE_NoUnfilteredReportItems;
     6ba:	0f 91       	pop	r16
     6bc:	08 95       	ret

000006be <EVENT_USB_Host_HostError>:

		switch (HIDReportItem & (HID_RI_TYPE_MASK | HID_RI_TAG_MASK))
		{
			case HID_RI_PUSH(0):
				if (CurrStateTable == &StateTable[HID_STATETABLE_STACK_DEPTH - 1])
				  return HID_PARSE_HIDStackOverflow;
     6be:	0e 94 ee 2a 	call	0x55dc	; 0x55dc <USB_Disable>
				CurrStateTable++;
				break;

			case HID_RI_POP(0):
				if (CurrStateTable == &StateTable[0])
				  return HID_PARSE_HIDStackUnderflow;
     6c2:	80 e9       	ldi	r24, 0x90	; 144
     6c4:	77 df       	rcall	.-274    	; 0x5b4 <LEDs_SetAllLEDs>
				CurrReportIDInfo->ReportID = CurrStateTable->ReportID;
				break;

			case HID_RI_USAGE(0):
				if (UsageListSize == HID_USAGE_STACK_DEPTH)
				  return HID_PARSE_UsageListOverflow;
     6c6:	ff cf       	rjmp	.-2      	; 0x6c6 <EVENT_USB_Host_HostError+0x8>

000006c8 <EVENT_USB_Host_DeviceEnumerationFailed>:
     6c8:	80 e9       	ldi	r24, 0x90	; 144
					CurrCollectionPath = &ParserData->CollectionPaths[1];

					while (CurrCollectionPath->Parent != NULL)
					{
						if (CurrCollectionPath == &ParserData->CollectionPaths[HID_MAX_COLLECTIONS - 1])
						  return HID_PARSE_InsufficientCollectionPaths;
     6ca:	74 cf       	rjmp	.-280    	; 0x5b4 <LEDs_SetAllLEDs>

000006cc <SCSI_Command_ReadWrite_10>:
     6cc:	0f 93       	push	r16

				break;

			case HID_RI_END_COLLECTION(0):
				if (CurrCollectionPath == NULL)
				  return HID_PARSE_UnexpectedEndCollection;
     6ce:	1f 93       	push	r17
     6d0:	cf 93       	push	r28
	}

	if (!(ParserData->TotalReportItems))
	  return HID_PARSE_NoUnfilteredReportItems;

	return HID_PARSE_Successful;
     6d2:	df 93       	push	r29
     6d4:	ec 01       	movw	r28, r24
					}

					if (CurrReportIDInfo == NULL)
					{
						if (ParserData->TotalDeviceReports == HID_MAX_REPORT_IDS)
						  return HID_PARSE_InsufficientReportIDItems;
     6d6:	86 2f       	mov	r24, r22

	if (!(ParserData->TotalReportItems))
	  return HID_PARSE_NoUnfilteredReportItems;

	return HID_PARSE_Successful;
}
     6d8:	48 a1       	ldd	r20, Y+32	; 0x20
     6da:	5f 8d       	ldd	r21, Y+31	; 0x1f
     6dc:	6e 8d       	ldd	r22, Y+30	; 0x1e
     6de:	7d 8d       	ldd	r23, Y+29	; 0x1d
     6e0:	0b a1       	ldd	r16, Y+35	; 0x23
     6e2:	1a a1       	ldd	r17, Y+34	; 0x22
     6e4:	41 15       	cp	r20, r1
     6e6:	90 e8       	ldi	r25, 0x80	; 128
     6e8:	59 07       	cpc	r21, r25
     6ea:	61 05       	cpc	r22, r1
     6ec:	71 05       	cpc	r23, r1
     6ee:	68 f0       	brcs	.+26     	; 0x70a <SCSI_Command_ReadWrite_10+0x3e>
     6f0:	80 91 7d 01 	lds	r24, 0x017D
     6f4:	80 7f       	andi	r24, 0xF0	; 240
     6f6:	85 60       	ori	r24, 0x05	; 5
     6f8:	80 93 7d 01 	sts	0x017D, r24
     6fc:	81 e2       	ldi	r24, 0x21	; 33
     6fe:	80 93 87 01 	sts	0x0187, r24
     702:	10 92 88 01 	sts	0x0188, r1
     706:	80 e0       	ldi	r24, 0x00	; 0
     708:	1e c0       	rjmp	.+60     	; 0x746 <SCSI_Command_ReadWrite_10+0x7a>
     70a:	98 01       	movw	r18, r16

		return false;
	}

	/* Determine if the packet is a READ (10) or WRITE (10) command, call appropriate function */
	if (IsDataRead == DATA_READ)
     70c:	88 23       	and	r24, r24
     70e:	19 f0       	breq	.+6      	; 0x716 <SCSI_Command_ReadWrite_10+0x4a>
	  DataflashManager_ReadBlocks(MSInterfaceInfo, BlockAddress, TotalBlocks);
     710:	ce 01       	movw	r24, r28
     712:	cd d2       	rcall	.+1434   	; 0xcae <DataflashManager_ReadBlocks>
     714:	02 c0       	rjmp	.+4      	; 0x71a <SCSI_Command_ReadWrite_10+0x4e>
     716:	ce 01       	movw	r24, r28
	else
	  DataflashManager_WriteBlocks(MSInterfaceInfo, BlockAddress, TotalBlocks);
     718:	89 d1       	rcall	.+786    	; 0xa2c <DataflashManager_WriteBlocks>
     71a:	20 e0       	ldi	r18, 0x00	; 0
     71c:	30 e0       	ldi	r19, 0x00	; 0

	/* Update the bytes transferred counter and succeed the command */
	MSInterfaceInfo->State.CommandBlock.DataTransferLength -= ((uint32_t)TotalBlocks * VIRTUAL_MEMORY_BLOCK_SIZE);
     71e:	89 e0       	ldi	r24, 0x09	; 9
     720:	00 0f       	add	r16, r16
     722:	11 1f       	adc	r17, r17
     724:	22 1f       	adc	r18, r18
     726:	33 1f       	adc	r19, r19
     728:	8a 95       	dec	r24
     72a:	d1 f7       	brne	.-12     	; 0x720 <SCSI_Command_ReadWrite_10+0x54>
     72c:	4c 89       	ldd	r20, Y+20	; 0x14
     72e:	5d 89       	ldd	r21, Y+21	; 0x15
     730:	6e 89       	ldd	r22, Y+22	; 0x16
     732:	7f 89       	ldd	r23, Y+23	; 0x17
     734:	40 1b       	sub	r20, r16
     736:	51 0b       	sbc	r21, r17
     738:	62 0b       	sbc	r22, r18
     73a:	73 0b       	sbc	r23, r19
     73c:	4c 8b       	std	Y+20, r20	; 0x14
     73e:	5d 8b       	std	Y+21, r21	; 0x15
     740:	6e 8b       	std	Y+22, r22	; 0x16
     742:	7f 8b       	std	Y+23, r23	; 0x17
     744:	81 e0       	ldi	r24, 0x01	; 1
     746:	df 91       	pop	r29

	return true;
     748:	cf 91       	pop	r28
}
     74a:	1f 91       	pop	r17
     74c:	0f 91       	pop	r16
     74e:	08 95       	ret

00000750 <SCSI_DecodeSCSICommand>:
     750:	cf 92       	push	r12
     752:	df 92       	push	r13
 *  \param[in] MSInterfaceInfo  Pointer to the Mass Storage class interface structure that the command is associated with
 *
 *  \return Boolean \c true if the command completed successfully, \c false otherwise
 */
bool SCSI_DecodeSCSICommand(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
     754:	ef 92       	push	r14
     756:	ff 92       	push	r15
     758:	0f 93       	push	r16
     75a:	1f 93       	push	r17
     75c:	cf 93       	push	r28
     75e:	df 93       	push	r29
     760:	cd b7       	in	r28, 0x3d	; 61
     762:	de b7       	in	r29, 0x3e	; 62
     764:	28 97       	sbiw	r28, 0x08	; 8
     766:	0f b6       	in	r0, 0x3f	; 63
     768:	f8 94       	cli
     76a:	de bf       	out	0x3e, r29	; 62
     76c:	0f be       	out	0x3f, r0	; 63
     76e:	cd bf       	out	0x3d, r28	; 61
     770:	8c 01       	movw	r16, r24
	bool CommandSuccess = false;

	/* Run the appropriate SCSI command hander function based on the passed command */
	switch (MSInterfaceInfo->State.CommandBlock.SCSICommandData[0])
     772:	fc 01       	movw	r30, r24
     774:	83 8d       	ldd	r24, Z+27	; 0x1b
     776:	8d 31       	cpi	r24, 0x1D	; 29
     778:	09 f4       	brne	.+2      	; 0x77c <SCSI_DecodeSCSICommand+0x2c>
     77a:	ad c0       	rjmp	.+346    	; 0x8d6 <SCSI_DecodeSCSICommand+0x186>
     77c:	90 f4       	brcc	.+36     	; 0x7a2 <SCSI_DecodeSCSICommand+0x52>
     77e:	82 31       	cpi	r24, 0x12	; 18
     780:	09 f4       	brne	.+2      	; 0x784 <SCSI_DecodeSCSICommand+0x34>
     782:	4e c0       	rjmp	.+156    	; 0x820 <SCSI_DecodeSCSICommand+0xd0>
     784:	38 f4       	brcc	.+14     	; 0x794 <SCSI_DecodeSCSICommand+0x44>
     786:	88 23       	and	r24, r24
     788:	09 f4       	brne	.+2      	; 0x78c <SCSI_DecodeSCSICommand+0x3c>
     78a:	e2 c0       	rjmp	.+452    	; 0x950 <SCSI_DecodeSCSICommand+0x200>
     78c:	83 30       	cpi	r24, 0x03	; 3
     78e:	09 f4       	brne	.+2      	; 0x792 <SCSI_DecodeSCSICommand+0x42>
     790:	76 c0       	rjmp	.+236    	; 0x87e <SCSI_DecodeSCSICommand+0x12e>
     792:	e4 c0       	rjmp	.+456    	; 0x95c <SCSI_DecodeSCSICommand+0x20c>
     794:	8a 31       	cpi	r24, 0x1A	; 26
     796:	09 f4       	brne	.+2      	; 0x79a <SCSI_DecodeSCSICommand+0x4a>
     798:	c0 c0       	rjmp	.+384    	; 0x91a <SCSI_DecodeSCSICommand+0x1ca>
     79a:	8b 31       	cpi	r24, 0x1B	; 27
     79c:	09 f4       	brne	.+2      	; 0x7a0 <SCSI_DecodeSCSICommand+0x50>
     79e:	d8 c0       	rjmp	.+432    	; 0x950 <SCSI_DecodeSCSICommand+0x200>
     7a0:	dd c0       	rjmp	.+442    	; 0x95c <SCSI_DecodeSCSICommand+0x20c>
     7a2:	88 32       	cpi	r24, 0x28	; 40
     7a4:	09 f4       	brne	.+2      	; 0x7a8 <SCSI_DecodeSCSICommand+0x58>
     7a6:	b3 c0       	rjmp	.+358    	; 0x90e <SCSI_DecodeSCSICommand+0x1be>
     7a8:	a0 f5       	brcc	.+104    	; 0x812 <SCSI_DecodeSCSICommand+0xc2>
     7aa:	8e 31       	cpi	r24, 0x1E	; 30
     7ac:	09 f4       	brne	.+2      	; 0x7b0 <SCSI_DecodeSCSICommand+0x60>
     7ae:	d0 c0       	rjmp	.+416    	; 0x950 <SCSI_DecodeSCSICommand+0x200>
     7b0:	85 32       	cpi	r24, 0x25	; 37
     7b2:	09 f0       	breq	.+2      	; 0x7b6 <SCSI_DecodeSCSICommand+0x66>
     7b4:	d3 c0       	rjmp	.+422    	; 0x95c <SCSI_DecodeSCSICommand+0x20c>
 *
 *  \return Boolean \c true if the command completed successfully, \c false otherwise.
 */
static bool SCSI_Command_Read_Capacity_10(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	uint32_t LastBlockAddressInLUN = (VIRTUAL_MEMORY_BLOCKS - 1);
     7b6:	8f ef       	ldi	r24, 0xFF	; 255
     7b8:	9f e7       	ldi	r25, 0x7F	; 127
     7ba:	a0 e0       	ldi	r26, 0x00	; 0
     7bc:	b0 e0       	ldi	r27, 0x00	; 0
     7be:	8d 83       	std	Y+5, r24	; 0x05
     7c0:	9e 83       	std	Y+6, r25	; 0x06
     7c2:	af 83       	std	Y+7, r26	; 0x07
     7c4:	b8 87       	std	Y+8, r27	; 0x08
	uint32_t MediaBlockSize        = VIRTUAL_MEMORY_BLOCK_SIZE;
     7c6:	80 e0       	ldi	r24, 0x00	; 0
     7c8:	92 e0       	ldi	r25, 0x02	; 2
     7ca:	a0 e0       	ldi	r26, 0x00	; 0
     7cc:	b0 e0       	ldi	r27, 0x00	; 0
     7ce:	89 83       	std	Y+1, r24	; 0x01
     7d0:	9a 83       	std	Y+2, r25	; 0x02
     7d2:	ab 83       	std	Y+3, r26	; 0x03
     7d4:	bc 83       	std	Y+4, r27	; 0x04

	Endpoint_Write_Stream_BE(&LastBlockAddressInLUN, sizeof(LastBlockAddressInLUN), NULL);
     7d6:	40 e0       	ldi	r20, 0x00	; 0
     7d8:	50 e0       	ldi	r21, 0x00	; 0
     7da:	64 e0       	ldi	r22, 0x04	; 4
     7dc:	70 e0       	ldi	r23, 0x00	; 0
     7de:	ce 01       	movw	r24, r28
     7e0:	05 96       	adiw	r24, 0x05	; 5
     7e2:	0e 94 19 25 	call	0x4a32	; 0x4a32 <Endpoint_Write_Stream_BE>
	Endpoint_Write_Stream_BE(&MediaBlockSize, sizeof(MediaBlockSize), NULL);
     7e6:	40 e0       	ldi	r20, 0x00	; 0
     7e8:	50 e0       	ldi	r21, 0x00	; 0
     7ea:	64 e0       	ldi	r22, 0x04	; 4
     7ec:	70 e0       	ldi	r23, 0x00	; 0
     7ee:	ce 01       	movw	r24, r28
     7f0:	01 96       	adiw	r24, 0x01	; 1
     7f2:	0e 94 19 25 	call	0x4a32	; 0x4a32 <Endpoint_Write_Stream_BE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
     7f6:	80 91 e8 00 	lds	r24, 0x00E8
     7fa:	8e 77       	andi	r24, 0x7E	; 126
     7fc:	80 93 e8 00 	sts	0x00E8, r24
	Endpoint_ClearIN();

	/* Succeed the command and update the bytes transferred counter */
	MSInterfaceInfo->State.CommandBlock.DataTransferLength -= 8;
     800:	f8 01       	movw	r30, r16
     802:	84 89       	ldd	r24, Z+20	; 0x14
     804:	95 89       	ldd	r25, Z+21	; 0x15
     806:	a6 89       	ldd	r26, Z+22	; 0x16
     808:	b7 89       	ldd	r27, Z+23	; 0x17
     80a:	08 97       	sbiw	r24, 0x08	; 8
     80c:	a1 09       	sbc	r26, r1
     80e:	b1 09       	sbc	r27, r1
     810:	5d c0       	rjmp	.+186    	; 0x8cc <SCSI_DecodeSCSICommand+0x17c>
bool SCSI_DecodeSCSICommand(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	bool CommandSuccess = false;

	/* Run the appropriate SCSI command hander function based on the passed command */
	switch (MSInterfaceInfo->State.CommandBlock.SCSICommandData[0])
     812:	8a 32       	cpi	r24, 0x2A	; 42
     814:	09 f4       	brne	.+2      	; 0x818 <SCSI_DecodeSCSICommand+0xc8>
     816:	79 c0       	rjmp	.+242    	; 0x90a <SCSI_DecodeSCSICommand+0x1ba>
     818:	8f 32       	cpi	r24, 0x2F	; 47
     81a:	09 f4       	brne	.+2      	; 0x81e <SCSI_DecodeSCSICommand+0xce>
     81c:	99 c0       	rjmp	.+306    	; 0x950 <SCSI_DecodeSCSICommand+0x200>
     81e:	9e c0       	rjmp	.+316    	; 0x95c <SCSI_DecodeSCSICommand+0x20c>

				Temp = Data.Bytes[0];
				Data.Bytes[0] = Data.Bytes[1];
				Data.Bytes[1] = Temp;

				return Data.Word;
     820:	f8 01       	movw	r30, r16
     822:	e7 8c       	ldd	r14, Z+31	; 0x1f
     824:	f6 8c       	ldd	r15, Z+30	; 0x1e
{
	uint16_t AllocationLength  = SwapEndian_16(*(uint16_t*)&MSInterfaceInfo->State.CommandBlock.SCSICommandData[3]);
	uint16_t BytesTransferred  = MIN(AllocationLength, sizeof(InquiryData));

	/* Only the standard INQUIRY data is supported, check if any optional INQUIRY bits set */
	if ((MSInterfaceInfo->State.CommandBlock.SCSICommandData[1] & ((1 << 0) | (1 << 1))) ||
     826:	84 8d       	ldd	r24, Z+28	; 0x1c
     828:	83 70       	andi	r24, 0x03	; 3
     82a:	09 f0       	breq	.+2      	; 0x82e <SCSI_DecodeSCSICommand+0xde>
     82c:	58 c0       	rjmp	.+176    	; 0x8de <SCSI_DecodeSCSICommand+0x18e>
     82e:	85 8d       	ldd	r24, Z+29	; 0x1d
     830:	81 11       	cpse	r24, r1
     832:	55 c0       	rjmp	.+170    	; 0x8de <SCSI_DecodeSCSICommand+0x18e>
 *  \return Boolean \c true if the command completed successfully, \c false otherwise.
 */
static bool SCSI_Command_Inquiry(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	uint16_t AllocationLength  = SwapEndian_16(*(uint16_t*)&MSInterfaceInfo->State.CommandBlock.SCSICommandData[3]);
	uint16_t BytesTransferred  = MIN(AllocationLength, sizeof(InquiryData));
     834:	67 01       	movw	r12, r14
     836:	f5 e2       	ldi	r31, 0x25	; 37
     838:	ef 16       	cp	r14, r31
     83a:	f1 04       	cpc	r15, r1
     83c:	18 f0       	brcs	.+6      	; 0x844 <SCSI_DecodeSCSICommand+0xf4>
     83e:	24 e2       	ldi	r18, 0x24	; 36
     840:	c2 2e       	mov	r12, r18
     842:	d1 2c       	mov	r13, r1
		               SCSI_ASENSEQ_NO_QUALIFIER);

		return false;
	}

	Endpoint_Write_Stream_LE(&InquiryData, BytesTransferred, NULL);
     844:	40 e0       	ldi	r20, 0x00	; 0
     846:	50 e0       	ldi	r21, 0x00	; 0
     848:	b6 01       	movw	r22, r12
     84a:	8e e8       	ldi	r24, 0x8E	; 142
     84c:	91 e0       	ldi	r25, 0x01	; 1
     84e:	0e 94 d2 24 	call	0x49a4	; 0x49a4 <Endpoint_Write_Stream_LE>

	/* Pad out remaining bytes with 0x00 */
	Endpoint_Null_Stream((AllocationLength - BytesTransferred), NULL);
     852:	60 e0       	ldi	r22, 0x00	; 0
     854:	70 e0       	ldi	r23, 0x00	; 0
     856:	c7 01       	movw	r24, r14
     858:	8c 19       	sub	r24, r12
     85a:	9d 09       	sbc	r25, r13
     85c:	0e 94 95 24 	call	0x492a	; 0x492a <Endpoint_Null_Stream>
     860:	80 91 e8 00 	lds	r24, 0x00E8
     864:	8e 77       	andi	r24, 0x7E	; 126
     866:	80 93 e8 00 	sts	0x00E8, r24

	/* Finalize the stream transfer to send the last packet */
	Endpoint_ClearIN();

	/* Succeed the command and update the bytes transferred counter */
	MSInterfaceInfo->State.CommandBlock.DataTransferLength -= BytesTransferred;
     86a:	f8 01       	movw	r30, r16
     86c:	84 89       	ldd	r24, Z+20	; 0x14
     86e:	95 89       	ldd	r25, Z+21	; 0x15
     870:	a6 89       	ldd	r26, Z+22	; 0x16
     872:	b7 89       	ldd	r27, Z+23	; 0x17
     874:	8c 19       	sub	r24, r12
     876:	9d 09       	sbc	r25, r13
     878:	a1 09       	sbc	r26, r1
     87a:	b1 09       	sbc	r27, r1
     87c:	27 c0       	rjmp	.+78     	; 0x8cc <SCSI_DecodeSCSICommand+0x17c>
 *
 *  \return Boolean \c true if the command completed successfully, \c false otherwise.
 */
static bool SCSI_Command_Request_Sense(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	uint8_t  AllocationLength = MSInterfaceInfo->State.CommandBlock.SCSICommandData[4];
     87e:	f8 01       	movw	r30, r16
     880:	c7 8c       	ldd	r12, Z+31	; 0x1f
	uint8_t  BytesTransferred = MIN(AllocationLength, sizeof(SenseData));
     882:	dc 2c       	mov	r13, r12
     884:	f2 e1       	ldi	r31, 0x12	; 18
     886:	fc 15       	cp	r31, r12
     888:	10 f4       	brcc	.+4      	; 0x88e <SCSI_DecodeSCSICommand+0x13e>
     88a:	92 e1       	ldi	r25, 0x12	; 18
     88c:	d9 2e       	mov	r13, r25

	Endpoint_Write_Stream_LE(&SenseData, BytesTransferred, NULL);
     88e:	ed 2c       	mov	r14, r13
     890:	f1 2c       	mov	r15, r1
     892:	40 e0       	ldi	r20, 0x00	; 0
     894:	50 e0       	ldi	r21, 0x00	; 0
     896:	b7 01       	movw	r22, r14
     898:	8b e7       	ldi	r24, 0x7B	; 123
     89a:	91 e0       	ldi	r25, 0x01	; 1
     89c:	0e 94 d2 24 	call	0x49a4	; 0x49a4 <Endpoint_Write_Stream_LE>
	Endpoint_Null_Stream((AllocationLength - BytesTransferred), NULL);
     8a0:	8c 2d       	mov	r24, r12
     8a2:	90 e0       	ldi	r25, 0x00	; 0
     8a4:	60 e0       	ldi	r22, 0x00	; 0
     8a6:	70 e0       	ldi	r23, 0x00	; 0
     8a8:	8e 19       	sub	r24, r14
     8aa:	9f 09       	sbc	r25, r15
     8ac:	0e 94 95 24 	call	0x492a	; 0x492a <Endpoint_Null_Stream>
     8b0:	80 91 e8 00 	lds	r24, 0x00E8
     8b4:	8e 77       	andi	r24, 0x7E	; 126
     8b6:	80 93 e8 00 	sts	0x00E8, r24
	Endpoint_ClearIN();

	/* Succeed the command and update the bytes transferred counter */
	MSInterfaceInfo->State.CommandBlock.DataTransferLength -= BytesTransferred;
     8ba:	f8 01       	movw	r30, r16
     8bc:	84 89       	ldd	r24, Z+20	; 0x14
     8be:	95 89       	ldd	r25, Z+21	; 0x15
     8c0:	a6 89       	ldd	r26, Z+22	; 0x16
     8c2:	b7 89       	ldd	r27, Z+23	; 0x17
     8c4:	8d 19       	sub	r24, r13
     8c6:	91 09       	sbc	r25, r1
     8c8:	a1 09       	sbc	r26, r1
     8ca:	b1 09       	sbc	r27, r1
     8cc:	84 8b       	std	Z+20, r24	; 0x14
     8ce:	95 8b       	std	Z+21, r25	; 0x15
     8d0:	a6 8b       	std	Z+22, r26	; 0x16
     8d2:	b7 8b       	std	Z+23, r27	; 0x17
		case SCSI_CMD_INQUIRY:
			CommandSuccess = SCSI_Command_Inquiry(MSInterfaceInfo);
			break;
		case SCSI_CMD_REQUEST_SENSE:
			CommandSuccess = SCSI_Command_Request_Sense(MSInterfaceInfo);
			break;
     8d4:	4d c0       	rjmp	.+154    	; 0x970 <SCSI_DecodeSCSICommand+0x220>
 *  \return Boolean \c true if the command completed successfully, \c false otherwise.
 */
static bool SCSI_Command_Send_Diagnostic(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	/* Check to see if the SELF TEST bit is not set */
	if (!(MSInterfaceInfo->State.CommandBlock.SCSICommandData[1] & (1 << 2)))
     8d6:	f8 01       	movw	r30, r16
     8d8:	84 8d       	ldd	r24, Z+28	; 0x1c
     8da:	82 fd       	sbrc	r24, 2
     8dc:	08 c0       	rjmp	.+16     	; 0x8ee <SCSI_DecodeSCSICommand+0x19e>
	{
		/* Only self-test supported - update SENSE key and fail the command */
		SCSI_SET_SENSE(SCSI_SENSE_KEY_ILLEGAL_REQUEST,
     8de:	80 91 7d 01 	lds	r24, 0x017D
     8e2:	80 7f       	andi	r24, 0xF0	; 240
     8e4:	85 60       	ori	r24, 0x05	; 5
     8e6:	80 93 7d 01 	sts	0x017D, r24
     8ea:	84 e2       	ldi	r24, 0x24	; 36
     8ec:	3e c0       	rjmp	.+124    	; 0x96a <SCSI_DecodeSCSICommand+0x21a>

		return false;
	}

	/* Check to see if all attached Dataflash ICs are functional */
	if (!(DataflashManager_CheckDataflashOperation()))
     8ee:	86 d3       	rcall	.+1804   	; 0xffc <DataflashManager_CheckDataflashOperation>
     8f0:	81 11       	cpse	r24, r1
     8f2:	2e c0       	rjmp	.+92     	; 0x950 <SCSI_DecodeSCSICommand+0x200>
     8f4:	80 91 7d 01 	lds	r24, 0x017D
	{
		/* Update SENSE key with a hardware error condition and return command fail */
		SCSI_SET_SENSE(SCSI_SENSE_KEY_HARDWARE_ERROR,
     8f8:	80 7f       	andi	r24, 0xF0	; 240
     8fa:	84 60       	ori	r24, 0x04	; 4
     8fc:	80 93 7d 01 	sts	0x017D, r24
     900:	10 92 87 01 	sts	0x0187, r1
     904:	10 92 88 01 	sts	0x0188, r1
     908:	3e c0       	rjmp	.+124    	; 0x986 <SCSI_DecodeSCSICommand+0x236>
     90a:	60 e0       	ldi	r22, 0x00	; 0
			break;
		case SCSI_CMD_SEND_DIAGNOSTIC:
			CommandSuccess = SCSI_Command_Send_Diagnostic(MSInterfaceInfo);
			break;
		case SCSI_CMD_WRITE_10:
			CommandSuccess = SCSI_Command_ReadWrite_10(MSInterfaceInfo, DATA_WRITE);
     90c:	01 c0       	rjmp	.+2      	; 0x910 <SCSI_DecodeSCSICommand+0x1c0>
     90e:	61 e0       	ldi	r22, 0x01	; 1
			break;
		case SCSI_CMD_READ_10:
			CommandSuccess = SCSI_Command_ReadWrite_10(MSInterfaceInfo, DATA_READ);
     910:	c8 01       	movw	r24, r16
     912:	dc de       	rcall	.-584    	; 0x6cc <SCSI_Command_ReadWrite_10>
     914:	88 23       	and	r24, r24
     916:	b9 f1       	breq	.+110    	; 0x986 <SCSI_DecodeSCSICommand+0x236>
		                   SCSI_ASENSEQ_NO_QUALIFIER);
			break;
	}

	/* Check if command was successfully processed */
	if (CommandSuccess)
     918:	2b c0       	rjmp	.+86     	; 0x970 <SCSI_DecodeSCSICommand+0x220>
     91a:	10 92 f1 00 	sts	0x00F1, r1
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
     91e:	10 92 f1 00 	sts	0x00F1, r1
     922:	10 92 f1 00 	sts	0x00F1, r1
     926:	10 92 f1 00 	sts	0x00F1, r1
     92a:	80 91 e8 00 	lds	r24, 0x00E8
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
     92e:	8e 77       	andi	r24, 0x7E	; 126
     930:	80 93 e8 00 	sts	0x00E8, r24
     934:	f8 01       	movw	r30, r16
     936:	44 89       	ldd	r20, Z+20	; 0x14
	Endpoint_Write_8(DISK_READ_ONLY ? 0x80 : 0x00);
	Endpoint_Write_8(0x00);
	Endpoint_ClearIN();

	/* Update the bytes transferred counter and succeed the command */
	MSInterfaceInfo->State.CommandBlock.DataTransferLength -= 4;
     938:	55 89       	ldd	r21, Z+21	; 0x15
     93a:	66 89       	ldd	r22, Z+22	; 0x16
     93c:	77 89       	ldd	r23, Z+23	; 0x17
     93e:	44 50       	subi	r20, 0x04	; 4
     940:	51 09       	sbc	r21, r1
     942:	61 09       	sbc	r22, r1
     944:	71 09       	sbc	r23, r1
     946:	44 8b       	std	Z+20, r20	; 0x14
     948:	55 8b       	std	Z+21, r21	; 0x15
     94a:	66 8b       	std	Z+22, r22	; 0x16
     94c:	77 8b       	std	Z+23, r23	; 0x17
     94e:	10 c0       	rjmp	.+32     	; 0x970 <SCSI_DecodeSCSICommand+0x220>
     950:	f8 01       	movw	r30, r16
		case SCSI_CMD_READ_10:
			CommandSuccess = SCSI_Command_ReadWrite_10(MSInterfaceInfo, DATA_READ);
			break;
		case SCSI_CMD_MODE_SENSE_6:
			CommandSuccess = SCSI_Command_ModeSense_6(MSInterfaceInfo);
			break;
     952:	14 8a       	std	Z+20, r1	; 0x14
		case SCSI_CMD_TEST_UNIT_READY:
		case SCSI_CMD_PREVENT_ALLOW_MEDIUM_REMOVAL:
		case SCSI_CMD_VERIFY_10:
			/* These commands should just succeed, no handling required */
			CommandSuccess = true;
			MSInterfaceInfo->State.CommandBlock.DataTransferLength = 0;
     954:	15 8a       	std	Z+21, r1	; 0x15
     956:	16 8a       	std	Z+22, r1	; 0x16
     958:	17 8a       	std	Z+23, r1	; 0x17
     95a:	0a c0       	rjmp	.+20     	; 0x970 <SCSI_DecodeSCSICommand+0x220>
     95c:	80 91 7d 01 	lds	r24, 0x017D
			break;
		default:
			/* Update the SENSE key to reflect the invalid command */
			SCSI_SET_SENSE(SCSI_SENSE_KEY_ILLEGAL_REQUEST,
     960:	80 7f       	andi	r24, 0xF0	; 240
     962:	85 60       	ori	r24, 0x05	; 5
     964:	80 93 7d 01 	sts	0x017D, r24
     968:	80 e2       	ldi	r24, 0x20	; 32
     96a:	80 93 87 01 	sts	0x0187, r24
     96e:	ca cf       	rjmp	.-108    	; 0x904 <SCSI_DecodeSCSICommand+0x1b4>
     970:	80 91 7d 01 	lds	r24, 0x017D
	}

	/* Check if command was successfully processed */
	if (CommandSuccess)
	{
		SCSI_SET_SENSE(SCSI_SENSE_KEY_GOOD,
     974:	80 7f       	andi	r24, 0xF0	; 240
     976:	80 93 7d 01 	sts	0x017D, r24
     97a:	10 92 87 01 	sts	0x0187, r1
     97e:	10 92 88 01 	sts	0x0188, r1
     982:	81 e0       	ldi	r24, 0x01	; 1
     984:	01 c0       	rjmp	.+2      	; 0x988 <SCSI_DecodeSCSICommand+0x238>
		               SCSI_ASENSE_NO_ADDITIONAL_INFORMATION,
		               SCSI_ASENSEQ_NO_QUALIFIER);

		return true;
     986:	80 e0       	ldi	r24, 0x00	; 0
     988:	28 96       	adiw	r28, 0x08	; 8
	}

	return false;
     98a:	0f b6       	in	r0, 0x3f	; 63
}
     98c:	f8 94       	cli
     98e:	de bf       	out	0x3e, r29	; 62
     990:	0f be       	out	0x3f, r0	; 63
     992:	cd bf       	out	0x3d, r28	; 61
     994:	df 91       	pop	r29
     996:	cf 91       	pop	r28
     998:	1f 91       	pop	r17
     99a:	0f 91       	pop	r16
     99c:	ff 90       	pop	r15
     99e:	ef 90       	pop	r14
     9a0:	df 90       	pop	r13
     9a2:	cf 90       	pop	r12
     9a4:	08 95       	ret

000009a6 <Dataflash_ToggleSelectedChipCS>:
			 *          or a DATAFLASH_CHIPn mask (where n is the chip number).
			 */
			static inline uint8_t Dataflash_GetSelectedChip(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t Dataflash_GetSelectedChip(void)
			{
				return (~DATAFLASH_CHIPCS_PORT & DATAFLASH_CHIPCS_MASK);
     9a6:	8e b1       	in	r24, 0x0e	; 14
			 *              the chip number).
			 */
			static inline void Dataflash_SelectChip(const uint8_t ChipMask) ATTR_ALWAYS_INLINE;
			static inline void Dataflash_SelectChip(const uint8_t ChipMask)
			{
				DATAFLASH_CHIPCS_PORT = ((DATAFLASH_CHIPCS_PORT | DATAFLASH_CHIPCS_MASK) & ~ChipMask);
     9a8:	9e b1       	in	r25, 0x0e	; 14
     9aa:	93 60       	ori	r25, 0x03	; 3
     9ac:	9e b9       	out	0x0e, r25	; 14
     9ae:	9e b1       	in	r25, 0x0e	; 14
     9b0:	8c 6f       	ori	r24, 0xFC	; 252
     9b2:	93 60       	ori	r25, 0x03	; 3
     9b4:	89 23       	and	r24, r25
     9b6:	8e b9       	out	0x0e, r24	; 14
     9b8:	08 95       	ret

000009ba <Dataflash_WaitWhileBusy>:
			/** Spin-loops while the currently selected dataflash is busy executing a command, such as a main
			 *  memory page program or main memory to buffer transfer.
			 */
			static inline void Dataflash_WaitWhileBusy(void)
			{
				Dataflash_ToggleSelectedChipCS();
     9ba:	f5 df       	rcall	.-22     	; 0x9a6 <Dataflash_ToggleSelectedChipCS>
     9bc:	87 ed       	ldi	r24, 0xD7	; 215
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     9be:	8e bd       	out	0x2e, r24	; 46
     9c0:	0d b4       	in	r0, 0x2d	; 45
				while (!(SPSR & (1 << SPIF)));
     9c2:	07 fe       	sbrs	r0, 7
     9c4:	fd cf       	rjmp	.-6      	; 0x9c0 <Dataflash_WaitWhileBusy+0x6>
     9c6:	1e bc       	out	0x2e, r1	; 46
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     9c8:	0d b4       	in	r0, 0x2d	; 45
				while (!(SPSR & (1 << SPIF)));
     9ca:	07 fe       	sbrs	r0, 7
     9cc:	fd cf       	rjmp	.-6      	; 0x9c8 <Dataflash_WaitWhileBusy+0xe>
     9ce:	0e b4       	in	r0, 0x2e	; 46
				Dataflash_SendByte(DF_CMD_GETSTATUS);
				while (!(Dataflash_ReceiveByte() & DF_STATUS_READY));
     9d0:	07 fe       	sbrs	r0, 7
     9d2:	f9 cf       	rjmp	.-14     	; 0x9c6 <Dataflash_WaitWhileBusy+0xc>
     9d4:	e8 cf       	rjmp	.-48     	; 0x9a6 <Dataflash_ToggleSelectedChipCS>

000009d6 <Dataflash_SendAddressBytes>:
				Dataflash_ToggleSelectedChipCS();
     9d6:	9c 01       	movw	r18, r24
     9d8:	36 95       	lsr	r19
			 */
			static inline void Dataflash_SendAddressBytes(uint16_t PageAddress,
			                                              const uint16_t BufferByte)
			{
				#if (DATAFLASH_TOTALCHIPS == 2)
					PageAddress >>= 1;
     9da:	27 95       	ror	r18
				#endif

				Dataflash_SendByte(PageAddress >> 5);
     9dc:	56 e0       	ldi	r21, 0x06	; 6
     9de:	96 95       	lsr	r25
     9e0:	87 95       	ror	r24
     9e2:	5a 95       	dec	r21
     9e4:	e1 f7       	brne	.-8      	; 0x9de <Dataflash_SendAddressBytes+0x8>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     9e6:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     9e8:	0d b4       	in	r0, 0x2d	; 45
     9ea:	07 fe       	sbrs	r0, 7
     9ec:	fd cf       	rjmp	.-6      	; 0x9e8 <Dataflash_SendAddressBytes+0x12>
				Dataflash_SendByte((PageAddress << 3) | (BufferByte >> 8));
     9ee:	22 0f       	add	r18, r18
     9f0:	22 0f       	add	r18, r18
     9f2:	22 0f       	add	r18, r18
     9f4:	27 2b       	or	r18, r23
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     9f6:	2e bd       	out	0x2e, r18	; 46
				while (!(SPSR & (1 << SPIF)));
     9f8:	0d b4       	in	r0, 0x2d	; 45
     9fa:	07 fe       	sbrs	r0, 7
     9fc:	fd cf       	rjmp	.-6      	; 0x9f8 <Dataflash_SendAddressBytes+0x22>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     9fe:	6e bd       	out	0x2e, r22	; 46
				while (!(SPSR & (1 << SPIF)));
     a00:	0d b4       	in	r0, 0x2d	; 45
     a02:	07 fe       	sbrs	r0, 7
     a04:	fd cf       	rjmp	.-6      	; 0xa00 <Dataflash_SendAddressBytes+0x2a>
				Dataflash_SendByte(BufferByte);
			}
     a06:	08 95       	ret

00000a08 <Dataflash_SelectChipFromPage>:
			 *              the chip number).
			 */
			static inline void Dataflash_SelectChip(const uint8_t ChipMask) ATTR_ALWAYS_INLINE;
			static inline void Dataflash_SelectChip(const uint8_t ChipMask)
			{
				DATAFLASH_CHIPCS_PORT = ((DATAFLASH_CHIPCS_PORT | DATAFLASH_CHIPCS_MASK) & ~ChipMask);
     a08:	2e b1       	in	r18, 0x0e	; 14
     a0a:	23 60       	ori	r18, 0x03	; 3
     a0c:	2e b9       	out	0x0e, r18	; 14
			 */
			static inline void Dataflash_SelectChipFromPage(const uint16_t PageAddress)
			{
				Dataflash_DeselectChip();

				if (PageAddress >= (DATAFLASH_PAGES * DATAFLASH_TOTALCHIPS))
     a0e:	81 15       	cp	r24, r1
     a10:	20 e4       	ldi	r18, 0x40	; 64
     a12:	92 07       	cpc	r25, r18
     a14:	50 f4       	brcc	.+20     	; 0xa2a <Dataflash_SelectChipFromPage+0x22>
				  return;

				#if (DATAFLASH_TOTALCHIPS == 2)
					if (PageAddress & 0x01)
     a16:	80 ff       	sbrs	r24, 0
     a18:	04 c0       	rjmp	.+8      	; 0xa22 <Dataflash_SelectChipFromPage+0x1a>
			 *              the chip number).
			 */
			static inline void Dataflash_SelectChip(const uint8_t ChipMask) ATTR_ALWAYS_INLINE;
			static inline void Dataflash_SelectChip(const uint8_t ChipMask)
			{
				DATAFLASH_CHIPCS_PORT = ((DATAFLASH_CHIPCS_PORT | DATAFLASH_CHIPCS_MASK) & ~ChipMask);
     a1a:	8e b1       	in	r24, 0x0e	; 14
     a1c:	83 60       	ori	r24, 0x03	; 3
     a1e:	8d 7f       	andi	r24, 0xFD	; 253
     a20:	03 c0       	rjmp	.+6      	; 0xa28 <Dataflash_SelectChipFromPage+0x20>
     a22:	8e b1       	in	r24, 0x0e	; 14
     a24:	83 60       	ori	r24, 0x03	; 3
     a26:	8e 7f       	andi	r24, 0xFE	; 254
     a28:	8e b9       	out	0x0e, r24	; 14
     a2a:	08 95       	ret

00000a2c <DataflashManager_WriteBlocks>:
 *  \param[in] TotalBlocks   Number of blocks of data to write
 */
void DataflashManager_WriteBlocks(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo,
                                  const uint32_t BlockAddress,
                                  uint16_t TotalBlocks)
{
     a2c:	4f 92       	push	r4
     a2e:	5f 92       	push	r5
     a30:	6f 92       	push	r6
     a32:	7f 92       	push	r7
     a34:	8f 92       	push	r8
     a36:	9f 92       	push	r9
     a38:	af 92       	push	r10
     a3a:	bf 92       	push	r11
     a3c:	cf 92       	push	r12
     a3e:	df 92       	push	r13
     a40:	ef 92       	push	r14
     a42:	ff 92       	push	r15
     a44:	0f 93       	push	r16
     a46:	1f 93       	push	r17
     a48:	cf 93       	push	r28
     a4a:	df 93       	push	r29
     a4c:	6c 01       	movw	r12, r24
     a4e:	89 01       	movw	r16, r18
	uint16_t CurrDFPage          = ((BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE) / DATAFLASH_PAGE_SIZE);
     a50:	4a 01       	movw	r8, r20
     a52:	5b 01       	movw	r10, r22
     a54:	f9 e0       	ldi	r31, 0x09	; 9
     a56:	88 0c       	add	r8, r8
     a58:	99 1c       	adc	r9, r9
     a5a:	aa 1c       	adc	r10, r10
     a5c:	bb 1c       	adc	r11, r11
     a5e:	fa 95       	dec	r31
     a60:	d1 f7       	brne	.-12     	; 0xa56 <DataflashManager_WriteBlocks+0x2a>
     a62:	aa e0       	ldi	r26, 0x0A	; 10
     a64:	b6 94       	lsr	r11
     a66:	a7 94       	ror	r10
     a68:	97 94       	ror	r9
     a6a:	87 94       	ror	r8
     a6c:	aa 95       	dec	r26
     a6e:	d1 f7       	brne	.-12     	; 0xa64 <DataflashManager_WriteBlocks+0x38>
     a70:	e4 01       	movw	r28, r8
	uint16_t CurrDFPageByte      = ((BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE) % DATAFLASH_PAGE_SIZE);
     a72:	7a 01       	movw	r14, r20
     a74:	fe 2c       	mov	r15, r14
     a76:	ee 24       	eor	r14, r14
     a78:	ff 0c       	add	r15, r15
     a7a:	ee 24       	eor	r14, r14
     a7c:	82 e0       	ldi	r24, 0x02	; 2
     a7e:	f8 22       	and	r15, r24
	uint8_t  CurrDFPageByteDiv16 = (CurrDFPageByte >> 4);
	bool     UsingSecondBuffer   = false;

	/* Select the correct starting Dataflash IC for the block requested */
	Dataflash_SelectChipFromPage(CurrDFPage);
     a80:	c4 01       	movw	r24, r8
     a82:	c2 df       	rcall	.-124    	; 0xa08 <Dataflash_SelectChipFromPage>
     a84:	83 e5       	ldi	r24, 0x53	; 83
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     a86:	8e bd       	out	0x2e, r24	; 46
     a88:	0d b4       	in	r0, 0x2d	; 45
				while (!(SPSR & (1 << SPIF)));
     a8a:	07 fe       	sbrs	r0, 7
     a8c:	fd cf       	rjmp	.-6      	; 0xa88 <DataflashManager_WriteBlocks+0x5c>
     a8e:	60 e0       	ldi	r22, 0x00	; 0

#if (DATAFLASH_PAGE_SIZE > VIRTUAL_MEMORY_BLOCK_SIZE)
	/* Copy selected dataflash's current page contents to the Dataflash buffer */
	Dataflash_SendByte(DF_CMD_MAINMEMTOBUFF1);
	Dataflash_SendAddressBytes(CurrDFPage, 0);
     a90:	70 e0       	ldi	r23, 0x00	; 0
     a92:	c4 01       	movw	r24, r8
     a94:	a0 df       	rcall	.-192    	; 0x9d6 <Dataflash_SendAddressBytes>
     a96:	91 df       	rcall	.-222    	; 0x9ba <Dataflash_WaitWhileBusy>
     a98:	84 e8       	ldi	r24, 0x84	; 132
	Dataflash_WaitWhileBusy();
     a9a:	8e bd       	out	0x2e, r24	; 46
     a9c:	0d b4       	in	r0, 0x2d	; 45
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     a9e:	07 fe       	sbrs	r0, 7
     aa0:	fd cf       	rjmp	.-6      	; 0xa9c <DataflashManager_WriteBlocks+0x70>
				while (!(SPSR & (1 << SPIF)));
     aa2:	b7 01       	movw	r22, r14
     aa4:	80 e0       	ldi	r24, 0x00	; 0
     aa6:	90 e0       	ldi	r25, 0x00	; 0
#endif

	/* Send the Dataflash buffer write command */
	Dataflash_SendByte(DF_CMD_BUFF1WRITE);
	Dataflash_SendAddressBytes(0, CurrDFPageByte);
     aa8:	96 df       	rcall	.-212    	; 0x9d6 <Dataflash_SendAddressBytes>
     aaa:	0e 94 34 27 	call	0x4e68	; 0x4e68 <Endpoint_WaitUntilReady>
     aae:	81 11       	cpse	r24, r1
     ab0:	ed c0       	rjmp	.+474    	; 0xc8c <DataflashManager_WriteBlocks+0x260>

	/* Wait until endpoint is ready before continuing */
	if (Endpoint_WaitUntilReady())
     ab2:	74 e0       	ldi	r23, 0x04	; 4
     ab4:	f6 94       	lsr	r15
     ab6:	e7 94       	ror	r14
     ab8:	7a 95       	dec	r23
                                  const uint32_t BlockAddress,
                                  uint16_t TotalBlocks)
{
	uint16_t CurrDFPage          = ((BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE) / DATAFLASH_PAGE_SIZE);
	uint16_t CurrDFPageByte      = ((BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE) % DATAFLASH_PAGE_SIZE);
	uint8_t  CurrDFPageByteDiv16 = (CurrDFPageByte >> 4);
     aba:	e1 f7       	brne	.-8      	; 0xab4 <DataflashManager_WriteBlocks+0x88>
     abc:	38 01       	movw	r6, r16
     abe:	e5 e0       	ldi	r30, 0x05	; 5
     ac0:	66 0c       	add	r6, r6
     ac2:	77 1c       	adc	r7, r7
     ac4:	ea 95       	dec	r30
     ac6:	e1 f7       	brne	.-8      	; 0xac0 <DataflashManager_WriteBlocks+0x94>
     ac8:	a1 2c       	mov	r10, r1
     aca:	b1 2c       	mov	r11, r1
     acc:	f1 2c       	mov	r15, r1
     ace:	44 24       	eor	r4, r4
     ad0:	43 94       	inc	r4
     ad2:	01 15       	cp	r16, r1
     ad4:	11 05       	cpc	r17, r1
				CurrDFPageByteDiv16 = 0;
				CurrDFPage++;

				/* Once all the Dataflash ICs have had their first buffers filled, switch buffers to maintain throughput */
				if (Dataflash_GetSelectedChip() == DATAFLASH_CHIP_MASK(DATAFLASH_TOTALCHIPS))
				  UsingSecondBuffer = !(UsingSecondBuffer);
     ad6:	09 f4       	brne	.+2      	; 0xada <DataflashManager_WriteBlocks+0xae>
     ad8:	be c0       	rjmp	.+380    	; 0xc56 <DataflashManager_WriteBlocks+0x22a>

	/* Wait until endpoint is ready before continuing */
	if (Endpoint_WaitUntilReady())
	  return;

	while (TotalBlocks)
     ada:	45 01       	movw	r8, r10
     adc:	86 0c       	add	r8, r6
     ade:	97 1c       	adc	r9, r7
     ae0:	60 e2       	ldi	r22, 0x20	; 32
     ae2:	56 2e       	mov	r5, r22
     ae4:	80 91 e8 00 	lds	r24, 0x00E8
     ae8:	85 ff       	sbrs	r24, 5
     aea:	04 c0       	rjmp	.+8      	; 0xaf4 <DataflashManager_WriteBlocks+0xc8>
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
     aec:	e0 e4       	ldi	r30, 0x40	; 64
     aee:	ee 12       	cpse	r14, r30

		/* Write an endpoint packet sized data block to the Dataflash */
		while (BytesInBlockDiv16 < (VIRTUAL_MEMORY_BLOCK_SIZE >> 4))
		{
			/* Check if the endpoint is currently empty */
			if (!(Endpoint_IsReadWriteAllowed()))
     af0:	44 c0       	rjmp	.+136    	; 0xb7a <DataflashManager_WriteBlocks+0x14e>
     af2:	0a c0       	rjmp	.+20     	; 0xb08 <DataflashManager_WriteBlocks+0xdc>
				if (Endpoint_WaitUntilReady())
				  return;
			}

			/* Check if end of Dataflash page reached */
			if (CurrDFPageByteDiv16 == (DATAFLASH_PAGE_SIZE >> 4))
     af4:	80 91 e8 00 	lds	r24, 0x00E8
     af8:	8b 77       	andi	r24, 0x7B	; 123
     afa:	80 93 e8 00 	sts	0x00E8, r24
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
     afe:	0e 94 34 27 	call	0x4e68	; 0x4e68 <Endpoint_WaitUntilReady>
     b02:	88 23       	and	r24, r24
     b04:	99 f3       	breq	.-26     	; 0xaec <DataflashManager_WriteBlocks+0xc0>
			{
				/* Clear the current endpoint bank */
				Endpoint_ClearOUT();

				/* Wait until the host has sent another packet */
				if (Endpoint_WaitUntilReady())
     b06:	c2 c0       	rjmp	.+388    	; 0xc8c <DataflashManager_WriteBlocks+0x260>
     b08:	58 df       	rcall	.-336    	; 0x9ba <Dataflash_WaitWhileBusy>
     b0a:	ff 20       	and	r15, r15
     b0c:	11 f0       	breq	.+4      	; 0xb12 <DataflashManager_WriteBlocks+0xe6>
     b0e:	86 e8       	ldi	r24, 0x86	; 134

			/* Check if end of Dataflash page reached */
			if (CurrDFPageByteDiv16 == (DATAFLASH_PAGE_SIZE >> 4))
			{
				/* Write the Dataflash buffer contents back to the Dataflash page */
				Dataflash_WaitWhileBusy();
     b10:	01 c0       	rjmp	.+2      	; 0xb14 <DataflashManager_WriteBlocks+0xe8>
     b12:	83 e8       	ldi	r24, 0x83	; 131
				Dataflash_SendByte(UsingSecondBuffer ? DF_CMD_BUFF2TOMAINMEMWITHERASE : DF_CMD_BUFF1TOMAINMEMWITHERASE);
     b14:	8e bd       	out	0x2e, r24	; 46
     b16:	0d b4       	in	r0, 0x2d	; 45
     b18:	07 fe       	sbrs	r0, 7
     b1a:	fd cf       	rjmp	.-6      	; 0xb16 <DataflashManager_WriteBlocks+0xea>
     b1c:	60 e0       	ldi	r22, 0x00	; 0
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     b1e:	70 e0       	ldi	r23, 0x00	; 0
				while (!(SPSR & (1 << SPIF)));
     b20:	ce 01       	movw	r24, r28
     b22:	59 df       	rcall	.-334    	; 0x9d6 <Dataflash_SendAddressBytes>
     b24:	21 96       	adiw	r28, 0x01	; 1
				Dataflash_SendAddressBytes(CurrDFPage, 0);
     b26:	8e b1       	in	r24, 0x0e	; 14
     b28:	80 95       	com	r24
     b2a:	83 70       	andi	r24, 0x03	; 3
     b2c:	82 30       	cpi	r24, 0x02	; 2
     b2e:	09 f4       	brne	.+2      	; 0xb32 <DataflashManager_WriteBlocks+0x106>

				/* Reset the Dataflash buffer counter, increment the page counter */
				CurrDFPageByteDiv16 = 0;
				CurrDFPage++;
     b30:	f4 24       	eor	r15, r4
			 *          or a DATAFLASH_CHIPn mask (where n is the chip number).
			 */
			static inline uint8_t Dataflash_GetSelectedChip(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t Dataflash_GetSelectedChip(void)
			{
				return (~DATAFLASH_CHIPCS_PORT & DATAFLASH_CHIPCS_MASK);
     b32:	ce 01       	movw	r24, r28
     b34:	69 df       	rcall	.-302    	; 0xa08 <Dataflash_SelectChipFromPage>
     b36:	f0 e4       	ldi	r31, 0x40	; 64

				/* Once all the Dataflash ICs have had their first buffers filled, switch buffers to maintain throughput */
				if (Dataflash_GetSelectedChip() == DATAFLASH_CHIP_MASK(DATAFLASH_TOTALCHIPS))
     b38:	8f 16       	cp	r8, r31
     b3a:	91 04       	cpc	r9, r1
				  UsingSecondBuffer = !(UsingSecondBuffer);
     b3c:	78 f4       	brcc	.+30     	; 0xb5c <DataflashManager_WriteBlocks+0x130>

				/* Select the next Dataflash chip based on the new Dataflash page index */
				Dataflash_SelectChipFromPage(CurrDFPage);
     b3e:	3d df       	rcall	.-390    	; 0x9ba <Dataflash_WaitWhileBusy>
     b40:	ff 20       	and	r15, r15
     b42:	11 f0       	breq	.+4      	; 0xb48 <DataflashManager_WriteBlocks+0x11c>

#if (DATAFLASH_PAGE_SIZE > VIRTUAL_MEMORY_BLOCK_SIZE)
				/* If less than one Dataflash page remaining, copy over the existing page to preserve trailing data */
				if ((TotalBlocks * (VIRTUAL_MEMORY_BLOCK_SIZE >> 4)) < (DATAFLASH_PAGE_SIZE >> 4))
     b44:	85 e5       	ldi	r24, 0x55	; 85
     b46:	01 c0       	rjmp	.+2      	; 0xb4a <DataflashManager_WriteBlocks+0x11e>
     b48:	83 e5       	ldi	r24, 0x53	; 83
     b4a:	8e bd       	out	0x2e, r24	; 46
				{
					/* Copy selected dataflash's current page contents to the Dataflash buffer */
					Dataflash_WaitWhileBusy();
     b4c:	0d b4       	in	r0, 0x2d	; 45
     b4e:	07 fe       	sbrs	r0, 7
					Dataflash_SendByte(UsingSecondBuffer ? DF_CMD_MAINMEMTOBUFF2 : DF_CMD_MAINMEMTOBUFF1);
     b50:	fd cf       	rjmp	.-6      	; 0xb4c <DataflashManager_WriteBlocks+0x120>
     b52:	60 e0       	ldi	r22, 0x00	; 0
     b54:	70 e0       	ldi	r23, 0x00	; 0
     b56:	ce 01       	movw	r24, r28
     b58:	3e df       	rcall	.-388    	; 0x9d6 <Dataflash_SendAddressBytes>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     b5a:	2f df       	rcall	.-418    	; 0x9ba <Dataflash_WaitWhileBusy>
				while (!(SPSR & (1 << SPIF)));
     b5c:	ff 20       	and	r15, r15
     b5e:	11 f0       	breq	.+4      	; 0xb64 <DataflashManager_WriteBlocks+0x138>
     b60:	87 e8       	ldi	r24, 0x87	; 135
					Dataflash_SendAddressBytes(CurrDFPage, 0);
     b62:	01 c0       	rjmp	.+2      	; 0xb66 <DataflashManager_WriteBlocks+0x13a>
     b64:	84 e8       	ldi	r24, 0x84	; 132
     b66:	8e bd       	out	0x2e, r24	; 46
     b68:	0d b4       	in	r0, 0x2d	; 45
     b6a:	07 fe       	sbrs	r0, 7
					Dataflash_WaitWhileBusy();
     b6c:	fd cf       	rjmp	.-6      	; 0xb68 <DataflashManager_WriteBlocks+0x13c>
     b6e:	60 e0       	ldi	r22, 0x00	; 0
				}
#endif

				/* Send the Dataflash buffer write command */
				Dataflash_SendByte(UsingSecondBuffer ? DF_CMD_BUFF2WRITE : DF_CMD_BUFF1WRITE);
     b70:	70 e0       	ldi	r23, 0x00	; 0
     b72:	80 e0       	ldi	r24, 0x00	; 0
     b74:	90 e0       	ldi	r25, 0x00	; 0
     b76:	2f df       	rcall	.-418    	; 0x9d6 <Dataflash_SendAddressBytes>
     b78:	e1 2c       	mov	r14, r1
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     b7a:	80 91 f1 00 	lds	r24, 0x00F1
				while (!(SPSR & (1 << SPIF)));
     b7e:	8e bd       	out	0x2e, r24	; 46
     b80:	0d b4       	in	r0, 0x2d	; 45
				Dataflash_SendAddressBytes(0, 0);
     b82:	07 fe       	sbrs	r0, 7
     b84:	fd cf       	rjmp	.-6      	; 0xb80 <DataflashManager_WriteBlocks+0x154>
     b86:	80 91 f1 00 	lds	r24, 0x00F1
     b8a:	8e bd       	out	0x2e, r24	; 46
     b8c:	0d b4       	in	r0, 0x2d	; 45
				Dataflash_WaitWhileBusy();
				Dataflash_SendByte(UsingSecondBuffer ? DF_CMD_BUFF2TOMAINMEMWITHERASE : DF_CMD_BUFF1TOMAINMEMWITHERASE);
				Dataflash_SendAddressBytes(CurrDFPage, 0);

				/* Reset the Dataflash buffer counter, increment the page counter */
				CurrDFPageByteDiv16 = 0;
     b8e:	07 fe       	sbrs	r0, 7
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
     b90:	fd cf       	rjmp	.-6      	; 0xb8c <DataflashManager_WriteBlocks+0x160>
     b92:	80 91 f1 00 	lds	r24, 0x00F1
     b96:	8e bd       	out	0x2e, r24	; 46
     b98:	0d b4       	in	r0, 0x2d	; 45
     b9a:	07 fe       	sbrs	r0, 7
     b9c:	fd cf       	rjmp	.-6      	; 0xb98 <DataflashManager_WriteBlocks+0x16c>
     b9e:	80 91 f1 00 	lds	r24, 0x00F1
     ba2:	8e bd       	out	0x2e, r24	; 46
     ba4:	0d b4       	in	r0, 0x2d	; 45
     ba6:	07 fe       	sbrs	r0, 7
     ba8:	fd cf       	rjmp	.-6      	; 0xba4 <DataflashManager_WriteBlocks+0x178>
     baa:	80 91 f1 00 	lds	r24, 0x00F1
     bae:	8e bd       	out	0x2e, r24	; 46
     bb0:	0d b4       	in	r0, 0x2d	; 45
     bb2:	07 fe       	sbrs	r0, 7
     bb4:	fd cf       	rjmp	.-6      	; 0xbb0 <DataflashManager_WriteBlocks+0x184>
     bb6:	80 91 f1 00 	lds	r24, 0x00F1
     bba:	8e bd       	out	0x2e, r24	; 46
     bbc:	0d b4       	in	r0, 0x2d	; 45
     bbe:	07 fe       	sbrs	r0, 7
     bc0:	fd cf       	rjmp	.-6      	; 0xbbc <DataflashManager_WriteBlocks+0x190>
     bc2:	80 91 f1 00 	lds	r24, 0x00F1
     bc6:	8e bd       	out	0x2e, r24	; 46
     bc8:	0d b4       	in	r0, 0x2d	; 45
     bca:	07 fe       	sbrs	r0, 7
     bcc:	fd cf       	rjmp	.-6      	; 0xbc8 <DataflashManager_WriteBlocks+0x19c>
     bce:	80 91 f1 00 	lds	r24, 0x00F1
     bd2:	8e bd       	out	0x2e, r24	; 46
     bd4:	0d b4       	in	r0, 0x2d	; 45
     bd6:	07 fe       	sbrs	r0, 7
     bd8:	fd cf       	rjmp	.-6      	; 0xbd4 <DataflashManager_WriteBlocks+0x1a8>
     bda:	80 91 f1 00 	lds	r24, 0x00F1
     bde:	8e bd       	out	0x2e, r24	; 46
     be0:	0d b4       	in	r0, 0x2d	; 45
     be2:	07 fe       	sbrs	r0, 7
     be4:	fd cf       	rjmp	.-6      	; 0xbe0 <DataflashManager_WriteBlocks+0x1b4>
     be6:	80 91 f1 00 	lds	r24, 0x00F1
     bea:	8e bd       	out	0x2e, r24	; 46
     bec:	0d b4       	in	r0, 0x2d	; 45
     bee:	07 fe       	sbrs	r0, 7
     bf0:	fd cf       	rjmp	.-6      	; 0xbec <DataflashManager_WriteBlocks+0x1c0>
     bf2:	80 91 f1 00 	lds	r24, 0x00F1
     bf6:	8e bd       	out	0x2e, r24	; 46
     bf8:	0d b4       	in	r0, 0x2d	; 45
     bfa:	07 fe       	sbrs	r0, 7
     bfc:	fd cf       	rjmp	.-6      	; 0xbf8 <DataflashManager_WriteBlocks+0x1cc>
     bfe:	80 91 f1 00 	lds	r24, 0x00F1
     c02:	8e bd       	out	0x2e, r24	; 46
     c04:	0d b4       	in	r0, 0x2d	; 45
     c06:	07 fe       	sbrs	r0, 7
     c08:	fd cf       	rjmp	.-6      	; 0xc04 <DataflashManager_WriteBlocks+0x1d8>
     c0a:	80 91 f1 00 	lds	r24, 0x00F1
     c0e:	8e bd       	out	0x2e, r24	; 46
     c10:	0d b4       	in	r0, 0x2d	; 45
     c12:	07 fe       	sbrs	r0, 7
     c14:	fd cf       	rjmp	.-6      	; 0xc10 <DataflashManager_WriteBlocks+0x1e4>
     c16:	80 91 f1 00 	lds	r24, 0x00F1
     c1a:	8e bd       	out	0x2e, r24	; 46
     c1c:	0d b4       	in	r0, 0x2d	; 45
     c1e:	07 fe       	sbrs	r0, 7
     c20:	fd cf       	rjmp	.-6      	; 0xc1c <DataflashManager_WriteBlocks+0x1f0>
     c22:	80 91 f1 00 	lds	r24, 0x00F1
     c26:	8e bd       	out	0x2e, r24	; 46
     c28:	0d b4       	in	r0, 0x2d	; 45
     c2a:	07 fe       	sbrs	r0, 7
     c2c:	fd cf       	rjmp	.-6      	; 0xc28 <DataflashManager_WriteBlocks+0x1fc>
     c2e:	80 91 f1 00 	lds	r24, 0x00F1
     c32:	8e bd       	out	0x2e, r24	; 46
     c34:	0d b4       	in	r0, 0x2d	; 45
     c36:	07 fe       	sbrs	r0, 7
     c38:	fd cf       	rjmp	.-6      	; 0xc34 <DataflashManager_WriteBlocks+0x208>
     c3a:	e3 94       	inc	r14
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     c3c:	f6 01       	movw	r30, r12
				while (!(SPSR & (1 << SPIF)));
     c3e:	80 ad       	ldd	r24, Z+56	; 0x38
     c40:	81 11       	cpse	r24, r1
     c42:	24 c0       	rjmp	.+72     	; 0xc8c <DataflashManager_WriteBlocks+0x260>
     c44:	5a 94       	dec	r5
     c46:	09 f0       	breq	.+2      	; 0xc4a <DataflashManager_WriteBlocks+0x21e>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     c48:	4d cf       	rjmp	.-358    	; 0xae4 <DataflashManager_WriteBlocks+0xb8>
				while (!(SPSR & (1 << SPIF)));
     c4a:	01 50       	subi	r16, 0x01	; 1
     c4c:	11 09       	sbc	r17, r1
     c4e:	f0 e2       	ldi	r31, 0x20	; 32
			Dataflash_SendByte(Endpoint_Read_8());
			Dataflash_SendByte(Endpoint_Read_8());
			Dataflash_SendByte(Endpoint_Read_8());

			/* Increment the Dataflash page 16 byte block counter */
			CurrDFPageByteDiv16++;
     c50:	af 1a       	sub	r10, r31

			/* Increment the block 16 byte block counter */
			BytesInBlockDiv16++;

			/* Check if the current command is being aborted by the host */
			if (MSInterfaceInfo->State.IsMassStoreReset)
     c52:	b1 08       	sbc	r11, r1
     c54:	3e cf       	rjmp	.-388    	; 0xad2 <DataflashManager_WriteBlocks+0xa6>
     c56:	b1 de       	rcall	.-670    	; 0x9ba <Dataflash_WaitWhileBusy>
     c58:	ff 20       	and	r15, r15
     c5a:	11 f0       	breq	.+4      	; 0xc60 <DataflashManager_WriteBlocks+0x234>
	while (TotalBlocks)
	{
		uint8_t BytesInBlockDiv16 = 0;

		/* Write an endpoint packet sized data block to the Dataflash */
		while (BytesInBlockDiv16 < (VIRTUAL_MEMORY_BLOCK_SIZE >> 4))
     c5c:	86 e8       	ldi	r24, 0x86	; 134
     c5e:	01 c0       	rjmp	.+2      	; 0xc62 <DataflashManager_WriteBlocks+0x236>
			if (MSInterfaceInfo->State.IsMassStoreReset)
			  return;
		}

		/* Decrement the blocks remaining counter */
		TotalBlocks--;
     c60:	83 e8       	ldi	r24, 0x83	; 131
     c62:	8e bd       	out	0x2e, r24	; 46
     c64:	0d b4       	in	r0, 0x2d	; 45
     c66:	07 fe       	sbrs	r0, 7
     c68:	fd cf       	rjmp	.-6      	; 0xc64 <DataflashManager_WriteBlocks+0x238>
     c6a:	60 e0       	ldi	r22, 0x00	; 0
	}

	/* Write the Dataflash buffer contents back to the Dataflash page */
	Dataflash_WaitWhileBusy();
     c6c:	70 e0       	ldi	r23, 0x00	; 0
     c6e:	ce 01       	movw	r24, r28
	Dataflash_SendByte(UsingSecondBuffer ? DF_CMD_BUFF2TOMAINMEMWITHERASE : DF_CMD_BUFF1TOMAINMEMWITHERASE);
     c70:	b2 de       	rcall	.-668    	; 0x9d6 <Dataflash_SendAddressBytes>
     c72:	a3 de       	rcall	.-698    	; 0x9ba <Dataflash_WaitWhileBusy>
     c74:	80 91 e8 00 	lds	r24, 0x00E8
     c78:	85 fd       	sbrc	r24, 5
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     c7a:	05 c0       	rjmp	.+10     	; 0xc86 <DataflashManager_WriteBlocks+0x25a>
				while (!(SPSR & (1 << SPIF)));
     c7c:	80 91 e8 00 	lds	r24, 0x00E8
     c80:	8b 77       	andi	r24, 0x7B	; 123
	Dataflash_SendAddressBytes(CurrDFPage, 0x00);
     c82:	80 93 e8 00 	sts	0x00E8, r24
     c86:	8e b1       	in	r24, 0x0e	; 14
     c88:	83 60       	ori	r24, 0x03	; 3
     c8a:	8e b9       	out	0x0e, r24	; 14
	Dataflash_WaitWhileBusy();
     c8c:	df 91       	pop	r29
     c8e:	cf 91       	pop	r28
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
     c90:	1f 91       	pop	r17
     c92:	0f 91       	pop	r16

	/* If the endpoint is empty, clear it ready for the next packet from the host */
	if (!(Endpoint_IsReadWriteAllowed()))
     c94:	ff 90       	pop	r15
     c96:	ef 90       	pop	r14
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
     c98:	df 90       	pop	r13
     c9a:	cf 90       	pop	r12
     c9c:	bf 90       	pop	r11
     c9e:	af 90       	pop	r10
     ca0:	9f 90       	pop	r9
			 *              the chip number).
			 */
			static inline void Dataflash_SelectChip(const uint8_t ChipMask) ATTR_ALWAYS_INLINE;
			static inline void Dataflash_SelectChip(const uint8_t ChipMask)
			{
				DATAFLASH_CHIPCS_PORT = ((DATAFLASH_CHIPCS_PORT | DATAFLASH_CHIPCS_MASK) & ~ChipMask);
     ca2:	8f 90       	pop	r8
     ca4:	7f 90       	pop	r7
     ca6:	6f 90       	pop	r6
	  Endpoint_ClearOUT();

	/* Deselect all Dataflash chips */
	Dataflash_DeselectChip();
}
     ca8:	5f 90       	pop	r5
     caa:	4f 90       	pop	r4
     cac:	08 95       	ret

00000cae <DataflashManager_ReadBlocks>:
     cae:	8f 92       	push	r8
     cb0:	9f 92       	push	r9
     cb2:	af 92       	push	r10
     cb4:	bf 92       	push	r11
     cb6:	cf 92       	push	r12
     cb8:	df 92       	push	r13
     cba:	ef 92       	push	r14
     cbc:	ff 92       	push	r15
     cbe:	0f 93       	push	r16
     cc0:	1f 93       	push	r17
     cc2:	cf 93       	push	r28
     cc4:	df 93       	push	r29
     cc6:	6c 01       	movw	r12, r24
     cc8:	79 01       	movw	r14, r18
 */
void DataflashManager_ReadBlocks(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo,
                                 const uint32_t BlockAddress,
                                 uint16_t TotalBlocks)
{
	uint16_t CurrDFPage          = ((BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE) / DATAFLASH_PAGE_SIZE);
     cca:	4a 01       	movw	r8, r20
     ccc:	5b 01       	movw	r10, r22
     cce:	29 e0       	ldi	r18, 0x09	; 9
     cd0:	88 0c       	add	r8, r8
     cd2:	99 1c       	adc	r9, r9
     cd4:	aa 1c       	adc	r10, r10
     cd6:	bb 1c       	adc	r11, r11
     cd8:	2a 95       	dec	r18
     cda:	d1 f7       	brne	.-12     	; 0xcd0 <DataflashManager_ReadBlocks+0x22>
     cdc:	3a e0       	ldi	r19, 0x0A	; 10
     cde:	b6 94       	lsr	r11
     ce0:	a7 94       	ror	r10
     ce2:	97 94       	ror	r9
     ce4:	87 94       	ror	r8
     ce6:	3a 95       	dec	r19
     ce8:	d1 f7       	brne	.-12     	; 0xcde <DataflashManager_ReadBlocks+0x30>
     cea:	e4 01       	movw	r28, r8
	uint16_t CurrDFPageByte      = ((BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE) % DATAFLASH_PAGE_SIZE);
     cec:	8a 01       	movw	r16, r20
     cee:	10 2f       	mov	r17, r16
     cf0:	00 27       	eor	r16, r16
     cf2:	11 0f       	add	r17, r17
     cf4:	00 27       	eor	r16, r16
     cf6:	12 70       	andi	r17, 0x02	; 2
	uint8_t  CurrDFPageByteDiv16 = (CurrDFPageByte >> 4);

	/* Select the correct starting Dataflash IC for the block requested */
	Dataflash_SelectChipFromPage(CurrDFPage);
     cf8:	c4 01       	movw	r24, r8
     cfa:	86 de       	rcall	.-756    	; 0xa08 <Dataflash_SelectChipFromPage>
     cfc:	82 ed       	ldi	r24, 0xD2	; 210
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     cfe:	8e bd       	out	0x2e, r24	; 46
     d00:	0d b4       	in	r0, 0x2d	; 45
				while (!(SPSR & (1 << SPIF)));
     d02:	07 fe       	sbrs	r0, 7
     d04:	fd cf       	rjmp	.-6      	; 0xd00 <DataflashManager_ReadBlocks+0x52>
     d06:	b8 01       	movw	r22, r16

	/* Send the Dataflash main memory page read command */
	Dataflash_SendByte(DF_CMD_MAINMEMPAGEREAD);
	Dataflash_SendAddressBytes(CurrDFPage, CurrDFPageByte);
     d08:	c4 01       	movw	r24, r8
     d0a:	65 de       	rcall	.-822    	; 0x9d6 <Dataflash_SendAddressBytes>
     d0c:	1e bc       	out	0x2e, r1	; 46
     d0e:	0d b4       	in	r0, 0x2d	; 45
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     d10:	07 fe       	sbrs	r0, 7
				while (!(SPSR & (1 << SPIF)));
     d12:	fd cf       	rjmp	.-6      	; 0xd0e <DataflashManager_ReadBlocks+0x60>
     d14:	1e bc       	out	0x2e, r1	; 46
     d16:	0d b4       	in	r0, 0x2d	; 45
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     d18:	07 fe       	sbrs	r0, 7
				while (!(SPSR & (1 << SPIF)));
     d1a:	fd cf       	rjmp	.-6      	; 0xd16 <DataflashManager_ReadBlocks+0x68>
     d1c:	1e bc       	out	0x2e, r1	; 46
     d1e:	0d b4       	in	r0, 0x2d	; 45
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     d20:	07 fe       	sbrs	r0, 7
				while (!(SPSR & (1 << SPIF)));
     d22:	fd cf       	rjmp	.-6      	; 0xd1e <DataflashManager_ReadBlocks+0x70>
     d24:	1e bc       	out	0x2e, r1	; 46
     d26:	0d b4       	in	r0, 0x2d	; 45
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     d28:	07 fe       	sbrs	r0, 7
				while (!(SPSR & (1 << SPIF)));
     d2a:	fd cf       	rjmp	.-6      	; 0xd26 <DataflashManager_ReadBlocks+0x78>
     d2c:	0e 94 34 27 	call	0x4e68	; 0x4e68 <Endpoint_WaitUntilReady>
	Dataflash_SendByte(0x00);
	Dataflash_SendByte(0x00);
	Dataflash_SendByte(0x00);

	/* Wait until endpoint is ready before continuing */
	if (Endpoint_WaitUntilReady())
     d30:	81 11       	cpse	r24, r1
     d32:	c1 c0       	rjmp	.+386    	; 0xeb6 <DataflashManager_ReadBlocks+0x208>
     d34:	84 e0       	ldi	r24, 0x04	; 4
     d36:	16 95       	lsr	r17
                                 const uint32_t BlockAddress,
                                 uint16_t TotalBlocks)
{
	uint16_t CurrDFPage          = ((BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE) / DATAFLASH_PAGE_SIZE);
	uint16_t CurrDFPageByte      = ((BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE) % DATAFLASH_PAGE_SIZE);
	uint8_t  CurrDFPageByteDiv16 = (CurrDFPageByte >> 4);
     d38:	07 95       	ror	r16
     d3a:	8a 95       	dec	r24
     d3c:	e1 f7       	brne	.-8      	; 0xd36 <DataflashManager_ReadBlocks+0x88>
     d3e:	92 ed       	ldi	r25, 0xD2	; 210
     d40:	b9 2e       	mov	r11, r25
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     d42:	e1 14       	cp	r14, r1
     d44:	f1 04       	cpc	r15, r1

	/* Wait until endpoint is ready before continuing */
	if (Endpoint_WaitUntilReady())
	  return;

	while (TotalBlocks)
     d46:	09 f4       	brne	.+2      	; 0xd4a <DataflashManager_ReadBlocks+0x9c>
     d48:	aa c0       	rjmp	.+340    	; 0xe9e <DataflashManager_ReadBlocks+0x1f0>
     d4a:	10 e2       	ldi	r17, 0x20	; 32
     d4c:	80 91 e8 00 	lds	r24, 0x00E8
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
     d50:	85 ff       	sbrs	r24, 5
     d52:	07 c0       	rjmp	.+14     	; 0xd62 <DataflashManager_ReadBlocks+0xb4>

		/* Write an endpoint packet sized data block to the Dataflash */
		while (BytesInBlockDiv16 < (VIRTUAL_MEMORY_BLOCK_SIZE >> 4))
		{
			/* Check if the endpoint is currently full */
			if (!(Endpoint_IsReadWriteAllowed()))
     d54:	00 34       	cpi	r16, 0x40	; 64
     d56:	39 f5       	brne	.+78     	; 0xda6 <DataflashManager_ReadBlocks+0xf8>
				if (Endpoint_WaitUntilReady())
				  return;
			}

			/* Check if end of Dataflash page reached */
			if (CurrDFPageByteDiv16 == (DATAFLASH_PAGE_SIZE >> 4))
     d58:	21 96       	adiw	r28, 0x01	; 1
     d5a:	ce 01       	movw	r24, r28
			{
				/* Reset the Dataflash buffer counter, increment the page counter */
				CurrDFPageByteDiv16 = 0;
				CurrDFPage++;
     d5c:	55 de       	rcall	.-854    	; 0xa08 <Dataflash_SelectChipFromPage>

				/* Select the next Dataflash chip based on the new Dataflash page index */
				Dataflash_SelectChipFromPage(CurrDFPage);
     d5e:	be bc       	out	0x2e, r11	; 46
     d60:	0a c0       	rjmp	.+20     	; 0xd76 <DataflashManager_ReadBlocks+0xc8>
     d62:	80 91 e8 00 	lds	r24, 0x00E8
     d66:	8e 77       	andi	r24, 0x7E	; 126
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
     d68:	80 93 e8 00 	sts	0x00E8, r24
     d6c:	0e 94 34 27 	call	0x4e68	; 0x4e68 <Endpoint_WaitUntilReady>
     d70:	88 23       	and	r24, r24
			{
				/* Clear the endpoint bank to send its contents to the host */
				Endpoint_ClearIN();

				/* Wait until the endpoint is ready for more data */
				if (Endpoint_WaitUntilReady())
     d72:	81 f3       	breq	.-32     	; 0xd54 <DataflashManager_ReadBlocks+0xa6>
     d74:	a0 c0       	rjmp	.+320    	; 0xeb6 <DataflashManager_ReadBlocks+0x208>
     d76:	0d b4       	in	r0, 0x2d	; 45
     d78:	07 fe       	sbrs	r0, 7
     d7a:	fd cf       	rjmp	.-6      	; 0xd76 <DataflashManager_ReadBlocks+0xc8>
				while (!(SPSR & (1 << SPIF)));
     d7c:	60 e0       	ldi	r22, 0x00	; 0
     d7e:	70 e0       	ldi	r23, 0x00	; 0
     d80:	ce 01       	movw	r24, r28
				/* Select the next Dataflash chip based on the new Dataflash page index */
				Dataflash_SelectChipFromPage(CurrDFPage);

				/* Send the Dataflash main memory page read command */
				Dataflash_SendByte(DF_CMD_MAINMEMPAGEREAD);
				Dataflash_SendAddressBytes(CurrDFPage, 0);
     d82:	29 de       	rcall	.-942    	; 0x9d6 <Dataflash_SendAddressBytes>
     d84:	1e bc       	out	0x2e, r1	; 46
     d86:	0d b4       	in	r0, 0x2d	; 45
     d88:	07 fe       	sbrs	r0, 7
     d8a:	fd cf       	rjmp	.-6      	; 0xd86 <DataflashManager_ReadBlocks+0xd8>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     d8c:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     d8e:	0d b4       	in	r0, 0x2d	; 45
     d90:	07 fe       	sbrs	r0, 7
     d92:	fd cf       	rjmp	.-6      	; 0xd8e <DataflashManager_ReadBlocks+0xe0>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     d94:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     d96:	0d b4       	in	r0, 0x2d	; 45
     d98:	07 fe       	sbrs	r0, 7
     d9a:	fd cf       	rjmp	.-6      	; 0xd96 <DataflashManager_ReadBlocks+0xe8>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     d9c:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     d9e:	0d b4       	in	r0, 0x2d	; 45
     da0:	07 fe       	sbrs	r0, 7
     da2:	fd cf       	rjmp	.-6      	; 0xd9e <DataflashManager_ReadBlocks+0xf0>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     da4:	00 e0       	ldi	r16, 0x00	; 0
				while (!(SPSR & (1 << SPIF)));
     da6:	1e bc       	out	0x2e, r1	; 46
     da8:	0d b4       	in	r0, 0x2d	; 45
     daa:	07 fe       	sbrs	r0, 7

			/* Check if end of Dataflash page reached */
			if (CurrDFPageByteDiv16 == (DATAFLASH_PAGE_SIZE >> 4))
			{
				/* Reset the Dataflash buffer counter, increment the page counter */
				CurrDFPageByteDiv16 = 0;
     dac:	fd cf       	rjmp	.-6      	; 0xda8 <DataflashManager_ReadBlocks+0xfa>
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     dae:	8e b5       	in	r24, 0x2e	; 46
				while (!(SPSR & (1 << SPIF)));
     db0:	80 93 f1 00 	sts	0x00F1, r24
     db4:	1e bc       	out	0x2e, r1	; 46
				return SPDR;
     db6:	0d b4       	in	r0, 0x2d	; 45
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
     db8:	07 fe       	sbrs	r0, 7
     dba:	fd cf       	rjmp	.-6      	; 0xdb6 <DataflashManager_ReadBlocks+0x108>
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     dbc:	8e b5       	in	r24, 0x2e	; 46
				while (!(SPSR & (1 << SPIF)));
     dbe:	80 93 f1 00 	sts	0x00F1, r24
     dc2:	1e bc       	out	0x2e, r1	; 46
				return SPDR;
     dc4:	0d b4       	in	r0, 0x2d	; 45
     dc6:	07 fe       	sbrs	r0, 7
     dc8:	fd cf       	rjmp	.-6      	; 0xdc4 <DataflashManager_ReadBlocks+0x116>
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     dca:	8e b5       	in	r24, 0x2e	; 46
				while (!(SPSR & (1 << SPIF)));
     dcc:	80 93 f1 00 	sts	0x00F1, r24
     dd0:	1e bc       	out	0x2e, r1	; 46
				return SPDR;
     dd2:	0d b4       	in	r0, 0x2d	; 45
     dd4:	07 fe       	sbrs	r0, 7
     dd6:	fd cf       	rjmp	.-6      	; 0xdd2 <DataflashManager_ReadBlocks+0x124>
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     dd8:	8e b5       	in	r24, 0x2e	; 46
				while (!(SPSR & (1 << SPIF)));
     dda:	80 93 f1 00 	sts	0x00F1, r24
     dde:	1e bc       	out	0x2e, r1	; 46
				return SPDR;
     de0:	0d b4       	in	r0, 0x2d	; 45
     de2:	07 fe       	sbrs	r0, 7
     de4:	fd cf       	rjmp	.-6      	; 0xde0 <DataflashManager_ReadBlocks+0x132>
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     de6:	8e b5       	in	r24, 0x2e	; 46
				while (!(SPSR & (1 << SPIF)));
     de8:	80 93 f1 00 	sts	0x00F1, r24
     dec:	1e bc       	out	0x2e, r1	; 46
				return SPDR;
     dee:	0d b4       	in	r0, 0x2d	; 45
     df0:	07 fe       	sbrs	r0, 7
     df2:	fd cf       	rjmp	.-6      	; 0xdee <DataflashManager_ReadBlocks+0x140>
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     df4:	8e b5       	in	r24, 0x2e	; 46
				while (!(SPSR & (1 << SPIF)));
     df6:	80 93 f1 00 	sts	0x00F1, r24
     dfa:	1e bc       	out	0x2e, r1	; 46
				return SPDR;
     dfc:	0d b4       	in	r0, 0x2d	; 45
     dfe:	07 fe       	sbrs	r0, 7
     e00:	fd cf       	rjmp	.-6      	; 0xdfc <DataflashManager_ReadBlocks+0x14e>
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     e02:	8e b5       	in	r24, 0x2e	; 46
				while (!(SPSR & (1 << SPIF)));
     e04:	80 93 f1 00 	sts	0x00F1, r24
     e08:	1e bc       	out	0x2e, r1	; 46
				return SPDR;
     e0a:	0d b4       	in	r0, 0x2d	; 45
     e0c:	07 fe       	sbrs	r0, 7
     e0e:	fd cf       	rjmp	.-6      	; 0xe0a <DataflashManager_ReadBlocks+0x15c>
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     e10:	8e b5       	in	r24, 0x2e	; 46
				while (!(SPSR & (1 << SPIF)));
     e12:	80 93 f1 00 	sts	0x00F1, r24
     e16:	1e bc       	out	0x2e, r1	; 46
				return SPDR;
     e18:	0d b4       	in	r0, 0x2d	; 45
     e1a:	07 fe       	sbrs	r0, 7
     e1c:	fd cf       	rjmp	.-6      	; 0xe18 <DataflashManager_ReadBlocks+0x16a>
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     e1e:	8e b5       	in	r24, 0x2e	; 46
				while (!(SPSR & (1 << SPIF)));
     e20:	80 93 f1 00 	sts	0x00F1, r24
     e24:	1e bc       	out	0x2e, r1	; 46
				return SPDR;
     e26:	0d b4       	in	r0, 0x2d	; 45
     e28:	07 fe       	sbrs	r0, 7
     e2a:	fd cf       	rjmp	.-6      	; 0xe26 <DataflashManager_ReadBlocks+0x178>
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     e2c:	8e b5       	in	r24, 0x2e	; 46
				while (!(SPSR & (1 << SPIF)));
     e2e:	80 93 f1 00 	sts	0x00F1, r24
     e32:	1e bc       	out	0x2e, r1	; 46
				return SPDR;
     e34:	0d b4       	in	r0, 0x2d	; 45
     e36:	07 fe       	sbrs	r0, 7
     e38:	fd cf       	rjmp	.-6      	; 0xe34 <DataflashManager_ReadBlocks+0x186>
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     e3a:	8e b5       	in	r24, 0x2e	; 46
				while (!(SPSR & (1 << SPIF)));
     e3c:	80 93 f1 00 	sts	0x00F1, r24
     e40:	1e bc       	out	0x2e, r1	; 46
				return SPDR;
     e42:	0d b4       	in	r0, 0x2d	; 45
     e44:	07 fe       	sbrs	r0, 7
     e46:	fd cf       	rjmp	.-6      	; 0xe42 <DataflashManager_ReadBlocks+0x194>
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     e48:	8e b5       	in	r24, 0x2e	; 46
				while (!(SPSR & (1 << SPIF)));
     e4a:	80 93 f1 00 	sts	0x00F1, r24
     e4e:	1e bc       	out	0x2e, r1	; 46
				return SPDR;
     e50:	0d b4       	in	r0, 0x2d	; 45
     e52:	07 fe       	sbrs	r0, 7
     e54:	fd cf       	rjmp	.-6      	; 0xe50 <DataflashManager_ReadBlocks+0x1a2>
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     e56:	8e b5       	in	r24, 0x2e	; 46
				while (!(SPSR & (1 << SPIF)));
     e58:	80 93 f1 00 	sts	0x00F1, r24
     e5c:	1e bc       	out	0x2e, r1	; 46
				return SPDR;
     e5e:	0d b4       	in	r0, 0x2d	; 45
     e60:	07 fe       	sbrs	r0, 7
     e62:	fd cf       	rjmp	.-6      	; 0xe5e <DataflashManager_ReadBlocks+0x1b0>
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     e64:	8e b5       	in	r24, 0x2e	; 46
				while (!(SPSR & (1 << SPIF)));
     e66:	80 93 f1 00 	sts	0x00F1, r24
     e6a:	1e bc       	out	0x2e, r1	; 46
				return SPDR;
     e6c:	0d b4       	in	r0, 0x2d	; 45
     e6e:	07 fe       	sbrs	r0, 7
     e70:	fd cf       	rjmp	.-6      	; 0xe6c <DataflashManager_ReadBlocks+0x1be>
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     e72:	8e b5       	in	r24, 0x2e	; 46
				while (!(SPSR & (1 << SPIF)));
     e74:	80 93 f1 00 	sts	0x00F1, r24
     e78:	1e bc       	out	0x2e, r1	; 46
				return SPDR;
     e7a:	0d b4       	in	r0, 0x2d	; 45
     e7c:	07 fe       	sbrs	r0, 7
     e7e:	fd cf       	rjmp	.-6      	; 0xe7a <DataflashManager_ReadBlocks+0x1cc>
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     e80:	8e b5       	in	r24, 0x2e	; 46
				while (!(SPSR & (1 << SPIF)));
     e82:	80 93 f1 00 	sts	0x00F1, r24
     e86:	0f 5f       	subi	r16, 0xFF	; 255
				return SPDR;
     e88:	f6 01       	movw	r30, r12
     e8a:	80 ad       	ldd	r24, Z+56	; 0x38
     e8c:	81 11       	cpse	r24, r1
			Endpoint_Write_8(Dataflash_ReceiveByte());
			Endpoint_Write_8(Dataflash_ReceiveByte());
			Endpoint_Write_8(Dataflash_ReceiveByte());

			/* Increment the Dataflash page 16 byte block counter */
			CurrDFPageByteDiv16++;
     e8e:	13 c0       	rjmp	.+38     	; 0xeb6 <DataflashManager_ReadBlocks+0x208>

			/* Increment the block 16 byte block counter */
			BytesInBlockDiv16++;

			/* Check if the current command is being aborted by the host */
			if (MSInterfaceInfo->State.IsMassStoreReset)
     e90:	11 50       	subi	r17, 0x01	; 1
     e92:	09 f0       	breq	.+2      	; 0xe96 <DataflashManager_ReadBlocks+0x1e8>
     e94:	5b cf       	rjmp	.-330    	; 0xd4c <DataflashManager_ReadBlocks+0x9e>
     e96:	f1 e0       	ldi	r31, 0x01	; 1
     e98:	ef 1a       	sub	r14, r31
	while (TotalBlocks)
	{
		uint8_t BytesInBlockDiv16 = 0;

		/* Write an endpoint packet sized data block to the Dataflash */
		while (BytesInBlockDiv16 < (VIRTUAL_MEMORY_BLOCK_SIZE >> 4))
     e9a:	f1 08       	sbc	r15, r1
     e9c:	52 cf       	rjmp	.-348    	; 0xd42 <DataflashManager_ReadBlocks+0x94>
			if (MSInterfaceInfo->State.IsMassStoreReset)
			  return;
		}

		/* Decrement the blocks remaining counter */
		TotalBlocks--;
     e9e:	80 91 e8 00 	lds	r24, 0x00E8
     ea2:	85 fd       	sbrc	r24, 5
     ea4:	05 c0       	rjmp	.+10     	; 0xeb0 <DataflashManager_ReadBlocks+0x202>
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
     ea6:	80 91 e8 00 	lds	r24, 0x00E8
	}

	/* If the endpoint is full, send its contents to the host */
	if (!(Endpoint_IsReadWriteAllowed()))
     eaa:	8e 77       	andi	r24, 0x7E	; 126
     eac:	80 93 e8 00 	sts	0x00E8, r24
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
     eb0:	8e b1       	in	r24, 0x0e	; 14
     eb2:	83 60       	ori	r24, 0x03	; 3
     eb4:	8e b9       	out	0x0e, r24	; 14
     eb6:	df 91       	pop	r29
     eb8:	cf 91       	pop	r28
     eba:	1f 91       	pop	r17
     ebc:	0f 91       	pop	r16
	  Endpoint_ClearIN();

	/* Deselect all Dataflash chips */
	Dataflash_DeselectChip();
}
     ebe:	ff 90       	pop	r15
     ec0:	ef 90       	pop	r14
     ec2:	df 90       	pop	r13
     ec4:	cf 90       	pop	r12
     ec6:	bf 90       	pop	r11
     ec8:	af 90       	pop	r10
     eca:	9f 90       	pop	r9
     ecc:	8f 90       	pop	r8
     ece:	08 95       	ret

00000ed0 <DataflashManager_ReadBlocks_RAM>:
     ed0:	6f 92       	push	r6
     ed2:	7f 92       	push	r7
     ed4:	9f 92       	push	r9
     ed6:	af 92       	push	r10
 *  \param[out] BufferPtr    Pointer to the data destination RAM buffer
 */
void DataflashManager_ReadBlocks_RAM(const uint32_t BlockAddress,
                                     uint16_t TotalBlocks,
                                     uint8_t* BufferPtr)
{
     ed8:	bf 92       	push	r11
     eda:	cf 92       	push	r12
     edc:	df 92       	push	r13
     ede:	ef 92       	push	r14
     ee0:	ff 92       	push	r15
     ee2:	0f 93       	push	r16
     ee4:	1f 93       	push	r17
     ee6:	cf 93       	push	r28
     ee8:	df 93       	push	r29
     eea:	5a 01       	movw	r10, r20
     eec:	89 01       	movw	r16, r18
	uint16_t CurrDFPage          = ((BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE) / DATAFLASH_PAGE_SIZE);
     eee:	6b 01       	movw	r12, r22
     ef0:	7c 01       	movw	r14, r24
     ef2:	99 e0       	ldi	r25, 0x09	; 9
     ef4:	cc 0c       	add	r12, r12
     ef6:	dd 1c       	adc	r13, r13
     ef8:	ee 1c       	adc	r14, r14
     efa:	ff 1c       	adc	r15, r15
     efc:	9a 95       	dec	r25
     efe:	d1 f7       	brne	.-12     	; 0xef4 <DataflashManager_ReadBlocks_RAM+0x24>
     f00:	2a e0       	ldi	r18, 0x0A	; 10
     f02:	f6 94       	lsr	r15
     f04:	e7 94       	ror	r14
     f06:	d7 94       	ror	r13
     f08:	c7 94       	ror	r12
     f0a:	2a 95       	dec	r18
     f0c:	d1 f7       	brne	.-12     	; 0xf02 <DataflashManager_ReadBlocks_RAM+0x32>
     f0e:	e6 01       	movw	r28, r12
	uint16_t CurrDFPageByte      = ((BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE) % DATAFLASH_PAGE_SIZE);
     f10:	3b 01       	movw	r6, r22
     f12:	76 2c       	mov	r7, r6
     f14:	66 24       	eor	r6, r6
     f16:	77 0c       	add	r7, r7
     f18:	66 24       	eor	r6, r6
     f1a:	82 e0       	ldi	r24, 0x02	; 2
     f1c:	78 22       	and	r7, r24
	uint8_t  CurrDFPageByteDiv16 = (CurrDFPageByte >> 4);
     f1e:	c3 01       	movw	r24, r6
     f20:	44 e0       	ldi	r20, 0x04	; 4
     f22:	96 95       	lsr	r25
     f24:	87 95       	ror	r24
     f26:	4a 95       	dec	r20
     f28:	e1 f7       	brne	.-8      	; 0xf22 <DataflashManager_ReadBlocks_RAM+0x52>
     f2a:	98 2e       	mov	r9, r24

	/* Select the correct starting Dataflash IC for the block requested */
	Dataflash_SelectChipFromPage(CurrDFPage);
     f2c:	c6 01       	movw	r24, r12
     f2e:	6c dd       	rcall	.-1320   	; 0xa08 <Dataflash_SelectChipFromPage>
     f30:	82 ed       	ldi	r24, 0xD2	; 210
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     f32:	8e bd       	out	0x2e, r24	; 46
     f34:	0d b4       	in	r0, 0x2d	; 45
				while (!(SPSR & (1 << SPIF)));
     f36:	07 fe       	sbrs	r0, 7
     f38:	fd cf       	rjmp	.-6      	; 0xf34 <DataflashManager_ReadBlocks_RAM+0x64>
     f3a:	b3 01       	movw	r22, r6

	/* Send the Dataflash main memory page read command */
	Dataflash_SendByte(DF_CMD_MAINMEMPAGEREAD);
	Dataflash_SendAddressBytes(CurrDFPage, CurrDFPageByte);
     f3c:	c6 01       	movw	r24, r12
     f3e:	4b dd       	rcall	.-1386   	; 0x9d6 <Dataflash_SendAddressBytes>
     f40:	1e bc       	out	0x2e, r1	; 46
     f42:	0d b4       	in	r0, 0x2d	; 45
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     f44:	07 fe       	sbrs	r0, 7
				while (!(SPSR & (1 << SPIF)));
     f46:	fd cf       	rjmp	.-6      	; 0xf42 <DataflashManager_ReadBlocks_RAM+0x72>
     f48:	1e bc       	out	0x2e, r1	; 46
     f4a:	0d b4       	in	r0, 0x2d	; 45
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     f4c:	07 fe       	sbrs	r0, 7
				while (!(SPSR & (1 << SPIF)));
     f4e:	fd cf       	rjmp	.-6      	; 0xf4a <DataflashManager_ReadBlocks_RAM+0x7a>
     f50:	1e bc       	out	0x2e, r1	; 46
     f52:	0d b4       	in	r0, 0x2d	; 45
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     f54:	07 fe       	sbrs	r0, 7
				while (!(SPSR & (1 << SPIF)));
     f56:	fd cf       	rjmp	.-6      	; 0xf52 <DataflashManager_ReadBlocks_RAM+0x82>
     f58:	1e bc       	out	0x2e, r1	; 46
     f5a:	0d b4       	in	r0, 0x2d	; 45
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     f5c:	07 fe       	sbrs	r0, 7
				while (!(SPSR & (1 << SPIF)));
     f5e:	fd cf       	rjmp	.-6      	; 0xf5a <DataflashManager_ReadBlocks_RAM+0x8a>
     f60:	82 ed       	ldi	r24, 0xD2	; 210
     f62:	d8 2e       	mov	r13, r24
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     f64:	a1 14       	cp	r10, r1
     f66:	b1 04       	cpc	r11, r1
	Dataflash_SendByte(0x00);
	Dataflash_SendByte(0x00);
	Dataflash_SendByte(0x00);
	Dataflash_SendByte(0x00);

	while (TotalBlocks)
     f68:	c1 f1       	breq	.+112    	; 0xfda <DataflashManager_ReadBlocks_RAM+0x10a>
     f6a:	78 01       	movw	r14, r16
     f6c:	8e ef       	ldi	r24, 0xFE	; 254
     f6e:	f8 1a       	sub	r15, r24
     f70:	80 e4       	ldi	r24, 0x40	; 64
     f72:	98 12       	cpse	r9, r24

		/* Write an endpoint packet sized data block to the Dataflash */
		while (BytesInBlockDiv16 < (VIRTUAL_MEMORY_BLOCK_SIZE >> 4))
		{
			/* Check if end of Dataflash page reached */
			if (CurrDFPageByteDiv16 == (DATAFLASH_PAGE_SIZE >> 4))
     f74:	1c c0       	rjmp	.+56     	; 0xfae <DataflashManager_ReadBlocks_RAM+0xde>
     f76:	21 96       	adiw	r28, 0x01	; 1
     f78:	ce 01       	movw	r24, r28
			{
				/* Reset the Dataflash buffer counter, increment the page counter */
				CurrDFPageByteDiv16 = 0;
				CurrDFPage++;
     f7a:	46 dd       	rcall	.-1396   	; 0xa08 <Dataflash_SelectChipFromPage>

				/* Select the next Dataflash chip based on the new Dataflash page index */
				Dataflash_SelectChipFromPage(CurrDFPage);
     f7c:	de bc       	out	0x2e, r13	; 46
     f7e:	0d b4       	in	r0, 0x2d	; 45
     f80:	07 fe       	sbrs	r0, 7
     f82:	fd cf       	rjmp	.-6      	; 0xf7e <DataflashManager_ReadBlocks_RAM+0xae>
				while (!(SPSR & (1 << SPIF)));
     f84:	60 e0       	ldi	r22, 0x00	; 0
     f86:	70 e0       	ldi	r23, 0x00	; 0
     f88:	ce 01       	movw	r24, r28

				/* Send the Dataflash main memory page read command */
				Dataflash_SendByte(DF_CMD_MAINMEMPAGEREAD);
				Dataflash_SendAddressBytes(CurrDFPage, 0);
     f8a:	25 dd       	rcall	.-1462   	; 0x9d6 <Dataflash_SendAddressBytes>
     f8c:	1e bc       	out	0x2e, r1	; 46
     f8e:	0d b4       	in	r0, 0x2d	; 45
     f90:	07 fe       	sbrs	r0, 7
     f92:	fd cf       	rjmp	.-6      	; 0xf8e <DataflashManager_ReadBlocks_RAM+0xbe>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     f94:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     f96:	0d b4       	in	r0, 0x2d	; 45
     f98:	07 fe       	sbrs	r0, 7
     f9a:	fd cf       	rjmp	.-6      	; 0xf96 <DataflashManager_ReadBlocks_RAM+0xc6>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     f9c:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     f9e:	0d b4       	in	r0, 0x2d	; 45
     fa0:	07 fe       	sbrs	r0, 7
     fa2:	fd cf       	rjmp	.-6      	; 0xf9e <DataflashManager_ReadBlocks_RAM+0xce>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     fa4:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     fa6:	0d b4       	in	r0, 0x2d	; 45
     fa8:	07 fe       	sbrs	r0, 7
     faa:	fd cf       	rjmp	.-6      	; 0xfa6 <DataflashManager_ReadBlocks_RAM+0xd6>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     fac:	91 2c       	mov	r9, r1
				while (!(SPSR & (1 << SPIF)));
     fae:	f8 01       	movw	r30, r16
     fb0:	c8 01       	movw	r24, r16
     fb2:	40 96       	adiw	r24, 0x10	; 16
		{
			/* Check if end of Dataflash page reached */
			if (CurrDFPageByteDiv16 == (DATAFLASH_PAGE_SIZE >> 4))
			{
				/* Reset the Dataflash buffer counter, increment the page counter */
				CurrDFPageByteDiv16 = 0;
     fb4:	1e bc       	out	0x2e, r1	; 46
     fb6:	0d b4       	in	r0, 0x2d	; 45
     fb8:	07 fe       	sbrs	r0, 7
     fba:	fd cf       	rjmp	.-6      	; 0xfb6 <DataflashManager_ReadBlocks_RAM+0xe6>
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     fbc:	2e b5       	in	r18, 0x2e	; 46
				while (!(SPSR & (1 << SPIF)));
     fbe:	21 93       	st	Z+, r18
     fc0:	e8 17       	cp	r30, r24
     fc2:	f9 07       	cpc	r31, r25
				return SPDR;
     fc4:	b9 f7       	brne	.-18     	; 0xfb4 <DataflashManager_ReadBlocks_RAM+0xe4>
				Dataflash_SendByte(0x00);
			}

			/* Read one 16-byte chunk of data from the Dataflash */
			for (uint8_t ByteNum = 0; ByteNum < 16; ByteNum++)
			  *(BufferPtr++) = Dataflash_ReceiveByte();
     fc6:	8f 01       	movw	r16, r30
				Dataflash_SendByte(0x00);
				Dataflash_SendByte(0x00);
			}

			/* Read one 16-byte chunk of data from the Dataflash */
			for (uint8_t ByteNum = 0; ByteNum < 16; ByteNum++)
     fc8:	93 94       	inc	r9
     fca:	ee 15       	cp	r30, r14
     fcc:	ff 05       	cpc	r31, r15
     fce:	81 f6       	brne	.-96     	; 0xf70 <DataflashManager_ReadBlocks_RAM+0xa0>
			  *(BufferPtr++) = Dataflash_ReceiveByte();

			/* Increment the Dataflash page 16 byte block counter */
			CurrDFPageByteDiv16++;
     fd0:	8f 01       	movw	r16, r30
	while (TotalBlocks)
	{
		uint8_t BytesInBlockDiv16 = 0;

		/* Write an endpoint packet sized data block to the Dataflash */
		while (BytesInBlockDiv16 < (VIRTUAL_MEMORY_BLOCK_SIZE >> 4))
     fd2:	81 e0       	ldi	r24, 0x01	; 1
     fd4:	a8 1a       	sub	r10, r24
     fd6:	b1 08       	sbc	r11, r1
     fd8:	c5 cf       	rjmp	.-118    	; 0xf64 <DataflashManager_ReadBlocks_RAM+0x94>
			/* Increment the block 16 byte block counter */
			BytesInBlockDiv16++;
		}

		/* Decrement the blocks remaining counter */
		TotalBlocks--;
     fda:	8e b1       	in	r24, 0x0e	; 14
     fdc:	83 60       	ori	r24, 0x03	; 3
     fde:	8e b9       	out	0x0e, r24	; 14
     fe0:	df 91       	pop	r29
     fe2:	cf 91       	pop	r28
     fe4:	1f 91       	pop	r17
     fe6:	0f 91       	pop	r16
	}

	/* Deselect all Dataflash chips */
	Dataflash_DeselectChip();
}
     fe8:	ff 90       	pop	r15
     fea:	ef 90       	pop	r14
     fec:	df 90       	pop	r13
     fee:	cf 90       	pop	r12
     ff0:	bf 90       	pop	r11
     ff2:	af 90       	pop	r10
     ff4:	9f 90       	pop	r9
     ff6:	7f 90       	pop	r7
     ff8:	6f 90       	pop	r6
     ffa:	08 95       	ret

00000ffc <DataflashManager_CheckDataflashOperation>:
     ffc:	8e b1       	in	r24, 0x0e	; 14
     ffe:	83 60       	ori	r24, 0x03	; 3
    1000:	8e 7f       	andi	r24, 0xFE	; 254
    1002:	8e b9       	out	0x0e, r24	; 14
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
    1004:	8f e9       	ldi	r24, 0x9F	; 159
    1006:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
    1008:	0d b4       	in	r0, 0x2d	; 45
    100a:	07 fe       	sbrs	r0, 7
    100c:	fd cf       	rjmp	.-6      	; 0x1008 <DataflashManager_CheckDataflashOperation+0xc>
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
    100e:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
    1010:	0d b4       	in	r0, 0x2d	; 45
    1012:	07 fe       	sbrs	r0, 7
    1014:	fd cf       	rjmp	.-6      	; 0x1010 <DataflashManager_CheckDataflashOperation+0x14>
				return SPDR;
    1016:	9e b5       	in	r25, 0x2e	; 46
    1018:	8e b1       	in	r24, 0x0e	; 14
    101a:	83 60       	ori	r24, 0x03	; 3
    101c:	8e b9       	out	0x0e, r24	; 14
	Dataflash_SendByte(DF_CMD_READMANUFACTURERDEVICEINFO);
	ReturnByte = Dataflash_ReceiveByte();
	Dataflash_DeselectChip();

	/* If returned data is invalid, fail the command */
	if (ReturnByte != DF_MANUFACTURER_ATMEL)
    101e:	9f 31       	cpi	r25, 0x1F	; 31
    1020:	a1 f4       	brne	.+40     	; 0x104a <DataflashManager_CheckDataflashOperation+0x4e>
    1022:	8e b1       	in	r24, 0x0e	; 14
    1024:	83 60       	ori	r24, 0x03	; 3
    1026:	8d 7f       	andi	r24, 0xFD	; 253
    1028:	8e b9       	out	0x0e, r24	; 14
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
    102a:	8f e9       	ldi	r24, 0x9F	; 159
    102c:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
    102e:	0d b4       	in	r0, 0x2d	; 45
    1030:	07 fe       	sbrs	r0, 7
    1032:	fd cf       	rjmp	.-6      	; 0x102e <DataflashManager_CheckDataflashOperation+0x32>
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
    1034:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
    1036:	0d b4       	in	r0, 0x2d	; 45
    1038:	07 fe       	sbrs	r0, 7
    103a:	fd cf       	rjmp	.-6      	; 0x1036 <DataflashManager_CheckDataflashOperation+0x3a>
				return SPDR;
    103c:	9e b5       	in	r25, 0x2e	; 46
    103e:	8e b1       	in	r24, 0x0e	; 14
    1040:	83 60       	ori	r24, 0x03	; 3
    1042:	8e b9       	out	0x0e, r24	; 14
	Dataflash_SendByte(DF_CMD_READMANUFACTURERDEVICEINFO);
	ReturnByte = Dataflash_ReceiveByte();
	Dataflash_DeselectChip();

	/* If returned data is invalid, fail the command */
	if (ReturnByte != DF_MANUFACTURER_ATMEL)
    1044:	81 e0       	ldi	r24, 0x01	; 1
    1046:	9f 31       	cpi	r25, 0x1F	; 31
    1048:	09 f0       	breq	.+2      	; 0x104c <DataflashManager_CheckDataflashOperation+0x50>
	ReturnByte = Dataflash_ReceiveByte();
	Dataflash_DeselectChip();

	/* If returned data is invalid, fail the command */
	if (ReturnByte != DF_MANUFACTURER_ATMEL)
	  return false;
    104a:	80 e0       	ldi	r24, 0x00	; 0
	if (ReturnByte != DF_MANUFACTURER_ATMEL)
	  return false;
	#endif

	return true;
}
    104c:	08 95       	ret

0000104e <LEDs_SetAllLEDs>:
				PORTD &= ~LEDMask;
			}

			static inline void LEDs_SetAllLEDs(const uint8_t LEDMask)
			{
				PORTD = ((PORTD & ~LEDS_ALL_LEDS) | LEDMask);
    104e:	9b b1       	in	r25, 0x0b	; 11
    1050:	9f 70       	andi	r25, 0x0F	; 15
    1052:	98 2b       	or	r25, r24
    1054:	9b b9       	out	0x0b, r25	; 11
    1056:	08 95       	ret

00001058 <uIPManagement_Init>:
struct uip_eth_addr MACAddress;


/** Configures the uIP stack ready for network traffic processing. */
void uIPManagement_Init(void)
{
    1058:	cf 93       	push	r28
	/* uIP Timing Initialization */
	clock_init();
    105a:	0e 94 45 1b 	call	0x368a	; 0x368a <clock_init>
	timer_set(&ConnectionTimer, CLOCK_SECOND / 2);
    105e:	62 e3       	ldi	r22, 0x32	; 50
    1060:	70 e0       	ldi	r23, 0x00	; 0
    1062:	88 e8       	ldi	r24, 0x88	; 136
    1064:	93 e0       	ldi	r25, 0x03	; 3
    1066:	0e 94 04 1b 	call	0x3608	; 0x3608 <timer_set>
	timer_set(&ARPTimer, CLOCK_SECOND * 10);
    106a:	68 ee       	ldi	r22, 0xE8	; 232
    106c:	73 e0       	ldi	r23, 0x03	; 3
    106e:	84 e8       	ldi	r24, 0x84	; 132
    1070:	93 e0       	ldi	r25, 0x03	; 3
    1072:	0e 94 04 1b 	call	0x3608	; 0x3608 <timer_set>

	/* uIP Stack Initialization */
	uip_init();
    1076:	0e 94 52 10 	call	0x20a4	; 0x20a4 <uip_init>
	uip_arp_init();
    107a:	0e 94 14 19 	call	0x3228	; 0x3228 <uip_arp_init>

	/* DHCP/Server IP Settings Initialization */
	if (USB_CurrentMode == USB_MODE_Device)
    107e:	c0 91 07 04 	lds	r28, 0x0407
    1082:	c1 30       	cpi	r28, 0x01	; 1
    1084:	49 f5       	brne	.+82     	; 0x10d8 <uIPManagement_Init+0x80>
	{
		MACAddress.addr[0] = SERVER_MAC_ADDRESS[0];
    1086:	c0 93 0a 04 	sts	0x040A, r28
		MACAddress.addr[1] = SERVER_MAC_ADDRESS[1];
    108a:	10 92 0b 04 	sts	0x040B, r1
		MACAddress.addr[2] = SERVER_MAC_ADDRESS[2];
    108e:	c0 93 0c 04 	sts	0x040C, r28
		MACAddress.addr[3] = SERVER_MAC_ADDRESS[3];
    1092:	10 92 0d 04 	sts	0x040D, r1
		MACAddress.addr[4] = SERVER_MAC_ADDRESS[4];
    1096:	c0 93 0e 04 	sts	0x040E, r28
		MACAddress.addr[5] = SERVER_MAC_ADDRESS[5];
    109a:	10 92 0f 04 	sts	0x040F, r1

		#if defined(ENABLE_DHCP_SERVER)
		DHCPServerApp_Init();
    109e:	7a d3       	rcall	.+1780   	; 0x1794 <DHCPServerApp_Init>
    10a0:	9a e0       	ldi	r25, 0x0A	; 10

		uip_ipaddr_t IPAddress, Netmask, GatewayIPAddress;
		uip_ipaddr(&IPAddress,        DEVICE_IP_ADDRESS[0], DEVICE_IP_ADDRESS[1], DEVICE_IP_ADDRESS[2], DEVICE_IP_ADDRESS[3]);
		uip_ipaddr(&Netmask,          DEVICE_NETMASK[0],    DEVICE_NETMASK[1],    DEVICE_NETMASK[2],    DEVICE_NETMASK[3]);
		uip_ipaddr(&GatewayIPAddress, DEVICE_GATEWAY[0],    DEVICE_GATEWAY[1],    DEVICE_GATEWAY[2],    DEVICE_GATEWAY[3]);
		uip_sethostaddr(&IPAddress);
    10a2:	90 93 c7 07 	sts	0x07C7, r25
    10a6:	10 92 c8 07 	sts	0x07C8, r1
    10aa:	10 92 c9 07 	sts	0x07C9, r1
    10ae:	82 e0       	ldi	r24, 0x02	; 2
    10b0:	80 93 ca 07 	sts	0x07CA, r24
    10b4:	8f ef       	ldi	r24, 0xFF	; 255
		uip_setnetmask(&Netmask);
    10b6:	80 93 c3 07 	sts	0x07C3, r24
    10ba:	80 93 c4 07 	sts	0x07C4, r24
    10be:	80 93 c5 07 	sts	0x07C5, r24
    10c2:	10 92 c6 07 	sts	0x07C6, r1
    10c6:	90 93 bf 07 	sts	0x07BF, r25
		uip_setdraddr(&GatewayIPAddress);
    10ca:	10 92 c0 07 	sts	0x07C0, r1
    10ce:	10 92 c1 07 	sts	0x07C1, r1
    10d2:	c0 93 c2 07 	sts	0x07C2, r28
    10d6:	01 c0       	rjmp	.+2      	; 0x10da <uIPManagement_Init+0x82>
    10d8:	a6 d1       	rcall	.+844    	; 0x1426 <DHCPClientApp_Init>
	}
	else
	{
		#if defined(ENABLE_DHCP_CLIENT)
		DHCPClientApp_Init();
    10da:	80 91 0a 04 	lds	r24, 0x040A
		uip_setdraddr(&GatewayIPAddress);
		#endif
	}

	/* Virtual Webserver Ethernet Address Configuration */
	uip_setethaddr(MACAddress);
    10de:	80 93 8c 03 	sts	0x038C, r24
    10e2:	80 91 0b 04 	lds	r24, 0x040B
    10e6:	80 93 8d 03 	sts	0x038D, r24
    10ea:	80 91 0c 04 	lds	r24, 0x040C
    10ee:	80 93 8e 03 	sts	0x038E, r24
    10f2:	80 91 0d 04 	lds	r24, 0x040D
    10f6:	80 93 8f 03 	sts	0x038F, r24
    10fa:	80 91 0e 04 	lds	r24, 0x040E
    10fe:	80 93 90 03 	sts	0x0390, r24
    1102:	80 91 0f 04 	lds	r24, 0x040F
    1106:	80 93 91 03 	sts	0x0391, r24
    110a:	97 d4       	rcall	.+2350   	; 0x1a3a <HTTPServerApp_Init>
    110c:	cf 91       	pop	r28

	/* HTTP Webserver Initialization */
	HTTPServerApp_Init();
    110e:	1a c6       	rjmp	.+3124   	; 0x1d44 <TELNETServerApp_Init>

00001110 <uIPManagement_ManageNetwork>:
    1110:	cf 93       	push	r28

	/* TELNET Server Initialization */
	#if defined(ENABLE_TELNET_SERVER)
	TELNETServerApp_Init();
	#endif
}
    1112:	df 93       	push	r29
	/* HTTP Webserver Initialization */
	HTTPServerApp_Init();

	/* TELNET Server Initialization */
	#if defined(ENABLE_TELNET_SERVER)
	TELNETServerApp_Init();
    1114:	80 91 07 04 	lds	r24, 0x0407
/** uIP Management function. This function manages the uIP stack when called while an RNDIS device has been
 *  attached to the system.
 */
void uIPManagement_ManageNetwork(void)
{
	if (((USB_CurrentMode == USB_MODE_Host)   && (USB_HostState   == HOST_STATE_Configured)) ||
    1118:	82 30       	cpi	r24, 0x02	; 2
    111a:	19 f4       	brne	.+6      	; 0x1122 <uIPManagement_ManageNetwork+0x12>
    111c:	8e b3       	in	r24, 0x1e	; 30
    111e:	8b 30       	cpi	r24, 0x0B	; 11
    1120:	49 f0       	breq	.+18     	; 0x1134 <uIPManagement_ManageNetwork+0x24>
	    ((USB_CurrentMode == USB_MODE_Device) && (USB_DeviceState == DEVICE_STATE_Configured)))
    1122:	80 91 07 04 	lds	r24, 0x0407
/** uIP Management function. This function manages the uIP stack when called while an RNDIS device has been
 *  attached to the system.
 */
void uIPManagement_ManageNetwork(void)
{
	if (((USB_CurrentMode == USB_MODE_Host)   && (USB_HostState   == HOST_STATE_Configured)) ||
    1126:	81 30       	cpi	r24, 0x01	; 1
    1128:	09 f0       	breq	.+2      	; 0x112c <uIPManagement_ManageNetwork+0x1c>
    112a:	b1 c0       	rjmp	.+354    	; 0x128e <uIPManagement_ManageNetwork+0x17e>
	    ((USB_CurrentMode == USB_MODE_Device) && (USB_DeviceState == DEVICE_STATE_Configured)))
    112c:	8e b3       	in	r24, 0x1e	; 30
    112e:	84 30       	cpi	r24, 0x04	; 4
    1130:	09 f0       	breq	.+2      	; 0x1134 <uIPManagement_ManageNetwork+0x24>
    1132:	ad c0       	rjmp	.+346    	; 0x128e <uIPManagement_ManageNetwork+0x17e>

/** Processes Incoming packets to the server from the connected RNDIS device, creating responses as needed. */
static void uIPManagement_ProcessIncomingPacket(void)
{
	/* Determine which USB mode the system is currently initialized in */
	if (USB_CurrentMode == USB_MODE_Device)
    1134:	80 91 07 04 	lds	r24, 0x0407
    1138:	81 30       	cpi	r24, 0x01	; 1
    113a:	91 f4       	brne	.+36     	; 0x1160 <uIPManagement_ManageNetwork+0x50>
	{
		/* If no packet received, exit processing routine */
		if (!(RNDIS_Device_IsPacketReceived(&Ethernet_RNDIS_Interface_Device)))
    113c:	89 e3       	ldi	r24, 0x39	; 57
    113e:	91 e0       	ldi	r25, 0x01	; 1
    1140:	0e 94 49 35 	call	0x6a92	; 0x6a92 <RNDIS_Device_IsPacketReceived>
    1144:	88 23       	and	r24, r24
    1146:	09 f4       	brne	.+2      	; 0x114a <uIPManagement_ManageNetwork+0x3a>
    1148:	44 c0       	rjmp	.+136    	; 0x11d2 <uIPManagement_ManageNetwork+0xc2>
		  return;

		LEDs_SetAllLEDs(LEDMASK_USB_BUSY);
    114a:	80 ed       	ldi	r24, 0xD0	; 208
    114c:	80 df       	rcall	.-256    	; 0x104e <LEDs_SetAllLEDs>
    114e:	43 e5       	ldi	r20, 0x53	; 83

		/* Read the Incoming packet straight into the UIP packet buffer */
		RNDIS_Device_ReadPacket(&Ethernet_RNDIS_Interface_Device, uip_buf, &uip_len);
    1150:	56 e0       	ldi	r21, 0x06	; 6
    1152:	6b ec       	ldi	r22, 0xCB	; 203
    1154:	77 e0       	ldi	r23, 0x07	; 7
    1156:	89 e3       	ldi	r24, 0x39	; 57
    1158:	91 e0       	ldi	r25, 0x01	; 1
    115a:	0e 94 5c 35 	call	0x6ab8	; 0x6ab8 <RNDIS_Device_ReadPacket>
    115e:	10 c0       	rjmp	.+32     	; 0x1180 <uIPManagement_ManageNetwork+0x70>
    1160:	8b e5       	ldi	r24, 0x5B	; 91
	}
	else
	{
		/* If no packet received, exit processing routine */
		if (!(RNDIS_Host_IsPacketReceived(&Ethernet_RNDIS_Interface_Host)))
    1162:	91 e0       	ldi	r25, 0x01	; 1
    1164:	0e 94 21 39 	call	0x7242	; 0x7242 <RNDIS_Host_IsPacketReceived>
    1168:	88 23       	and	r24, r24
    116a:	99 f1       	breq	.+102    	; 0x11d2 <uIPManagement_ManageNetwork+0xc2>
    116c:	80 ed       	ldi	r24, 0xD0	; 208
		  return;

		LEDs_SetAllLEDs(LEDMASK_USB_BUSY);
    116e:	6f df       	rcall	.-290    	; 0x104e <LEDs_SetAllLEDs>
    1170:	43 e5       	ldi	r20, 0x53	; 83
    1172:	56 e0       	ldi	r21, 0x06	; 6

		/* Read the Incoming packet straight into the UIP packet buffer */
		RNDIS_Host_ReadPacket(&Ethernet_RNDIS_Interface_Host, uip_buf, &uip_len);
    1174:	6b ec       	ldi	r22, 0xCB	; 203
    1176:	77 e0       	ldi	r23, 0x07	; 7
    1178:	8b e5       	ldi	r24, 0x5B	; 91
    117a:	91 e0       	ldi	r25, 0x01	; 1
    117c:	0e 94 3c 39 	call	0x7278	; 0x7278 <RNDIS_Host_ReadPacket>
    1180:	80 91 53 06 	lds	r24, 0x0653
	}

	/* If the packet contains an Ethernet frame, process it */
	if (uip_len > 0)
    1184:	90 91 54 06 	lds	r25, 0x0654
    1188:	89 2b       	or	r24, r25
    118a:	09 f1       	breq	.+66     	; 0x11ce <uIPManagement_ManageNetwork+0xbe>
    118c:	80 91 d7 07 	lds	r24, 0x07D7
	{
		switch (((struct uip_eth_hdr*)uip_buf)->type)
    1190:	90 91 d8 07 	lds	r25, 0x07D8
    1194:	88 30       	cpi	r24, 0x08	; 8
    1196:	91 05       	cpc	r25, r1
    1198:	21 f0       	breq	.+8      	; 0x11a2 <uIPManagement_ManageNetwork+0x92>
    119a:	88 30       	cpi	r24, 0x08	; 8
    119c:	96 40       	sbci	r25, 0x06	; 6
    119e:	69 f0       	breq	.+26     	; 0x11ba <uIPManagement_ManageNetwork+0xaa>
    11a0:	16 c0       	rjmp	.+44     	; 0x11ce <uIPManagement_ManageNetwork+0xbe>
    11a2:	81 e0       	ldi	r24, 0x01	; 1
    11a4:	0e 94 d9 10 	call	0x21b2	; 0x21b2 <uip_process>
			case HTONS(UIP_ETHTYPE_IP):
				/* Filter packet by MAC destination */
				uip_arp_ipin();

				/* Process Incoming packet */
				uip_input();
    11a8:	80 91 53 06 	lds	r24, 0x0653

				/* If a response was generated, send it */
				if (uip_len > 0)
    11ac:	90 91 54 06 	lds	r25, 0x0654
    11b0:	89 2b       	or	r24, r25
    11b2:	69 f0       	breq	.+26     	; 0x11ce <uIPManagement_ManageNetwork+0xbe>
    11b4:	0e 94 01 1a 	call	0x3402	; 0x3402 <uip_arp_out>
				{
					/* Add destination MAC to outgoing packet */
					uip_arp_out();
    11b8:	08 c0       	rjmp	.+16     	; 0x11ca <uIPManagement_ManageNetwork+0xba>
    11ba:	0e 94 61 19 	call	0x32c2	; 0x32c2 <uip_arp_arpin>
				}

				break;
			case HTONS(UIP_ETHTYPE_ARP):
				/* Process ARP packet */
				uip_arp_arpin();
    11be:	80 91 53 06 	lds	r24, 0x0653

				/* If a response was generated, send it */
				if (uip_len > 0)
    11c2:	90 91 54 06 	lds	r25, 0x0654
    11c6:	89 2b       	or	r24, r25
    11c8:	11 f0       	breq	.+4      	; 0x11ce <uIPManagement_ManageNetwork+0xbe>
    11ca:	0e 94 59 1b 	call	0x36b2	; 0x36b2 <uip_split_output>
				  uip_split_output();
    11ce:	80 e2       	ldi	r24, 0x20	; 32
    11d0:	3e df       	rcall	.-388    	; 0x104e <LEDs_SetAllLEDs>

				break;
		}
	}

	LEDs_SetAllLEDs(LEDMASK_USB_READY);
    11d2:	c2 e6       	ldi	r28, 0x62	; 98
    11d4:	d6 e0       	ldi	r29, 0x06	; 6
    11d6:	d0 93 61 06 	sts	0x0661, r29

/** uIP Management function. This function manages the uIP stack when called while an RNDIS device has been
 *  attached to the system.
 */
void uIPManagement_ManageNetwork(void)
{
    11da:	c0 93 60 06 	sts	0x0660, r28
static void uIPManagement_ManageConnections(void)
{
	/* Poll TCP connections for more data to send back to the host */
	for (uint8_t i = 0; i < UIP_CONNS; i++)
	{
		uip_poll_conn(&uip_conns[i]);
    11de:	83 e0       	ldi	r24, 0x03	; 3
    11e0:	e8 d7       	rcall	.+4048   	; 0x21b2 <uip_process>
    11e2:	80 91 53 06 	lds	r24, 0x0653
    11e6:	90 91 54 06 	lds	r25, 0x0654

		/* If a response was generated, send it */
		if (uip_len > 0)
    11ea:	89 2b       	or	r24, r25
    11ec:	21 f0       	breq	.+8      	; 0x11f6 <uIPManagement_ManageNetwork+0xe6>
    11ee:	0e 94 01 1a 	call	0x3402	; 0x3402 <uip_arp_out>
    11f2:	0e 94 59 1b 	call	0x36b2	; 0x36b2 <uip_split_output>
		{
			/* Add destination MAC to outgoing packet */
			uip_arp_out();
    11f6:	cf 58       	subi	r28, 0x8F	; 143
    11f8:	df 4f       	sbci	r29, 0xFF	; 255

			/* Split and send the outgoing packet */
			uip_split_output();
    11fa:	87 e0       	ldi	r24, 0x07	; 7
    11fc:	c5 3b       	cpi	r28, 0xB5	; 181
    11fe:	d8 07       	cpc	r29, r24
    1200:	51 f7       	brne	.-44     	; 0x11d6 <uIPManagement_ManageNetwork+0xc6>

/** Manages the currently open network connections, including TCP and (if enabled) UDP. */
static void uIPManagement_ManageConnections(void)
{
	/* Poll TCP connections for more data to send back to the host */
	for (uint8_t i = 0; i < UIP_CONNS; i++)
    1202:	88 e8       	ldi	r24, 0x88	; 136
    1204:	93 e0       	ldi	r25, 0x03	; 3
    1206:	0e 94 19 1b 	call	0x3632	; 0x3632 <timer_expired>
			uip_split_output();
		}
	}

	/* Manage open connections for timeouts */
	if (timer_expired(&ConnectionTimer))
    120a:	89 2b       	or	r24, r25
    120c:	91 f1       	breq	.+100    	; 0x1272 <uIPManagement_ManageNetwork+0x162>
    120e:	88 e8       	ldi	r24, 0x88	; 136
    1210:	93 e0       	ldi	r25, 0x03	; 3
    1212:	0e 94 0f 1b 	call	0x361e	; 0x361e <timer_reset>
	{
		timer_reset(&ConnectionTimer);
    1216:	80 ed       	ldi	r24, 0xD0	; 208
    1218:	1a df       	rcall	.-460    	; 0x104e <LEDs_SetAllLEDs>
    121a:	c2 e6       	ldi	r28, 0x62	; 98
    121c:	d6 e0       	ldi	r29, 0x06	; 6

		LEDs_SetAllLEDs(LEDMASK_USB_BUSY);
    121e:	d0 93 61 06 	sts	0x0661, r29
    1222:	c0 93 60 06 	sts	0x0660, r28
    1226:	82 e0       	ldi	r24, 0x02	; 2

		for (uint8_t i = 0; i < UIP_CONNS; i++)
		{
			/* Run periodic connection management for each TCP connection */
			uip_periodic(i);
    1228:	c4 d7       	rcall	.+3976   	; 0x21b2 <uip_process>
    122a:	80 91 53 06 	lds	r24, 0x0653
    122e:	90 91 54 06 	lds	r25, 0x0654
    1232:	89 2b       	or	r24, r25
    1234:	21 f0       	breq	.+8      	; 0x123e <uIPManagement_ManageNetwork+0x12e>

			/* If a response was generated, send it */
			if (uip_len > 0)
    1236:	0e 94 01 1a 	call	0x3402	; 0x3402 <uip_arp_out>
    123a:	0e 94 59 1b 	call	0x36b2	; 0x36b2 <uip_split_output>
    123e:	cf 58       	subi	r28, 0x8F	; 143
    1240:	df 4f       	sbci	r29, 0xFF	; 255
			{
				/* Add destination MAC to outgoing packet */
				uip_arp_out();
    1242:	27 e0       	ldi	r18, 0x07	; 7
    1244:	c5 3b       	cpi	r28, 0xB5	; 181

				/* Split and send the outgoing packet */
				uip_split_output();
    1246:	d2 07       	cpc	r29, r18
    1248:	51 f7       	brne	.-44     	; 0x121e <uIPManagement_ManageNetwork+0x10e>
    124a:	89 eb       	ldi	r24, 0xB9	; 185
    124c:	9d e0       	ldi	r25, 0x0D	; 13
	{
		timer_reset(&ConnectionTimer);

		LEDs_SetAllLEDs(LEDMASK_USB_BUSY);

		for (uint8_t i = 0; i < UIP_CONNS; i++)
    124e:	90 93 5d 06 	sts	0x065D, r25
    1252:	80 93 5c 06 	sts	0x065C, r24

		#if defined(ENABLE_DHCP_CLIENT)
		for (uint8_t i = 0; i < UIP_UDP_CONNS; i++)
		{
			/* Run periodic connection management for each UDP connection */
			uip_udp_periodic(i);
    1256:	85 e0       	ldi	r24, 0x05	; 5
    1258:	ac d7       	rcall	.+3928   	; 0x21b2 <uip_process>
    125a:	80 91 53 06 	lds	r24, 0x0653
    125e:	90 91 54 06 	lds	r25, 0x0654
    1262:	89 2b       	or	r24, r25
    1264:	21 f0       	breq	.+8      	; 0x126e <uIPManagement_ManageNetwork+0x15e>
    1266:	0e 94 01 1a 	call	0x3402	; 0x3402 <uip_arp_out>

			/* If a response was generated, send it */
			if (uip_len > 0)
    126a:	0e 94 59 1b 	call	0x36b2	; 0x36b2 <uip_split_output>
    126e:	80 e2       	ldi	r24, 0x20	; 32
    1270:	ee de       	rcall	.-548    	; 0x104e <LEDs_SetAllLEDs>
    1272:	84 e8       	ldi	r24, 0x84	; 132
			{
				/* Add destination MAC to outgoing packet */
				uip_arp_out();
    1274:	93 e0       	ldi	r25, 0x03	; 3
    1276:	0e 94 19 1b 	call	0x3632	; 0x3632 <timer_expired>

				/* Split and send the outgoing packet */
				uip_split_output();
    127a:	89 2b       	or	r24, r25
			}
		}
		#endif

		LEDs_SetAllLEDs(LEDMASK_USB_READY);
    127c:	41 f0       	breq	.+16     	; 0x128e <uIPManagement_ManageNetwork+0x17e>
    127e:	84 e8       	ldi	r24, 0x84	; 132
    1280:	93 e0       	ldi	r25, 0x03	; 3
	}

	/* Manage ARP cache refreshing */
	if (timer_expired(&ARPTimer))
    1282:	0e 94 0f 1b 	call	0x361e	; 0x361e <timer_reset>
    1286:	df 91       	pop	r29
    1288:	cf 91       	pop	r28
    128a:	0c 94 29 19 	jmp	0x3252	; 0x3252 <uip_arp_timer>
	{
		timer_reset(&ARPTimer);
    128e:	df 91       	pop	r29
    1290:	cf 91       	pop	r28
    1292:	08 95       	ret

00001294 <uIPManagement_TCPCallback>:
    1294:	e0 91 60 06 	lds	r30, 0x0660
	    ((USB_CurrentMode == USB_MODE_Device) && (USB_DeviceState == DEVICE_STATE_Configured)))
	{
		uIPManagement_ProcessIncomingPacket();
		uIPManagement_ManageConnections();
	}
}
    1298:	f0 91 61 06 	lds	r31, 0x0661

	/* Manage ARP cache refreshing */
	if (timer_expired(&ARPTimer))
	{
		timer_reset(&ARPTimer);
		uip_arp_timer();
    129c:	84 81       	ldd	r24, Z+4	; 0x04
	    ((USB_CurrentMode == USB_MODE_Device) && (USB_DeviceState == DEVICE_STATE_Configured)))
	{
		uIPManagement_ProcessIncomingPacket();
		uIPManagement_ManageConnections();
	}
}
    129e:	95 81       	ldd	r25, Z+5	; 0x05
    12a0:	81 15       	cp	r24, r1
    12a2:	27 e1       	ldi	r18, 0x17	; 23
 *  to the appropriate TCP protocol application based on the connection's listen port number.
 */
void uIPManagement_TCPCallback(void)
{
	/* Call the correct TCP application based on the port number the connection is listening on */
	switch (uip_conn->lport)
    12a4:	92 07       	cpc	r25, r18
    12a6:	21 f0       	breq	.+8      	; 0x12b0 <uIPManagement_TCPCallback+0x1c>
    12a8:	81 15       	cp	r24, r1
    12aa:	90 45       	sbci	r25, 0x50	; 80
    12ac:	11 f4       	brne	.+4      	; 0x12b2 <uIPManagement_TCPCallback+0x1e>
	{
		case HTONS(HTTP_SERVER_PORT):
			HTTPServerApp_Callback();
    12ae:	cd c3       	rjmp	.+1946   	; 0x1a4a <HTTPServerApp_Callback>
    12b0:	4c c5       	rjmp	.+2712   	; 0x1d4a <TELNETServerApp_Callback>
			break;
		#if defined(ENABLE_TELNET_SERVER)
		case HTONS(TELNET_SERVER_PORT):
			TELNETServerApp_Callback();
    12b2:	08 95       	ret

000012b4 <uIPManagement_UDPCallback>:
    12b4:	e0 91 5c 06 	lds	r30, 0x065C
 *  to the appropriate UDP protocol application based on the connection's listen port number.
 */
void uIPManagement_UDPCallback(void)
{
	/* Call the correct UDP application based on the port number the connection is listening on */
	switch (uip_udp_conn->lport)
    12b8:	f0 91 5d 06 	lds	r31, 0x065D
    12bc:	84 81       	ldd	r24, Z+4	; 0x04
    12be:	95 81       	ldd	r25, Z+5	; 0x05
    12c0:	81 15       	cp	r24, r1
    12c2:	23 e4       	ldi	r18, 0x43	; 67
    12c4:	92 07       	cpc	r25, r18
    12c6:	21 f0       	breq	.+8      	; 0x12d0 <uIPManagement_UDPCallback+0x1c>
    12c8:	81 15       	cp	r24, r1
    12ca:	94 44       	sbci	r25, 0x44	; 68
    12cc:	11 f4       	brne	.+4      	; 0x12d2 <uIPManagement_UDPCallback+0x1e>
	{
		#if defined(ENABLE_DHCP_CLIENT)
		case HTONS(DHCP_CLIENT_PORT):
			DHCPClientApp_Callback();
    12ce:	be c0       	rjmp	.+380    	; 0x144c <DHCPClientApp_Callback>
    12d0:	7a c2       	rjmp	.+1268   	; 0x17c6 <DHCPServerApp_Callback>
			break;
		#endif
		#if defined(ENABLE_DHCP_SERVER)
		case HTONS(DHCP_SERVER_PORT):
			DHCPServerApp_Callback();
    12d2:	08 95       	ret

000012d4 <DHCPCommon_SetOption>:
 */
uint8_t DHCPCommon_SetOption(uint8_t* DHCPOptionList,
                             const uint8_t Option,
                             const uint8_t DataLen,
                             void* const OptionData)
{
    12d4:	ef 92       	push	r14
    12d6:	ff 92       	push	r15
    12d8:	0f 93       	push	r16
    12da:	1f 93       	push	r17
    12dc:	cf 93       	push	r28
    12de:	df 93       	push	r29
    12e0:	ec 01       	movw	r28, r24
    12e2:	f4 2e       	mov	r15, r20
	/* Skip through the DHCP options list until the terminator option is found */
	while (*DHCPOptionList != DHCP_OPTION_END)
    12e4:	e8 80       	ld	r14, Y
    12e6:	8f ef       	ldi	r24, 0xFF	; 255
    12e8:	e8 16       	cp	r14, r24
    12ea:	31 f0       	breq	.+12     	; 0x12f8 <DHCPCommon_SetOption+0x24>
	  DHCPOptionList += (DHCPOptionList[1] + 2);
    12ec:	e9 81       	ldd	r30, Y+1	; 0x01
    12ee:	f0 e0       	ldi	r31, 0x00	; 0
    12f0:	32 96       	adiw	r30, 0x02	; 2
    12f2:	ce 0f       	add	r28, r30
    12f4:	df 1f       	adc	r29, r31
    12f6:	f6 cf       	rjmp	.-20     	; 0x12e4 <DHCPCommon_SetOption+0x10>

	/* Overwrite the existing terminator with the new option, add a new terminator at the end of the list */
	DHCPOptionList[0] = Option;
    12f8:	68 83       	st	Y, r22
	DHCPOptionList[1] = DataLen;
    12fa:	f9 82       	std	Y+1, r15	; 0x01
	memcpy(&DHCPOptionList[2], OptionData, DataLen);
    12fc:	0f 2d       	mov	r16, r15
    12fe:	10 e0       	ldi	r17, 0x00	; 0
    1300:	a8 01       	movw	r20, r16
    1302:	b9 01       	movw	r22, r18
    1304:	ce 01       	movw	r24, r28
    1306:	02 96       	adiw	r24, 0x02	; 2
    1308:	0e 94 9c 3a 	call	0x7538	; 0x7538 <memcpy>
	DHCPOptionList[2 + DataLen] = DHCP_OPTION_END;
    130c:	c0 0f       	add	r28, r16
    130e:	d1 1f       	adc	r29, r17
    1310:	ea 82       	std	Y+2, r14	; 0x02

	/* Calculate the total number of bytes added to the outgoing packet */
	return (2 + DataLen);
}
    1312:	82 e0       	ldi	r24, 0x02	; 2
    1314:	8f 0d       	add	r24, r15
    1316:	df 91       	pop	r29
    1318:	cf 91       	pop	r28
    131a:	1f 91       	pop	r17
    131c:	0f 91       	pop	r16
    131e:	ff 90       	pop	r15
    1320:	ef 90       	pop	r14
    1322:	08 95       	ret

00001324 <DHCPCommon_GetOption>:
 *  \return Boolean \c true if the option was found in the DHCP packet's options list, \c false otherwise
 */
bool DHCPCommon_GetOption(const uint8_t* DHCPOptionList,
                          const uint8_t Option,
                          void* const Destination)
{
    1324:	fc 01       	movw	r30, r24
    1326:	ca 01       	movw	r24, r20
	/* Look through the incoming DHCP packet's options list for the requested option */
	while (*DHCPOptionList != DHCP_OPTION_END)
    1328:	20 81       	ld	r18, Z
    132a:	2f 3f       	cpi	r18, 0xFF	; 255
    132c:	91 f0       	breq	.+36     	; 0x1352 <DHCPCommon_GetOption+0x2e>
	{
		/* Check if the current DHCP option in the packet is the one requested */
		if (DHCPOptionList[0] == Option)
    132e:	26 13       	cpse	r18, r22
    1330:	09 c0       	rjmp	.+18     	; 0x1344 <DHCPCommon_GetOption+0x20>
		{
			/* Copy request option's data to the destination buffer */
			memcpy(Destination, &DHCPOptionList[2], DHCPOptionList[1]);
    1332:	41 81       	ldd	r20, Z+1	; 0x01
    1334:	50 e0       	ldi	r21, 0x00	; 0
    1336:	bf 01       	movw	r22, r30
    1338:	6e 5f       	subi	r22, 0xFE	; 254
    133a:	7f 4f       	sbci	r23, 0xFF	; 255
    133c:	0e 94 9c 3a 	call	0x7538	; 0x7538 <memcpy>

			/* Indicate that the requested option data was successfully retrieved */
			return true;
    1340:	81 e0       	ldi	r24, 0x01	; 1
    1342:	08 95       	ret
		}

		/* Skip to next DHCP option in the options list */
		DHCPOptionList += (DHCPOptionList[1] + 2);
    1344:	21 81       	ldd	r18, Z+1	; 0x01
    1346:	30 e0       	ldi	r19, 0x00	; 0
    1348:	2e 5f       	subi	r18, 0xFE	; 254
    134a:	3f 4f       	sbci	r19, 0xFF	; 255
    134c:	e2 0f       	add	r30, r18
    134e:	f3 1f       	adc	r31, r19
    1350:	eb cf       	rjmp	.-42     	; 0x1328 <DHCPCommon_GetOption+0x4>
	}

	/* Requested option not found in the incoming packet's DHCP options list */
	return false;
    1352:	80 e0       	ldi	r24, 0x00	; 0
}
    1354:	08 95       	ret

00001356 <DHCPClientApp_FillDHCPHeader>:
 *  \return Size in bytes of the created DHCP packet
 */
static uint16_t DHCPClientApp_FillDHCPHeader(DHCP_Header_t* const DHCPHeader,
                                             const uint8_t DHCPMessageType,
                                             uip_udp_appstate_t* const AppState)
{
    1356:	0f 93       	push	r16
    1358:	1f 93       	push	r17
    135a:	cf 93       	push	r28
    135c:	df 93       	push	r29
    135e:	ec 01       	movw	r28, r24
    1360:	86 2f       	mov	r24, r22
	/* Erase existing packet data so that we start will all 0x00 DHCP header data */
 	memset(DHCPHeader, 0, sizeof(DHCP_Header_t));
    1362:	90 ef       	ldi	r25, 0xF0	; 240
    1364:	fe 01       	movw	r30, r28
    1366:	11 92       	st	Z+, r1
    1368:	9a 95       	dec	r25
    136a:	e9 f7       	brne	.-6      	; 0x1366 <DHCPClientApp_FillDHCPHeader+0x10>

	/* Fill out the DHCP packet header */
	DHCPHeader->Operation             = DHCP_OP_BOOTREQUEST;
    136c:	91 e0       	ldi	r25, 0x01	; 1
    136e:	98 83       	st	Y, r25
	DHCPHeader->HardwareType          = DHCP_HTYPE_ETHERNET;
    1370:	99 83       	std	Y+1, r25	; 0x01
	DHCPHeader->HardwareAddressLength = sizeof(MACAddress);
    1372:	26 e0       	ldi	r18, 0x06	; 6
    1374:	2a 83       	std	Y+2, r18	; 0x02
	DHCPHeader->Hops                  = 0;
    1376:	1b 82       	std	Y+3, r1	; 0x03
	DHCPHeader->TransactionID         = DHCP_TRANSACTION_ID;
    1378:	06 e6       	ldi	r16, 0x66	; 102
    137a:	14 e5       	ldi	r17, 0x54	; 84
    137c:	24 e2       	ldi	r18, 0x24	; 36
    137e:	33 e1       	ldi	r19, 0x13	; 19
    1380:	0c 83       	std	Y+4, r16	; 0x04
    1382:	1d 83       	std	Y+5, r17	; 0x05
    1384:	2e 83       	std	Y+6, r18	; 0x06
    1386:	3f 83       	std	Y+7, r19	; 0x07
	DHCPHeader->ElapsedSeconds        = 0;
    1388:	19 86       	std	Y+9, r1	; 0x09
    138a:	18 86       	std	Y+8, r1	; 0x08
	DHCPHeader->Flags                 = HTONS(BOOTP_BROADCAST);
    138c:	20 e8       	ldi	r18, 0x80	; 128
    138e:	30 e0       	ldi	r19, 0x00	; 0
    1390:	3b 87       	std	Y+11, r19	; 0x0b
    1392:	2a 87       	std	Y+10, r18	; 0x0a
	memcpy(&DHCPHeader->ClientIP,     &uip_hostaddr,        sizeof(uip_ipaddr_t));
    1394:	00 91 c7 07 	lds	r16, 0x07C7
    1398:	10 91 c8 07 	lds	r17, 0x07C8
    139c:	20 91 c9 07 	lds	r18, 0x07C9
    13a0:	30 91 ca 07 	lds	r19, 0x07CA
    13a4:	0c 87       	std	Y+12, r16	; 0x0c
    13a6:	1d 87       	std	Y+13, r17	; 0x0d
    13a8:	2e 87       	std	Y+14, r18	; 0x0e
    13aa:	3f 87       	std	Y+15, r19	; 0x0f
	memcpy(&DHCPHeader->YourIP,       &AppState->DHCPClient.DHCPOffer_Data.AllocatedIP, sizeof(uip_ipaddr_t));
    13ac:	fa 01       	movw	r30, r20
    13ae:	05 81       	ldd	r16, Z+5	; 0x05
    13b0:	16 81       	ldd	r17, Z+6	; 0x06
    13b2:	27 81       	ldd	r18, Z+7	; 0x07
    13b4:	30 85       	ldd	r19, Z+8	; 0x08
    13b6:	08 8b       	std	Y+16, r16	; 0x10
    13b8:	19 8b       	std	Y+17, r17	; 0x11
    13ba:	2a 8b       	std	Y+18, r18	; 0x12
    13bc:	3b 8b       	std	Y+19, r19	; 0x13
	memcpy(&DHCPHeader->NextServerIP, &AppState->DHCPClient.DHCPOffer_Data.ServerIP,    sizeof(uip_ipaddr_t));
    13be:	41 89       	ldd	r20, Z+17	; 0x11
    13c0:	52 89       	ldd	r21, Z+18	; 0x12
    13c2:	63 89       	ldd	r22, Z+19	; 0x13
    13c4:	74 89       	ldd	r23, Z+20	; 0x14
    13c6:	4c 8b       	std	Y+20, r20	; 0x14
    13c8:	5d 8b       	std	Y+21, r21	; 0x15
    13ca:	6e 8b       	std	Y+22, r22	; 0x16
    13cc:	7f 8b       	std	Y+23, r23	; 0x17
	memcpy(&DHCPHeader->ClientHardwareAddress, &MACAddress, sizeof(struct uip_eth_addr));
    13ce:	26 e0       	ldi	r18, 0x06	; 6
    13d0:	ea e0       	ldi	r30, 0x0A	; 10
    13d2:	f4 e0       	ldi	r31, 0x04	; 4
    13d4:	de 01       	movw	r26, r28
    13d6:	5c 96       	adiw	r26, 0x1c	; 28
    13d8:	01 90       	ld	r0, Z+
    13da:	0d 92       	st	X+, r0
    13dc:	2a 95       	dec	r18
    13de:	e1 f7       	brne	.-8      	; 0x13d8 <DHCPClientApp_FillDHCPHeader+0x82>
	DHCPHeader->Cookie                = DHCP_MAGIC_COOKIE;
    13e0:	fe 01       	movw	r30, r28
    13e2:	e4 51       	subi	r30, 0x14	; 20
    13e4:	ff 4f       	sbci	r31, 0xFF	; 255
    13e6:	43 e6       	ldi	r20, 0x63	; 99
    13e8:	52 e8       	ldi	r21, 0x82	; 130
    13ea:	63 e5       	ldi	r22, 0x53	; 83
    13ec:	73 e6       	ldi	r23, 0x63	; 99
    13ee:	40 83       	st	Z, r20
    13f0:	51 83       	std	Z+1, r21	; 0x01
    13f2:	62 83       	std	Z+2, r22	; 0x02
    13f4:	73 83       	std	Z+3, r23	; 0x03

	/* Add a DHCP message type and terminator options to the start of the DHCP options field */
	DHCPHeader->Options[0]            = DHCP_OPTION_MSG_TYPE;
    13f6:	fe 01       	movw	r30, r28
    13f8:	e0 51       	subi	r30, 0x10	; 16
    13fa:	ff 4f       	sbci	r31, 0xFF	; 255
    13fc:	25 e3       	ldi	r18, 0x35	; 53
    13fe:	20 83       	st	Z, r18
	DHCPHeader->Options[1]            = 1;
    1400:	fe 01       	movw	r30, r28
    1402:	ef 50       	subi	r30, 0x0F	; 15
    1404:	ff 4f       	sbci	r31, 0xFF	; 255
    1406:	90 83       	st	Z, r25
	DHCPHeader->Options[2]            = DHCPMessageType;
    1408:	fe 01       	movw	r30, r28
    140a:	ee 50       	subi	r30, 0x0E	; 14
    140c:	ff 4f       	sbci	r31, 0xFF	; 255
    140e:	80 83       	st	Z, r24
	DHCPHeader->Options[3]            = DHCP_OPTION_END;
    1410:	cd 50       	subi	r28, 0x0D	; 13
    1412:	df 4f       	sbci	r29, 0xFF	; 255
    1414:	8f ef       	ldi	r24, 0xFF	; 255
    1416:	88 83       	st	Y, r24

	/* Calculate the total number of bytes added to the outgoing packet */
	return (sizeof(DHCP_Header_t) + 4);
}
    1418:	84 ef       	ldi	r24, 0xF4	; 244
    141a:	90 e0       	ldi	r25, 0x00	; 0
    141c:	df 91       	pop	r29
    141e:	cf 91       	pop	r28
    1420:	1f 91       	pop	r17
    1422:	0f 91       	pop	r16
    1424:	08 95       	ret

00001426 <DHCPClientApp_Init>:

/** Initialization function for the DHCP client. */
void DHCPClientApp_Init(void)
{
	/* Create a new UDP connection to the DHCP server port for the DHCP solicitation */
	struct uip_udp_conn* Connection = uip_udp_new(&uip_broadcast_addr, HTONS(DHCP_SERVER_PORT));
    1426:	60 e0       	ldi	r22, 0x00	; 0
    1428:	73 e4       	ldi	r23, 0x43	; 67
    142a:	8e ed       	ldi	r24, 0xDE	; 222
    142c:	91 e0       	ldi	r25, 0x01	; 1
    142e:	5f d6       	rcall	.+3262   	; 0x20ee <uip_udp_new>
    1430:	00 97       	sbiw	r24, 0x00	; 0

	/* If the connection was successfully created, bind it to the local DHCP client port */
	if (Connection != NULL)
    1432:	59 f0       	breq	.+22     	; 0x144a <DHCPClientApp_Init+0x24>
    1434:	20 e0       	ldi	r18, 0x00	; 0
	{
		uip_udp_appstate_t* const AppState = &Connection->appstate;
		uip_udp_bind(Connection, HTONS(DHCP_CLIENT_PORT));
    1436:	34 e4       	ldi	r19, 0x44	; 68
    1438:	fc 01       	movw	r30, r24
    143a:	35 83       	std	Z+5, r19	; 0x05
    143c:	24 83       	std	Z+4, r18	; 0x04
    143e:	11 86       	std	Z+9, r1	; 0x09

		/* Set the initial client state */
		AppState->DHCPClient.CurrentState = DHCP_STATE_SendDiscover;
    1440:	62 e3       	ldi	r22, 0x32	; 50

		/* Set timeout period to half a second for a DHCP server to respond */
		timer_set(&AppState->DHCPClient.Timeout, CLOCK_SECOND / 2);
    1442:	70 e0       	ldi	r23, 0x00	; 0
    1444:	0a 96       	adiw	r24, 0x0a	; 10
    1446:	0c 94 04 1b 	jmp	0x3608	; 0x3608 <timer_set>
    144a:	08 95       	ret

0000144c <DHCPClientApp_Callback>:
    144c:	bf 92       	push	r11

/** uIP stack application callback for the DHCP client. This function must be called each time the TCP/IP stack
 *  needs a UDP packet to be processed.
 */
void DHCPClientApp_Callback(void)
{
    144e:	cf 92       	push	r12
    1450:	df 92       	push	r13
    1452:	ef 92       	push	r14
    1454:	ff 92       	push	r15
    1456:	0f 93       	push	r16
    1458:	1f 93       	push	r17
    145a:	cf 93       	push	r28
    145c:	df 93       	push	r29
    145e:	00 d0       	rcall	.+0      	; 0x1460 <DHCPClientApp_Callback+0x14>
    1460:	1f 92       	push	r1
    1462:	cd b7       	in	r28, 0x3d	; 61
    1464:	de b7       	in	r29, 0x3e	; 62
	uip_udp_appstate_t* const AppState    = &uip_udp_conn->appstate;
    1466:	00 91 5c 06 	lds	r16, 0x065C
    146a:	10 91 5d 06 	lds	r17, 0x065D
    146e:	a8 01       	movw	r20, r16
    1470:	47 5f       	subi	r20, 0xF7	; 247
    1472:	5f 4f       	sbci	r21, 0xFF	; 255
	DHCP_Header_t*      const AppData     = (DHCP_Header_t*)uip_appdata;
    1474:	e0 90 5e 06 	lds	r14, 0x065E
    1478:	f0 90 5f 06 	lds	r15, 0x065F
	uint16_t                  AppDataSize = 0;

	switch (AppState->DHCPClient.CurrentState)
    147c:	d8 01       	movw	r26, r16
    147e:	19 96       	adiw	r26, 0x09	; 9
    1480:	8c 91       	ld	r24, X
    1482:	81 30       	cpi	r24, 0x01	; 1
    1484:	d1 f1       	breq	.+116    	; 0x14fa <DHCPClientApp_Callback+0xae>
    1486:	38 f0       	brcs	.+14     	; 0x1496 <DHCPClientApp_Callback+0x4a>
    1488:	82 30       	cpi	r24, 0x02	; 2
    148a:	09 f4       	brne	.+2      	; 0x148e <DHCPClientApp_Callback+0x42>
    148c:	86 c0       	rjmp	.+268    	; 0x159a <DHCPClientApp_Callback+0x14e>
    148e:	83 30       	cpi	r24, 0x03	; 3
    1490:	09 f4       	brne	.+2      	; 0x1494 <DHCPClientApp_Callback+0x48>
    1492:	ac c0       	rjmp	.+344    	; 0x15ec <DHCPClientApp_Callback+0x1a0>
    1494:	f8 c0       	rjmp	.+496    	; 0x1686 <DHCPClientApp_Callback+0x23a>
	{
		case DHCP_STATE_SendDiscover:
			/* Clear all DHCP settings, reset client IP address */
			memset(&AppState->DHCPClient.DHCPOffer_Data, 0x00, sizeof(AppState->DHCPClient.DHCPOffer_Data));
    1496:	f8 01       	movw	r30, r16
    1498:	3e 96       	adiw	r30, 0x0e	; 14
    149a:	80 e1       	ldi	r24, 0x10	; 16
    149c:	df 01       	movw	r26, r30
    149e:	1d 92       	st	X+, r1
    14a0:	8a 95       	dec	r24
    14a2:	e9 f7       	brne	.-6      	; 0x149e <DHCPClientApp_Callback+0x52>
			uip_sethostaddr((uip_ipaddr_t*)&AppState->DHCPClient.DHCPOffer_Data.AllocatedIP);
    14a4:	f8 01       	movw	r30, r16
    14a6:	86 85       	ldd	r24, Z+14	; 0x0e
    14a8:	97 85       	ldd	r25, Z+15	; 0x0f
    14aa:	a0 89       	ldd	r26, Z+16	; 0x10
    14ac:	b1 89       	ldd	r27, Z+17	; 0x11
    14ae:	80 93 c7 07 	sts	0x07C7, r24
    14b2:	90 93 c8 07 	sts	0x07C8, r25
    14b6:	a0 93 c9 07 	sts	0x07C9, r26
    14ba:	b0 93 ca 07 	sts	0x07CA, r27

			/* Fill out the DHCP response header */
			AppDataSize += DHCPClientApp_FillDHCPHeader(AppData, DHCP_DISCOVER, AppState);
    14be:	61 e0       	ldi	r22, 0x01	; 1
    14c0:	c7 01       	movw	r24, r14
    14c2:	49 df       	rcall	.-366    	; 0x1356 <DHCPClientApp_FillDHCPHeader>
    14c4:	6c 01       	movw	r12, r24
    14c6:	bb 24       	eor	r11, r11

			/* Add the required DHCP options list to the packet */
			uint8_t RequiredOptionList[] = {DHCP_OPTION_SUBNET_MASK, DHCP_OPTION_ROUTER, DHCP_OPTION_DNS_SERVER};
    14c8:	b3 94       	inc	r11
    14ca:	b9 82       	std	Y+1, r11	; 0x01
    14cc:	83 e0       	ldi	r24, 0x03	; 3
    14ce:	8a 83       	std	Y+2, r24	; 0x02
    14d0:	86 e0       	ldi	r24, 0x06	; 6
    14d2:	8b 83       	std	Y+3, r24	; 0x03
    14d4:	9e 01       	movw	r18, r28
			AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_REQ_LIST, sizeof(RequiredOptionList),
    14d6:	2f 5f       	subi	r18, 0xFF	; 255
    14d8:	3f 4f       	sbci	r19, 0xFF	; 255
    14da:	43 e0       	ldi	r20, 0x03	; 3
    14dc:	67 e3       	ldi	r22, 0x37	; 55
    14de:	c7 01       	movw	r24, r14
    14e0:	80 51       	subi	r24, 0x10	; 16
    14e2:	9f 4f       	sbci	r25, 0xFF	; 255
    14e4:	f7 de       	rcall	.-530    	; 0x12d4 <DHCPCommon_SetOption>
    14e6:	b6 01       	movw	r22, r12
    14e8:	68 0f       	add	r22, r24
    14ea:	71 1d       	adc	r23, r1
    14ec:	80 91 5e 06 	lds	r24, 0x065E
			                                    RequiredOptionList);

			/* Send the DHCP DISCOVER packet */
			uip_udp_send(AppDataSize);
    14f0:	90 91 5f 06 	lds	r25, 0x065F
    14f4:	0e 94 56 18 	call	0x30ac	; 0x30ac <uip_send>
    14f8:	48 c0       	rjmp	.+144    	; 0x158a <DHCPClientApp_Callback+0x13e>
    14fa:	80 91 5b 06 	lds	r24, 0x065B
			timer_reset(&AppState->DHCPClient.Timeout);
			AppState->DHCPClient.CurrentState = DHCP_STATE_WaitForOffer;

			break;
		case DHCP_STATE_WaitForOffer:
			if (!(uip_newdata()))
    14fe:	81 fd       	sbrc	r24, 1
    1500:	0a c0       	rjmp	.+20     	; 0x1516 <DHCPClientApp_Callback+0xca>
    1502:	c8 01       	movw	r24, r16
    1504:	0a 96       	adiw	r24, 0x0a	; 10
			{
				/* Check if the DHCP timeout period has expired while waiting for a response */
				if (timer_expired(&AppState->DHCPClient.Timeout))
    1506:	0e 94 19 1b 	call	0x3632	; 0x3632 <timer_expired>
    150a:	89 2b       	or	r24, r25
    150c:	09 f4       	brne	.+2      	; 0x1510 <DHCPClientApp_Callback+0xc4>
    150e:	bb c0       	rjmp	.+374    	; 0x1686 <DHCPClientApp_Callback+0x23a>
    1510:	f8 01       	movw	r30, r16
    1512:	11 86       	std	Z+9, r1	; 0x09
				  AppState->DHCPClient.CurrentState = DHCP_STATE_SendDiscover;
    1514:	b8 c0       	rjmp	.+368    	; 0x1686 <DHCPClientApp_Callback+0x23a>
    1516:	f7 01       	movw	r30, r14
    1518:	84 81       	ldd	r24, Z+4	; 0x04

				break;
			}

			uint8_t OfferResponse_MessageType;
			if ((AppData->TransactionID == DHCP_TRANSACTION_ID) &&
    151a:	95 81       	ldd	r25, Z+5	; 0x05
    151c:	a6 81       	ldd	r26, Z+6	; 0x06
    151e:	b7 81       	ldd	r27, Z+7	; 0x07
    1520:	86 36       	cpi	r24, 0x66	; 102
    1522:	94 45       	sbci	r25, 0x54	; 84
    1524:	a4 42       	sbci	r26, 0x24	; 36
    1526:	b3 41       	sbci	r27, 0x13	; 19
    1528:	09 f0       	breq	.+2      	; 0x152c <DHCPClientApp_Callback+0xe0>
    152a:	ad c0       	rjmp	.+346    	; 0x1686 <DHCPClientApp_Callback+0x23a>
    152c:	67 01       	movw	r12, r14
    152e:	20 ef       	ldi	r18, 0xF0	; 240
			    DHCPCommon_GetOption(AppData->Options, DHCP_OPTION_MSG_TYPE, &OfferResponse_MessageType) &&
    1530:	c2 0e       	add	r12, r18
    1532:	d1 1c       	adc	r13, r1
    1534:	ae 01       	movw	r20, r28
    1536:	4f 5f       	subi	r20, 0xFF	; 255
    1538:	5f 4f       	sbci	r21, 0xFF	; 255
    153a:	65 e3       	ldi	r22, 0x35	; 53
    153c:	c6 01       	movw	r24, r12
    153e:	f2 de       	rcall	.-540    	; 0x1324 <DHCPCommon_GetOption>
    1540:	88 23       	and	r24, r24
    1542:	09 f4       	brne	.+2      	; 0x1546 <DHCPClientApp_Callback+0xfa>
    1544:	a0 c0       	rjmp	.+320    	; 0x1686 <DHCPClientApp_Callback+0x23a>

				break;
			}

			uint8_t OfferResponse_MessageType;
			if ((AppData->TransactionID == DHCP_TRANSACTION_ID) &&
    1546:	b9 80       	ldd	r11, Y+1	; 0x01
    1548:	82 e0       	ldi	r24, 0x02	; 2
    154a:	b8 12       	cpse	r11, r24
			    DHCPCommon_GetOption(AppData->Options, DHCP_OPTION_MSG_TYPE, &OfferResponse_MessageType) &&
    154c:	9c c0       	rjmp	.+312    	; 0x1686 <DHCPClientApp_Callback+0x23a>
    154e:	d7 01       	movw	r26, r14
    1550:	50 96       	adiw	r26, 0x10	; 16
    1552:	4d 91       	ld	r20, X+
			    (OfferResponse_MessageType == DHCP_OFFER))
			{
				/* Received a DHCP offer for an IP address, copy over values for later request */
				memcpy(&AppState->DHCPClient.DHCPOffer_Data.AllocatedIP, &AppData->YourIP, sizeof(uip_ipaddr_t));
    1554:	5d 91       	ld	r21, X+
    1556:	6d 91       	ld	r22, X+
    1558:	7c 91       	ld	r23, X
    155a:	53 97       	sbiw	r26, 0x13	; 19
    155c:	f8 01       	movw	r30, r16
    155e:	46 87       	std	Z+14, r20	; 0x0e
    1560:	57 87       	std	Z+15, r21	; 0x0f
    1562:	60 8b       	std	Z+16, r22	; 0x10
    1564:	71 8b       	std	Z+17, r23	; 0x11
    1566:	a8 01       	movw	r20, r16
    1568:	4e 5e       	subi	r20, 0xEE	; 238
    156a:	5f 4f       	sbci	r21, 0xFF	; 255
				DHCPCommon_GetOption(AppData->Options, DHCP_OPTION_SUBNET_MASK, &AppState->DHCPClient.DHCPOffer_Data.Netmask);
    156c:	61 e0       	ldi	r22, 0x01	; 1
    156e:	c6 01       	movw	r24, r12
    1570:	d9 de       	rcall	.-590    	; 0x1324 <DHCPCommon_GetOption>
    1572:	a8 01       	movw	r20, r16
    1574:	4a 5e       	subi	r20, 0xEA	; 234
    1576:	5f 4f       	sbci	r21, 0xFF	; 255
    1578:	63 e0       	ldi	r22, 0x03	; 3
				DHCPCommon_GetOption(AppData->Options, DHCP_OPTION_ROUTER,      &AppState->DHCPClient.DHCPOffer_Data.GatewayIP);
    157a:	c6 01       	movw	r24, r12
    157c:	d3 de       	rcall	.-602    	; 0x1324 <DHCPCommon_GetOption>
    157e:	a8 01       	movw	r20, r16
    1580:	46 5e       	subi	r20, 0xE6	; 230
    1582:	5f 4f       	sbci	r21, 0xFF	; 255
    1584:	66 e3       	ldi	r22, 0x36	; 54
    1586:	c6 01       	movw	r24, r12
				DHCPCommon_GetOption(AppData->Options, DHCP_OPTION_SERVER_ID,   &AppState->DHCPClient.DHCPOffer_Data.ServerIP);
    1588:	cd de       	rcall	.-614    	; 0x1324 <DHCPCommon_GetOption>
    158a:	c8 01       	movw	r24, r16
    158c:	0a 96       	adiw	r24, 0x0a	; 10
    158e:	0e 94 0f 1b 	call	0x361e	; 0x361e <timer_reset>
    1592:	d8 01       	movw	r26, r16
    1594:	19 96       	adiw	r26, 0x09	; 9

				timer_reset(&AppState->DHCPClient.Timeout);
    1596:	bc 92       	st	X, r11
    1598:	76 c0       	rjmp	.+236    	; 0x1686 <DHCPClientApp_Callback+0x23a>
    159a:	63 e0       	ldi	r22, 0x03	; 3
    159c:	c7 01       	movw	r24, r14
				AppState->DHCPClient.CurrentState = DHCP_STATE_SendRequest;
    159e:	db de       	rcall	.-586    	; 0x1356 <DHCPClientApp_FillDHCPHeader>
    15a0:	6c 01       	movw	r12, r24
    15a2:	b0 ef       	ldi	r27, 0xF0	; 240
    15a4:	eb 0e       	add	r14, r27
			}

			break;
		case DHCP_STATE_SendRequest:
			/* Fill out the DHCP response header */
			AppDataSize += DHCPClientApp_FillDHCPHeader(AppData, DHCP_REQUEST, AppState);
    15a6:	f1 1c       	adc	r15, r1
    15a8:	98 01       	movw	r18, r16
    15aa:	22 5f       	subi	r18, 0xF2	; 242
    15ac:	3f 4f       	sbci	r19, 0xFF	; 255
    15ae:	44 e0       	ldi	r20, 0x04	; 4

			/* Add the DHCP REQUESTED IP ADDRESS option to the packet */
			AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_REQ_IPADDR, sizeof(uip_ipaddr_t),
    15b0:	62 e3       	ldi	r22, 0x32	; 50
    15b2:	c7 01       	movw	r24, r14
    15b4:	8f de       	rcall	.-738    	; 0x12d4 <DHCPCommon_SetOption>
			                                    &AppState->DHCPClient.DHCPOffer_Data.AllocatedIP);
    15b6:	b8 2e       	mov	r11, r24
    15b8:	98 01       	movw	r18, r16
    15ba:	26 5e       	subi	r18, 0xE6	; 230
		case DHCP_STATE_SendRequest:
			/* Fill out the DHCP response header */
			AppDataSize += DHCPClientApp_FillDHCPHeader(AppData, DHCP_REQUEST, AppState);

			/* Add the DHCP REQUESTED IP ADDRESS option to the packet */
			AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_REQ_IPADDR, sizeof(uip_ipaddr_t),
    15bc:	3f 4f       	sbci	r19, 0xFF	; 255
    15be:	44 e0       	ldi	r20, 0x04	; 4
    15c0:	66 e3       	ldi	r22, 0x36	; 54
    15c2:	c7 01       	movw	r24, r14
    15c4:	87 de       	rcall	.-754    	; 0x12d4 <DHCPCommon_SetOption>
    15c6:	68 2f       	mov	r22, r24
			                                    &AppState->DHCPClient.DHCPOffer_Data.AllocatedIP);

			/* Add the DHCP SERVER IP ADDRESS option to the packet */
			AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_SERVER_ID, sizeof(uip_ipaddr_t),
			                                    &AppState->DHCPClient.DHCPOffer_Data.ServerIP);
    15c8:	70 e0       	ldi	r23, 0x00	; 0
    15ca:	6b 0d       	add	r22, r11
    15cc:	71 1d       	adc	r23, r1
			/* Add the DHCP REQUESTED IP ADDRESS option to the packet */
			AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_REQ_IPADDR, sizeof(uip_ipaddr_t),
			                                    &AppState->DHCPClient.DHCPOffer_Data.AllocatedIP);

			/* Add the DHCP SERVER IP ADDRESS option to the packet */
			AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_SERVER_ID, sizeof(uip_ipaddr_t),
    15ce:	6c 0d       	add	r22, r12
    15d0:	7d 1d       	adc	r23, r13
    15d2:	80 91 5e 06 	lds	r24, 0x065E
    15d6:	90 91 5f 06 	lds	r25, 0x065F
    15da:	0e 94 56 18 	call	0x30ac	; 0x30ac <uip_send>
		case DHCP_STATE_SendRequest:
			/* Fill out the DHCP response header */
			AppDataSize += DHCPClientApp_FillDHCPHeader(AppData, DHCP_REQUEST, AppState);

			/* Add the DHCP REQUESTED IP ADDRESS option to the packet */
			AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_REQ_IPADDR, sizeof(uip_ipaddr_t),
    15de:	c8 01       	movw	r24, r16
			                                    &AppState->DHCPClient.DHCPOffer_Data.AllocatedIP);

			/* Add the DHCP SERVER IP ADDRESS option to the packet */
			AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_SERVER_ID, sizeof(uip_ipaddr_t),
    15e0:	0a 96       	adiw	r24, 0x0a	; 10
    15e2:	0e 94 0f 1b 	call	0x361e	; 0x361e <timer_reset>
			                                    &AppState->DHCPClient.DHCPOffer_Data.ServerIP);

			/* Send the DHCP REQUEST packet */
			uip_udp_send(AppDataSize);
    15e6:	83 e0       	ldi	r24, 0x03	; 3
    15e8:	f8 01       	movw	r30, r16
    15ea:	4c c0       	rjmp	.+152    	; 0x1684 <DHCPClientApp_Callback+0x238>
    15ec:	80 91 5b 06 	lds	r24, 0x065B

			/* Reset the timeout timer, progress to next state */
			timer_reset(&AppState->DHCPClient.Timeout);
    15f0:	81 fd       	sbrc	r24, 1
    15f2:	0b c0       	rjmp	.+22     	; 0x160a <DHCPClientApp_Callback+0x1be>
    15f4:	c8 01       	movw	r24, r16
    15f6:	0a 96       	adiw	r24, 0x0a	; 10
			AppState->DHCPClient.CurrentState = DHCP_STATE_WaitForACK;
    15f8:	0e 94 19 1b 	call	0x3632	; 0x3632 <timer_expired>
    15fc:	89 2b       	or	r24, r25

			break;
		case DHCP_STATE_WaitForACK:
			if (!(uip_newdata()))
    15fe:	09 f4       	brne	.+2      	; 0x1602 <DHCPClientApp_Callback+0x1b6>
    1600:	42 c0       	rjmp	.+132    	; 0x1686 <DHCPClientApp_Callback+0x23a>
    1602:	d8 01       	movw	r26, r16
    1604:	19 96       	adiw	r26, 0x09	; 9
			{
				/* Check if the DHCP timeout period has expired while waiting for a response */
				if (timer_expired(&AppState->DHCPClient.Timeout))
    1606:	1c 92       	st	X, r1
    1608:	3e c0       	rjmp	.+124    	; 0x1686 <DHCPClientApp_Callback+0x23a>
    160a:	f7 01       	movw	r30, r14
    160c:	44 81       	ldd	r20, Z+4	; 0x04
    160e:	55 81       	ldd	r21, Z+5	; 0x05
    1610:	66 81       	ldd	r22, Z+6	; 0x06
    1612:	77 81       	ldd	r23, Z+7	; 0x07
				  AppState->DHCPClient.CurrentState = DHCP_STATE_SendDiscover;
    1614:	46 36       	cpi	r20, 0x66	; 102
    1616:	54 45       	sbci	r21, 0x54	; 84
    1618:	64 42       	sbci	r22, 0x24	; 36
    161a:	73 41       	sbci	r23, 0x13	; 19

				break;
			}

			uint8_t RequestResponse_MessageType;
			if ((AppData->TransactionID == DHCP_TRANSACTION_ID) &&
    161c:	a1 f5       	brne	.+104    	; 0x1686 <DHCPClientApp_Callback+0x23a>
    161e:	ae 01       	movw	r20, r28
    1620:	4f 5f       	subi	r20, 0xFF	; 255
    1622:	5f 4f       	sbci	r21, 0xFF	; 255
    1624:	65 e3       	ldi	r22, 0x35	; 53
    1626:	c7 01       	movw	r24, r14
    1628:	80 51       	subi	r24, 0x10	; 16
    162a:	9f 4f       	sbci	r25, 0xFF	; 255
    162c:	7b de       	rcall	.-778    	; 0x1324 <DHCPCommon_GetOption>
    162e:	88 23       	and	r24, r24
			    DHCPCommon_GetOption(AppData->Options, DHCP_OPTION_MSG_TYPE, &RequestResponse_MessageType) &&
    1630:	51 f1       	breq	.+84     	; 0x1686 <DHCPClientApp_Callback+0x23a>
    1632:	89 81       	ldd	r24, Y+1	; 0x01
    1634:	85 30       	cpi	r24, 0x05	; 5
    1636:	39 f5       	brne	.+78     	; 0x1686 <DHCPClientApp_Callback+0x23a>
    1638:	f8 01       	movw	r30, r16
    163a:	86 85       	ldd	r24, Z+14	; 0x0e
    163c:	97 85       	ldd	r25, Z+15	; 0x0f
    163e:	a0 89       	ldd	r26, Z+16	; 0x10
    1640:	b1 89       	ldd	r27, Z+17	; 0x11

				break;
			}

			uint8_t RequestResponse_MessageType;
			if ((AppData->TransactionID == DHCP_TRANSACTION_ID) &&
    1642:	80 93 c7 07 	sts	0x07C7, r24
			    DHCPCommon_GetOption(AppData->Options, DHCP_OPTION_MSG_TYPE, &RequestResponse_MessageType) &&
    1646:	90 93 c8 07 	sts	0x07C8, r25
    164a:	a0 93 c9 07 	sts	0x07C9, r26
			    (RequestResponse_MessageType == DHCP_ACK))
			{
				/* Set the new network parameters from the DHCP server */
				uip_sethostaddr((uip_ipaddr_t*)&AppState->DHCPClient.DHCPOffer_Data.AllocatedIP);
    164e:	b0 93 ca 07 	sts	0x07CA, r27
    1652:	82 89       	ldd	r24, Z+18	; 0x12
    1654:	93 89       	ldd	r25, Z+19	; 0x13
    1656:	a4 89       	ldd	r26, Z+20	; 0x14
    1658:	b5 89       	ldd	r27, Z+21	; 0x15
    165a:	80 93 c3 07 	sts	0x07C3, r24
    165e:	90 93 c4 07 	sts	0x07C4, r25
    1662:	a0 93 c5 07 	sts	0x07C5, r26
				uip_setnetmask((uip_ipaddr_t*)&AppState->DHCPClient.DHCPOffer_Data.Netmask);
    1666:	b0 93 c6 07 	sts	0x07C6, r27
    166a:	86 89       	ldd	r24, Z+22	; 0x16
    166c:	97 89       	ldd	r25, Z+23	; 0x17
    166e:	a0 8d       	ldd	r26, Z+24	; 0x18
    1670:	b1 8d       	ldd	r27, Z+25	; 0x19
    1672:	80 93 bf 07 	sts	0x07BF, r24
    1676:	90 93 c0 07 	sts	0x07C0, r25
    167a:	a0 93 c1 07 	sts	0x07C1, r26
				uip_setdraddr((uip_ipaddr_t*)&AppState->DHCPClient.DHCPOffer_Data.GatewayIP);
    167e:	b0 93 c2 07 	sts	0x07C2, r27
    1682:	84 e0       	ldi	r24, 0x04	; 4
    1684:	81 87       	std	Z+9, r24	; 0x09
    1686:	0f 90       	pop	r0
    1688:	0f 90       	pop	r0
    168a:	0f 90       	pop	r0
    168c:	df 91       	pop	r29
    168e:	cf 91       	pop	r28
    1690:	1f 91       	pop	r17
    1692:	0f 91       	pop	r16
    1694:	ff 90       	pop	r15

				AppState->DHCPClient.CurrentState = DHCP_STATE_AddressLeased;
    1696:	ef 90       	pop	r14
    1698:	df 90       	pop	r13
			}

			break;
	}
}
    169a:	cf 90       	pop	r12
    169c:	bf 90       	pop	r11
    169e:	08 95       	ret

000016a0 <DHCPServerApp_FillDHCPHeader>:
static uint16_t DHCPServerApp_FillDHCPHeader(DHCP_Header_t* const DHCPHeader,
                                             const uint8_t DHCPMessageType,
                                             const struct uip_eth_addr* const ClientHardwareAddress,
											 const uip_ipaddr_t* const PreferredClientIP,
                                             const uint32_t TransactionID)
{
    16a0:	ef 92       	push	r14
    16a2:	ff 92       	push	r15
    16a4:	0f 93       	push	r16
    16a6:	1f 93       	push	r17
    16a8:	cf 93       	push	r28
    16aa:	df 93       	push	r29
    16ac:	ec 01       	movw	r28, r24
    16ae:	86 2f       	mov	r24, r22
    16b0:	f9 01       	movw	r30, r18
	/* Erase existing packet data so that we start will all 0x00 DHCP header data */
 	memset(DHCPHeader, 0, sizeof(DHCP_Header_t));
    16b2:	90 ef       	ldi	r25, 0xF0	; 240
    16b4:	de 01       	movw	r26, r28
    16b6:	1d 92       	st	X+, r1
    16b8:	9a 95       	dec	r25
    16ba:	e9 f7       	brne	.-6      	; 0x16b6 <DHCPServerApp_FillDHCPHeader+0x16>

	DHCPHeader->Operation             = DHCPMessageType;
    16bc:	68 83       	st	Y, r22
	DHCPHeader->HardwareType          = DHCP_HTYPE_ETHERNET;
    16be:	91 e0       	ldi	r25, 0x01	; 1
    16c0:	99 83       	std	Y+1, r25	; 0x01
	DHCPHeader->HardwareAddressLength = sizeof(MACAddress);
    16c2:	26 e0       	ldi	r18, 0x06	; 6
    16c4:	2a 83       	std	Y+2, r18	; 0x02
	DHCPHeader->Hops                  = 0;
    16c6:	1b 82       	std	Y+3, r1	; 0x03
	DHCPHeader->TransactionID         = TransactionID;
    16c8:	ec 82       	std	Y+4, r14	; 0x04
    16ca:	fd 82       	std	Y+5, r15	; 0x05
    16cc:	0e 83       	std	Y+6, r16	; 0x06
    16ce:	1f 83       	std	Y+7, r17	; 0x07
	DHCPHeader->ElapsedSeconds        = 0;
    16d0:	19 86       	std	Y+9, r1	; 0x09
    16d2:	18 86       	std	Y+8, r1	; 0x08
	DHCPHeader->Flags                 = 0;
    16d4:	1b 86       	std	Y+11, r1	; 0x0b
    16d6:	1a 86       	std	Y+10, r1	; 0x0a
	memcpy(&DHCPHeader->NextServerIP, &uip_hostaddr, sizeof(uip_ipaddr_t));
    16d8:	00 91 c7 07 	lds	r16, 0x07C7
    16dc:	10 91 c8 07 	lds	r17, 0x07C8
    16e0:	20 91 c9 07 	lds	r18, 0x07C9
    16e4:	30 91 ca 07 	lds	r19, 0x07CA
    16e8:	0c 8b       	std	Y+20, r16	; 0x14
    16ea:	1d 8b       	std	Y+21, r17	; 0x15
    16ec:	2e 8b       	std	Y+22, r18	; 0x16
    16ee:	3f 8b       	std	Y+23, r19	; 0x17
	memcpy(&DHCPHeader->YourIP, PreferredClientIP, sizeof(uip_ipaddr_t));
    16f0:	00 81       	ld	r16, Z
    16f2:	11 81       	ldd	r17, Z+1	; 0x01
    16f4:	22 81       	ldd	r18, Z+2	; 0x02
    16f6:	33 81       	ldd	r19, Z+3	; 0x03
    16f8:	08 8b       	std	Y+16, r16	; 0x10
    16fa:	19 8b       	std	Y+17, r17	; 0x11
    16fc:	2a 8b       	std	Y+18, r18	; 0x12
    16fe:	3b 8b       	std	Y+19, r19	; 0x13
	memcpy(&DHCPHeader->ClientHardwareAddress, ClientHardwareAddress, sizeof(struct uip_eth_addr));
    1700:	de 01       	movw	r26, r28
    1702:	5c 96       	adiw	r26, 0x1c	; 28
    1704:	26 e0       	ldi	r18, 0x06	; 6
    1706:	fa 01       	movw	r30, r20
    1708:	01 90       	ld	r0, Z+
    170a:	0d 92       	st	X+, r0
    170c:	2a 95       	dec	r18
    170e:	e1 f7       	brne	.-8      	; 0x1708 <DHCPServerApp_FillDHCPHeader+0x68>
	DHCPHeader->Cookie                = DHCP_MAGIC_COOKIE;
    1710:	fe 01       	movw	r30, r28
    1712:	e4 51       	subi	r30, 0x14	; 20
    1714:	ff 4f       	sbci	r31, 0xFF	; 255
    1716:	43 e6       	ldi	r20, 0x63	; 99
    1718:	52 e8       	ldi	r21, 0x82	; 130
    171a:	63 e5       	ldi	r22, 0x53	; 83
    171c:	73 e6       	ldi	r23, 0x63	; 99
    171e:	40 83       	st	Z, r20
    1720:	51 83       	std	Z+1, r21	; 0x01
    1722:	62 83       	std	Z+2, r22	; 0x02
    1724:	73 83       	std	Z+3, r23	; 0x03

	/* Add a DHCP message type and terminator options to the start of the DHCP options field */
	DHCPHeader->Options[0]            = DHCP_OPTION_MSG_TYPE;
    1726:	fe 01       	movw	r30, r28
    1728:	e0 51       	subi	r30, 0x10	; 16
    172a:	ff 4f       	sbci	r31, 0xFF	; 255
    172c:	25 e3       	ldi	r18, 0x35	; 53
    172e:	20 83       	st	Z, r18
	DHCPHeader->Options[1]            = 1;
    1730:	fe 01       	movw	r30, r28
    1732:	ef 50       	subi	r30, 0x0F	; 15
    1734:	ff 4f       	sbci	r31, 0xFF	; 255
    1736:	90 83       	st	Z, r25
	DHCPHeader->Options[2]            = DHCPMessageType;
    1738:	fe 01       	movw	r30, r28
    173a:	ee 50       	subi	r30, 0x0E	; 14
    173c:	ff 4f       	sbci	r31, 0xFF	; 255
    173e:	80 83       	st	Z, r24
	DHCPHeader->Options[3]            = DHCP_OPTION_END;
    1740:	cd 50       	subi	r28, 0x0D	; 13
    1742:	df 4f       	sbci	r29, 0xFF	; 255
    1744:	8f ef       	ldi	r24, 0xFF	; 255
    1746:	88 83       	st	Y, r24

	/* Calculate the total number of bytes added to the outgoing packet */
	return (sizeof(DHCP_Header_t) + 4);
}
    1748:	84 ef       	ldi	r24, 0xF4	; 244
    174a:	90 e0       	ldi	r25, 0x00	; 0
    174c:	df 91       	pop	r29
    174e:	cf 91       	pop	r28
    1750:	1f 91       	pop	r17
    1752:	0f 91       	pop	r16
    1754:	ff 90       	pop	r15
    1756:	ef 90       	pop	r14
    1758:	08 95       	ret

0000175a <DHCPServerApp_CheckIfIPLeased.isra.0>:
{
	uint8_t Byte = (IPAddress->u8[3] / 8);
	uint8_t Mask = (1 << (IPAddress->u8[3] % 8));

	/* Make sure that the requested IP address isn't already leased to the virtual server or another client */
	if (IPAddress->u8[3] && !(IPAddress->u8[3] == uip_hostaddr.u8[3]) && !(LeasedIPs[Byte] & Mask))
    175a:	88 23       	and	r24, r24
    175c:	c9 f0       	breq	.+50     	; 0x1790 <DHCPServerApp_CheckIfIPLeased.isra.0+0x36>
    175e:	90 91 ca 07 	lds	r25, 0x07CA
    1762:	89 17       	cp	r24, r25
    1764:	a9 f0       	breq	.+42     	; 0x1790 <DHCPServerApp_CheckIfIPLeased.isra.0+0x36>
 *  \return Boolean \c true if the IP has already been leased to a client, \c false otherwise.
 */
static bool DHCPServerApp_CheckIfIPLeased(const uip_ipaddr_t* const IPAddress)
{
	uint8_t Byte = (IPAddress->u8[3] / 8);
	uint8_t Mask = (1 << (IPAddress->u8[3] % 8));
    1766:	98 2f       	mov	r25, r24
    1768:	97 70       	andi	r25, 0x07	; 7
    176a:	21 e0       	ldi	r18, 0x01	; 1
    176c:	30 e0       	ldi	r19, 0x00	; 0
    176e:	01 c0       	rjmp	.+2      	; 0x1772 <DHCPServerApp_CheckIfIPLeased.isra.0+0x18>
    1770:	22 0f       	add	r18, r18
    1772:	9a 95       	dec	r25
    1774:	ea f7       	brpl	.-6      	; 0x1770 <DHCPServerApp_CheckIfIPLeased.isra.0+0x16>
 *
 *  \return Boolean \c true if the IP has already been leased to a client, \c false otherwise.
 */
static bool DHCPServerApp_CheckIfIPLeased(const uip_ipaddr_t* const IPAddress)
{
	uint8_t Byte = (IPAddress->u8[3] / 8);
    1776:	86 95       	lsr	r24
    1778:	86 95       	lsr	r24
    177a:	86 95       	lsr	r24
	uint8_t Mask = (1 << (IPAddress->u8[3] % 8));

	/* Make sure that the requested IP address isn't already leased to the virtual server or another client */
	if (IPAddress->u8[3] && !(IPAddress->u8[3] == uip_hostaddr.u8[3]) && !(LeasedIPs[Byte] & Mask))
    177c:	e8 2f       	mov	r30, r24
    177e:	f0 e0       	ldi	r31, 0x00	; 0
    1780:	e0 5f       	subi	r30, 0xF0	; 240
    1782:	fb 4f       	sbci	r31, 0xFB	; 251
    1784:	90 81       	ld	r25, Z
    1786:	92 23       	and	r25, r18
    1788:	81 e0       	ldi	r24, 0x01	; 1
    178a:	19 f4       	brne	.+6      	; 0x1792 <DHCPServerApp_CheckIfIPLeased.isra.0+0x38>
    178c:	80 e0       	ldi	r24, 0x00	; 0
    178e:	08 95       	ret
	  return false;
	else
	  return true;
    1790:	81 e0       	ldi	r24, 0x01	; 1
}
    1792:	08 95       	ret

00001794 <DHCPServerApp_Init>:

/** Initialization function for the DHCP server. */
void DHCPServerApp_Init(void)
{
	/* Listen on port 67 for DHCP server connections from hosts */
	uip_listen(HTONS(DHCP_SERVER_PORT));
    1794:	80 e0       	ldi	r24, 0x00	; 0
    1796:	93 e4       	ldi	r25, 0x43	; 67
    1798:	f3 d4       	rcall	.+2534   	; 0x2180 <uip_listen>
    179a:	60 e0       	ldi	r22, 0x00	; 0

	/* Create a new UDP connection to the DHCP server port for the DHCP solicitation */
	struct uip_udp_conn* BroadcastConnection = uip_udp_new(&uip_broadcast_addr, HTONS(DHCP_CLIENT_PORT));
    179c:	74 e4       	ldi	r23, 0x44	; 68
    179e:	8e ed       	ldi	r24, 0xDE	; 222
    17a0:	91 e0       	ldi	r25, 0x01	; 1
    17a2:	a5 d4       	rcall	.+2378   	; 0x20ee <uip_udp_new>
    17a4:	00 97       	sbiw	r24, 0x00	; 0
    17a6:	39 f0       	breq	.+14     	; 0x17b6 <DHCPServerApp_Init+0x22>

	/* If the connection was successfully created, bind it to the local DHCP client port */
	if (BroadcastConnection != NULL)
    17a8:	20 e0       	ldi	r18, 0x00	; 0
    17aa:	33 e4       	ldi	r19, 0x43	; 67
	  uip_udp_bind(BroadcastConnection, HTONS(DHCP_SERVER_PORT));
    17ac:	dc 01       	movw	r26, r24
    17ae:	15 96       	adiw	r26, 0x05	; 5
    17b0:	3c 93       	st	X, r19
    17b2:	2e 93       	st	-X, r18
    17b4:	14 97       	sbiw	r26, 0x04	; 4
    17b6:	8f e1       	ldi	r24, 0x1F	; 31
    17b8:	e0 e1       	ldi	r30, 0x10	; 16

	/* Set all IP addresses as unleased */
	memset(LeasedIPs, 0x00, sizeof(LeasedIPs));
    17ba:	f4 e0       	ldi	r31, 0x04	; 4
    17bc:	df 01       	movw	r26, r30
    17be:	1d 92       	st	X+, r1
    17c0:	8a 95       	dec	r24
    17c2:	e9 f7       	brne	.-6      	; 0x17be <DHCPServerApp_Init+0x2a>
    17c4:	08 95       	ret

000017c6 <DHCPServerApp_Callback>:
    17c6:	8f 92       	push	r8
    17c8:	9f 92       	push	r9

/** uIP stack application callback for the DHCP server. This function must be called each time the TCP/IP stack
 *  needs a UDP packet to be processed.
 */
void DHCPServerApp_Callback(void)
{
    17ca:	af 92       	push	r10
    17cc:	bf 92       	push	r11
    17ce:	cf 92       	push	r12
    17d0:	df 92       	push	r13
    17d2:	ef 92       	push	r14
    17d4:	ff 92       	push	r15
    17d6:	0f 93       	push	r16
    17d8:	1f 93       	push	r17
    17da:	cf 93       	push	r28
    17dc:	df 93       	push	r29
    17de:	cd b7       	in	r28, 0x3d	; 61
    17e0:	de b7       	in	r29, 0x3e	; 62
    17e2:	63 97       	sbiw	r28, 0x13	; 19
    17e4:	0f b6       	in	r0, 0x3f	; 63
    17e6:	f8 94       	cli
    17e8:	de bf       	out	0x3e, r29	; 62
    17ea:	0f be       	out	0x3f, r0	; 63
    17ec:	cd bf       	out	0x3d, r28	; 61
	DHCP_Header_t* const AppData     = (DHCP_Header_t*)uip_appdata;
    17ee:	a0 90 5e 06 	lds	r10, 0x065E
    17f2:	b0 90 5f 06 	lds	r11, 0x065F
	uint16_t             AppDataSize = 0;

	/* Only process when new data arrives - don't retransmit lost packets */
	if (uip_newdata())
    17f6:	80 91 5b 06 	lds	r24, 0x065B
    17fa:	81 ff       	sbrs	r24, 1
    17fc:	0b c1       	rjmp	.+534    	; 0x1a14 <DHCPServerApp_Callback+0x24e>
	{
		/* Get the DHCP message type (if present), otherwise early-abort */
		uint8_t DHCPMessageType;
		if (!(DHCPCommon_GetOption(AppData->Options, DHCP_OPTION_MSG_TYPE, &DHCPMessageType)))
    17fe:	45 01       	movw	r8, r10
    1800:	80 ef       	ldi	r24, 0xF0	; 240
    1802:	88 0e       	add	r8, r24
    1804:	91 1c       	adc	r9, r1
    1806:	ae 01       	movw	r20, r28
    1808:	4d 5e       	subi	r20, 0xED	; 237
    180a:	5f 4f       	sbci	r21, 0xFF	; 255
    180c:	65 e3       	ldi	r22, 0x35	; 53
    180e:	c4 01       	movw	r24, r8
    1810:	89 dd       	rcall	.-1262   	; 0x1324 <DHCPCommon_GetOption>
    1812:	88 23       	and	r24, r24
    1814:	09 f4       	brne	.+2      	; 0x1818 <DHCPServerApp_Callback+0x52>
    1816:	fe c0       	rjmp	.+508    	; 0x1a14 <DHCPServerApp_Callback+0x24e>
    1818:	80 91 c3 07 	lds	r24, 0x07C3
		uip_ipaddr_t        Netmask, GatewayIPAddress, PreferredClientIP;
		struct uip_eth_addr RemoteMACAddress;
		uint32_t            TransactionID;

		/* Get configured network mask, gateway IP and extract out DHCP transaction ID and remote IP */
		uip_getnetmask(&Netmask);
    181c:	90 91 c4 07 	lds	r25, 0x07C4
    1820:	a0 91 c5 07 	lds	r26, 0x07C5
    1824:	b0 91 c6 07 	lds	r27, 0x07C6
    1828:	8f 87       	std	Y+15, r24	; 0x0f
    182a:	98 8b       	std	Y+16, r25	; 0x10
    182c:	a9 8b       	std	Y+17, r26	; 0x11
    182e:	ba 8b       	std	Y+18, r27	; 0x12
    1830:	80 91 bf 07 	lds	r24, 0x07BF
		uip_getdraddr(&GatewayIPAddress);
    1834:	90 91 c0 07 	lds	r25, 0x07C0
    1838:	a0 91 c1 07 	lds	r26, 0x07C1
    183c:	b0 91 c2 07 	lds	r27, 0x07C2
    1840:	8b 87       	std	Y+11, r24	; 0x0b
    1842:	9c 87       	std	Y+12, r25	; 0x0c
    1844:	ad 87       	std	Y+13, r26	; 0x0d
    1846:	be 87       	std	Y+14, r27	; 0x0e
    1848:	86 e0       	ldi	r24, 0x06	; 6
		memcpy(&RemoteMACAddress, &AppData->ClientHardwareAddress, sizeof(struct uip_eth_addr));
    184a:	f5 01       	movw	r30, r10
    184c:	7c 96       	adiw	r30, 0x1c	; 28
    184e:	de 01       	movw	r26, r28
    1850:	11 96       	adiw	r26, 0x01	; 1
    1852:	01 90       	ld	r0, Z+
    1854:	0d 92       	st	X+, r0
    1856:	8a 95       	dec	r24
    1858:	e1 f7       	brne	.-8      	; 0x1852 <DHCPServerApp_Callback+0x8c>
    185a:	f5 01       	movw	r30, r10
		TransactionID = AppData->TransactionID;
    185c:	c4 80       	ldd	r12, Z+4	; 0x04
    185e:	d5 80       	ldd	r13, Z+5	; 0x05
    1860:	e6 80       	ldd	r14, Z+6	; 0x06
    1862:	f7 80       	ldd	r15, Z+7	; 0x07
    1864:	ae 01       	movw	r20, r28

		/* Try to extract out the client's preferred IP address if it is indicated in the packet */
		if (!(DHCPCommon_GetOption(AppData->Options, DHCP_OPTION_REQ_IPADDR, &PreferredClientIP)))
    1866:	49 5f       	subi	r20, 0xF9	; 249
    1868:	5f 4f       	sbci	r21, 0xFF	; 255
    186a:	62 e3       	ldi	r22, 0x32	; 50
    186c:	c4 01       	movw	r24, r8
    186e:	5a dd       	rcall	.-1356   	; 0x1324 <DHCPCommon_GetOption>
    1870:	81 11       	cpse	r24, r1
    1872:	0c c0       	rjmp	.+24     	; 0x188c <DHCPServerApp_Callback+0xc6>
    1874:	80 91 da 01 	lds	r24, 0x01DA
		  memcpy(&PreferredClientIP, &uip_all_zeroes_addr, sizeof(uip_ipaddr_t));
    1878:	90 91 db 01 	lds	r25, 0x01DB
    187c:	a0 91 dc 01 	lds	r26, 0x01DC
    1880:	b0 91 dd 01 	lds	r27, 0x01DD
    1884:	8f 83       	std	Y+7, r24	; 0x07
    1886:	98 87       	std	Y+8, r25	; 0x08
    1888:	a9 87       	std	Y+9, r26	; 0x09
    188a:	ba 87       	std	Y+10, r27	; 0x0a
    188c:	8b 89       	ldd	r24, Y+19	; 0x13
    188e:	83 30       	cpi	r24, 0x03	; 3

		switch (DHCPMessageType)
    1890:	09 f4       	brne	.+2      	; 0x1894 <DHCPServerApp_Callback+0xce>
    1892:	42 c0       	rjmp	.+132    	; 0x1918 <DHCPServerApp_Callback+0x152>
    1894:	87 30       	cpi	r24, 0x07	; 7
    1896:	09 f4       	brne	.+2      	; 0x189a <DHCPServerApp_Callback+0xd4>
    1898:	a4 c0       	rjmp	.+328    	; 0x19e2 <DHCPServerApp_Callback+0x21c>
    189a:	81 30       	cpi	r24, 0x01	; 1
    189c:	09 f0       	breq	.+2      	; 0x18a0 <DHCPServerApp_Callback+0xda>
    189e:	ba c0       	rjmp	.+372    	; 0x1a14 <DHCPServerApp_Callback+0x24e>
    18a0:	8a 85       	ldd	r24, Y+10	; 0x0a
    18a2:	5b df       	rcall	.-330    	; 0x175a <DHCPServerApp_CheckIfIPLeased.isra.0>
		{
			case DHCP_DISCOVER:
				/* If no preference was made or the preferred IP is already taken, find a new address */
				if (DHCPServerApp_CheckIfIPLeased(&PreferredClientIP))
    18a4:	81 11       	cpse	r24, r1
    18a6:	22 c0       	rjmp	.+68     	; 0x18ec <DHCPServerApp_Callback+0x126>
    18a8:	87 01       	movw	r16, r14
    18aa:	76 01       	movw	r14, r12
    18ac:	9e 01       	movw	r18, r28
				  DHCPServerApp_GetUnleasedIP(&PreferredClientIP);

				/* Create a new DHCP OFFER packet with the offered IP address */
				AppDataSize += DHCPServerApp_FillDHCPHeader(AppData, DHCP_OFFER, &RemoteMACAddress, &PreferredClientIP, TransactionID);
    18ae:	29 5f       	subi	r18, 0xF9	; 249
    18b0:	3f 4f       	sbci	r19, 0xFF	; 255
    18b2:	ae 01       	movw	r20, r28
    18b4:	4f 5f       	subi	r20, 0xFF	; 255
    18b6:	5f 4f       	sbci	r21, 0xFF	; 255
    18b8:	62 e0       	ldi	r22, 0x02	; 2
    18ba:	c5 01       	movw	r24, r10
    18bc:	f1 de       	rcall	.-542    	; 0x16a0 <DHCPServerApp_FillDHCPHeader>
    18be:	6c 01       	movw	r12, r24
    18c0:	9e 01       	movw	r18, r28
    18c2:	21 5f       	subi	r18, 0xF1	; 241
    18c4:	3f 4f       	sbci	r19, 0xFF	; 255
    18c6:	44 e0       	ldi	r20, 0x04	; 4

				/* Add network mask and router information to the list of DHCP OFFER packet options */
				AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_SUBNET_MASK,
    18c8:	61 e0       	ldi	r22, 0x01	; 1
    18ca:	c4 01       	movw	r24, r8
    18cc:	03 dd       	rcall	.-1530   	; 0x12d4 <DHCPCommon_SetOption>
    18ce:	18 2f       	mov	r17, r24
    18d0:	9e 01       	movw	r18, r28
    18d2:	25 5f       	subi	r18, 0xF5	; 245
    18d4:	3f 4f       	sbci	r19, 0xFF	; 255
    18d6:	44 e0       	ldi	r20, 0x04	; 4
    18d8:	63 e0       	ldi	r22, 0x03	; 3
													sizeof(uip_ipaddr_t), &Netmask);
				AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_ROUTER,
    18da:	c4 01       	movw	r24, r8
    18dc:	fb dc       	rcall	.-1546   	; 0x12d4 <DHCPCommon_SetOption>
    18de:	e8 2e       	mov	r14, r24
    18e0:	f1 2c       	mov	r15, r1
    18e2:	e1 0e       	add	r14, r17
    18e4:	f1 1c       	adc	r15, r1
    18e6:	ec 0c       	add	r14, r12
    18e8:	fd 1c       	adc	r15, r13
    18ea:	59 c0       	rjmp	.+178    	; 0x199e <DHCPServerApp_Callback+0x1d8>
    18ec:	80 91 c7 07 	lds	r24, 0x07C7

				/* Create a new DHCP OFFER packet with the offered IP address */
				AppDataSize += DHCPServerApp_FillDHCPHeader(AppData, DHCP_OFFER, &RemoteMACAddress, &PreferredClientIP, TransactionID);

				/* Add network mask and router information to the list of DHCP OFFER packet options */
				AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_SUBNET_MASK,
    18f0:	90 91 c8 07 	lds	r25, 0x07C8
													sizeof(uip_ipaddr_t), &Netmask);
				AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_ROUTER,
    18f4:	a0 91 c9 07 	lds	r26, 0x07C9
 *
 *  \param[out] NewIPAddress  Location where the generated IP Address should be stored
 */
static void DHCPServerApp_GetUnleasedIP(uip_ipaddr_t* const NewIPAddress)
{
	uip_ipaddr_copy(NewIPAddress, &uip_hostaddr);
    18f8:	b0 91 ca 07 	lds	r27, 0x07CA
    18fc:	8f 83       	std	Y+7, r24	; 0x07
    18fe:	98 87       	std	Y+8, r25	; 0x08
    1900:	a9 87       	std	Y+9, r26	; 0x09
    1902:	ba 87       	std	Y+10, r27	; 0x0a
    1904:	11 e0       	ldi	r17, 0x01	; 1
    1906:	1a 87       	std	Y+10, r17	; 0x0a
    1908:	81 2f       	mov	r24, r17
    190a:	27 df       	rcall	.-434    	; 0x175a <DHCPServerApp_CheckIfIPLeased.isra.0>
    190c:	88 23       	and	r24, r24
    190e:	61 f2       	breq	.-104    	; 0x18a8 <DHCPServerApp_Callback+0xe2>

	/** Look through the current subnet, skipping the broadcast and zero IP addresses */
	for (uint8_t IP = 1; IP < 254; IP++)
    1910:	1f 5f       	subi	r17, 0xFF	; 255
	{
		/* Update new IP address to lease with the current IP address to test */
		NewIPAddress->u8[3] = IP;
    1912:	1e 3f       	cpi	r17, 0xFE	; 254

		/* If we've found an unleased IP, abort with the updated IP stored for the called */
		if (!(DHCPServerApp_CheckIfIPLeased(NewIPAddress)))
    1914:	c1 f7       	brne	.-16     	; 0x1906 <DHCPServerApp_Callback+0x140>
    1916:	c8 cf       	rjmp	.-112    	; 0x18a8 <DHCPServerApp_Callback+0xe2>
    1918:	8a 85       	ldd	r24, Y+10	; 0x0a
    191a:	1f df       	rcall	.-450    	; 0x175a <DHCPServerApp_CheckIfIPLeased.isra.0>
    191c:	87 01       	movw	r16, r14
static void DHCPServerApp_GetUnleasedIP(uip_ipaddr_t* const NewIPAddress)
{
	uip_ipaddr_copy(NewIPAddress, &uip_hostaddr);

	/** Look through the current subnet, skipping the broadcast and zero IP addresses */
	for (uint8_t IP = 1; IP < 254; IP++)
    191e:	76 01       	movw	r14, r12
    1920:	81 11       	cpse	r24, r1
    1922:	34 c0       	rjmp	.+104    	; 0x198c <DHCPServerApp_Callback+0x1c6>
    1924:	9e 01       	movw	r18, r28
				uip_udp_send(AppDataSize);

				break;
			case DHCP_REQUEST:
				/* Check to see if the requested IP address has already been leased to a client */
				if (!(DHCPServerApp_CheckIfIPLeased(&PreferredClientIP)))
    1926:	29 5f       	subi	r18, 0xF9	; 249
    1928:	3f 4f       	sbci	r19, 0xFF	; 255
    192a:	ae 01       	movw	r20, r28
				{
					/* Create a new DHCP ACK packet to accept the IP address lease */
					AppDataSize += DHCPServerApp_FillDHCPHeader(AppData, DHCP_ACK, &RemoteMACAddress, &PreferredClientIP, TransactionID);
    192c:	4f 5f       	subi	r20, 0xFF	; 255
    192e:	5f 4f       	sbci	r21, 0xFF	; 255
				uip_udp_send(AppDataSize);

				break;
			case DHCP_REQUEST:
				/* Check to see if the requested IP address has already been leased to a client */
				if (!(DHCPServerApp_CheckIfIPLeased(&PreferredClientIP)))
    1930:	65 e0       	ldi	r22, 0x05	; 5
    1932:	c5 01       	movw	r24, r10
				{
					/* Create a new DHCP ACK packet to accept the IP address lease */
					AppDataSize += DHCPServerApp_FillDHCPHeader(AppData, DHCP_ACK, &RemoteMACAddress, &PreferredClientIP, TransactionID);
    1934:	b5 de       	rcall	.-662    	; 0x16a0 <DHCPServerApp_FillDHCPHeader>
    1936:	6c 01       	movw	r12, r24
    1938:	9e 01       	movw	r18, r28
    193a:	21 5f       	subi	r18, 0xF1	; 241
    193c:	3f 4f       	sbci	r19, 0xFF	; 255
    193e:	44 e0       	ldi	r20, 0x04	; 4
    1940:	61 e0       	ldi	r22, 0x01	; 1
    1942:	c4 01       	movw	r24, r8
    1944:	c7 dc       	rcall	.-1650   	; 0x12d4 <DHCPCommon_SetOption>
    1946:	18 2f       	mov	r17, r24
    1948:	9e 01       	movw	r18, r28

					/* Add network mask and router information to the list of DHCP ACK packet options */
					AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_SUBNET_MASK,
    194a:	25 5f       	subi	r18, 0xF5	; 245
    194c:	3f 4f       	sbci	r19, 0xFF	; 255
    194e:	44 e0       	ldi	r20, 0x04	; 4
    1950:	63 e0       	ldi	r22, 0x03	; 3
    1952:	c4 01       	movw	r24, r8
    1954:	bf dc       	rcall	.-1666   	; 0x12d4 <DHCPCommon_SetOption>
    1956:	e8 2e       	mov	r14, r24
    1958:	f1 2c       	mov	r15, r1
    195a:	e1 0e       	add	r14, r17
														sizeof(uip_ipaddr_t), &Netmask);
					AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_ROUTER,
    195c:	f1 1c       	adc	r15, r1
    195e:	ec 0c       	add	r14, r12
    1960:	fd 1c       	adc	r15, r13
    1962:	8a 85       	ldd	r24, Y+10	; 0x0a
    1964:	e8 2f       	mov	r30, r24
    1966:	e6 95       	lsr	r30
    1968:	e6 95       	lsr	r30
    196a:	e6 95       	lsr	r30
    196c:	f0 e0       	ldi	r31, 0x00	; 0
    196e:	e0 5f       	subi	r30, 0xF0	; 240
				{
					/* Create a new DHCP ACK packet to accept the IP address lease */
					AppDataSize += DHCPServerApp_FillDHCPHeader(AppData, DHCP_ACK, &RemoteMACAddress, &PreferredClientIP, TransactionID);

					/* Add network mask and router information to the list of DHCP ACK packet options */
					AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_SUBNET_MASK,
    1970:	fb 4f       	sbci	r31, 0xFB	; 251
    1972:	28 2f       	mov	r18, r24
														sizeof(uip_ipaddr_t), &Netmask);
					AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_ROUTER,
    1974:	27 70       	andi	r18, 0x07	; 7
    1976:	81 e0       	ldi	r24, 0x01	; 1
					                                    sizeof(uip_ipaddr_t), &GatewayIPAddress);

					/* Mark the requested IP as leased to a client */
					DHCPServerApp_LeaseIP(&PreferredClientIP);
    1978:	90 e0       	ldi	r25, 0x00	; 0
 *
 *  \pre The IP address must be within the same /24 subnet as the virtual webserver.
 */
static void DHCPServerApp_LeaseIP(const uip_ipaddr_t* const IPAddress)
{
	uint8_t Byte = (IPAddress->u8[3] / 8);
    197a:	02 2e       	mov	r0, r18
    197c:	01 c0       	rjmp	.+2      	; 0x1980 <DHCPServerApp_Callback+0x1ba>
    197e:	88 0f       	add	r24, r24
    1980:	0a 94       	dec	r0
	uint8_t Mask = (1 << (IPAddress->u8[3] % 8));

	/* Mark the IP address as leased in the allocation table */
	LeasedIPs[Byte] |= Mask;
    1982:	ea f7       	brpl	.-6      	; 0x197e <DHCPServerApp_Callback+0x1b8>
    1984:	90 81       	ld	r25, Z
    1986:	98 2b       	or	r25, r24
 *  \pre The IP address must be within the same /24 subnet as the virtual webserver.
 */
static void DHCPServerApp_LeaseIP(const uip_ipaddr_t* const IPAddress)
{
	uint8_t Byte = (IPAddress->u8[3] / 8);
	uint8_t Mask = (1 << (IPAddress->u8[3] % 8));
    1988:	90 83       	st	Z, r25
    198a:	09 c0       	rjmp	.+18     	; 0x199e <DHCPServerApp_Callback+0x1d8>
    198c:	2a ed       	ldi	r18, 0xDA	; 218
    198e:	31 e0       	ldi	r19, 0x01	; 1
    1990:	ae 01       	movw	r20, r28
    1992:	4f 5f       	subi	r20, 0xFF	; 255
    1994:	5f 4f       	sbci	r21, 0xFF	; 255
    1996:	66 e0       	ldi	r22, 0x06	; 6
    1998:	c5 01       	movw	r24, r10

	/* Mark the IP address as leased in the allocation table */
	LeasedIPs[Byte] |= Mask;
    199a:	82 de       	rcall	.-764    	; 0x16a0 <DHCPServerApp_FillDHCPHeader>
    199c:	7c 01       	movw	r14, r24
    199e:	80 91 2f 04 	lds	r24, 0x042F
					DHCPServerApp_LeaseIP(&PreferredClientIP);
				}
				else
				{
					/* Create a new DHCP NAK packet to reject the requested allocation */
					AppDataSize += DHCPServerApp_FillDHCPHeader(AppData, DHCP_NAK, &RemoteMACAddress, &uip_all_zeroes_addr, TransactionID);
    19a2:	90 91 30 04 	lds	r25, 0x0430
    19a6:	90 93 61 06 	sts	0x0661, r25
    19aa:	80 93 60 06 	sts	0x0660, r24
    19ae:	83 e0       	ldi	r24, 0x03	; 3
    19b0:	00 d4       	rcall	.+2048   	; 0x21b2 <uip_process>
    19b2:	e0 91 5c 06 	lds	r30, 0x065C
				}

				/* Send the DHCP ACK or NAK packet */
				uip_poll_conn(BroadcastConnection);
    19b6:	f0 91 5d 06 	lds	r31, 0x065D
    19ba:	40 91 de 01 	lds	r20, 0x01DE
    19be:	50 91 df 01 	lds	r21, 0x01DF
    19c2:	60 91 e0 01 	lds	r22, 0x01E0
    19c6:	70 91 e1 01 	lds	r23, 0x01E1
    19ca:	40 83       	st	Z, r20
				memcpy(&uip_udp_conn->ripaddr, &uip_broadcast_addr, sizeof(uip_ipaddr_t));
    19cc:	51 83       	std	Z+1, r21	; 0x01
    19ce:	62 83       	std	Z+2, r22	; 0x02
    19d0:	73 83       	std	Z+3, r23	; 0x03
    19d2:	b7 01       	movw	r22, r14
    19d4:	80 91 5e 06 	lds	r24, 0x065E
    19d8:	90 91 5f 06 	lds	r25, 0x065F
    19dc:	0e 94 56 18 	call	0x30ac	; 0x30ac <uip_send>
    19e0:	19 c0       	rjmp	.+50     	; 0x1a14 <DHCPServerApp_Callback+0x24e>
    19e2:	e0 91 5c 06 	lds	r30, 0x065C
    19e6:	f0 91 5d 06 	lds	r31, 0x065D
    19ea:	83 81       	ldd	r24, Z+3	; 0x03
				uip_udp_send(AppDataSize);
    19ec:	e8 2f       	mov	r30, r24
    19ee:	e6 95       	lsr	r30
    19f0:	e6 95       	lsr	r30
    19f2:	e6 95       	lsr	r30
    19f4:	f0 e0       	ldi	r31, 0x00	; 0
    19f6:	e0 5f       	subi	r30, 0xF0	; 240
    19f8:	fb 4f       	sbci	r31, 0xFB	; 251

				break;
    19fa:	28 2f       	mov	r18, r24
			case DHCP_RELEASE:
				/* Mark the IP address as released in the allocation table */
				DHCPServerApp_UnleaseIP(&uip_udp_conn->ripaddr);
    19fc:	27 70       	andi	r18, 0x07	; 7
    19fe:	81 e0       	ldi	r24, 0x01	; 1
    1a00:	90 e0       	ldi	r25, 0x00	; 0
    1a02:	02 2e       	mov	r0, r18
    1a04:	01 c0       	rjmp	.+2      	; 0x1a08 <DHCPServerApp_Callback+0x242>
 *
 *  \pre The IP address must be within the same /24 subnet as the virtual webserver.
 */
static void DHCPServerApp_UnleaseIP(const uip_ipaddr_t* const IPAddress)
{
	uint8_t Byte = (IPAddress->u8[3] / 8);
    1a06:	88 0f       	add	r24, r24
    1a08:	0a 94       	dec	r0
    1a0a:	ea f7       	brpl	.-6      	; 0x1a06 <DHCPServerApp_Callback+0x240>
    1a0c:	80 95       	com	r24
	uint8_t Mask = (1 << (IPAddress->u8[3] % 8));

	/* Mark the IP address as unleased in the allocation table */
	LeasedIPs[Byte] &= ~Mask;
    1a0e:	90 81       	ld	r25, Z
    1a10:	89 23       	and	r24, r25
    1a12:	80 83       	st	Z, r24
 *  \pre The IP address must be within the same /24 subnet as the virtual webserver.
 */
static void DHCPServerApp_UnleaseIP(const uip_ipaddr_t* const IPAddress)
{
	uint8_t Byte = (IPAddress->u8[3] / 8);
	uint8_t Mask = (1 << (IPAddress->u8[3] % 8));
    1a14:	63 96       	adiw	r28, 0x13	; 19
    1a16:	0f b6       	in	r0, 0x3f	; 63
    1a18:	f8 94       	cli
    1a1a:	de bf       	out	0x3e, r29	; 62
    1a1c:	0f be       	out	0x3f, r0	; 63
    1a1e:	cd bf       	out	0x3d, r28	; 61
    1a20:	df 91       	pop	r29
    1a22:	cf 91       	pop	r28
    1a24:	1f 91       	pop	r17

	/* Mark the IP address as unleased in the allocation table */
	LeasedIPs[Byte] &= ~Mask;
    1a26:	0f 91       	pop	r16
    1a28:	ff 90       	pop	r15
    1a2a:	ef 90       	pop	r14
    1a2c:	df 90       	pop	r13
				/* Mark the IP address as released in the allocation table */
				DHCPServerApp_UnleaseIP(&uip_udp_conn->ripaddr);
				break;
		}
	}
}
    1a2e:	cf 90       	pop	r12
    1a30:	bf 90       	pop	r11
    1a32:	af 90       	pop	r10
    1a34:	9f 90       	pop	r9
    1a36:	8f 90       	pop	r8
    1a38:	08 95       	ret

00001a3a <HTTPServerApp_Init>:

/** Initialization function for the simple HTTP webserver. */
void HTTPServerApp_Init(void)
{
	/* Listen on port 80 for HTTP connections from hosts */
	uip_listen(HTONS(HTTP_SERVER_PORT));
    1a3a:	80 e0       	ldi	r24, 0x00	; 0
    1a3c:	90 e5       	ldi	r25, 0x50	; 80
    1a3e:	a0 d3       	rcall	.+1856   	; 0x2180 <uip_listen>
    1a40:	61 e3       	ldi	r22, 0x31	; 49

	/* Mount the Dataflash disk via FatFS */
	f_mount(0, &DiskFATState);
    1a42:	74 e0       	ldi	r23, 0x04	; 4
    1a44:	80 e0       	ldi	r24, 0x00	; 0
    1a46:	0c 94 f3 1d 	jmp	0x3be6	; 0x3be6 <f_mount>

00001a4a <HTTPServerApp_Callback>:
    1a4a:	af 92       	push	r10

/** uIP stack application callback for the simple HTTP webserver. This function must be called each time the
 *  TCP/IP stack needs a TCP packet to be processed.
 */
void HTTPServerApp_Callback(void)
{
    1a4c:	bf 92       	push	r11
    1a4e:	cf 92       	push	r12
    1a50:	df 92       	push	r13
    1a52:	ef 92       	push	r14
    1a54:	ff 92       	push	r15
    1a56:	0f 93       	push	r16
    1a58:	1f 93       	push	r17
    1a5a:	cf 93       	push	r28
    1a5c:	df 93       	push	r29
	uip_tcp_appstate_t* const AppState = &uip_conn->appstate;
    1a5e:	c0 91 60 06 	lds	r28, 0x0660
    1a62:	d0 91 61 06 	lds	r29, 0x0661

	if (uip_aborted() || uip_timedout() || uip_closed())
    1a66:	40 91 5b 06 	lds	r20, 0x065B
    1a6a:	45 fd       	sbrc	r20, 5
    1a6c:	04 c0       	rjmp	.+8      	; 0x1a76 <HTTPServerApp_Callback+0x2c>
    1a6e:	47 fd       	sbrc	r20, 7
    1a70:	02 c0       	rjmp	.+4      	; 0x1a76 <HTTPServerApp_Callback+0x2c>
    1a72:	44 ff       	sbrs	r20, 4
    1a74:	03 c0       	rjmp	.+6      	; 0x1a7c <HTTPServerApp_Callback+0x32>
	{
		/* Lock to the closed state so that no further processing will occur on the connection */
		AppState->HTTPServer.CurrentState  = WEBSERVER_STATE_Closing;
    1a76:	83 e0       	ldi	r24, 0x03	; 3
    1a78:	8c 8f       	std	Y+28, r24	; 0x1c
		AppState->HTTPServer.NextState     = WEBSERVER_STATE_Closing;
    1a7a:	8d 8f       	std	Y+29, r24	; 0x1d
	}

	if (uip_connected())
    1a7c:	46 ff       	sbrs	r20, 6
    1a7e:	12 c0       	rjmp	.+36     	; 0x1aa4 <HTTPServerApp_Callback+0x5a>
	{
		/* New connection - initialize connection state values */
		AppState->HTTPServer.CurrentState  = WEBSERVER_STATE_OpenRequestedFile;
    1a80:	1c 8e       	std	Y+28, r1	; 0x1c
		AppState->HTTPServer.NextState     = WEBSERVER_STATE_OpenRequestedFile;
    1a82:	1d 8e       	std	Y+29, r1	; 0x1d
		AppState->HTTPServer.FileOpen      = false;
    1a84:	fe 01       	movw	r30, r28
    1a86:	e6 59       	subi	r30, 0x96	; 150
    1a88:	ff 4f       	sbci	r31, 0xFF	; 255
    1a8a:	10 82       	st	Z, r1
		AppState->HTTPServer.ACKedFilePos  = 0;
    1a8c:	fe 01       	movw	r30, r28
    1a8e:	e5 59       	subi	r30, 0x95	; 149
    1a90:	ff 4f       	sbci	r31, 0xFF	; 255
    1a92:	10 82       	st	Z, r1
    1a94:	11 82       	std	Z+1, r1	; 0x01
    1a96:	12 82       	std	Z+2, r1	; 0x02
    1a98:	13 82       	std	Z+3, r1	; 0x03
		AppState->HTTPServer.SentChunkSize = 0;
    1a9a:	fe 01       	movw	r30, r28
    1a9c:	e1 59       	subi	r30, 0x91	; 145
    1a9e:	ff 4f       	sbci	r31, 0xFF	; 255
    1aa0:	11 82       	std	Z+1, r1	; 0x01
    1aa2:	10 82       	st	Z, r1
	}

	if (uip_acked())
    1aa4:	40 ff       	sbrs	r20, 0
    1aa6:	16 c0       	rjmp	.+44     	; 0x1ad4 <HTTPServerApp_Callback+0x8a>
	{
		/* Add the amount of ACKed file data to the total sent file bytes counter */
		AppState->HTTPServer.ACKedFilePos += AppState->HTTPServer.SentChunkSize;
    1aa8:	fe 01       	movw	r30, r28
    1aaa:	e1 59       	subi	r30, 0x91	; 145
    1aac:	ff 4f       	sbci	r31, 0xFF	; 255
    1aae:	20 81       	ld	r18, Z
    1ab0:	31 81       	ldd	r19, Z+1	; 0x01
    1ab2:	fe 01       	movw	r30, r28
    1ab4:	e5 59       	subi	r30, 0x95	; 149
    1ab6:	ff 4f       	sbci	r31, 0xFF	; 255
    1ab8:	80 81       	ld	r24, Z
    1aba:	91 81       	ldd	r25, Z+1	; 0x01
    1abc:	a2 81       	ldd	r26, Z+2	; 0x02
    1abe:	b3 81       	ldd	r27, Z+3	; 0x03
    1ac0:	82 0f       	add	r24, r18
    1ac2:	93 1f       	adc	r25, r19
    1ac4:	a1 1d       	adc	r26, r1
    1ac6:	b1 1d       	adc	r27, r1
    1ac8:	80 83       	st	Z, r24
    1aca:	91 83       	std	Z+1, r25	; 0x01
    1acc:	a2 83       	std	Z+2, r26	; 0x02
    1ace:	b3 83       	std	Z+3, r27	; 0x03

		/* Progress to the next state once the current state's data has been ACKed */
		AppState->HTTPServer.CurrentState = AppState->HTTPServer.NextState;
    1ad0:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1ad2:	8c 8f       	std	Y+28, r24	; 0x1c
	}

	if (uip_rexmit())
    1ad4:	42 ff       	sbrs	r20, 2
    1ad6:	0c c0       	rjmp	.+24     	; 0x1af0 <HTTPServerApp_Callback+0xa6>
	{
		/* Return file pointer to the last ACKed position */
		f_lseek(&AppState->HTTPServer.FileHandle, AppState->HTTPServer.ACKedFilePos);
    1ad8:	fe 01       	movw	r30, r28
    1ada:	e5 59       	subi	r30, 0x95	; 149
    1adc:	ff 4f       	sbci	r31, 0xFF	; 255
    1ade:	40 81       	ld	r20, Z
    1ae0:	51 81       	ldd	r21, Z+1	; 0x01
    1ae2:	62 81       	ldd	r22, Z+2	; 0x02
    1ae4:	73 81       	ldd	r23, Z+3	; 0x03
    1ae6:	ce 01       	movw	r24, r28
    1ae8:	80 5b       	subi	r24, 0xB0	; 176
    1aea:	9f 4f       	sbci	r25, 0xFF	; 255
    1aec:	0e 94 2f 23 	call	0x465e	; 0x465e <f_lseek>
	}

	if (uip_rexmit() || uip_acked() || uip_newdata() || uip_connected() || uip_poll())
    1af0:	20 91 5b 06 	lds	r18, 0x065B
    1af4:	22 fd       	sbrc	r18, 2
    1af6:	07 c0       	rjmp	.+14     	; 0x1b06 <HTTPServerApp_Callback+0xbc>
    1af8:	82 2f       	mov	r24, r18
    1afa:	83 70       	andi	r24, 0x03	; 3
    1afc:	21 f4       	brne	.+8      	; 0x1b06 <HTTPServerApp_Callback+0xbc>
    1afe:	82 2f       	mov	r24, r18
    1b00:	88 74       	andi	r24, 0x48	; 72
    1b02:	09 f4       	brne	.+2      	; 0x1b06 <HTTPServerApp_Callback+0xbc>
    1b04:	14 c1       	rjmp	.+552    	; 0x1d2e <HTTPServerApp_Callback+0x2e4>
	{
		switch (AppState->HTTPServer.CurrentState)
    1b06:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1b08:	81 30       	cpi	r24, 0x01	; 1
    1b0a:	09 f4       	brne	.+2      	; 0x1b0e <HTTPServerApp_Callback+0xc4>
    1b0c:	72 c0       	rjmp	.+228    	; 0x1bf2 <HTTPServerApp_Callback+0x1a8>
    1b0e:	a0 f0       	brcs	.+40     	; 0x1b38 <HTTPServerApp_Callback+0xee>
    1b10:	82 30       	cpi	r24, 0x02	; 2
    1b12:	09 f4       	brne	.+2      	; 0x1b16 <HTTPServerApp_Callback+0xcc>
    1b14:	e7 c0       	rjmp	.+462    	; 0x1ce4 <HTTPServerApp_Callback+0x29a>
    1b16:	83 30       	cpi	r24, 0x03	; 3
    1b18:	09 f0       	breq	.+2      	; 0x1b1c <HTTPServerApp_Callback+0xd2>
    1b1a:	09 c1       	rjmp	.+530    	; 0x1d2e <HTTPServerApp_Callback+0x2e4>
			case WEBSERVER_STATE_SendData:
				HTTPServerApp_SendData();
				break;
			case WEBSERVER_STATE_Closing:
				/* Connection is being terminated for some reason - close file handle */
				f_close(&AppState->HTTPServer.FileHandle);
    1b1c:	ce 01       	movw	r24, r28
    1b1e:	80 5b       	subi	r24, 0xB0	; 176
    1b20:	9f 4f       	sbci	r25, 0xFF	; 255
    1b22:	0e 94 24 23 	call	0x4648	; 0x4648 <f_close>
				AppState->HTTPServer.FileOpen = false;
    1b26:	fe 01       	movw	r30, r28
    1b28:	e6 59       	subi	r30, 0x96	; 150
    1b2a:	ff 4f       	sbci	r31, 0xFF	; 255
    1b2c:	10 82       	st	Z, r1

				/* If connection is not already closed, close it */
				uip_close();
    1b2e:	80 e1       	ldi	r24, 0x10	; 16
    1b30:	80 93 5b 06 	sts	0x065B, r24

				AppState->HTTPServer.CurrentState = WEBSERVER_STATE_Closed;
    1b34:	84 e0       	ldi	r24, 0x04	; 4
    1b36:	f9 c0       	rjmp	.+498    	; 0x1d2a <HTTPServerApp_Callback+0x2e0>
/** HTTP Server State handler for the Request Process state. This state manages the processing of incoming HTTP
 *  GET requests to the server from the receiving HTTP client.
 */
static void HTTPServerApp_OpenRequestedFile(void)
{
	uip_tcp_appstate_t* const AppState    = &uip_conn->appstate;
    1b38:	c0 91 60 06 	lds	r28, 0x0660
    1b3c:	d0 91 61 06 	lds	r29, 0x0661
	char*               const AppData     = (char*)uip_appdata;
    1b40:	80 91 5e 06 	lds	r24, 0x065E
    1b44:	90 91 5f 06 	lds	r25, 0x065F

	/* No HTTP header received from the client, abort processing */
	if (!(uip_newdata()))
    1b48:	21 ff       	sbrs	r18, 1
    1b4a:	f1 c0       	rjmp	.+482    	; 0x1d2e <HTTPServerApp_Callback+0x2e4>
	  return;

	char* RequestToken      = strtok(AppData, " ");
    1b4c:	63 e1       	ldi	r22, 0x13	; 19
    1b4e:	72 e0       	ldi	r23, 0x02	; 2
    1b50:	0e 94 99 3a 	call	0x7532	; 0x7532 <strtok>
    1b54:	8c 01       	movw	r16, r24
	char* RequestedFileName = strtok(NULL, " ");
    1b56:	63 e1       	ldi	r22, 0x13	; 19
    1b58:	72 e0       	ldi	r23, 0x02	; 2
    1b5a:	80 e0       	ldi	r24, 0x00	; 0
    1b5c:	90 e0       	ldi	r25, 0x00	; 0
    1b5e:	0e 94 99 3a 	call	0x7532	; 0x7532 <strtok>
    1b62:	7c 01       	movw	r14, r24

	/* Must be a GET request, abort otherwise */
	if (strcmp_P(RequestToken, PSTR("GET")) != 0)
    1b64:	6a e4       	ldi	r22, 0x4A	; 74
    1b66:	71 e0       	ldi	r23, 0x01	; 1
    1b68:	c8 01       	movw	r24, r16
    1b6a:	0e 94 75 3a 	call	0x74ea	; 0x74ea <strcmp_P>
    1b6e:	89 2b       	or	r24, r25
    1b70:	21 f0       	breq	.+8      	; 0x1b7a <HTTPServerApp_Callback+0x130>
	{
		uip_abort();
    1b72:	80 e2       	ldi	r24, 0x20	; 32
    1b74:	80 93 5b 06 	sts	0x065B, r24
    1b78:	da c0       	rjmp	.+436    	; 0x1d2e <HTTPServerApp_Callback+0x2e4>
		return;
	}

	/* Copy over the requested filename */
	strlcpy(AppState->HTTPServer.FileName, &RequestedFileName[1], sizeof(AppState->HTTPServer.FileName));
    1b7a:	8e 01       	movw	r16, r28
    1b7c:	02 5e       	subi	r16, 0xE2	; 226
    1b7e:	1f 4f       	sbci	r17, 0xFF	; 255
    1b80:	b7 01       	movw	r22, r14
    1b82:	6f 5f       	subi	r22, 0xFF	; 255
    1b84:	7f 4f       	sbci	r23, 0xFF	; 255
    1b86:	42 e3       	ldi	r20, 0x32	; 50
    1b88:	50 e0       	ldi	r21, 0x00	; 0
    1b8a:	c8 01       	movw	r24, r16
    1b8c:	0e 94 cb 3a 	call	0x7596	; 0x7596 <strlcpy>

	/* Determine the length of the URI so that it can be checked to see if it is a directory */
	uint8_t FileNameLen = strlen(AppState->HTTPServer.FileName);
    1b90:	f8 01       	movw	r30, r16
    1b92:	01 90       	ld	r0, Z+
    1b94:	00 20       	and	r0, r0
    1b96:	e9 f7       	brne	.-6      	; 0x1b92 <HTTPServerApp_Callback+0x148>
    1b98:	31 97       	sbiw	r30, 0x01	; 1
    1b9a:	e0 1b       	sub	r30, r16
    1b9c:	f1 0b       	sbc	r31, r17
    1b9e:	8e 2f       	mov	r24, r30
    1ba0:	ff 27       	eor	r31, r31

	/* If the URI is a directory, append the default filename */
	if ((AppState->HTTPServer.FileName[FileNameLen - 1] == '/') || !(FileNameLen))
    1ba2:	de 01       	movw	r26, r28
    1ba4:	ae 0f       	add	r26, r30
    1ba6:	bf 1f       	adc	r27, r31
    1ba8:	5d 96       	adiw	r26, 0x1d	; 29
    1baa:	9c 91       	ld	r25, X
    1bac:	9e 01       	movw	r18, r28
    1bae:	24 5e       	subi	r18, 0xE4	; 228
    1bb0:	3f 4f       	sbci	r19, 0xFF	; 255
    1bb2:	79 01       	movw	r14, r18
    1bb4:	9f 32       	cpi	r25, 0x2F	; 47
    1bb6:	11 f0       	breq	.+4      	; 0x1bbc <HTTPServerApp_Callback+0x172>
    1bb8:	81 11       	cpse	r24, r1
    1bba:	0c c0       	rjmp	.+24     	; 0x1bd4 <HTTPServerApp_Callback+0x18a>
	{
		strlcpy_P(&AppState->HTTPServer.FileName[FileNameLen], DefaultDirFileName,
    1bbc:	42 e3       	ldi	r20, 0x32	; 50
    1bbe:	50 e0       	ldi	r21, 0x00	; 0
    1bc0:	4e 1b       	sub	r20, r30
    1bc2:	5f 0b       	sbc	r21, r31
    1bc4:	cf 01       	movw	r24, r30
    1bc6:	02 96       	adiw	r24, 0x02	; 2
    1bc8:	69 e5       	ldi	r22, 0x59	; 89
    1bca:	71 e0       	ldi	r23, 0x01	; 1
    1bcc:	8e 0d       	add	r24, r14
    1bce:	9f 1d       	adc	r25, r15
    1bd0:	0e 94 85 3a 	call	0x750a	; 0x750a <strlcpy_P>
		          (sizeof(AppState->HTTPServer.FileName) - FileNameLen));
	}

	/* Try to open the file from the Dataflash disk */
	AppState->HTTPServer.FileOpen     = (f_open(&AppState->HTTPServer.FileHandle, AppState->HTTPServer.FileName,
    1bd4:	41 e0       	ldi	r20, 0x01	; 1
    1bd6:	b8 01       	movw	r22, r16
    1bd8:	c7 01       	movw	r24, r14
    1bda:	c4 96       	adiw	r24, 0x34	; 52
    1bdc:	0e 94 09 1e 	call	0x3c12	; 0x3c12 <f_open>
    1be0:	fe 01       	movw	r30, r28
    1be2:	e6 59       	subi	r30, 0x96	; 150
    1be4:	ff 4f       	sbci	r31, 0xFF	; 255
	                                            (FA_OPEN_EXISTING | FA_READ)) == FR_OK);
    1be6:	91 e0       	ldi	r25, 0x01	; 1
    1be8:	81 11       	cpse	r24, r1
    1bea:	90 e0       	ldi	r25, 0x00	; 0
		strlcpy_P(&AppState->HTTPServer.FileName[FileNameLen], DefaultDirFileName,
		          (sizeof(AppState->HTTPServer.FileName) - FileNameLen));
	}

	/* Try to open the file from the Dataflash disk */
	AppState->HTTPServer.FileOpen     = (f_open(&AppState->HTTPServer.FileHandle, AppState->HTTPServer.FileName,
    1bec:	90 83       	st	Z, r25
	                                            (FA_OPEN_EXISTING | FA_READ)) == FR_OK);

	/* Lock to the SendResponseHeader state until connection terminated */
	AppState->HTTPServer.CurrentState = WEBSERVER_STATE_SendResponseHeader;
    1bee:	81 e0       	ldi	r24, 0x01	; 1
    1bf0:	9c c0       	rjmp	.+312    	; 0x1d2a <HTTPServerApp_Callback+0x2e0>
/** HTTP Server State handler for the HTTP Response Header Send state. This state manages the transmission of
 *  the HTTP response header to the receiving HTTP client.
 */
static void HTTPServerApp_SendResponseHeader(void)
{
	uip_tcp_appstate_t* const AppState    = &uip_conn->appstate;
    1bf2:	00 91 60 06 	lds	r16, 0x0660
    1bf6:	10 91 61 06 	lds	r17, 0x0661
	char*               const AppData     = (char*)uip_appdata;
    1bfa:	c0 91 5e 06 	lds	r28, 0x065E
    1bfe:	d0 91 5f 06 	lds	r29, 0x065F

	char* Extension     = strpbrk(AppState->HTTPServer.FileName, ".");
    1c02:	78 01       	movw	r14, r16
    1c04:	3e e1       	ldi	r19, 0x1E	; 30
    1c06:	e3 0e       	add	r14, r19
    1c08:	f1 1c       	adc	r15, r1
    1c0a:	6e e2       	ldi	r22, 0x2E	; 46
    1c0c:	70 e0       	ldi	r23, 0x00	; 0
    1c0e:	c7 01       	movw	r24, r14
    1c10:	0e 94 b7 3a 	call	0x756e	; 0x756e <strchr>
    1c14:	5c 01       	movw	r10, r24
	bool  FoundMIMEType = false;

	/* If the file isn't already open, it wasn't found - send back a 404 error response and abort */
	if (!(AppState->HTTPServer.FileOpen))
    1c16:	f8 01       	movw	r30, r16
    1c18:	e6 59       	subi	r30, 0x96	; 150
    1c1a:	ff 4f       	sbci	r31, 0xFF	; 255
    1c1c:	80 81       	ld	r24, Z
    1c1e:	81 11       	cpse	r24, r1
    1c20:	17 c0       	rjmp	.+46     	; 0x1c50 <HTTPServerApp_Callback+0x206>
	{
		/* Copy over the HTTP 404 response header and send it to the receiving client */
		strcpy_P(AppData, HTTP404Header);
    1c22:	63 e6       	ldi	r22, 0x63	; 99
    1c24:	71 e0       	ldi	r23, 0x01	; 1
    1c26:	ce 01       	movw	r24, r28
    1c28:	0e 94 7e 3a 	call	0x74fc	; 0x74fc <strcpy_P>
		strcat(AppData, AppState->HTTPServer.FileName);
    1c2c:	b7 01       	movw	r22, r14
    1c2e:	ce 01       	movw	r24, r28
    1c30:	0e 94 ac 3a 	call	0x7558	; 0x7558 <strcat>
		uip_send(AppData, strlen(AppData));
    1c34:	fe 01       	movw	r30, r28
    1c36:	01 90       	ld	r0, Z+
    1c38:	00 20       	and	r0, r0
    1c3a:	e9 f7       	brne	.-6      	; 0x1c36 <HTTPServerApp_Callback+0x1ec>
    1c3c:	bf 01       	movw	r22, r30
    1c3e:	61 50       	subi	r22, 0x01	; 1
    1c40:	71 09       	sbc	r23, r1
    1c42:	6c 1b       	sub	r22, r28
    1c44:	7d 0b       	sbc	r23, r29
    1c46:	ce 01       	movw	r24, r28
    1c48:	0e 94 56 18 	call	0x30ac	; 0x30ac <uip_send>

		AppState->HTTPServer.NextState = WEBSERVER_STATE_Closing;
    1c4c:	83 e0       	ldi	r24, 0x03	; 3
    1c4e:	47 c0       	rjmp	.+142    	; 0x1cde <HTTPServerApp_Callback+0x294>
		return;
	}

	/* Copy over the HTTP 200 response header and send it to the receiving client */
	strcpy_P(AppData, HTTP200Header);
    1c50:	6f ee       	ldi	r22, 0xEF	; 239
    1c52:	71 e0       	ldi	r23, 0x01	; 1
    1c54:	ce 01       	movw	r24, r28
    1c56:	0e 94 7e 3a 	call	0x74fc	; 0x74fc <strcpy_P>

	/* Check to see if a MIME type for the requested file's extension was found */
	if (Extension != NULL)
    1c5a:	a1 14       	cp	r10, r1
    1c5c:	b1 04       	cpc	r11, r1
    1c5e:	41 f1       	breq	.+80     	; 0x1cb0 <HTTPServerApp_Callback+0x266>
    1c60:	92 eb       	ldi	r25, 0xB2	; 178
    1c62:	c9 2e       	mov	r12, r25
    1c64:	91 e0       	ldi	r25, 0x01	; 1
    1c66:	d9 2e       	mov	r13, r25
    1c68:	e1 2c       	mov	r14, r1
    1c6a:	f1 2c       	mov	r15, r1
	{
		/* Look through the MIME type list, copy over the required MIME type if found */
		for (uint8_t i = 0; i < (sizeof(MIMETypes) / sizeof(MIMETypes[0])); i++)
		{
			if (strcmp(&Extension[1], MIMETypes[i].Extension) == 0)
    1c6c:	ff ef       	ldi	r31, 0xFF	; 255
    1c6e:	af 1a       	sub	r10, r31
    1c70:	bf 0a       	sbc	r11, r31
    1c72:	f6 01       	movw	r30, r12
    1c74:	60 81       	ld	r22, Z
    1c76:	71 81       	ldd	r23, Z+1	; 0x01
    1c78:	c5 01       	movw	r24, r10
    1c7a:	0e 94 c2 3a 	call	0x7584	; 0x7584 <strcmp>
    1c7e:	89 2b       	or	r24, r25
    1c80:	69 f4       	brne	.+26     	; 0x1c9c <HTTPServerApp_Callback+0x252>
			{
				strcat(AppData, MIMETypes[i].MIMEType);
    1c82:	f7 01       	movw	r30, r14
    1c84:	ee 0f       	add	r30, r30
    1c86:	ff 1f       	adc	r31, r31
    1c88:	ee 0f       	add	r30, r30
    1c8a:	ff 1f       	adc	r31, r31
    1c8c:	ee 54       	subi	r30, 0x4E	; 78
    1c8e:	fe 4f       	sbci	r31, 0xFE	; 254
    1c90:	62 81       	ldd	r22, Z+2	; 0x02
    1c92:	73 81       	ldd	r23, Z+3	; 0x03
    1c94:	ce 01       	movw	r24, r28
    1c96:	0e 94 ac 3a 	call	0x7558	; 0x7558 <strcat>
    1c9a:	0f c0       	rjmp	.+30     	; 0x1cba <HTTPServerApp_Callback+0x270>
    1c9c:	ff ef       	ldi	r31, 0xFF	; 255
    1c9e:	ef 1a       	sub	r14, r31
    1ca0:	ff 0a       	sbc	r15, r31
    1ca2:	24 e0       	ldi	r18, 0x04	; 4
    1ca4:	c2 0e       	add	r12, r18
    1ca6:	d1 1c       	adc	r13, r1

	/* Check to see if a MIME type for the requested file's extension was found */
	if (Extension != NULL)
	{
		/* Look through the MIME type list, copy over the required MIME type if found */
		for (uint8_t i = 0; i < (sizeof(MIMETypes) / sizeof(MIMETypes[0])); i++)
    1ca8:	3a e0       	ldi	r19, 0x0A	; 10
    1caa:	e3 16       	cp	r14, r19
    1cac:	f1 04       	cpc	r15, r1
    1cae:	09 f7       	brne	.-62     	; 0x1c72 <HTTPServerApp_Callback+0x228>

	/* Check if a MIME type was found and copied to the output buffer */
	if (!(FoundMIMEType))
	{
		/* MIME type not found - copy over the default MIME type */
		strcat_P(AppData, DefaultMIMEType);
    1cb0:	6e e4       	ldi	r22, 0x4E	; 78
    1cb2:	71 e0       	ldi	r23, 0x01	; 1
    1cb4:	ce 01       	movw	r24, r28
    1cb6:	0e 94 6a 3a 	call	0x74d4	; 0x74d4 <strcat_P>
	}

	/* Add the end-of-line terminator and end-of-headers terminator after the MIME type */
	strcat_P(AppData, PSTR("\r\n\r\n"));
    1cba:	65 e4       	ldi	r22, 0x45	; 69
    1cbc:	71 e0       	ldi	r23, 0x01	; 1
    1cbe:	ce 01       	movw	r24, r28
    1cc0:	0e 94 6a 3a 	call	0x74d4	; 0x74d4 <strcat_P>

	/* Send the MIME header to the receiving client */
	uip_send(AppData, strlen(AppData));
    1cc4:	fe 01       	movw	r30, r28
    1cc6:	01 90       	ld	r0, Z+
    1cc8:	00 20       	and	r0, r0
    1cca:	e9 f7       	brne	.-6      	; 0x1cc6 <HTTPServerApp_Callback+0x27c>
    1ccc:	bf 01       	movw	r22, r30
    1cce:	61 50       	subi	r22, 0x01	; 1
    1cd0:	71 09       	sbc	r23, r1
    1cd2:	6c 1b       	sub	r22, r28
    1cd4:	7d 0b       	sbc	r23, r29
    1cd6:	ce 01       	movw	r24, r28
    1cd8:	0e 94 56 18 	call	0x30ac	; 0x30ac <uip_send>

	/* When the MIME header is ACKed, progress to the data send stage */
	AppState->HTTPServer.NextState = WEBSERVER_STATE_SendData;
    1cdc:	82 e0       	ldi	r24, 0x02	; 2
    1cde:	f8 01       	movw	r30, r16
    1ce0:	85 8f       	std	Z+29, r24	; 0x1d
    1ce2:	25 c0       	rjmp	.+74     	; 0x1d2e <HTTPServerApp_Callback+0x2e4>
/** HTTP Server State handler for the Data Send state. This state manages the transmission of file chunks
 *  to the receiving HTTP client.
 */
static void HTTPServerApp_SendData(void)
{
	uip_tcp_appstate_t* const AppState    = &uip_conn->appstate;
    1ce4:	c0 91 60 06 	lds	r28, 0x0660
    1ce8:	d0 91 61 06 	lds	r29, 0x0661
	char*               const AppData     = (char*)uip_appdata;
    1cec:	c0 90 5e 06 	lds	r12, 0x065E
    1cf0:	d0 90 5f 06 	lds	r13, 0x065F

	/* Get the maximum segment size for the current packet */
	uint16_t MaxChunkSize = uip_mss();
    1cf4:	ea 88       	ldd	r14, Y+18	; 0x12
    1cf6:	fb 88       	ldd	r15, Y+19	; 0x13

	/* Read the next chunk of data from the open file */
	f_read(&AppState->HTTPServer.FileHandle, AppData, MaxChunkSize, &AppState->HTTPServer.SentChunkSize);
    1cf8:	8e 01       	movw	r16, r28
    1cfa:	01 59       	subi	r16, 0x91	; 145
    1cfc:	1f 4f       	sbci	r17, 0xFF	; 255
    1cfe:	98 01       	movw	r18, r16
    1d00:	a7 01       	movw	r20, r14
    1d02:	b6 01       	movw	r22, r12
    1d04:	ce 01       	movw	r24, r28
    1d06:	80 5b       	subi	r24, 0xB0	; 176
    1d08:	9f 4f       	sbci	r25, 0xFF	; 255
    1d0a:	0e 94 fd 21 	call	0x43fa	; 0x43fa <f_read>

	/* Send the next file chunk to the receiving client */
	uip_send(AppData, AppState->HTTPServer.SentChunkSize);
    1d0e:	f8 01       	movw	r30, r16
    1d10:	60 81       	ld	r22, Z
    1d12:	71 81       	ldd	r23, Z+1	; 0x01
    1d14:	c6 01       	movw	r24, r12
    1d16:	0e 94 56 18 	call	0x30ac	; 0x30ac <uip_send>

	/* Check if we are at the last chunk of the file, if so next ACK should close the connection */
	if (MaxChunkSize != AppState->HTTPServer.SentChunkSize)
    1d1a:	f8 01       	movw	r30, r16
    1d1c:	80 81       	ld	r24, Z
    1d1e:	91 81       	ldd	r25, Z+1	; 0x01
    1d20:	e8 16       	cp	r14, r24
    1d22:	f9 06       	cpc	r15, r25
    1d24:	21 f0       	breq	.+8      	; 0x1d2e <HTTPServerApp_Callback+0x2e4>
	  AppState->HTTPServer.NextState = WEBSERVER_STATE_Closing;
    1d26:	83 e0       	ldi	r24, 0x03	; 3
    1d28:	01 c0       	rjmp	.+2      	; 0x1d2c <HTTPServerApp_Callback+0x2e2>
				AppState->HTTPServer.FileOpen = false;

				/* If connection is not already closed, close it */
				uip_close();

				AppState->HTTPServer.CurrentState = WEBSERVER_STATE_Closed;
    1d2a:	8c 8f       	std	Y+28, r24	; 0x1c
				AppState->HTTPServer.NextState    = WEBSERVER_STATE_Closed;
    1d2c:	8d 8f       	std	Y+29, r24	; 0x1d
				break;
		}
	}
}
    1d2e:	df 91       	pop	r29
    1d30:	cf 91       	pop	r28
    1d32:	1f 91       	pop	r17
    1d34:	0f 91       	pop	r16
    1d36:	ff 90       	pop	r15
    1d38:	ef 90       	pop	r14
    1d3a:	df 90       	pop	r13
    1d3c:	cf 90       	pop	r12
    1d3e:	bf 90       	pop	r11
    1d40:	af 90       	pop	r10
    1d42:	08 95       	ret

00001d44 <TELNETServerApp_Init>:

/** Initialization function for the simple TELNET webserver. */
void TELNETServerApp_Init(void)
{
	/* Listen on port 23 for TELNET connections from hosts */
	uip_listen(HTONS(TELNET_SERVER_PORT));
    1d44:	80 e0       	ldi	r24, 0x00	; 0
    1d46:	97 e1       	ldi	r25, 0x17	; 23
    1d48:	1b c2       	rjmp	.+1078   	; 0x2180 <uip_listen>

00001d4a <TELNETServerApp_Callback>:
    1d4a:	6f 92       	push	r6

/** uIP stack application callback for the TELNET server. This function must be called each time the
 *  TCP/IP stack needs a TCP packet to be processed.
 */
void TELNETServerApp_Callback(void)
{
    1d4c:	7f 92       	push	r7
    1d4e:	9f 92       	push	r9
    1d50:	af 92       	push	r10
    1d52:	bf 92       	push	r11
    1d54:	cf 92       	push	r12
    1d56:	df 92       	push	r13
    1d58:	ef 92       	push	r14
    1d5a:	ff 92       	push	r15
    1d5c:	0f 93       	push	r16
    1d5e:	1f 93       	push	r17
    1d60:	cf 93       	push	r28
    1d62:	df 93       	push	r29
    1d64:	00 d0       	rcall	.+0      	; 0x1d66 <TELNETServerApp_Callback+0x1c>
    1d66:	cd b7       	in	r28, 0x3d	; 61
    1d68:	de b7       	in	r29, 0x3e	; 62
	uip_tcp_appstate_t* const AppState   = &uip_conn->appstate;
    1d6a:	00 91 60 06 	lds	r16, 0x0660
    1d6e:	10 91 61 06 	lds	r17, 0x0661
	char*               const AppData    = (char*)uip_appdata;
    1d72:	60 90 5e 06 	lds	r6, 0x065E
    1d76:	70 90 5f 06 	lds	r7, 0x065F

	if (uip_connected())
    1d7a:	80 91 5b 06 	lds	r24, 0x065B
    1d7e:	86 ff       	sbrs	r24, 6
    1d80:	03 c0       	rjmp	.+6      	; 0x1d88 <TELNETServerApp_Callback+0x3e>
	{
		/* New connection - initialize connection state values */
		AppState->TELNETServer.CurrentState = TELNET_STATE_SendHeader;
    1d82:	d8 01       	movw	r26, r16
    1d84:	5c 96       	adiw	r26, 0x1c	; 28
    1d86:	1c 92       	st	X, r1
	}

	if (uip_acked())
    1d88:	80 ff       	sbrs	r24, 0
    1d8a:	03 c0       	rjmp	.+6      	; 0x1d92 <TELNETServerApp_Callback+0x48>
	{
		/* Progress to the next state once the current state's data has been ACKed */
		AppState->TELNETServer.CurrentState = AppState->TELNETServer.NextState;
    1d8c:	f8 01       	movw	r30, r16
    1d8e:	95 8d       	ldd	r25, Z+29	; 0x1d
    1d90:	94 8f       	std	Z+28, r25	; 0x1c
	}

	if (uip_rexmit() || uip_acked() || uip_newdata() || uip_connected() || uip_poll())
    1d92:	82 fd       	sbrc	r24, 2
    1d94:	06 c0       	rjmp	.+12     	; 0x1da2 <TELNETServerApp_Callback+0x58>
    1d96:	98 2f       	mov	r25, r24
    1d98:	93 70       	andi	r25, 0x03	; 3
    1d9a:	19 f4       	brne	.+6      	; 0x1da2 <TELNETServerApp_Callback+0x58>
    1d9c:	88 74       	andi	r24, 0x48	; 72
    1d9e:	09 f4       	brne	.+2      	; 0x1da2 <TELNETServerApp_Callback+0x58>
    1da0:	c0 c0       	rjmp	.+384    	; 0x1f22 <TELNETServerApp_Callback+0x1d8>
	{
		switch (AppState->TELNETServer.CurrentState)
    1da2:	d8 01       	movw	r26, r16
    1da4:	5c 96       	adiw	r26, 0x1c	; 28
    1da6:	8c 91       	ld	r24, X
    1da8:	81 30       	cpi	r24, 0x01	; 1
    1daa:	c9 f0       	breq	.+50     	; 0x1dde <TELNETServerApp_Callback+0x94>
    1dac:	28 f0       	brcs	.+10     	; 0x1db8 <TELNETServerApp_Callback+0x6e>
    1dae:	82 30       	cpi	r24, 0x02	; 2
    1db0:	61 f1       	breq	.+88     	; 0x1e0a <TELNETServerApp_Callback+0xc0>
    1db2:	83 30       	cpi	r24, 0x03	; 3
    1db4:	d9 f1       	breq	.+118    	; 0x1e2c <TELNETServerApp_Callback+0xe2>
    1db6:	b5 c0       	rjmp	.+362    	; 0x1f22 <TELNETServerApp_Callback+0x1d8>
		{
			case TELNET_STATE_SendHeader:
				/* Copy over and send the TELNET welcome message upon first connection */
				strcpy_P(AppData, WelcomeHeader);
    1db8:	68 e1       	ldi	r22, 0x18	; 24
    1dba:	73 e0       	ldi	r23, 0x03	; 3
    1dbc:	c3 01       	movw	r24, r6
    1dbe:	0e 94 7e 3a 	call	0x74fc	; 0x74fc <strcpy_P>
				uip_send(AppData, strlen(AppData));
    1dc2:	f3 01       	movw	r30, r6
    1dc4:	01 90       	ld	r0, Z+
    1dc6:	00 20       	and	r0, r0
    1dc8:	e9 f7       	brne	.-6      	; 0x1dc4 <TELNETServerApp_Callback+0x7a>
    1dca:	bf 01       	movw	r22, r30
    1dcc:	61 50       	subi	r22, 0x01	; 1
    1dce:	71 09       	sbc	r23, r1
    1dd0:	66 19       	sub	r22, r6
    1dd2:	77 09       	sbc	r23, r7
    1dd4:	c3 01       	movw	r24, r6
    1dd6:	0e 94 56 18 	call	0x30ac	; 0x30ac <uip_send>

				AppState->TELNETServer.NextState = TELNET_STATE_SendMenu;
    1dda:	81 e0       	ldi	r24, 0x01	; 1
    1ddc:	12 c0       	rjmp	.+36     	; 0x1e02 <TELNETServerApp_Callback+0xb8>
				break;
			case TELNET_STATE_SendMenu:
				/* Copy over and send the TELNET menu to the client */
				strcpy_P(AppData, TELNETMenu);
    1dde:	63 eb       	ldi	r22, 0xB3	; 179
    1de0:	72 e0       	ldi	r23, 0x02	; 2
    1de2:	c3 01       	movw	r24, r6
    1de4:	0e 94 7e 3a 	call	0x74fc	; 0x74fc <strcpy_P>
				uip_send(AppData, strlen(AppData));
    1de8:	f3 01       	movw	r30, r6
    1dea:	01 90       	ld	r0, Z+
    1dec:	00 20       	and	r0, r0
    1dee:	e9 f7       	brne	.-6      	; 0x1dea <TELNETServerApp_Callback+0xa0>
    1df0:	bf 01       	movw	r22, r30
    1df2:	61 50       	subi	r22, 0x01	; 1
    1df4:	71 09       	sbc	r23, r1
    1df6:	66 19       	sub	r22, r6
    1df8:	77 09       	sbc	r23, r7
    1dfa:	c3 01       	movw	r24, r6
    1dfc:	0e 94 56 18 	call	0x30ac	; 0x30ac <uip_send>

				AppState->TELNETServer.NextState = TELNET_STATE_GetCommand;
    1e00:	82 e0       	ldi	r24, 0x02	; 2
    1e02:	d8 01       	movw	r26, r16
    1e04:	5d 96       	adiw	r26, 0x1d	; 29
    1e06:	8c 93       	st	X, r24
				break;
    1e08:	8c c0       	rjmp	.+280    	; 0x1f22 <TELNETServerApp_Callback+0x1d8>
			case TELNET_STATE_GetCommand:
				if (!(uip_datalen()))
    1e0a:	80 91 53 06 	lds	r24, 0x0653
    1e0e:	90 91 54 06 	lds	r25, 0x0654
    1e12:	89 2b       	or	r24, r25
    1e14:	09 f4       	brne	.+2      	; 0x1e18 <TELNETServerApp_Callback+0xce>
    1e16:	85 c0       	rjmp	.+266    	; 0x1f22 <TELNETServerApp_Callback+0x1d8>
				  break;

				/* Save the issued command for later processing */
				AppState->TELNETServer.IssuedCommand = AppData[0];
    1e18:	f3 01       	movw	r30, r6
    1e1a:	80 81       	ld	r24, Z
    1e1c:	d8 01       	movw	r26, r16
    1e1e:	5e 96       	adiw	r26, 0x1e	; 30
    1e20:	8c 93       	st	X, r24
    1e22:	5e 97       	sbiw	r26, 0x1e	; 30

				AppState->TELNETServer.CurrentState  = TELNET_STATE_SendResponse;
    1e24:	83 e0       	ldi	r24, 0x03	; 3
    1e26:	5c 96       	adiw	r26, 0x1c	; 28
    1e28:	8c 93       	st	X, r24
				break;
    1e2a:	7b c0       	rjmp	.+246    	; 0x1f22 <TELNETServerApp_Callback+0x1d8>
			case TELNET_STATE_SendResponse:
				/* Determine which command was issued, perform command processing */
				switch (AppState->TELNETServer.IssuedCommand)
    1e2c:	f8 01       	movw	r30, r16
    1e2e:	86 8d       	ldd	r24, Z+30	; 0x1e
    1e30:	83 36       	cpi	r24, 0x63	; 99
    1e32:	09 f0       	breq	.+2      	; 0x1e36 <TELNETServerApp_Callback+0xec>
    1e34:	62 c0       	rjmp	.+196    	; 0x1efa <TELNETServerApp_Callback+0x1b0>
/** Sends a list of active TCP connections to the TELNET client. */
static void TELNETServerApp_DisplayTCPConnections(void)
{
	char* const AppData    = (char*)uip_appdata;

	strcpy_P(AppData, CurrentConnectionsHeader);
    1e36:	62 e9       	ldi	r22, 0x92	; 146
    1e38:	72 e0       	ldi	r23, 0x02	; 2
    1e3a:	c3 01       	movw	r24, r6
    1e3c:	0e 94 7e 3a 	call	0x74fc	; 0x74fc <strcpy_P>

	uint16_t ResponseLen     = strlen(AppData);
    1e40:	d3 01       	movw	r26, r6
    1e42:	0d 90       	ld	r0, X+
    1e44:	00 20       	and	r0, r0
    1e46:	e9 f7       	brne	.-6      	; 0x1e42 <TELNETServerApp_Callback+0xf8>
    1e48:	bd 01       	movw	r22, r26
    1e4a:	61 50       	subi	r22, 0x01	; 1
    1e4c:	71 09       	sbc	r23, r1
    1e4e:	66 19       	sub	r22, r6
    1e50:	77 09       	sbc	r23, r7
    1e52:	82 e6       	ldi	r24, 0x62	; 98
    1e54:	e8 2e       	mov	r14, r24
    1e56:	86 e0       	ldi	r24, 0x06	; 6
    1e58:	f8 2e       	mov	r15, r24
    1e5a:	c1 2c       	mov	r12, r1
    1e5c:	d1 2c       	mov	r13, r1
	uint8_t  ActiveConnCount = 0;
    1e5e:	91 2c       	mov	r9, r1

		/* If the connection is not closed, it is active and must be added to the out buffer */
		if (CurrConnection->tcpstateflags != UIP_CLOSED)
		{
			/* Add the current connection's details to the out buffer */
			ResponseLen += sprintf_P(&AppData[ResponseLen], PSTR("%u) %d.%d.%d.%d (Local Port %u <=> Remote Port %u)\r\n"),
    1e60:	9a e4       	ldi	r25, 0x4A	; 74
    1e62:	a9 2e       	mov	r10, r25
    1e64:	92 e0       	ldi	r25, 0x02	; 2
    1e66:	b9 2e       	mov	r11, r25
    1e68:	f6 01       	movw	r30, r12
    1e6a:	ee 59       	subi	r30, 0x9E	; 158
    1e6c:	f9 4f       	sbci	r31, 0xF9	; 249
	for (uint8_t i = 0; i < UIP_CONNS; i++)
	{
		struct uip_conn* CurrConnection = &uip_conns[i];

		/* If the connection is not closed, it is active and must be added to the out buffer */
		if (CurrConnection->tcpstateflags != UIP_CLOSED)
    1e6e:	81 8d       	ldd	r24, Z+25	; 0x19
    1e70:	88 23       	and	r24, r24
    1e72:	b1 f1       	breq	.+108    	; 0x1ee0 <TELNETServerApp_Callback+0x196>
		{
			/* Add the current connection's details to the out buffer */
			ResponseLen += sprintf_P(&AppData[ResponseLen], PSTR("%u) %d.%d.%d.%d (Local Port %u <=> Remote Port %u)\r\n"),
    1e74:	93 94       	inc	r9
    1e76:	d7 01       	movw	r26, r14
    1e78:	16 96       	adiw	r26, 0x06	; 6
    1e7a:	8d 91       	ld	r24, X+
    1e7c:	9c 91       	ld	r25, X
    1e7e:	17 97       	sbiw	r26, 0x07	; 7
    1e80:	98 27       	eor	r25, r24
    1e82:	89 27       	eor	r24, r25
    1e84:	98 27       	eor	r25, r24
    1e86:	9f 93       	push	r25
    1e88:	8f 93       	push	r24
    1e8a:	14 96       	adiw	r26, 0x04	; 4
    1e8c:	8d 91       	ld	r24, X+
    1e8e:	9c 91       	ld	r25, X
    1e90:	15 97       	sbiw	r26, 0x05	; 5
    1e92:	98 27       	eor	r25, r24
    1e94:	89 27       	eor	r24, r25
    1e96:	98 27       	eor	r25, r24
    1e98:	9f 93       	push	r25
    1e9a:	8f 93       	push	r24
    1e9c:	83 81       	ldd	r24, Z+3	; 0x03
    1e9e:	1f 92       	push	r1
    1ea0:	8f 93       	push	r24
    1ea2:	82 81       	ldd	r24, Z+2	; 0x02
    1ea4:	1f 92       	push	r1
    1ea6:	8f 93       	push	r24
    1ea8:	81 81       	ldd	r24, Z+1	; 0x01
    1eaa:	1f 92       	push	r1
    1eac:	8f 93       	push	r24
    1eae:	8c 91       	ld	r24, X
    1eb0:	1f 92       	push	r1
    1eb2:	8f 93       	push	r24
    1eb4:	1f 92       	push	r1
    1eb6:	9f 92       	push	r9
    1eb8:	bf 92       	push	r11
    1eba:	af 92       	push	r10
    1ebc:	c3 01       	movw	r24, r6
    1ebe:	86 0f       	add	r24, r22
    1ec0:	97 1f       	adc	r25, r23
    1ec2:	9f 93       	push	r25
    1ec4:	8f 93       	push	r24
    1ec6:	69 83       	std	Y+1, r22	; 0x01
    1ec8:	7a 83       	std	Y+2, r23	; 0x02
    1eca:	0e 94 06 3b 	call	0x760c	; 0x760c <sprintf_P>
    1ece:	69 81       	ldd	r22, Y+1	; 0x01
    1ed0:	7a 81       	ldd	r23, Y+2	; 0x02
    1ed2:	68 0f       	add	r22, r24
    1ed4:	79 1f       	adc	r23, r25
    1ed6:	0f b6       	in	r0, 0x3f	; 63
    1ed8:	f8 94       	cli
    1eda:	de bf       	out	0x3e, r29	; 62
    1edc:	0f be       	out	0x3f, r0	; 63
    1ede:	cd bf       	out	0x3d, r28	; 61
    1ee0:	f1 e7       	ldi	r31, 0x71	; 113
    1ee2:	cf 0e       	add	r12, r31
    1ee4:	d1 1c       	adc	r13, r1
    1ee6:	81 e7       	ldi	r24, 0x71	; 113
    1ee8:	e8 0e       	add	r14, r24
    1eea:	f1 1c       	adc	r15, r1

	uint16_t ResponseLen     = strlen(AppData);
	uint8_t  ActiveConnCount = 0;

	/* Loop through the complete uIP TCP connections list, looking for active connections */
	for (uint8_t i = 0; i < UIP_CONNS; i++)
    1eec:	93 e5       	ldi	r25, 0x53	; 83
    1eee:	c9 16       	cp	r12, r25
    1ef0:	91 e0       	ldi	r25, 0x01	; 1
    1ef2:	d9 06       	cpc	r13, r25
    1ef4:	09 f0       	breq	.+2      	; 0x1ef8 <TELNETServerApp_Callback+0x1ae>
    1ef6:	b8 cf       	rjmp	.-144    	; 0x1e68 <TELNETServerApp_Callback+0x11e>
    1ef8:	0e c0       	rjmp	.+28     	; 0x1f16 <TELNETServerApp_Callback+0x1cc>
				{
					case 'c':
						TELNETServerApp_DisplayTCPConnections();
						break;
					default:
						strcpy_P(AppData, PSTR("Invalid Command.\r\n"));
    1efa:	6f e7       	ldi	r22, 0x7F	; 127
    1efc:	72 e0       	ldi	r23, 0x02	; 2
    1efe:	c3 01       	movw	r24, r6
    1f00:	0e 94 7e 3a 	call	0x74fc	; 0x74fc <strcpy_P>
						uip_send(AppData, strlen(AppData));
    1f04:	d3 01       	movw	r26, r6
    1f06:	0d 90       	ld	r0, X+
    1f08:	00 20       	and	r0, r0
    1f0a:	e9 f7       	brne	.-6      	; 0x1f06 <TELNETServerApp_Callback+0x1bc>
    1f0c:	bd 01       	movw	r22, r26
    1f0e:	61 50       	subi	r22, 0x01	; 1
    1f10:	71 09       	sbc	r23, r1
    1f12:	66 19       	sub	r22, r6
    1f14:	77 09       	sbc	r23, r7
    1f16:	c3 01       	movw	r24, r6
    1f18:	0e 94 56 18 	call	0x30ac	; 0x30ac <uip_send>
						break;
				}

				AppState->TELNETServer.NextState = TELNET_STATE_SendMenu;
    1f1c:	81 e0       	ldi	r24, 0x01	; 1
    1f1e:	f8 01       	movw	r30, r16
    1f20:	85 8f       	std	Z+29, r24	; 0x1d
				break;
		}
	}
}
    1f22:	0f 90       	pop	r0
    1f24:	0f 90       	pop	r0
    1f26:	df 91       	pop	r29
    1f28:	cf 91       	pop	r28
    1f2a:	1f 91       	pop	r17
    1f2c:	0f 91       	pop	r16
    1f2e:	ff 90       	pop	r15
    1f30:	ef 90       	pop	r14
    1f32:	df 90       	pop	r13
    1f34:	cf 90       	pop	r12
    1f36:	bf 90       	pop	r11
    1f38:	af 90       	pop	r10
    1f3a:	9f 90       	pop	r9
    1f3c:	7f 90       	pop	r7
    1f3e:	6f 90       	pop	r6
    1f40:	08 95       	ret

00001f42 <chksum>:

#if ! UIP_ARCH_CHKSUM
/*---------------------------------------------------------------------------*/
static u16_t
chksum(u16_t sum, const u8_t *data, u16_t len)
{
    1f42:	fb 01       	movw	r30, r22
  u16_t t;
  const u8_t *dataptr;
  const u8_t *last_byte;

  dataptr = data;
  last_byte = data + len - 1;
    1f44:	41 50       	subi	r20, 0x01	; 1
    1f46:	51 09       	sbc	r21, r1
    1f48:	46 0f       	add	r20, r22
    1f4a:	57 1f       	adc	r21, r23

  while(dataptr < last_byte) {	/* At least two more bytes */
    1f4c:	e4 17       	cp	r30, r20
    1f4e:	f5 07       	cpc	r31, r21
    1f50:	78 f4       	brcc	.+30     	; 0x1f70 <chksum+0x2e>
    t = (dataptr[0] << 8) + dataptr[1];
    1f52:	20 81       	ld	r18, Z
    1f54:	30 e0       	ldi	r19, 0x00	; 0
    1f56:	32 2f       	mov	r19, r18
    1f58:	22 27       	eor	r18, r18
    1f5a:	61 81       	ldd	r22, Z+1	; 0x01
    1f5c:	26 0f       	add	r18, r22
    1f5e:	31 1d       	adc	r19, r1
    sum += t;
    1f60:	82 0f       	add	r24, r18
    1f62:	93 1f       	adc	r25, r19
    if(sum < t) {
    1f64:	82 17       	cp	r24, r18
    1f66:	93 07       	cpc	r25, r19
    1f68:	08 f4       	brcc	.+2      	; 0x1f6c <chksum+0x2a>
      sum++;		/* carry */
    1f6a:	01 96       	adiw	r24, 0x01	; 1
    }
    dataptr += 2;
    1f6c:	32 96       	adiw	r30, 0x02	; 2
    1f6e:	ee cf       	rjmp	.-36     	; 0x1f4c <chksum+0xa>
  }

  if(dataptr == last_byte) {
    1f70:	e4 17       	cp	r30, r20
    1f72:	f5 07       	cpc	r31, r21
    1f74:	51 f4       	brne	.+20     	; 0x1f8a <chksum+0x48>
    t = (dataptr[0] << 8) + 0;
    1f76:	20 81       	ld	r18, Z
    1f78:	30 e0       	ldi	r19, 0x00	; 0
    1f7a:	32 2f       	mov	r19, r18
    1f7c:	22 27       	eor	r18, r18
    sum += t;
    1f7e:	82 0f       	add	r24, r18
    1f80:	93 1f       	adc	r25, r19
    if(sum < t) {
    1f82:	82 17       	cp	r24, r18
    1f84:	93 07       	cpc	r25, r19
    1f86:	08 f4       	brcc	.+2      	; 0x1f8a <chksum+0x48>
      sum++;		/* carry */
    1f88:	01 96       	adiw	r24, 0x01	; 1
    }
  }

  /* Return sum in host byte order. */
  return sum;
}
    1f8a:	08 95       	ret

00001f8c <uip_add32>:
#endif /* UIP_LOGGING == 1 */

#if ! UIP_ARCH_ADD32
void
uip_add32(u8_t *op32, u16_t op16)
{
    1f8c:	fc 01       	movw	r30, r24
  uip_acc32[3] = op32[3] + (op16 & 0xff);
    1f8e:	53 81       	ldd	r21, Z+3	; 0x03
    1f90:	56 0f       	add	r21, r22
    1f92:	50 93 5a 06 	sts	0x065A, r21
  uip_acc32[2] = op32[2] + (op16 >> 8);
    1f96:	87 2f       	mov	r24, r23
    1f98:	99 27       	eor	r25, r25
    1f9a:	42 81       	ldd	r20, Z+2	; 0x02
    1f9c:	48 0f       	add	r20, r24
    1f9e:	40 93 59 06 	sts	0x0659, r20
  uip_acc32[1] = op32[1];
    1fa2:	a1 81       	ldd	r26, Z+1	; 0x01
    1fa4:	a0 93 58 06 	sts	0x0658, r26
  uip_acc32[0] = op32[0];
    1fa8:	e0 81       	ld	r30, Z
    1faa:	e0 93 57 06 	sts	0x0657, r30

  if(uip_acc32[2] < (op16 >> 8)) {
    1fae:	24 2f       	mov	r18, r20
    1fb0:	30 e0       	ldi	r19, 0x00	; 0
    1fb2:	28 17       	cp	r18, r24
    1fb4:	39 07       	cpc	r19, r25
    1fb6:	48 f4       	brcc	.+18     	; 0x1fca <uip_add32+0x3e>
    ++uip_acc32[1];
    1fb8:	81 e0       	ldi	r24, 0x01	; 1
    1fba:	8a 0f       	add	r24, r26
    1fbc:	80 93 58 06 	sts	0x0658, r24
    if(uip_acc32[1] == 0) {
    1fc0:	81 11       	cpse	r24, r1
    1fc2:	03 c0       	rjmp	.+6      	; 0x1fca <uip_add32+0x3e>
      ++uip_acc32[0];
    1fc4:	ef 5f       	subi	r30, 0xFF	; 255
    1fc6:	e0 93 57 06 	sts	0x0657, r30
    }
  }


  if(uip_acc32[3] < (op16 & 0xff)) {
    1fca:	85 2f       	mov	r24, r21
    1fcc:	90 e0       	ldi	r25, 0x00	; 0
    1fce:	77 27       	eor	r23, r23
    1fd0:	86 17       	cp	r24, r22
    1fd2:	97 07       	cpc	r25, r23
    1fd4:	88 f4       	brcc	.+34     	; 0x1ff8 <uip_add32+0x6c>
    ++uip_acc32[2];
    1fd6:	4f 5f       	subi	r20, 0xFF	; 255
    1fd8:	40 93 59 06 	sts	0x0659, r20
    if(uip_acc32[2] == 0) {
    1fdc:	41 11       	cpse	r20, r1
    1fde:	0c c0       	rjmp	.+24     	; 0x1ff8 <uip_add32+0x6c>
      ++uip_acc32[1];
    1fe0:	80 91 58 06 	lds	r24, 0x0658
    1fe4:	8f 5f       	subi	r24, 0xFF	; 255
    1fe6:	80 93 58 06 	sts	0x0658, r24
      if(uip_acc32[1] == 0) {
    1fea:	81 11       	cpse	r24, r1
    1fec:	05 c0       	rjmp	.+10     	; 0x1ff8 <uip_add32+0x6c>
	++uip_acc32[0];
    1fee:	80 91 57 06 	lds	r24, 0x0657
    1ff2:	8f 5f       	subi	r24, 0xFF	; 255
    1ff4:	80 93 57 06 	sts	0x0657, r24
    1ff8:	08 95       	ret

00001ffa <uip_add_rcv_nxt>:
#endif /* UIP_REASSEMBLY */
/*---------------------------------------------------------------------------*/
static void
uip_add_rcv_nxt(u16_t n)
{
  uip_add32(uip_conn->rcv_nxt, n);
    1ffa:	20 91 60 06 	lds	r18, 0x0660
    1ffe:	30 91 61 06 	lds	r19, 0x0661
    2002:	bc 01       	movw	r22, r24
    2004:	c9 01       	movw	r24, r18
    2006:	08 96       	adiw	r24, 0x08	; 8
    2008:	c1 df       	rcall	.-126    	; 0x1f8c <uip_add32>
    200a:	e0 91 60 06 	lds	r30, 0x0660
  uip_conn->rcv_nxt[0] = uip_acc32[0];
    200e:	f0 91 61 06 	lds	r31, 0x0661
    2012:	80 91 57 06 	lds	r24, 0x0657
    2016:	80 87       	std	Z+8, r24	; 0x08
    2018:	80 91 58 06 	lds	r24, 0x0658
  uip_conn->rcv_nxt[1] = uip_acc32[1];
    201c:	81 87       	std	Z+9, r24	; 0x09
    201e:	80 91 59 06 	lds	r24, 0x0659
  uip_conn->rcv_nxt[2] = uip_acc32[2];
    2022:	82 87       	std	Z+10, r24	; 0x0a
    2024:	80 91 5a 06 	lds	r24, 0x065A
  uip_conn->rcv_nxt[3] = uip_acc32[3];
    2028:	83 87       	std	Z+11, r24	; 0x0b
    202a:	08 95       	ret

0000202c <uip_chksum>:
    202c:	ab 01       	movw	r20, r22
}
/*---------------------------------------------------------------------------*/
u16_t
uip_chksum(u16_t *data, u16_t len)
{
  return htons(chksum(0, (u8_t *)data, len));
    202e:	bc 01       	movw	r22, r24
    2030:	80 e0       	ldi	r24, 0x00	; 0
    2032:	90 e0       	ldi	r25, 0x00	; 0
    2034:	86 df       	rcall	.-244    	; 0x1f42 <chksum>
    2036:	98 27       	eor	r25, r24
}
    2038:	89 27       	eor	r24, r25
    203a:	98 27       	eor	r25, r24
    203c:	08 95       	ret

0000203e <uip_ipchksum>:
    203e:	44 e1       	ldi	r20, 0x14	; 20
u16_t
uip_ipchksum(void)
{
  u16_t sum;

  sum = chksum(0, &uip_buf[UIP_LLH_LEN], UIP_IPH_LEN);
    2040:	50 e0       	ldi	r21, 0x00	; 0
    2042:	69 ed       	ldi	r22, 0xD9	; 217
    2044:	77 e0       	ldi	r23, 0x07	; 7
    2046:	80 e0       	ldi	r24, 0x00	; 0
    2048:	90 e0       	ldi	r25, 0x00	; 0
    204a:	7b df       	rcall	.-266    	; 0x1f42 <chksum>
    204c:	00 97       	sbiw	r24, 0x00	; 0
  DEBUG_PRINTF("uip_ipchksum: sum 0x%04x\n", sum);
  return (sum == 0) ? 0xffff : htons(sum);
    204e:	21 f0       	breq	.+8      	; 0x2058 <uip_ipchksum+0x1a>
    2050:	98 27       	eor	r25, r24
    2052:	89 27       	eor	r24, r25
    2054:	98 27       	eor	r25, r24
    2056:	08 95       	ret
    2058:	8f ef       	ldi	r24, 0xFF	; 255
    205a:	9f ef       	ldi	r25, 0xFF	; 255
    205c:	08 95       	ret

0000205e <uip_tcpchksum>:
}
    205e:	cf 93       	push	r28
}
#endif /* UIP_CONF_IPV6 */
/*---------------------------------------------------------------------------*/
u16_t
uip_tcpchksum(void)
{
    2060:	df 93       	push	r29
  u16_t sum;

#if UIP_CONF_IPV6
  upper_layer_len = (((u16_t)(BUF->len[0]) << 8) + BUF->len[1]);
#else /* UIP_CONF_IPV6 */
  upper_layer_len = (((u16_t)(BUF->len[0]) << 8) + BUF->len[1]) - UIP_IPH_LEN;
    2062:	c0 91 db 07 	lds	r28, 0x07DB
    2066:	d0 e0       	ldi	r29, 0x00	; 0
    2068:	dc 2f       	mov	r29, r28
    206a:	cc 27       	eor	r28, r28
    206c:	80 91 dc 07 	lds	r24, 0x07DC
    2070:	c8 0f       	add	r28, r24
    2072:	d1 1d       	adc	r29, r1
  /* First sum pseudo-header. */

  /* IP protocol and length fields. This addition cannot carry. */
  sum = upper_layer_len + proto;
  /* Sum IP source and destination addresses. */
  sum = chksum(sum, (u8_t *)&BUF->srcipaddr, 2 * sizeof(uip_ipaddr_t));
    2074:	48 e0       	ldi	r20, 0x08	; 8
    2076:	50 e0       	ldi	r21, 0x00	; 0
    2078:	65 ee       	ldi	r22, 0xE5	; 229
    207a:	77 e0       	ldi	r23, 0x07	; 7
    207c:	ce 01       	movw	r24, r28
    207e:	0e 97       	sbiw	r24, 0x0e	; 14
    2080:	60 df       	rcall	.-320    	; 0x1f42 <chksum>
    2082:	ae 01       	movw	r20, r28
  u16_t sum;

#if UIP_CONF_IPV6
  upper_layer_len = (((u16_t)(BUF->len[0]) << 8) + BUF->len[1]);
#else /* UIP_CONF_IPV6 */
  upper_layer_len = (((u16_t)(BUF->len[0]) << 8) + BUF->len[1]) - UIP_IPH_LEN;
    2084:	44 51       	subi	r20, 0x14	; 20
    2086:	51 09       	sbc	r21, r1
    2088:	6d ee       	ldi	r22, 0xED	; 237
  sum = upper_layer_len + proto;
  /* Sum IP source and destination addresses. */
  sum = chksum(sum, (u8_t *)&BUF->srcipaddr, 2 * sizeof(uip_ipaddr_t));

  /* Sum TCP header and data. */
  sum = chksum(sum, &uip_buf[UIP_IPH_LEN + UIP_LLH_LEN],
    208a:	77 e0       	ldi	r23, 0x07	; 7
    208c:	5a df       	rcall	.-332    	; 0x1f42 <chksum>
    208e:	00 97       	sbiw	r24, 0x00	; 0
    2090:	21 f0       	breq	.+8      	; 0x209a <uip_tcpchksum+0x3c>
	       upper_layer_len);

  return (sum == 0) ? 0xffff : htons(sum);
    2092:	98 27       	eor	r25, r24
    2094:	89 27       	eor	r24, r25
    2096:	98 27       	eor	r25, r24
    2098:	02 c0       	rjmp	.+4      	; 0x209e <uip_tcpchksum+0x40>
    209a:	8f ef       	ldi	r24, 0xFF	; 255
    209c:	9f ef       	ldi	r25, 0xFF	; 255
    209e:	df 91       	pop	r29
    20a0:	cf 91       	pop	r28
/*---------------------------------------------------------------------------*/
u16_t
uip_tcpchksum(void)
{
  return upper_layer_chksum(UIP_PROTO_TCP);
}
    20a2:	08 95       	ret

000020a4 <uip_init>:
    20a4:	80 e0       	ldi	r24, 0x00	; 0
    20a6:	e8 2f       	mov	r30, r24
/*---------------------------------------------------------------------------*/
void
uip_init(void)
{
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    uip_listenports[c] = 0;
    20a8:	f0 e0       	ldi	r31, 0x00	; 0
    20aa:	ee 0f       	add	r30, r30
    20ac:	ff 1f       	adc	r31, r31
    20ae:	eb 54       	subi	r30, 0x4B	; 75
    20b0:	f8 4f       	sbci	r31, 0xF8	; 248
    20b2:	11 82       	std	Z+1, r1	; 0x01
    20b4:	10 82       	st	Z, r1
#endif /* UIP_ARCH_CHKSUM */
/*---------------------------------------------------------------------------*/
void
uip_init(void)
{
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    20b6:	8f 5f       	subi	r24, 0xFF	; 255
    20b8:	85 30       	cpi	r24, 0x05	; 5
    20ba:	a8 f3       	brcs	.-22     	; 0x20a6 <uip_init+0x2>
    uip_listenports[c] = 0;
  }
  for(c = 0; c < UIP_CONNS; ++c) {
    20bc:	80 e0       	ldi	r24, 0x00	; 0
    uip_conns[c].tcpstateflags = UIP_CLOSED;
    20be:	91 e7       	ldi	r25, 0x71	; 113
    20c0:	98 9f       	mul	r25, r24
    20c2:	f0 01       	movw	r30, r0
    20c4:	11 24       	eor	r1, r1
    20c6:	ee 59       	subi	r30, 0x9E	; 158
    20c8:	f9 4f       	sbci	r31, 0xF9	; 249
    20ca:	11 8e       	std	Z+25, r1	; 0x19
uip_init(void)
{
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    uip_listenports[c] = 0;
  }
  for(c = 0; c < UIP_CONNS; ++c) {
    20cc:	8f 5f       	subi	r24, 0xFF	; 255
    20ce:	83 30       	cpi	r24, 0x03	; 3
    20d0:	b8 f3       	brcs	.-18     	; 0x20c0 <uip_init+0x1c>
    uip_conns[c].tcpstateflags = UIP_CLOSED;
  }
#if UIP_ACTIVE_OPEN
  lastport = 1024;
    20d2:	80 e0       	ldi	r24, 0x00	; 0
    20d4:	94 e0       	ldi	r25, 0x04	; 4
    20d6:	90 93 97 03 	sts	0x0397, r25
    20da:	80 93 96 03 	sts	0x0396, r24
    20de:	81 e0       	ldi	r24, 0x01	; 1
    20e0:	80 93 95 03 	sts	0x0395, r24
    20e4:	10 92 be 0d 	sts	0x0DBE, r1
    20e8:	10 92 bd 0d 	sts	0x0DBD, r1
    20ec:	08 95       	ret

000020ee <uip_udp_new>:
  if(lastport >= 32000) {
    lastport = 4096;
  }

  for(c = 0; c < UIP_UDP_CONNS; ++c) {
    if(uip_udp_conns[c].lport == htons(lastport)) {
    20ee:	e0 91 bd 0d 	lds	r30, 0x0DBD
    20f2:	f0 91 be 0d 	lds	r31, 0x0DBE
    20f6:	20 91 96 03 	lds	r18, 0x0396
    20fa:	30 91 97 03 	lds	r19, 0x0397
{
  register struct uip_udp_conn *conn;

  /* Find an unused local port. */
 again:
  ++lastport;
    20fe:	2f 5f       	subi	r18, 0xFF	; 255
    2100:	3f 4f       	sbci	r19, 0xFF	; 255

  if(lastport >= 32000) {
    2102:	21 15       	cp	r18, r1
    2104:	4d e7       	ldi	r20, 0x7D	; 125
    2106:	34 07       	cpc	r19, r20
    2108:	10 f0       	brcs	.+4      	; 0x210e <__stack+0xf>
    lastport = 4096;
    210a:	20 e0       	ldi	r18, 0x00	; 0
    210c:	30 e1       	ldi	r19, 0x10	; 16
}
/*---------------------------------------------------------------------------*/
u16_t
htons(u16_t val)
{
  return HTONS(val);
    210e:	52 2f       	mov	r21, r18
    2110:	43 2f       	mov	r20, r19
  if(lastport >= 32000) {
    lastport = 4096;
  }

  for(c = 0; c < UIP_UDP_CONNS; ++c) {
    if(uip_udp_conns[c].lport == htons(lastport)) {
    2112:	e4 17       	cp	r30, r20
    2114:	f5 07       	cpc	r31, r21
    2116:	99 f3       	breq	.-26     	; 0x20fe <uip_udp_new+0x10>
    2118:	30 93 97 03 	sts	0x0397, r19
    211c:	20 93 96 03 	sts	0x0396, r18
  }


  conn = 0;
  for(c = 0; c < UIP_UDP_CONNS; ++c) {
    if(uip_udp_conns[c].lport == 0) {
    2120:	ef 2b       	or	r30, r31
    2122:	41 f5       	brne	.+80     	; 0x2174 <__stack+0x75>
    2124:	10 92 95 03 	sts	0x0395, r1

  if(conn == 0) {
    return 0;
  }

  conn->lport = HTONS(lastport);
    2128:	50 93 be 0d 	sts	0x0DBE, r21
    212c:	40 93 bd 0d 	sts	0x0DBD, r20
  conn->rport = rport;
    2130:	70 93 c0 0d 	sts	0x0DC0, r23
    2134:	60 93 bf 0d 	sts	0x0DBF, r22
  if(ripaddr == NULL) {
    2138:	00 97       	sbiw	r24, 0x00	; 0
    213a:	49 f4       	brne	.+18     	; 0x214e <__stack+0x4f>
    memset(&conn->ripaddr, 0, sizeof(uip_ipaddr_t));
    213c:	10 92 b9 0d 	sts	0x0DB9, r1
    2140:	10 92 ba 0d 	sts	0x0DBA, r1
    2144:	10 92 bb 0d 	sts	0x0DBB, r1
    2148:	10 92 bc 0d 	sts	0x0DBC, r1
    214c:	0d c0       	rjmp	.+26     	; 0x2168 <__stack+0x69>
  } else {
    uip_ipaddr_copy(&conn->ripaddr, ripaddr);
    214e:	fc 01       	movw	r30, r24
    2150:	80 81       	ld	r24, Z
    2152:	91 81       	ldd	r25, Z+1	; 0x01
    2154:	a2 81       	ldd	r26, Z+2	; 0x02
    2156:	b3 81       	ldd	r27, Z+3	; 0x03
    2158:	80 93 b9 0d 	sts	0x0DB9, r24
    215c:	90 93 ba 0d 	sts	0x0DBA, r25
    2160:	a0 93 bb 0d 	sts	0x0DBB, r26
    2164:	b0 93 bc 0d 	sts	0x0DBC, r27
  }
  conn->ttl = UIP_TTL;
    2168:	80 e4       	ldi	r24, 0x40	; 64
    216a:	80 93 c1 0d 	sts	0x0DC1, r24


  conn = 0;
  for(c = 0; c < UIP_UDP_CONNS; ++c) {
    if(uip_udp_conns[c].lport == 0) {
      conn = &uip_udp_conns[c];
    216e:	89 eb       	ldi	r24, 0xB9	; 185
    2170:	9d e0       	ldi	r25, 0x0D	; 13
  } else {
    uip_ipaddr_copy(&conn->ripaddr, ripaddr);
  }
  conn->ttl = UIP_TTL;

  return conn;
    2172:	08 95       	ret
    2174:	81 e0       	ldi	r24, 0x01	; 1
    2176:	80 93 95 03 	sts	0x0395, r24
      break;
    }
  }

  if(conn == 0) {
    return 0;
    217a:	80 e0       	ldi	r24, 0x00	; 0
    217c:	90 e0       	ldi	r25, 0x00	; 0
    uip_ipaddr_copy(&conn->ripaddr, ripaddr);
  }
  conn->ttl = UIP_TTL;

  return conn;
}
    217e:	08 95       	ret

00002180 <uip_listen>:
}
/*---------------------------------------------------------------------------*/
void
uip_listen(u16_t port)
{
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    2180:	40 e0       	ldi	r20, 0x00	; 0
    2182:	45 30       	cpi	r20, 0x05	; 5
    2184:	98 f4       	brcc	.+38     	; 0x21ac <uip_listen+0x2c>
    if(uip_listenports[c] == 0) {
    2186:	e4 2f       	mov	r30, r20
    2188:	f0 e0       	ldi	r31, 0x00	; 0
    218a:	51 e0       	ldi	r21, 0x01	; 1
    218c:	54 0f       	add	r21, r20
    218e:	ee 0f       	add	r30, r30
    2190:	ff 1f       	adc	r31, r31
    2192:	eb 54       	subi	r30, 0x4B	; 75
    2194:	f8 4f       	sbci	r31, 0xF8	; 248
    2196:	20 81       	ld	r18, Z
    2198:	31 81       	ldd	r19, Z+1	; 0x01
    219a:	23 2b       	or	r18, r19
    219c:	29 f4       	brne	.+10     	; 0x21a8 <uip_listen+0x28>
    219e:	40 93 95 03 	sts	0x0395, r20
      uip_listenports[c] = port;
    21a2:	91 83       	std	Z+1, r25	; 0x01
    21a4:	80 83       	st	Z, r24
      return;
    21a6:	08 95       	ret
/*---------------------------------------------------------------------------*/
void
uip_listen(u16_t port)
{
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    if(uip_listenports[c] == 0) {
    21a8:	45 2f       	mov	r20, r21
    21aa:	eb cf       	rjmp	.-42     	; 0x2182 <uip_listen+0x2>
    21ac:	40 93 95 03 	sts	0x0395, r20
    21b0:	08 95       	ret

000021b2 <uip_process>:
  uip_conn->rcv_nxt[3] = uip_acc32[3];
}
/*---------------------------------------------------------------------------*/
void
uip_process(u8_t flag)
{
    21b2:	af 92       	push	r10
    21b4:	bf 92       	push	r11
    21b6:	cf 92       	push	r12
    21b8:	df 92       	push	r13
    21ba:	ef 92       	push	r14
    21bc:	ff 92       	push	r15
    21be:	0f 93       	push	r16
    21c0:	1f 93       	push	r17
    21c2:	cf 93       	push	r28
    21c4:	df 93       	push	r29
  register struct uip_conn *uip_connr = uip_conn;
    21c6:	c0 91 60 06 	lds	r28, 0x0660
    21ca:	d0 91 61 06 	lds	r29, 0x0661

#if UIP_UDP
  if(flag == UIP_UDP_SEND_CONN) {
    21ce:	84 30       	cpi	r24, 0x04	; 4
    21d0:	09 f4       	brne	.+2      	; 0x21d4 <uip_process+0x22>
    21d2:	58 c2       	rjmp	.+1200   	; 0x2684 <uip_process+0x4d2>
    goto udp_send;
  }
#endif /* UIP_UDP */

  uip_sappdata = uip_appdata = &uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN];
    21d4:	21 e0       	ldi	r18, 0x01	; 1
    21d6:	38 e0       	ldi	r19, 0x08	; 8
    21d8:	30 93 5f 06 	sts	0x065F, r19
    21dc:	20 93 5e 06 	sts	0x065E, r18
    21e0:	30 93 56 06 	sts	0x0656, r19
    21e4:	20 93 55 06 	sts	0x0655, r18

  /* Check if we were invoked because of a poll request for a
     particular connection. */
  if(flag == UIP_POLL_REQUEST) {
    21e8:	83 30       	cpi	r24, 0x03	; 3
    21ea:	99 f4       	brne	.+38     	; 0x2212 <uip_process+0x60>
    if((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_ESTABLISHED &&
    21ec:	89 8d       	ldd	r24, Y+25	; 0x19
    21ee:	8f 70       	andi	r24, 0x0F	; 15
    21f0:	83 30       	cpi	r24, 0x03	; 3
    21f2:	09 f0       	breq	.+2      	; 0x21f6 <uip_process+0x44>
    21f4:	4a c7       	rjmp	.+3732   	; 0x308a <uip_process+0xed8>
    21f6:	88 89       	ldd	r24, Y+16	; 0x10
    21f8:	99 89       	ldd	r25, Y+17	; 0x11
    21fa:	89 2b       	or	r24, r25
    21fc:	09 f0       	breq	.+2      	; 0x2200 <uip_process+0x4e>
    21fe:	45 c7       	rjmp	.+3722   	; 0x308a <uip_process+0xed8>
       !uip_outstanding(uip_connr)) {
	uip_len = uip_slen = 0;
    2200:	10 92 b8 0d 	sts	0x0DB8, r1
    2204:	10 92 b7 0d 	sts	0x0DB7, r1
    2208:	10 92 54 06 	sts	0x0654, r1
    220c:	10 92 53 06 	sts	0x0653, r1
    2210:	7f c0       	rjmp	.+254    	; 0x2310 <uip_process+0x15e>
	goto appsend;
    }
    goto drop;

    /* Check if we were invoked because of the periodic timer firing. */
  } else if(flag == UIP_TIMER) {
    2212:	82 30       	cpi	r24, 0x02	; 2
    2214:	09 f0       	breq	.+2      	; 0x2218 <uip_process+0x66>
    2216:	80 c0       	rjmp	.+256    	; 0x2318 <uip_process+0x166>
    if(uip_reasstmr != 0) {
      --uip_reasstmr;
    }
#endif /* UIP_REASSEMBLY */
    /* Increase the initial sequence number. */
    if(++iss[3] == 0) {
    2218:	80 91 9b 03 	lds	r24, 0x039B
    221c:	8f 5f       	subi	r24, 0xFF	; 255
    221e:	80 93 9b 03 	sts	0x039B, r24
    2222:	81 11       	cpse	r24, r1
    2224:	13 c0       	rjmp	.+38     	; 0x224c <uip_process+0x9a>
      if(++iss[2] == 0) {
    2226:	80 91 9a 03 	lds	r24, 0x039A
    222a:	8f 5f       	subi	r24, 0xFF	; 255
    222c:	80 93 9a 03 	sts	0x039A, r24
    2230:	81 11       	cpse	r24, r1
    2232:	0c c0       	rjmp	.+24     	; 0x224c <uip_process+0x9a>
	if(++iss[1] == 0) {
    2234:	80 91 99 03 	lds	r24, 0x0399
    2238:	8f 5f       	subi	r24, 0xFF	; 255
    223a:	80 93 99 03 	sts	0x0399, r24
    223e:	81 11       	cpse	r24, r1
    2240:	05 c0       	rjmp	.+10     	; 0x224c <uip_process+0x9a>
	  ++iss[0];
    2242:	80 91 98 03 	lds	r24, 0x0398
    2246:	8f 5f       	subi	r24, 0xFF	; 255
    2248:	80 93 98 03 	sts	0x0398, r24
	}
      }
    }

    /* Reset the length variables. */
    uip_len = 0;
    224c:	10 92 54 06 	sts	0x0654, r1
    2250:	10 92 53 06 	sts	0x0653, r1
    uip_slen = 0;
    2254:	10 92 b8 0d 	sts	0x0DB8, r1
    2258:	10 92 b7 0d 	sts	0x0DB7, r1

    /* Check if the connection is in a state in which we simply wait
       for the connection to time out. If so, we increase the
       connection's timer and remove the connection if it times
       out. */
    if(uip_connr->tcpstateflags == UIP_TIME_WAIT ||
    225c:	29 8d       	ldd	r18, Y+25	; 0x19
    225e:	82 2f       	mov	r24, r18
    2260:	8d 7f       	andi	r24, 0xFD	; 253
    2262:	85 30       	cpi	r24, 0x05	; 5
    2264:	41 f4       	brne	.+16     	; 0x2276 <uip_process+0xc4>
       uip_connr->tcpstateflags == UIP_FIN_WAIT_2) {
      ++(uip_connr->timer);
    2266:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2268:	8f 5f       	subi	r24, 0xFF	; 255
    226a:	8a 8f       	std	Y+26, r24	; 0x1a
      if(uip_connr->timer == UIP_TIME_WAIT_TIMEOUT) {
    226c:	88 37       	cpi	r24, 0x78	; 120
    226e:	09 f0       	breq	.+2      	; 0x2272 <uip_process+0xc0>
    2270:	0c c7       	rjmp	.+3608   	; 0x308a <uip_process+0xed8>
	uip_connr->tcpstateflags = UIP_CLOSED;
    2272:	19 8e       	std	Y+25, r1	; 0x19
    2274:	0a c7       	rjmp	.+3604   	; 0x308a <uip_process+0xed8>
      }
    } else if(uip_connr->tcpstateflags != UIP_CLOSED) {
    2276:	22 23       	and	r18, r18
    2278:	09 f4       	brne	.+2      	; 0x227c <uip_process+0xca>
    227a:	07 c7       	rjmp	.+3598   	; 0x308a <uip_process+0xed8>
      /* If the connection has outstanding data, we increase the
	 connection's timer and see if it has reached the RTO value
	 in which case we retransmit. */
      if(uip_outstanding(uip_connr)) {
    227c:	88 89       	ldd	r24, Y+16	; 0x10
    227e:	99 89       	ldd	r25, Y+17	; 0x11
    2280:	89 2b       	or	r24, r25
    2282:	09 f4       	brne	.+2      	; 0x2286 <uip_process+0xd4>
    2284:	41 c0       	rjmp	.+130    	; 0x2308 <uip_process+0x156>
	if(uip_connr->timer-- == 0) {
    2286:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2288:	9f ef       	ldi	r25, 0xFF	; 255
    228a:	98 0f       	add	r25, r24
    228c:	9a 8f       	std	Y+26, r25	; 0x1a
    228e:	81 11       	cpse	r24, r1
    2290:	fc c6       	rjmp	.+3576   	; 0x308a <uip_process+0xed8>
	  if(uip_connr->nrtx == UIP_MAXRTX ||
    2292:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2294:	88 30       	cpi	r24, 0x08	; 8
    2296:	31 f0       	breq	.+12     	; 0x22a4 <uip_process+0xf2>
	     ((uip_connr->tcpstateflags == UIP_SYN_SENT ||
    2298:	9f ef       	ldi	r25, 0xFF	; 255
    229a:	92 0f       	add	r25, r18
      /* If the connection has outstanding data, we increase the
	 connection's timer and see if it has reached the RTO value
	 in which case we retransmit. */
      if(uip_outstanding(uip_connr)) {
	if(uip_connr->timer-- == 0) {
	  if(uip_connr->nrtx == UIP_MAXRTX ||
    229c:	92 30       	cpi	r25, 0x02	; 2
    229e:	48 f4       	brcc	.+18     	; 0x22b2 <uip_process+0x100>
	     ((uip_connr->tcpstateflags == UIP_SYN_SENT ||
	       uip_connr->tcpstateflags == UIP_SYN_RCVD) &&
    22a0:	85 30       	cpi	r24, 0x05	; 5
    22a2:	39 f4       	brne	.+14     	; 0x22b2 <uip_process+0x100>
	      uip_connr->nrtx == UIP_MAXSYNRTX)) {
	    uip_connr->tcpstateflags = UIP_CLOSED;
    22a4:	19 8e       	std	Y+25, r1	; 0x19

	    /* We call UIP_APPCALL() with uip_flags set to
	       UIP_TIMEDOUT to inform the application that the
	       connection has timed out. */
	    uip_flags = UIP_TIMEDOUT;
    22a6:	80 e8       	ldi	r24, 0x80	; 128
    22a8:	80 93 5b 06 	sts	0x065B, r24
	    UIP_APPCALL();
    22ac:	0e 94 4a 09 	call	0x1294	; 0x1294 <uIPManagement_TCPCallback>
    22b0:	a9 c5       	rjmp	.+2898   	; 0x2e04 <uip_process+0xc52>
	    BUF->flags = TCP_RST | TCP_ACK;
	    goto tcp_send_nodata;
	  }

	  /* Exponential back-off. */
	  uip_connr->timer = UIP_RTO << (uip_connr->nrtx > 4?
    22b2:	85 30       	cpi	r24, 0x05	; 5
    22b4:	38 f4       	brcc	.+14     	; 0x22c4 <uip_process+0x112>
    22b6:	93 e0       	ldi	r25, 0x03	; 3
    22b8:	08 2e       	mov	r0, r24
    22ba:	01 c0       	rjmp	.+2      	; 0x22be <uip_process+0x10c>
    22bc:	99 0f       	add	r25, r25
    22be:	0a 94       	dec	r0
    22c0:	ea f7       	brpl	.-6      	; 0x22bc <uip_process+0x10a>
    22c2:	01 c0       	rjmp	.+2      	; 0x22c6 <uip_process+0x114>
    22c4:	90 e3       	ldi	r25, 0x30	; 48
    22c6:	9a 8f       	std	Y+26, r25	; 0x1a
					 4:
					 uip_connr->nrtx);
	  ++(uip_connr->nrtx);
    22c8:	8f 5f       	subi	r24, 0xFF	; 255
    22ca:	8b 8f       	std	Y+27, r24	; 0x1b
	     call upon the application so that it may prepare the
	     data for the retransmit. In SYN_RCVD, we resend the
	     SYNACK that we sent earlier and in LAST_ACK we have to
	     retransmit our FINACK. */
	  UIP_STAT(++uip_stat.tcp.rexmit);
	  switch(uip_connr->tcpstateflags & UIP_TS_MASK) {
    22cc:	82 2f       	mov	r24, r18
    22ce:	8f 70       	andi	r24, 0x0F	; 15
    22d0:	83 30       	cpi	r24, 0x03	; 3
    22d2:	a1 f0       	breq	.+40     	; 0x22fc <uip_process+0x14a>
    22d4:	48 f4       	brcc	.+18     	; 0x22e8 <uip_process+0x136>
    22d6:	81 30       	cpi	r24, 0x01	; 1
    22d8:	09 f4       	brne	.+2      	; 0x22dc <uip_process+0x12a>
    22da:	b7 c3       	rjmp	.+1902   	; 0x2a4a <uip_process+0x898>
    22dc:	82 30       	cpi	r24, 0x02	; 2
    22de:	09 f0       	breq	.+2      	; 0x22e2 <uip_process+0x130>
    22e0:	d4 c6       	rjmp	.+3496   	; 0x308a <uip_process+0xed8>
	    goto tcp_send_synack;

#if UIP_ACTIVE_OPEN
	  case UIP_SYN_SENT:
	    /* In the SYN_SENT state, we retransmit out SYN. */
	    BUF->flags = 0;
    22e2:	10 92 fa 07 	sts	0x07FA, r1
	    goto tcp_send_syn;
    22e6:	b4 c3       	rjmp	.+1896   	; 0x2a50 <uip_process+0x89e>
	     call upon the application so that it may prepare the
	     data for the retransmit. In SYN_RCVD, we resend the
	     SYNACK that we sent earlier and in LAST_ACK we have to
	     retransmit our FINACK. */
	  UIP_STAT(++uip_stat.tcp.rexmit);
	  switch(uip_connr->tcpstateflags & UIP_TS_MASK) {
    22e8:	86 30       	cpi	r24, 0x06	; 6
    22ea:	09 f4       	brne	.+2      	; 0x22ee <uip_process+0x13c>
    22ec:	2b c5       	rjmp	.+2646   	; 0x2d44 <uip_process+0xb92>
    22ee:	88 30       	cpi	r24, 0x08	; 8
    22f0:	09 f4       	brne	.+2      	; 0x22f4 <uip_process+0x142>
    22f2:	28 c5       	rjmp	.+2640   	; 0x2d44 <uip_process+0xb92>
    22f4:	84 30       	cpi	r24, 0x04	; 4
    22f6:	09 f0       	breq	.+2      	; 0x22fa <uip_process+0x148>
    22f8:	c8 c6       	rjmp	.+3472   	; 0x308a <uip_process+0xed8>
    22fa:	24 c5       	rjmp	.+2632   	; 0x2d44 <uip_process+0xb92>
	  case UIP_ESTABLISHED:
	    /* In the ESTABLISHED state, we call upon the application
               to do the actual retransmit after which we jump into
               the code for sending out the packet (the apprexmit
               label). */
	    uip_flags = UIP_REXMIT;
    22fc:	84 e0       	ldi	r24, 0x04	; 4
    22fe:	80 93 5b 06 	sts	0x065B, r24
	    UIP_APPCALL();
    2302:	0e 94 4a 09 	call	0x1294	; 0x1294 <uIPManagement_TCPCallback>
	    goto apprexmit;
    2306:	b0 c5       	rjmp	.+2912   	; 0x2e68 <uip_process+0xcb6>
	    /* In all these states we should retransmit a FINACK. */
	    goto tcp_send_finack;

	  }
	}
      } else if((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_ESTABLISHED) {
    2308:	2f 70       	andi	r18, 0x0F	; 15
    230a:	23 30       	cpi	r18, 0x03	; 3
    230c:	09 f0       	breq	.+2      	; 0x2310 <uip_process+0x15e>
    230e:	bd c6       	rjmp	.+3450   	; 0x308a <uip_process+0xed8>
	/* If there was no need for a retransmission, we poll the
           application for new data. */
	uip_len = uip_slen = 0;
	uip_flags = UIP_POLL;
    2310:	88 e0       	ldi	r24, 0x08	; 8
    2312:	80 93 5b 06 	sts	0x065B, r24
    2316:	6b c5       	rjmp	.+2774   	; 0x2dee <uip_process+0xc3c>
      }
    }
    goto drop;
  }
#if UIP_UDP
  if(flag == UIP_UDP_TIMER) {
    2318:	85 30       	cpi	r24, 0x05	; 5
    231a:	19 f5       	brne	.+70     	; 0x2362 <uip_process+0x1b0>
    if(uip_udp_conn->lport != 0) {
    231c:	e0 91 5c 06 	lds	r30, 0x065C
    2320:	f0 91 5d 06 	lds	r31, 0x065D
    2324:	84 81       	ldd	r24, Z+4	; 0x04
    2326:	95 81       	ldd	r25, Z+5	; 0x05
    2328:	89 2b       	or	r24, r25
    232a:	09 f4       	brne	.+2      	; 0x232e <uip_process+0x17c>
    232c:	ae c6       	rjmp	.+3420   	; 0x308a <uip_process+0xed8>
      uip_conn = NULL;
    232e:	10 92 61 06 	sts	0x0661, r1
    2332:	10 92 60 06 	sts	0x0660, r1
      uip_sappdata = uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];
    2336:	85 ef       	ldi	r24, 0xF5	; 245
    2338:	97 e0       	ldi	r25, 0x07	; 7
    233a:	90 93 5f 06 	sts	0x065F, r25
    233e:	80 93 5e 06 	sts	0x065E, r24
    2342:	90 93 56 06 	sts	0x0656, r25
    2346:	80 93 55 06 	sts	0x0655, r24
      uip_len = uip_slen = 0;
    234a:	10 92 b8 0d 	sts	0x0DB8, r1
    234e:	10 92 b7 0d 	sts	0x0DB7, r1
    2352:	10 92 54 06 	sts	0x0654, r1
    2356:	10 92 53 06 	sts	0x0653, r1
      uip_flags = UIP_POLL;
    235a:	88 e0       	ldi	r24, 0x08	; 8
    235c:	80 93 5b 06 	sts	0x065B, r24
    2360:	8f c1       	rjmp	.+798    	; 0x2680 <uip_process+0x4ce>
    UIP_LOG("ipv6: invalid version.");
    goto drop;
  }
#else /* UIP_CONF_IPV6 */
  /* Check validity of the IP header. */
  if(BUF->vhl != 0x45)  { /* IP version and header length. */
    2362:	80 91 d9 07 	lds	r24, 0x07D9
    2366:	85 34       	cpi	r24, 0x45	; 69
    2368:	09 f0       	breq	.+2      	; 0x236c <uip_process+0x1ba>
    236a:	8f c6       	rjmp	.+3358   	; 0x308a <uip_process+0xed8>
     that the packet has been corrupted in transit. If the size of
     uip_len is larger than the size reported in the IP packet header,
     the packet has been padded and we set uip_len to the correct
     value.. */

  if((BUF->len[0] << 8) + BUF->len[1] <= uip_len) {
    236c:	00 91 db 07 	lds	r16, 0x07DB
    2370:	10 e0       	ldi	r17, 0x00	; 0
    2372:	10 2f       	mov	r17, r16
    2374:	00 27       	eor	r16, r16
    2376:	80 91 dc 07 	lds	r24, 0x07DC
    237a:	08 0f       	add	r16, r24
    237c:	11 1d       	adc	r17, r1
    237e:	80 91 53 06 	lds	r24, 0x0653
    2382:	90 91 54 06 	lds	r25, 0x0654
    2386:	80 17       	cp	r24, r16
    2388:	91 07       	cpc	r25, r17
    238a:	08 f4       	brcc	.+2      	; 0x238e <uip_process+0x1dc>
    238c:	7e c6       	rjmp	.+3324   	; 0x308a <uip_process+0xed8>
    uip_len = (BUF->len[0] << 8) + BUF->len[1];
    238e:	10 93 54 06 	sts	0x0654, r17
    2392:	00 93 53 06 	sts	0x0653, r16
    goto drop;
  }

#if !UIP_CONF_IPV6
  /* Check the fragment flag. */
  if((BUF->ipoffset[0] & 0x3f) != 0 ||
    2396:	80 91 df 07 	lds	r24, 0x07DF
    239a:	8f 73       	andi	r24, 0x3F	; 63
    239c:	09 f0       	breq	.+2      	; 0x23a0 <uip_process+0x1ee>
    239e:	75 c6       	rjmp	.+3306   	; 0x308a <uip_process+0xed8>
    23a0:	80 91 e0 07 	lds	r24, 0x07E0
    23a4:	81 11       	cpse	r24, r1
    23a6:	71 c6       	rjmp	.+3298   	; 0x308a <uip_process+0xed8>
    goto drop;
#endif /* UIP_REASSEMBLY */
  }
#endif /* UIP_CONF_IPV6 */

  if(uip_ipaddr_cmp(&uip_hostaddr, &uip_all_zeroes_addr)) {
    23a8:	80 91 c7 07 	lds	r24, 0x07C7
    23ac:	90 91 c8 07 	lds	r25, 0x07C8
    23b0:	c0 91 da 01 	lds	r28, 0x01DA
    23b4:	d0 91 db 01 	lds	r29, 0x01DB
    23b8:	8c 17       	cp	r24, r28
    23ba:	9d 07       	cpc	r25, r29
    23bc:	61 f4       	brne	.+24     	; 0x23d6 <uip_process+0x224>
    23be:	40 91 c9 07 	lds	r20, 0x07C9
    23c2:	50 91 ca 07 	lds	r21, 0x07CA
    23c6:	20 91 dc 01 	lds	r18, 0x01DC
    23ca:	30 91 dd 01 	lds	r19, 0x01DD
    23ce:	42 17       	cp	r20, r18
    23d0:	53 07       	cpc	r21, r19
    23d2:	09 f4       	brne	.+2      	; 0x23d6 <uip_process+0x224>
    23d4:	48 c0       	rjmp	.+144    	; 0x2466 <uip_process+0x2b4>
  } else {
    /* If IP broadcast support is configured, we check for a broadcast
       UDP packet, which may be destined to us. */
#if UIP_BROADCAST
    DEBUG_PRINTF("UDP IP checksum 0x%04x\n", uip_ipchksum());
    if(BUF->proto == UIP_PROTO_UDP &&
    23d6:	40 91 e2 07 	lds	r20, 0x07E2
    23da:	20 91 e9 07 	lds	r18, 0x07E9
    23de:	30 91 ea 07 	lds	r19, 0x07EA
    23e2:	41 31       	cpi	r20, 0x11	; 17
    23e4:	81 f5       	brne	.+96     	; 0x2446 <uip_process+0x294>
    23e6:	40 91 de 01 	lds	r20, 0x01DE
    23ea:	50 91 df 01 	lds	r21, 0x01DF
    23ee:	24 17       	cp	r18, r20
    23f0:	35 07       	cpc	r19, r21
    23f2:	49 f5       	brne	.+82     	; 0x2446 <uip_process+0x294>
       uip_ipaddr_cmp(&BUF->destipaddr, &uip_broadcast_addr))
    23f4:	60 91 eb 07 	lds	r22, 0x07EB
    23f8:	70 91 ec 07 	lds	r23, 0x07EC
    23fc:	40 91 e0 01 	lds	r20, 0x01E0
    2400:	50 91 e1 01 	lds	r21, 0x01E1
    2404:	64 17       	cp	r22, r20
    2406:	75 07       	cpc	r23, r21
    2408:	f1 f4       	brne	.+60     	; 0x2446 <uip_process+0x294>
	{
		if (uip_ipaddr_cmp(&BUF->srcipaddr, &uip_all_zeroes_addr))
    240a:	80 91 e5 07 	lds	r24, 0x07E5
    240e:	90 91 e6 07 	lds	r25, 0x07E6
    2412:	8c 17       	cp	r24, r28
    2414:	9d 07       	cpc	r25, r29
    2416:	09 f0       	breq	.+2      	; 0x241a <uip_process+0x268>
    2418:	6e c0       	rjmp	.+220    	; 0x24f6 <uip_process+0x344>
    241a:	20 91 e7 07 	lds	r18, 0x07E7
    241e:	30 91 e8 07 	lds	r19, 0x07E8
    2422:	80 91 dc 01 	lds	r24, 0x01DC
    2426:	90 91 dd 01 	lds	r25, 0x01DD
    242a:	28 17       	cp	r18, r24
    242c:	39 07       	cpc	r19, r25
    242e:	09 f0       	breq	.+2      	; 0x2432 <uip_process+0x280>
    2430:	62 c0       	rjmp	.+196    	; 0x24f6 <uip_process+0x344>
		  uip_ipaddr_copy(&BUF->srcipaddr, &uip_broadcast_addr);
    2432:	8f ef       	ldi	r24, 0xFF	; 255
    2434:	80 93 e5 07 	sts	0x07E5, r24
    2438:	80 93 e6 07 	sts	0x07E6, r24
    243c:	80 93 e7 07 	sts	0x07E7, r24
    2440:	80 93 e8 07 	sts	0x07E8, r24
    2444:	58 c0       	rjmp	.+176    	; 0x24f6 <uip_process+0x344>
    }
#endif /* UIP_BROADCAST */

    /* Check if the packet is destined for our IP address. */
#if !UIP_CONF_IPV6
    if(!uip_ipaddr_cmp(&BUF->destipaddr, &uip_hostaddr)) {
    2446:	28 17       	cp	r18, r24
    2448:	39 07       	cpc	r19, r25
    244a:	09 f0       	breq	.+2      	; 0x244e <uip_process+0x29c>
    244c:	1e c6       	rjmp	.+3132   	; 0x308a <uip_process+0xed8>
    244e:	20 91 eb 07 	lds	r18, 0x07EB
    2452:	30 91 ec 07 	lds	r19, 0x07EC
    2456:	80 91 c9 07 	lds	r24, 0x07C9
    245a:	90 91 ca 07 	lds	r25, 0x07CA
    245e:	28 17       	cp	r18, r24
    2460:	39 07       	cpc	r19, r25
    2462:	09 f0       	breq	.+2      	; 0x2466 <uip_process+0x2b4>
    2464:	12 c6       	rjmp	.+3108   	; 0x308a <uip_process+0xed8>
    }
#endif /* UIP_CONF_IPV6 */
  }

#if !UIP_CONF_IPV6
  if(uip_ipchksum() != 0xffff) { /* Compute and check the IP header
    2466:	eb dd       	rcall	.-1066   	; 0x203e <uip_ipchksum>
    2468:	01 96       	adiw	r24, 0x01	; 1
    246a:	09 f0       	breq	.+2      	; 0x246e <uip_process+0x2bc>
    246c:	0e c6       	rjmp	.+3100   	; 0x308a <uip_process+0xed8>
    246e:	80 91 e2 07 	lds	r24, 0x07E2
    UIP_LOG("ip: bad checksum.");
    goto drop;
  }
#endif /* UIP_CONF_IPV6 */

  if(BUF->proto == UIP_PROTO_TCP) { /* Check for TCP packet. If so,
    2472:	86 30       	cpi	r24, 0x06	; 6
    2474:	09 f4       	brne	.+2      	; 0x2478 <uip_process+0x2c6>
    2476:	5d c1       	rjmp	.+698    	; 0x2732 <uip_process+0x580>
    2478:	81 31       	cpi	r24, 0x11	; 17
				       processing. */
    goto tcp_input;
  }

#if UIP_UDP
  if(BUF->proto == UIP_PROTO_UDP) {
    247a:	e9 f1       	breq	.+122    	; 0x24f6 <uip_process+0x344>
    247c:	81 30       	cpi	r24, 0x01	; 1
  }
#endif /* UIP_UDP */

#if !UIP_CONF_IPV6
  /* ICMPv4 processing code follows. */
  if(BUF->proto != UIP_PROTO_ICMP) { /* We only allow ICMP packets from
    247e:	09 f0       	breq	.+2      	; 0x2482 <uip_process+0x2d0>
    2480:	04 c6       	rjmp	.+3080   	; 0x308a <uip_process+0xed8>
    2482:	80 91 ed 07 	lds	r24, 0x07ED
  UIP_STAT(++uip_stat.icmp.recv);

  /* ICMP echo (i.e., ping) processing. This is simple, we only change
     the ICMP type from ECHO to ECHO_REPLY and adjust the ICMP
     checksum before we return the packet. */
  if(ICMPBUF->type != ICMP_ECHO) {
    2486:	88 30       	cpi	r24, 0x08	; 8
    2488:	09 f0       	breq	.+2      	; 0x248c <uip_process+0x2da>
    248a:	ff c5       	rjmp	.+3070   	; 0x308a <uip_process+0xed8>
    248c:	10 92 ed 07 	sts	0x07ED, r1
  if(uip_ipaddr_cmp(&uip_hostaddr, &uip_all_zeroes_addr)) {
    uip_hostaddr = BUF->destipaddr;
  }
#endif /* UIP_PINGADDRCONF */

  ICMPBUF->type = ICMP_ECHO_REPLY;
    2490:	80 91 ef 07 	lds	r24, 0x07EF

  if(ICMPBUF->icmpchksum >= HTONS(0xffff - (ICMP_ECHO << 8))) {
    2494:	90 91 f0 07 	lds	r25, 0x07F0
    2498:	87 3f       	cpi	r24, 0xF7	; 247
    249a:	af ef       	ldi	r26, 0xFF	; 255
    249c:	9a 07       	cpc	r25, r26
    249e:	10 f0       	brcs	.+4      	; 0x24a4 <uip_process+0x2f2>
    24a0:	09 96       	adiw	r24, 0x09	; 9
    ICMPBUF->icmpchksum += HTONS(ICMP_ECHO << 8) + 1;
    24a2:	01 c0       	rjmp	.+2      	; 0x24a6 <uip_process+0x2f4>
    24a4:	08 96       	adiw	r24, 0x08	; 8
  } else {
    ICMPBUF->icmpchksum += HTONS(ICMP_ECHO << 8);
    24a6:	90 93 f0 07 	sts	0x07F0, r25
    24aa:	80 93 ef 07 	sts	0x07EF, r24
    24ae:	80 91 e5 07 	lds	r24, 0x07E5
  }

  /* Swap IP addresses. */
  uip_ipaddr_copy(&BUF->destipaddr, &BUF->srcipaddr);
    24b2:	90 91 e6 07 	lds	r25, 0x07E6
    24b6:	a0 91 e7 07 	lds	r26, 0x07E7
    24ba:	b0 91 e8 07 	lds	r27, 0x07E8
    24be:	80 93 e9 07 	sts	0x07E9, r24
    24c2:	90 93 ea 07 	sts	0x07EA, r25
    24c6:	a0 93 eb 07 	sts	0x07EB, r26
    24ca:	b0 93 ec 07 	sts	0x07EC, r27
    24ce:	80 91 c7 07 	lds	r24, 0x07C7
  uip_ipaddr_copy(&BUF->srcipaddr, &uip_hostaddr);
    24d2:	90 91 c8 07 	lds	r25, 0x07C8
    24d6:	a0 91 c9 07 	lds	r26, 0x07C9
    24da:	b0 91 ca 07 	lds	r27, 0x07CA
    24de:	80 93 e5 07 	sts	0x07E5, r24
    24e2:	90 93 e6 07 	sts	0x07E6, r25
    24e6:	a0 93 e7 07 	sts	0x07E7, r26
    24ea:	b0 93 e8 07 	sts	0x07E8, r27
    24ee:	80 e4       	ldi	r24, 0x40	; 64

  UIP_STAT(++uip_stat.icmp.sent);
  BUF->ttl = UIP_TTL;
    24f0:	80 93 e1 07 	sts	0x07E1, r24
    24f4:	a7 c5       	rjmp	.+2894   	; 0x3044 <uip_process+0xe92>
  goto ip_send_nolen;
    24f6:	0c 51       	subi	r16, 0x1C	; 28
    UIP_STAT(++uip_stat.udp.chkerr);
    UIP_LOG("udp: bad checksum.");
    goto drop;
  }
#else /* UIP_UDP_CHECKSUMS */
  uip_len = uip_len - UIP_IPUDPH_LEN;
    24f8:	11 09       	sbc	r17, r1
    24fa:	10 93 54 06 	sts	0x0654, r17
    24fe:	00 93 53 06 	sts	0x0653, r16
    2502:	89 eb       	ldi	r24, 0xB9	; 185
#endif /* UIP_UDP_CHECKSUMS */

  /* Demultiplex this UDP packet between the UDP "connections". */
  for(uip_udp_conn = &uip_udp_conns[0];
    2504:	9d e0       	ldi	r25, 0x0D	; 13
    2506:	90 93 5d 06 	sts	0x065D, r25
    250a:	80 93 5c 06 	sts	0x065C, r24
    250e:	a0 90 ef 07 	lds	r10, 0x07EF
       numbers match, the remote port number is checked if the
       connection is bound to a remote port. Finally, if the
       connection is bound to a remote IP address, the source IP
       address of the packet is checked. */
    if(uip_udp_conn->lport != 0 &&
       UDPBUF->destport == uip_udp_conn->lport &&
    2512:	b0 90 f0 07 	lds	r11, 0x07F0
    2516:	20 91 ed 07 	lds	r18, 0x07ED
       (uip_udp_conn->rport == 0 ||
        UDPBUF->srcport == uip_udp_conn->rport) &&
    251a:	30 91 ee 07 	lds	r19, 0x07EE
    251e:	40 91 dc 01 	lds	r20, 0x01DC
       (uip_ipaddr_cmp(&uip_udp_conn->ripaddr, &uip_all_zeroes_addr) ||
    2522:	50 91 dd 01 	lds	r21, 0x01DD
    2526:	60 91 de 01 	lds	r22, 0x01DE
	uip_ipaddr_cmp(&uip_udp_conn->ripaddr, &uip_broadcast_addr) ||
    252a:	70 91 df 01 	lds	r23, 0x01DF
    252e:	a0 91 e0 01 	lds	r26, 0x01E0
    2532:	b0 91 e1 01 	lds	r27, 0x01E1
    2536:	00 91 e5 07 	lds	r16, 0x07E5
	uip_ipaddr_cmp(&BUF->srcipaddr, &uip_udp_conn->ripaddr))) {
    253a:	10 91 e6 07 	lds	r17, 0x07E6
    253e:	e0 90 e7 07 	lds	r14, 0x07E7
    2542:	f0 90 e8 07 	lds	r15, 0x07E8
    2546:	e0 91 5c 06 	lds	r30, 0x065C
  uip_len = uip_len - UIP_IPUDPH_LEN;
#endif /* UIP_UDP_CHECKSUMS */

  /* Demultiplex this UDP packet between the UDP "connections". */
  for(uip_udp_conn = &uip_udp_conns[0];
      uip_udp_conn < &uip_udp_conns[UIP_UDP_CONNS];
    254a:	f0 91 5d 06 	lds	r31, 0x065D
    254e:	8d e0       	ldi	r24, 0x0D	; 13
#else /* UIP_UDP_CHECKSUMS */
  uip_len = uip_len - UIP_IPUDPH_LEN;
#endif /* UIP_UDP_CHECKSUMS */

  /* Demultiplex this UDP packet between the UDP "connections". */
  for(uip_udp_conn = &uip_udp_conns[0];
    2550:	e7 3d       	cpi	r30, 0xD7	; 215
    2552:	f8 07       	cpc	r31, r24
    2554:	88 f5       	brcc	.+98     	; 0x25b8 <uip_process+0x406>
    2556:	84 81       	ldd	r24, Z+4	; 0x04
       destination port number in the received packet. If the two port
       numbers match, the remote port number is checked if the
       connection is bound to a remote port. Finally, if the
       connection is bound to a remote IP address, the source IP
       address of the packet is checked. */
    if(uip_udp_conn->lport != 0 &&
    2558:	95 81       	ldd	r25, Z+5	; 0x05
    255a:	00 97       	sbiw	r24, 0x00	; 0
    255c:	39 f1       	breq	.+78     	; 0x25ac <uip_process+0x3fa>
    255e:	a8 16       	cp	r10, r24
    2560:	b9 06       	cpc	r11, r25
    2562:	21 f5       	brne	.+72     	; 0x25ac <uip_process+0x3fa>
    2564:	86 81       	ldd	r24, Z+6	; 0x06
       UDPBUF->destport == uip_udp_conn->lport &&
       (uip_udp_conn->rport == 0 ||
    2566:	97 81       	ldd	r25, Z+7	; 0x07
    2568:	00 97       	sbiw	r24, 0x00	; 0
       numbers match, the remote port number is checked if the
       connection is bound to a remote port. Finally, if the
       connection is bound to a remote IP address, the source IP
       address of the packet is checked. */
    if(uip_udp_conn->lport != 0 &&
       UDPBUF->destport == uip_udp_conn->lport &&
    256a:	19 f0       	breq	.+6      	; 0x2572 <uip_process+0x3c0>
    256c:	28 17       	cp	r18, r24
       (uip_udp_conn->rport == 0 ||
    256e:	39 07       	cpc	r19, r25
    2570:	e9 f4       	brne	.+58     	; 0x25ac <uip_process+0x3fa>
    2572:	80 81       	ld	r24, Z
        UDPBUF->srcport == uip_udp_conn->rport) &&
       (uip_ipaddr_cmp(&uip_udp_conn->ripaddr, &uip_all_zeroes_addr) ||
    2574:	91 81       	ldd	r25, Z+1	; 0x01
    2576:	8c 17       	cp	r24, r28
       connection is bound to a remote IP address, the source IP
       address of the packet is checked. */
    if(uip_udp_conn->lport != 0 &&
       UDPBUF->destport == uip_udp_conn->lport &&
       (uip_udp_conn->rport == 0 ||
        UDPBUF->srcport == uip_udp_conn->rport) &&
    2578:	9d 07       	cpc	r25, r29
    257a:	31 f4       	brne	.+12     	; 0x2588 <uip_process+0x3d6>
    257c:	c2 80       	ldd	r12, Z+2	; 0x02
       (uip_ipaddr_cmp(&uip_udp_conn->ripaddr, &uip_all_zeroes_addr) ||
    257e:	d3 80       	ldd	r13, Z+3	; 0x03
    2580:	c4 16       	cp	r12, r20
    2582:	d5 06       	cpc	r13, r21
    2584:	09 f4       	brne	.+2      	; 0x2588 <uip_process+0x3d6>
    2586:	67 c0       	rjmp	.+206    	; 0x2656 <uip_process+0x4a4>
    2588:	86 17       	cp	r24, r22
    258a:	97 07       	cpc	r25, r23
    258c:	31 f4       	brne	.+12     	; 0x259a <uip_process+0x3e8>
    258e:	c2 80       	ldd	r12, Z+2	; 0x02
	uip_ipaddr_cmp(&uip_udp_conn->ripaddr, &uip_broadcast_addr) ||
    2590:	d3 80       	ldd	r13, Z+3	; 0x03
    2592:	ca 16       	cp	r12, r26
    2594:	db 06       	cpc	r13, r27
    2596:	09 f4       	brne	.+2      	; 0x259a <uip_process+0x3e8>
    2598:	5e c0       	rjmp	.+188    	; 0x2656 <uip_process+0x4a4>
    259a:	08 17       	cp	r16, r24
    259c:	19 07       	cpc	r17, r25
    259e:	31 f4       	brne	.+12     	; 0x25ac <uip_process+0x3fa>
    25a0:	82 81       	ldd	r24, Z+2	; 0x02
	uip_ipaddr_cmp(&BUF->srcipaddr, &uip_udp_conn->ripaddr))) {
    25a2:	93 81       	ldd	r25, Z+3	; 0x03
    25a4:	e8 16       	cp	r14, r24
    25a6:	f9 06       	cpc	r15, r25
    25a8:	09 f4       	brne	.+2      	; 0x25ac <uip_process+0x3fa>
    25aa:	55 c0       	rjmp	.+170    	; 0x2656 <uip_process+0x4a4>
    25ac:	7e 96       	adiw	r30, 0x1e	; 30
#endif /* UIP_UDP_CHECKSUMS */

  /* Demultiplex this UDP packet between the UDP "connections". */
  for(uip_udp_conn = &uip_udp_conns[0];
      uip_udp_conn < &uip_udp_conns[UIP_UDP_CONNS];
      ++uip_udp_conn) {
    25ae:	f0 93 5d 06 	sts	0x065D, r31
    25b2:	e0 93 5c 06 	sts	0x065C, r30
    25b6:	c7 cf       	rjmp	.-114    	; 0x2546 <uip_process+0x394>
    25b8:	8c e1       	ldi	r24, 0x1C	; 28
    }
  }
  UIP_LOG("udp: no matching connection found");
#if UIP_CONF_ICMP_DEST_UNREACH && !UIP_CONF_IPV6
  /* Copy fields from packet header into payload of this ICMP packet. */
  memcpy(&(ICMPBUF->payload[0]), ICMPBUF, UIP_IPH_LEN + 8);
    25ba:	e9 ed       	ldi	r30, 0xD9	; 217
    25bc:	f7 e0       	ldi	r31, 0x07	; 7
    25be:	a5 ef       	ldi	r26, 0xF5	; 245
    25c0:	b7 e0       	ldi	r27, 0x07	; 7
    25c2:	01 90       	ld	r0, Z+
    25c4:	0d 92       	st	X+, r0
    25c6:	8a 95       	dec	r24
    25c8:	e1 f7       	brne	.-8      	; 0x25c2 <uip_process+0x410>
    25ca:	83 e0       	ldi	r24, 0x03	; 3

  /* Set the ICMP type and code. */
  ICMPBUF->type = ICMP_DEST_UNREACHABLE;
    25cc:	80 93 ed 07 	sts	0x07ED, r24
    25d0:	80 93 ee 07 	sts	0x07EE, r24
  ICMPBUF->icode = ICMP_PORT_UNREACHABLE;
    25d4:	10 92 f0 07 	sts	0x07F0, r1

  /* Calculate the ICMP checksum. */
  ICMPBUF->icmpchksum = 0;
    25d8:	10 92 ef 07 	sts	0x07EF, r1
    25dc:	64 e2       	ldi	r22, 0x24	; 36
  ICMPBUF->icmpchksum = ~uip_chksum((u16_t *)&(ICMPBUF->type), 36);
    25de:	70 e0       	ldi	r23, 0x00	; 0
    25e0:	8d ee       	ldi	r24, 0xED	; 237
    25e2:	97 e0       	ldi	r25, 0x07	; 7
    25e4:	23 dd       	rcall	.-1466   	; 0x202c <uip_chksum>
    25e6:	80 95       	com	r24
    25e8:	90 95       	com	r25
    25ea:	90 93 f0 07 	sts	0x07F0, r25
    25ee:	80 93 ef 07 	sts	0x07EF, r24
    25f2:	80 91 e5 07 	lds	r24, 0x07E5

  /* Set the IP destination address to be the source address of the
     original packet. */
  uip_ipaddr_copy(&BUF->destipaddr, &BUF->srcipaddr);
    25f6:	90 91 e6 07 	lds	r25, 0x07E6
    25fa:	a0 91 e7 07 	lds	r26, 0x07E7
    25fe:	b0 91 e8 07 	lds	r27, 0x07E8
    2602:	80 93 e9 07 	sts	0x07E9, r24
    2606:	90 93 ea 07 	sts	0x07EA, r25
    260a:	a0 93 eb 07 	sts	0x07EB, r26
    260e:	b0 93 ec 07 	sts	0x07EC, r27
    2612:	80 91 c7 07 	lds	r24, 0x07C7

  /* Set our IP address as the source address. */
  uip_ipaddr_copy(&BUF->srcipaddr, &uip_hostaddr);
    2616:	90 91 c8 07 	lds	r25, 0x07C8
    261a:	a0 91 c9 07 	lds	r26, 0x07C9
    261e:	b0 91 ca 07 	lds	r27, 0x07CA
    2622:	80 93 e5 07 	sts	0x07E5, r24
    2626:	90 93 e6 07 	sts	0x07E6, r25
    262a:	a0 93 e7 07 	sts	0x07E7, r26
    262e:	b0 93 e8 07 	sts	0x07E8, r27
    2632:	88 e3       	ldi	r24, 0x38	; 56
    2634:	90 e0       	ldi	r25, 0x00	; 0

  /* The size of the ICMP destination unreachable packet is 36 + the
     size of the IP header (20) = 56. */
  uip_len = 36 + UIP_IPH_LEN;
    2636:	90 93 54 06 	sts	0x0654, r25
    263a:	80 93 53 06 	sts	0x0653, r24
    263e:	10 92 db 07 	sts	0x07DB, r1
  ICMPBUF->len[0] = 0;
    2642:	88 e3       	ldi	r24, 0x38	; 56
    2644:	80 93 dc 07 	sts	0x07DC, r24
  ICMPBUF->len[1] = (u8_t)uip_len;
    2648:	80 e4       	ldi	r24, 0x40	; 64
    264a:	80 93 e1 07 	sts	0x07E1, r24
  ICMPBUF->ttl = UIP_TTL;
    264e:	81 e0       	ldi	r24, 0x01	; 1
    2650:	80 93 e2 07 	sts	0x07E2, r24
  ICMPBUF->proto = UIP_PROTO_ICMP;
    2654:	f7 c4       	rjmp	.+2542   	; 0x3044 <uip_process+0xe92>
    2656:	10 92 61 06 	sts	0x0661, r1
#else /* UIP_CONF_ICMP_DEST_UNREACH */
  goto drop;
#endif /* UIP_CONF_ICMP_DEST_UNREACH */

 udp_found:
  uip_conn = NULL;
    265a:	10 92 60 06 	sts	0x0660, r1
    265e:	82 e0       	ldi	r24, 0x02	; 2
    2660:	80 93 5b 06 	sts	0x065B, r24
  uip_flags = UIP_NEWDATA;
    2664:	85 ef       	ldi	r24, 0xF5	; 245
    2666:	97 e0       	ldi	r25, 0x07	; 7
  uip_sappdata = uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];
    2668:	90 93 5f 06 	sts	0x065F, r25
    266c:	80 93 5e 06 	sts	0x065E, r24
    2670:	90 93 56 06 	sts	0x0656, r25
    2674:	80 93 55 06 	sts	0x0655, r24
    2678:	10 92 b8 0d 	sts	0x0DB8, r1
  uip_slen = 0;
    267c:	10 92 b7 0d 	sts	0x0DB7, r1
    2680:	0e 94 5a 09 	call	0x12b4	; 0x12b4 <uIPManagement_UDPCallback>
  UIP_UDP_APPCALL();
    2684:	80 91 b7 0d 	lds	r24, 0x0DB7

 udp_send:
  if(uip_slen == 0) {
    2688:	90 91 b8 0d 	lds	r25, 0x0DB8
    268c:	00 97       	sbiw	r24, 0x00	; 0
    268e:	09 f4       	brne	.+2      	; 0x2692 <uip_process+0x4e0>
    2690:	fc c4       	rjmp	.+2552   	; 0x308a <uip_process+0xed8>
    2692:	9c 01       	movw	r18, r24
    2694:	24 5e       	subi	r18, 0xE4	; 228
    goto drop;
  }
  uip_len = uip_slen + UIP_IPUDPH_LEN;
    2696:	3f 4f       	sbci	r19, 0xFF	; 255
    2698:	30 93 54 06 	sts	0x0654, r19
    269c:	20 93 53 06 	sts	0x0653, r18
    26a0:	30 93 db 07 	sts	0x07DB, r19
  /* For IPv6, the IP length field does not include the IPv6 IP header
     length. */
  BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
  BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
#else /* UIP_CONF_IPV6 */
  BUF->len[0] = (uip_len >> 8);
    26a4:	20 93 dc 07 	sts	0x07DC, r18
  BUF->len[1] = (uip_len & 0xff);
    26a8:	e0 91 5c 06 	lds	r30, 0x065C
#endif /* UIP_CONF_IPV6 */

  BUF->ttl = uip_udp_conn->ttl;
    26ac:	f0 91 5d 06 	lds	r31, 0x065D
    26b0:	20 85       	ldd	r18, Z+8	; 0x08
    26b2:	20 93 e1 07 	sts	0x07E1, r18
    26b6:	21 e1       	ldi	r18, 0x11	; 17
    26b8:	20 93 e2 07 	sts	0x07E2, r18
  BUF->proto = UIP_PROTO_UDP;
    26bc:	08 96       	adiw	r24, 0x08	; 8
    26be:	98 27       	eor	r25, r24

  UDPBUF->udplen = HTONS(uip_slen + UIP_UDPH_LEN);
    26c0:	89 27       	eor	r24, r25
    26c2:	98 27       	eor	r25, r24
    26c4:	90 93 f2 07 	sts	0x07F2, r25
    26c8:	80 93 f1 07 	sts	0x07F1, r24
    26cc:	10 92 f4 07 	sts	0x07F4, r1
  UDPBUF->udpchksum = 0;
    26d0:	10 92 f3 07 	sts	0x07F3, r1
    26d4:	84 81       	ldd	r24, Z+4	; 0x04
    26d6:	95 81       	ldd	r25, Z+5	; 0x05

  BUF->srcport  = uip_udp_conn->lport;
    26d8:	90 93 ee 07 	sts	0x07EE, r25
    26dc:	80 93 ed 07 	sts	0x07ED, r24
    26e0:	86 81       	ldd	r24, Z+6	; 0x06
    26e2:	97 81       	ldd	r25, Z+7	; 0x07
  BUF->destport = uip_udp_conn->rport;
    26e4:	90 93 f0 07 	sts	0x07F0, r25
    26e8:	80 93 ef 07 	sts	0x07EF, r24
    26ec:	80 91 c7 07 	lds	r24, 0x07C7

  uip_ipaddr_copy(&BUF->srcipaddr, &uip_hostaddr);
    26f0:	90 91 c8 07 	lds	r25, 0x07C8
    26f4:	a0 91 c9 07 	lds	r26, 0x07C9
    26f8:	b0 91 ca 07 	lds	r27, 0x07CA
    26fc:	80 93 e5 07 	sts	0x07E5, r24
    2700:	90 93 e6 07 	sts	0x07E6, r25
    2704:	a0 93 e7 07 	sts	0x07E7, r26
    2708:	b0 93 e8 07 	sts	0x07E8, r27
    270c:	80 81       	ld	r24, Z
    270e:	91 81       	ldd	r25, Z+1	; 0x01
  uip_ipaddr_copy(&BUF->destipaddr, &uip_udp_conn->ripaddr);
    2710:	a2 81       	ldd	r26, Z+2	; 0x02
    2712:	b3 81       	ldd	r27, Z+3	; 0x03
    2714:	80 93 e9 07 	sts	0x07E9, r24
    2718:	90 93 ea 07 	sts	0x07EA, r25
    271c:	a0 93 eb 07 	sts	0x07EB, r26
    2720:	b0 93 ec 07 	sts	0x07EC, r27
    2724:	81 e0       	ldi	r24, 0x01	; 1
    2726:	98 e0       	ldi	r25, 0x08	; 8

  uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPTCPH_LEN];
    2728:	90 93 5f 06 	sts	0x065F, r25
    272c:	80 93 5e 06 	sts	0x065E, r24
    2730:	89 c4       	rjmp	.+2322   	; 0x3044 <uip_process+0xe92>
    2732:	95 dc       	rcall	.-1750   	; 0x205e <uip_tcpchksum>
  if(UDPBUF->udpchksum == 0) {
    UDPBUF->udpchksum = 0xffff;
  }
#endif /* UIP_UDP_CHECKSUMS */

  goto ip_send_nolen;
    2734:	01 96       	adiw	r24, 0x01	; 1
 tcp_input:
  UIP_STAT(++uip_stat.tcp.recv);

  /* Start of TCP input header processing code. */

  if(uip_tcpchksum() != 0xffff) {   /* Compute and check the TCP
    2736:	09 f0       	breq	.+2      	; 0x273a <uip_process+0x588>
    2738:	a8 c4       	rjmp	.+2384   	; 0x308a <uip_process+0xed8>
    273a:	80 91 ef 07 	lds	r24, 0x07EF
    273e:	90 91 f0 07 	lds	r25, 0x07F0
  /* Demultiplex this segment. */
  /* First check any active connections. */
  for(uip_connr = &uip_conns[0]; uip_connr <= &uip_conns[UIP_CONNS - 1];
      ++uip_connr) {
    if(uip_connr->tcpstateflags != UIP_CLOSED &&
       BUF->destport == uip_connr->lport &&
    2742:	20 91 ed 07 	lds	r18, 0x07ED
    2746:	30 91 ee 07 	lds	r19, 0x07EE
       BUF->srcport == uip_connr->rport &&
    274a:	40 91 e5 07 	lds	r20, 0x07E5
    274e:	50 91 e6 07 	lds	r21, 0x07E6
       uip_ipaddr_cmp(&BUF->srcipaddr, &uip_connr->ripaddr)) {
    2752:	60 91 e7 07 	lds	r22, 0x07E7
    2756:	70 91 e8 07 	lds	r23, 0x07E8
    275a:	eb e7       	ldi	r30, 0x7B	; 123
    275c:	f6 e0       	ldi	r31, 0x06	; 6
    275e:	c2 e6       	ldi	r28, 0x62	; 98
    2760:	d6 e0       	ldi	r29, 0x06	; 6
    2762:	f0 80       	ld	r15, Z
    2764:	ff 20       	and	r15, r15
    2766:	a9 f0       	breq	.+42     	; 0x2792 <uip_process+0x5e0>

  /* Demultiplex this segment. */
  /* First check any active connections. */
  for(uip_connr = &uip_conns[0]; uip_connr <= &uip_conns[UIP_CONNS - 1];
      ++uip_connr) {
    if(uip_connr->tcpstateflags != UIP_CLOSED &&
    2768:	ac 81       	ldd	r26, Y+4	; 0x04
    276a:	bd 81       	ldd	r27, Y+5	; 0x05
    276c:	8a 17       	cp	r24, r26
    276e:	9b 07       	cpc	r25, r27
    2770:	81 f4       	brne	.+32     	; 0x2792 <uip_process+0x5e0>
    2772:	ae 81       	ldd	r26, Y+6	; 0x06
    2774:	bf 81       	ldd	r27, Y+7	; 0x07
    2776:	2a 17       	cp	r18, r26
       BUF->destport == uip_connr->lport &&
    2778:	3b 07       	cpc	r19, r27
    277a:	59 f4       	brne	.+22     	; 0x2792 <uip_process+0x5e0>
    277c:	a8 81       	ld	r26, Y
    277e:	b9 81       	ldd	r27, Y+1	; 0x01
    2780:	4a 17       	cp	r20, r26
       BUF->srcport == uip_connr->rport &&
    2782:	5b 07       	cpc	r21, r27
    2784:	31 f4       	brne	.+12     	; 0x2792 <uip_process+0x5e0>
    2786:	aa 81       	ldd	r26, Y+2	; 0x02
    2788:	bb 81       	ldd	r27, Y+3	; 0x03
    278a:	6a 17       	cp	r22, r26
       uip_ipaddr_cmp(&BUF->srcipaddr, &uip_connr->ripaddr)) {
    278c:	7b 07       	cpc	r23, r27
    278e:	09 f4       	brne	.+2      	; 0x2792 <uip_process+0x5e0>
    2790:	78 c1       	rjmp	.+752    	; 0x2a82 <uip_process+0x8d0>
    2792:	cf 58       	subi	r28, 0x8F	; 143
    2794:	df 4f       	sbci	r29, 0xFF	; 255
    2796:	ef 58       	subi	r30, 0x8F	; 143
  }

  /* Demultiplex this segment. */
  /* First check any active connections. */
  for(uip_connr = &uip_conns[0]; uip_connr <= &uip_conns[UIP_CONNS - 1];
      ++uip_connr) {
    2798:	ff 4f       	sbci	r31, 0xFF	; 255
    279a:	a7 e0       	ldi	r26, 0x07	; 7
    279c:	c5 3b       	cpi	r28, 0xB5	; 181
    279e:	da 07       	cpc	r29, r26
    goto drop;
  }

  /* Demultiplex this segment. */
  /* First check any active connections. */
  for(uip_connr = &uip_conns[0]; uip_connr <= &uip_conns[UIP_CONNS - 1];
    27a0:	01 f7       	brne	.-64     	; 0x2762 <uip_process+0x5b0>
    27a2:	20 91 fa 07 	lds	r18, 0x07FA
    27a6:	2f 73       	andi	r18, 0x3F	; 63

  /* If we didn't find and active connection that expected the packet,
     either this packet is an old duplicate, or this is a SYN packet
     destined for a connection in LISTEN. If the SYN flag isn't set,
     it is an old packet and we send a RST. */
  if((BUF->flags & TCP_CTL) != TCP_SYN) {
    27a8:	22 30       	cpi	r18, 0x02	; 2
    27aa:	e1 f4       	brne	.+56     	; 0x27e4 <uip_process+0x632>
    27ac:	90 93 93 03 	sts	0x0393, r25
    27b0:	80 93 92 03 	sts	0x0392, r24
    goto reset;
  }

  tmp16 = BUF->destport;
    27b4:	40 e0       	ldi	r20, 0x00	; 0
    27b6:	45 30       	cpi	r20, 0x05	; 5
    27b8:	98 f4       	brcc	.+38     	; 0x27e0 <uip_process+0x62e>
  /* Next, check listening connections. */
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    27ba:	e4 2f       	mov	r30, r20
    27bc:	f0 e0       	ldi	r31, 0x00	; 0
    27be:	ee 0f       	add	r30, r30
    if(tmp16 == uip_listenports[c]) {
    27c0:	ff 1f       	adc	r31, r31
    27c2:	eb 54       	subi	r30, 0x4B	; 75
    27c4:	f8 4f       	sbci	r31, 0xF8	; 248
    27c6:	20 81       	ld	r18, Z
    27c8:	31 81       	ldd	r19, Z+1	; 0x01
    27ca:	4f 5f       	subi	r20, 0xFF	; 255
    27cc:	82 17       	cp	r24, r18
    27ce:	93 07       	cpc	r25, r19
    27d0:	91 f7       	brne	.-28     	; 0x27b6 <uip_process+0x604>
    27d2:	10 92 95 03 	sts	0x0395, r1
    27d6:	20 e0       	ldi	r18, 0x00	; 0
     unused ones have the tcpstate set to CLOSED. Also, connections in
     TIME_WAIT are kept track of and we'll use the oldest one if no
     CLOSED connections are found. Thanks to Eddie C. Dost for a very
     nice algorithm for the TIME_WAIT search. */
  uip_connr = 0;
  for(c = 0; c < UIP_CONNS; ++c) {
    27d8:	c0 e0       	ldi	r28, 0x00	; 0
    27da:	d0 e0       	ldi	r29, 0x00	; 0
    27dc:	31 e7       	ldi	r19, 0x71	; 113
     connections are kept in the same table as used connections, but
     unused ones have the tcpstate set to CLOSED. Also, connections in
     TIME_WAIT are kept track of and we'll use the oldest one if no
     CLOSED connections are found. Thanks to Eddie C. Dost for a very
     nice algorithm for the TIME_WAIT search. */
  uip_connr = 0;
    27de:	7e c0       	rjmp	.+252    	; 0x28dc <uip_process+0x72a>
    27e0:	40 93 95 03 	sts	0x0395, r20
  for(c = 0; c < UIP_CONNS; ++c) {
    27e4:	80 91 fa 07 	lds	r24, 0x07FA
    27e8:	82 fd       	sbrc	r24, 2
  /* No matching connection found, so we send a RST packet. */
  UIP_STAT(++uip_stat.tcp.synrst);

 reset:
  /* We do not send resets in response to resets. */
  if(BUF->flags & TCP_RST) {
    27ea:	4f c4       	rjmp	.+2206   	; 0x308a <uip_process+0xed8>
    27ec:	84 e1       	ldi	r24, 0x14	; 20
    27ee:	80 93 fa 07 	sts	0x07FA, r24
    goto drop;
  }

  UIP_STAT(++uip_stat.tcp.rst);

  BUF->flags = TCP_RST | TCP_ACK;
    27f2:	88 e2       	ldi	r24, 0x28	; 40
    27f4:	90 e0       	ldi	r25, 0x00	; 0
    27f6:	90 93 54 06 	sts	0x0654, r25
  uip_len = UIP_IPTCPH_LEN;
    27fa:	80 93 53 06 	sts	0x0653, r24
    27fe:	80 e5       	ldi	r24, 0x50	; 80
    2800:	80 93 f9 07 	sts	0x07F9, r24
  BUF->tcpoffset = 5 << 4;
    2804:	80 91 f4 07 	lds	r24, 0x07F4
    2808:	90 91 f8 07 	lds	r25, 0x07F8

  /* Flip the seqno and ackno fields in the TCP header. */
  c = BUF->seqno[3];
    280c:	90 93 f4 07 	sts	0x07F4, r25
  BUF->seqno[3] = BUF->ackno[3];
    2810:	30 91 f3 07 	lds	r19, 0x07F3
    2814:	90 91 f7 07 	lds	r25, 0x07F7
  BUF->ackno[3] = c;

  c = BUF->seqno[2];
    2818:	90 93 f3 07 	sts	0x07F3, r25
  BUF->seqno[2] = BUF->ackno[2];
    281c:	30 93 f7 07 	sts	0x07F7, r19
    2820:	20 91 f2 07 	lds	r18, 0x07F2
  BUF->ackno[2] = c;
    2824:	90 91 f6 07 	lds	r25, 0x07F6

  c = BUF->seqno[1];
    2828:	90 93 f2 07 	sts	0x07F2, r25
  BUF->seqno[1] = BUF->ackno[1];
    282c:	20 93 f6 07 	sts	0x07F6, r18
    2830:	90 91 f1 07 	lds	r25, 0x07F1
  BUF->ackno[1] = c;
    2834:	90 93 95 03 	sts	0x0395, r25

  c = BUF->seqno[0];
    2838:	40 91 f5 07 	lds	r20, 0x07F5
    283c:	40 93 f1 07 	sts	0x07F1, r20
  BUF->seqno[0] = BUF->ackno[0];
    2840:	90 93 f5 07 	sts	0x07F5, r25
    2844:	8f 5f       	subi	r24, 0xFF	; 255
  BUF->ackno[0] = c;
    2846:	80 93 f8 07 	sts	0x07F8, r24

  /* We also have to increase the sequence number we are
     acknowledging. If the least significant byte overflowed, we need
     to propagate the carry to the other bytes as well. */
  if(++BUF->ackno[3] == 0) {
    284a:	81 11       	cpse	r24, r1
    284c:	0f c0       	rjmp	.+30     	; 0x286c <uip_process+0x6ba>
    284e:	81 e0       	ldi	r24, 0x01	; 1
    2850:	83 0f       	add	r24, r19
    2852:	80 93 f7 07 	sts	0x07F7, r24
    if(++BUF->ackno[2] == 0) {
    2856:	81 11       	cpse	r24, r1
    2858:	09 c0       	rjmp	.+18     	; 0x286c <uip_process+0x6ba>
    285a:	81 e0       	ldi	r24, 0x01	; 1
    285c:	82 0f       	add	r24, r18
    285e:	80 93 f6 07 	sts	0x07F6, r24
      if(++BUF->ackno[1] == 0) {
    2862:	81 11       	cpse	r24, r1
    2864:	03 c0       	rjmp	.+6      	; 0x286c <uip_process+0x6ba>
    2866:	9f 5f       	subi	r25, 0xFF	; 255
    2868:	90 93 f5 07 	sts	0x07F5, r25
	++BUF->ackno[0];
    286c:	80 91 ed 07 	lds	r24, 0x07ED
    2870:	90 91 ee 07 	lds	r25, 0x07EE
      }
    }
  }

  /* Swap port numbers. */
  tmp16 = BUF->srcport;
    2874:	90 93 93 03 	sts	0x0393, r25
    2878:	80 93 92 03 	sts	0x0392, r24
    287c:	20 91 ef 07 	lds	r18, 0x07EF
    2880:	30 91 f0 07 	lds	r19, 0x07F0
  BUF->srcport = BUF->destport;
    2884:	30 93 ee 07 	sts	0x07EE, r19
    2888:	20 93 ed 07 	sts	0x07ED, r18
    288c:	90 93 f0 07 	sts	0x07F0, r25
    2890:	80 93 ef 07 	sts	0x07EF, r24
  BUF->destport = tmp16;
    2894:	80 91 e5 07 	lds	r24, 0x07E5
    2898:	90 91 e6 07 	lds	r25, 0x07E6

  /* Swap IP addresses. */
  uip_ipaddr_copy(&BUF->destipaddr, &BUF->srcipaddr);
    289c:	a0 91 e7 07 	lds	r26, 0x07E7
    28a0:	b0 91 e8 07 	lds	r27, 0x07E8
    28a4:	80 93 e9 07 	sts	0x07E9, r24
    28a8:	90 93 ea 07 	sts	0x07EA, r25
    28ac:	a0 93 eb 07 	sts	0x07EB, r26
    28b0:	b0 93 ec 07 	sts	0x07EC, r27
    28b4:	80 91 c7 07 	lds	r24, 0x07C7
    28b8:	90 91 c8 07 	lds	r25, 0x07C8
  uip_ipaddr_copy(&BUF->srcipaddr, &uip_hostaddr);
    28bc:	a0 91 c9 07 	lds	r26, 0x07C9
    28c0:	b0 91 ca 07 	lds	r27, 0x07CA
    28c4:	80 93 e5 07 	sts	0x07E5, r24
    28c8:	90 93 e6 07 	sts	0x07E6, r25
    28cc:	a0 93 e7 07 	sts	0x07E7, r26
    28d0:	b0 93 e8 07 	sts	0x07E8, r27
    28d4:	9d c3       	rjmp	.+1850   	; 0x3010 <uip_process+0xe5e>
    28d6:	47 30       	cpi	r20, 0x07	; 7
    28d8:	99 f0       	breq	.+38     	; 0x2900 <uip_process+0x74e>

  /* And send out the RST packet! */
  goto tcp_send_noconn;
    28da:	2f 5f       	subi	r18, 0xFF	; 255
  for(c = 0; c < UIP_CONNS; ++c) {
    if(uip_conns[c].tcpstateflags == UIP_CLOSED) {
      uip_connr = &uip_conns[c];
      break;
    }
    if(uip_conns[c].tcpstateflags == UIP_TIME_WAIT) {
    28dc:	23 30       	cpi	r18, 0x03	; 3
    28de:	f0 f4       	brcc	.+60     	; 0x291c <uip_process+0x76a>
    28e0:	82 2f       	mov	r24, r18
     unused ones have the tcpstate set to CLOSED. Also, connections in
     TIME_WAIT are kept track of and we'll use the oldest one if no
     CLOSED connections are found. Thanks to Eddie C. Dost for a very
     nice algorithm for the TIME_WAIT search. */
  uip_connr = 0;
  for(c = 0; c < UIP_CONNS; ++c) {
    28e2:	90 e0       	ldi	r25, 0x00	; 0
    28e4:	38 9f       	mul	r19, r24
    if(uip_conns[c].tcpstateflags == UIP_CLOSED) {
    28e6:	f0 01       	movw	r30, r0
    28e8:	39 9f       	mul	r19, r25
    28ea:	f0 0d       	add	r31, r0
    28ec:	11 24       	eor	r1, r1
    28ee:	ee 59       	subi	r30, 0x9E	; 158
    28f0:	f9 4f       	sbci	r31, 0xF9	; 249
    28f2:	41 8d       	ldd	r20, Z+25	; 0x19
    28f4:	41 11       	cpse	r20, r1
    28f6:	ef cf       	rjmp	.-34     	; 0x28d6 <uip_process+0x724>
    28f8:	20 93 95 03 	sts	0x0395, r18
    28fc:	ef 01       	movw	r28, r30
    28fe:	10 c0       	rjmp	.+32     	; 0x2920 <uip_process+0x76e>
    2900:	20 97       	sbiw	r28, 0x00	; 0
      uip_connr = &uip_conns[c];
    2902:	21 f0       	breq	.+8      	; 0x290c <uip_process+0x75a>
      break;
    2904:	52 8d       	ldd	r21, Z+26	; 0x1a
    }
    if(uip_conns[c].tcpstateflags == UIP_TIME_WAIT) {
      if(uip_connr == 0 ||
    2906:	4a 8d       	ldd	r20, Y+26	; 0x1a
    2908:	45 17       	cp	r20, r21
    290a:	38 f7       	brcc	.-50     	; 0x28da <uip_process+0x728>
    290c:	38 9f       	mul	r19, r24
    290e:	e0 01       	movw	r28, r0
    2910:	39 9f       	mul	r19, r25
	 uip_conns[c].timer > uip_connr->timer) {
	uip_connr = &uip_conns[c];
    2912:	d0 0d       	add	r29, r0
    2914:	11 24       	eor	r1, r1
    2916:	ce 59       	subi	r28, 0x9E	; 158
    2918:	d9 4f       	sbci	r29, 0xF9	; 249
    291a:	df cf       	rjmp	.-66     	; 0x28da <uip_process+0x728>
    291c:	20 93 95 03 	sts	0x0395, r18
    2920:	20 97       	sbiw	r28, 0x00	; 0
    2922:	09 f4       	brne	.+2      	; 0x2926 <uip_process+0x774>
    2924:	b2 c3       	rjmp	.+1892   	; 0x308a <uip_process+0xed8>
      }
    }
  }

  if(uip_connr == 0) {
    2926:	d0 93 61 06 	sts	0x0661, r29
    292a:	c0 93 60 06 	sts	0x0660, r28
       have more spare connections. */
    UIP_STAT(++uip_stat.tcp.syndrop);
    UIP_LOG("tcp: found no unused connections.");
    goto drop;
  }
  uip_conn = uip_connr;
    292e:	83 e0       	ldi	r24, 0x03	; 3
    2930:	8a 8f       	std	Y+26, r24	; 0x1a
    2932:	88 8f       	std	Y+24, r24	; 0x18

  /* Fill in the necessary fields for the new connection. */
  uip_connr->rto = uip_connr->timer = UIP_RTO;
    2934:	1e 8a       	std	Y+22, r1	; 0x16
    2936:	84 e0       	ldi	r24, 0x04	; 4
    2938:	8f 8b       	std	Y+23, r24	; 0x17
  uip_connr->sa = 0;
    293a:	1b 8e       	std	Y+27, r1	; 0x1b
  uip_connr->sv = 4;
    293c:	80 91 ef 07 	lds	r24, 0x07EF
  uip_connr->nrtx = 0;
    2940:	90 91 f0 07 	lds	r25, 0x07F0
  uip_connr->lport = BUF->destport;
    2944:	9d 83       	std	Y+5, r25	; 0x05
    2946:	8c 83       	std	Y+4, r24	; 0x04
    2948:	80 91 ed 07 	lds	r24, 0x07ED
    294c:	90 91 ee 07 	lds	r25, 0x07EE
  uip_connr->rport = BUF->srcport;
    2950:	9f 83       	std	Y+7, r25	; 0x07
    2952:	8e 83       	std	Y+6, r24	; 0x06
    2954:	80 91 e5 07 	lds	r24, 0x07E5
    2958:	90 91 e6 07 	lds	r25, 0x07E6
  uip_ipaddr_copy(&uip_connr->ripaddr, &BUF->srcipaddr);
    295c:	a0 91 e7 07 	lds	r26, 0x07E7
    2960:	b0 91 e8 07 	lds	r27, 0x07E8
    2964:	88 83       	st	Y, r24
    2966:	99 83       	std	Y+1, r25	; 0x01
    2968:	aa 83       	std	Y+2, r26	; 0x02
    296a:	bb 83       	std	Y+3, r27	; 0x03
    296c:	81 e0       	ldi	r24, 0x01	; 1
    296e:	89 8f       	std	Y+25, r24	; 0x19
    2970:	80 91 98 03 	lds	r24, 0x0398
  uip_connr->tcpstateflags = UIP_SYN_RCVD;
    2974:	8c 87       	std	Y+12, r24	; 0x0c

  uip_connr->snd_nxt[0] = iss[0];
    2976:	80 91 99 03 	lds	r24, 0x0399
    297a:	8d 87       	std	Y+13, r24	; 0x0d
  uip_connr->snd_nxt[1] = iss[1];
    297c:	80 91 9a 03 	lds	r24, 0x039A
    2980:	8e 87       	std	Y+14, r24	; 0x0e
  uip_connr->snd_nxt[2] = iss[2];
    2982:	80 91 9b 03 	lds	r24, 0x039B
    2986:	8f 87       	std	Y+15, r24	; 0x0f
  uip_connr->snd_nxt[3] = iss[3];
    2988:	81 e0       	ldi	r24, 0x01	; 1
    298a:	90 e0       	ldi	r25, 0x00	; 0
    298c:	99 8b       	std	Y+17, r25	; 0x11
  uip_connr->len = 1;
    298e:	88 8b       	std	Y+16, r24	; 0x10
    2990:	80 91 f4 07 	lds	r24, 0x07F4
    2994:	8b 87       	std	Y+11, r24	; 0x0b

  /* rcv_nxt should be the seqno from the incoming packet + 1. */
  uip_connr->rcv_nxt[3] = BUF->seqno[3];
    2996:	80 91 f3 07 	lds	r24, 0x07F3
    299a:	8a 87       	std	Y+10, r24	; 0x0a
  uip_connr->rcv_nxt[2] = BUF->seqno[2];
    299c:	80 91 f2 07 	lds	r24, 0x07F2
    29a0:	89 87       	std	Y+9, r24	; 0x09
  uip_connr->rcv_nxt[1] = BUF->seqno[1];
    29a2:	80 91 f1 07 	lds	r24, 0x07F1
    29a6:	88 87       	std	Y+8, r24	; 0x08
  uip_connr->rcv_nxt[0] = BUF->seqno[0];
    29a8:	81 e0       	ldi	r24, 0x01	; 1
    29aa:	90 e0       	ldi	r25, 0x00	; 0
    29ac:	26 db       	rcall	.-2484   	; 0x1ffa <uip_add_rcv_nxt>
  uip_add_rcv_nxt(1);
    29ae:	80 91 f9 07 	lds	r24, 0x07F9
    29b2:	28 2f       	mov	r18, r24
    29b4:	20 7f       	andi	r18, 0xF0	; 240

  /* Parse the TCP MSS option, if present. */
  if((BUF->tcpoffset & 0xf0) > 0x50) {
    29b6:	30 e0       	ldi	r19, 0x00	; 0
    29b8:	21 35       	cpi	r18, 0x51	; 81
    29ba:	31 05       	cpc	r19, r1
    29bc:	0c f4       	brge	.+2      	; 0x29c0 <uip_process+0x80e>
    29be:	45 c0       	rjmp	.+138    	; 0x2a4a <uip_process+0x898>
    29c0:	82 95       	swap	r24
    29c2:	8f 70       	andi	r24, 0x0F	; 15
    29c4:	90 e0       	ldi	r25, 0x00	; 0
    29c6:	05 97       	sbiw	r24, 0x05	; 5
    for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
    29c8:	88 0f       	add	r24, r24
    29ca:	99 1f       	adc	r25, r25
    29cc:	88 0f       	add	r24, r24
    29ce:	99 1f       	adc	r25, r25
    29d0:	30 91 94 03 	lds	r19, 0x0394
    29d4:	20 e0       	ldi	r18, 0x00	; 0
    29d6:	e2 2f       	mov	r30, r18
    29d8:	f0 e0       	ldi	r31, 0x00	; 0
    29da:	e8 17       	cp	r30, r24
    29dc:	f9 07       	cpc	r31, r25
    29de:	8c f5       	brge	.+98     	; 0x2a42 <uip_process+0x890>
    29e0:	e5 53       	subi	r30, 0x35	; 53
    29e2:	f8 4f       	sbci	r31, 0xF8	; 248
    29e4:	36 a9       	ldd	r19, Z+54	; 0x36
    29e6:	31 11       	cpse	r19, r1
      opt = uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + c];
    29e8:	05 c0       	rjmp	.+10     	; 0x29f4 <uip_process+0x842>
    29ea:	20 93 95 03 	sts	0x0395, r18
      if(opt == TCP_OPT_END) {
    29ee:	10 92 94 03 	sts	0x0394, r1
    29f2:	2b c0       	rjmp	.+86     	; 0x2a4a <uip_process+0x898>
    29f4:	31 30       	cpi	r19, 0x01	; 1
    29f6:	11 f4       	brne	.+4      	; 0x29fc <uip_process+0x84a>
    29f8:	2f 5f       	subi	r18, 0xFF	; 255
    29fa:	ed cf       	rjmp	.-38     	; 0x29d6 <uip_process+0x824>
	/* End of options. */
	break;
      } else if(opt == TCP_OPT_NOOP) {
    29fc:	32 30       	cpi	r19, 0x02	; 2
    29fe:	e1 f4       	brne	.+56     	; 0x2a38 <uip_process+0x886>
	++c;
    2a00:	47 a9       	ldd	r20, Z+55	; 0x37
    2a02:	44 30       	cpi	r20, 0x04	; 4
	/* NOP option. */
      } else if(opt == TCP_OPT_MSS &&
    2a04:	c9 f4       	brne	.+50     	; 0x2a38 <uip_process+0x886>
    2a06:	20 93 95 03 	sts	0x0395, r18
    2a0a:	30 93 94 03 	sts	0x0394, r19
    2a0e:	80 ad       	ldd	r24, Z+56	; 0x38
    2a10:	90 e0       	ldi	r25, 0x00	; 0
    2a12:	98 2f       	mov	r25, r24
    2a14:	88 27       	eor	r24, r24
		uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
	/* An MSS option with the right option length. */
	tmp16 = ((u16_t)uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
    2a16:	21 ad       	ldd	r18, Z+57	; 0x39
    2a18:	82 2b       	or	r24, r18
    2a1a:	90 93 93 03 	sts	0x0393, r25
	  (u16_t)uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + 3 + c];
    2a1e:	80 93 92 03 	sts	0x0392, r24
	++c;
	/* NOP option. */
      } else if(opt == TCP_OPT_MSS &&
		uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
	/* An MSS option with the right option length. */
	tmp16 = ((u16_t)uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
    2a22:	85 3b       	cpi	r24, 0xB5	; 181
    2a24:	25 e0       	ldi	r18, 0x05	; 5
    2a26:	92 07       	cpc	r25, r18
    2a28:	10 f0       	brcs	.+4      	; 0x2a2e <uip_process+0x87c>
	  (u16_t)uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + 3 + c];
	uip_connr->initialmss = uip_connr->mss =
	  tmp16 > UIP_TCP_MSS? UIP_TCP_MSS: tmp16;
    2a2a:	84 eb       	ldi	r24, 0xB4	; 180
    2a2c:	95 e0       	ldi	r25, 0x05	; 5
    2a2e:	9b 8b       	std	Y+19, r25	; 0x13
    2a30:	8a 8b       	std	Y+18, r24	; 0x12
    2a32:	9d 8b       	std	Y+21, r25	; 0x15
    2a34:	8c 8b       	std	Y+20, r24	; 0x14
      } else if(opt == TCP_OPT_MSS &&
		uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
	/* An MSS option with the right option length. */
	tmp16 = ((u16_t)uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
	  (u16_t)uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + 3 + c];
	uip_connr->initialmss = uip_connr->mss =
    2a36:	09 c0       	rjmp	.+18     	; 0x2a4a <uip_process+0x898>
    2a38:	47 a9       	ldd	r20, Z+55	; 0x37
    2a3a:	44 23       	and	r20, r20
    2a3c:	11 f0       	breq	.+4      	; 0x2a42 <uip_process+0x890>
	  tmp16 > UIP_TCP_MSS? UIP_TCP_MSS: tmp16;

	/* And we are done processing options. */
	break;
    2a3e:	24 0f       	add	r18, r20
      } else {
	/* All other options have a length field, so that we easily
	   can skip past them. */
	if(uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0) {
    2a40:	ca cf       	rjmp	.-108    	; 0x29d6 <uip_process+0x824>
    2a42:	20 93 95 03 	sts	0x0395, r18
	  /* If the length field is zero, the options are malformed
	     and we don't process them further. */
	  break;
	}
	c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
    2a46:	30 93 94 03 	sts	0x0394, r19
    2a4a:	80 e1       	ldi	r24, 0x10	; 16
    2a4c:	80 93 fa 07 	sts	0x07FA, r24
    2a50:	80 91 fa 07 	lds	r24, 0x07FA
  }

  /* Our response will be a SYNACK. */
#if UIP_ACTIVE_OPEN
 tcp_send_synack:
  BUF->flags = TCP_ACK;
    2a54:	82 60       	ori	r24, 0x02	; 2
    2a56:	80 93 fa 07 	sts	0x07FA, r24

 tcp_send_syn:
  BUF->flags |= TCP_SYN;
    2a5a:	82 e0       	ldi	r24, 0x02	; 2
    2a5c:	80 93 01 08 	sts	0x0801, r24
    2a60:	84 e0       	ldi	r24, 0x04	; 4
  BUF->flags = TCP_SYN | TCP_ACK;
#endif /* UIP_ACTIVE_OPEN */

  /* We send out the TCP Maximum Segment Size option with our
     SYNACK. */
  BUF->optdata[0] = TCP_OPT_MSS;
    2a62:	80 93 02 08 	sts	0x0802, r24
    2a66:	85 e0       	ldi	r24, 0x05	; 5
  BUF->optdata[1] = TCP_OPT_MSS_LEN;
    2a68:	80 93 03 08 	sts	0x0803, r24
    2a6c:	84 eb       	ldi	r24, 0xB4	; 180
  BUF->optdata[2] = (UIP_TCP_MSS) / 256;
    2a6e:	80 93 04 08 	sts	0x0804, r24
    2a72:	8c e2       	ldi	r24, 0x2C	; 44
  BUF->optdata[3] = (UIP_TCP_MSS) & 255;
    2a74:	90 e0       	ldi	r25, 0x00	; 0
    2a76:	90 93 54 06 	sts	0x0654, r25
  uip_len = UIP_IPTCPH_LEN + TCP_OPT_MSS_LEN;
    2a7a:	80 93 53 06 	sts	0x0653, r24
    2a7e:	80 e6       	ldi	r24, 0x60	; 96
    2a80:	74 c2       	rjmp	.+1256   	; 0x2f6a <uip_process+0xdb8>
    2a82:	d0 93 61 06 	sts	0x0661, r29
  BUF->tcpoffset = ((UIP_TCPH_LEN + TCP_OPT_MSS_LEN) / 4) << 4;
    2a86:	c0 93 60 06 	sts	0x0660, r28
  goto tcp_send;

  /* This label will be jumped to if we found an active connection. */
 found:
  uip_conn = uip_connr;
    2a8a:	10 92 5b 06 	sts	0x065B, r1
    2a8e:	90 91 fa 07 	lds	r25, 0x07FA
  uip_flags = 0;
    2a92:	92 ff       	sbrs	r25, 2
    2a94:	03 c0       	rjmp	.+6      	; 0x2a9c <uip_process+0x8ea>
  /* We do a very naive form of TCP reset processing; we just accept
     any RST and kill our connection. We should in fact check if the
     sequence number of this reset is within our advertised window
     before we accept the reset. */
  if(BUF->flags & TCP_RST) {
    2a96:	19 8e       	std	Y+25, r1	; 0x19
    2a98:	80 e2       	ldi	r24, 0x20	; 32
    2a9a:	13 c2       	rjmp	.+1062   	; 0x2ec2 <uip_process+0xd10>
    2a9c:	80 91 f9 07 	lds	r24, 0x07F9
    uip_connr->tcpstateflags = UIP_CLOSED;
    UIP_LOG("tcp: got reset, aborting connection.");
    uip_flags = UIP_ABORT;
    2aa0:	82 95       	swap	r24
    2aa2:	8f 70       	andi	r24, 0x0F	; 15
    UIP_APPCALL();
    goto drop;
  }
  /* Calculate the length of the data, if the application has sent
     any data to us. */
  c = (BUF->tcpoffset >> 4) << 2;
    2aa4:	88 0f       	add	r24, r24
    2aa6:	88 0f       	add	r24, r24
    2aa8:	80 93 95 03 	sts	0x0395, r24
    2aac:	08 1b       	sub	r16, r24
    2aae:	11 09       	sbc	r17, r1
    2ab0:	04 51       	subi	r16, 0x14	; 20
    2ab2:	11 09       	sbc	r17, r1
  /* uip_len will contain the length of the actual TCP data. This is
     calculated by subtracing the length of the TCP header (in
     c) and the length of the IP header (20 bytes). */
  uip_len = uip_len - c - UIP_IPH_LEN;
    2ab4:	10 93 54 06 	sts	0x0654, r17
    2ab8:	00 93 53 06 	sts	0x0653, r16
    2abc:	8f 2d       	mov	r24, r15
    2abe:	8f 70       	andi	r24, 0x0F	; 15
    2ac0:	82 30       	cpi	r24, 0x02	; 2
    2ac2:	21 f4       	brne	.+8      	; 0x2acc <uip_process+0x91a>

  /* First, check if the sequence number of the incoming packet is
     what we're expecting next. If not, we send out an ACK with the
     correct numbers in. */
  if(!(((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_SENT) &&
    2ac4:	89 2f       	mov	r24, r25
    2ac6:	8f 73       	andi	r24, 0x3F	; 63
    2ac8:	82 31       	cpi	r24, 0x12	; 18
    2aca:	c9 f0       	breq	.+50     	; 0x2afe <uip_process+0x94c>
       ((BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)))) {
    2acc:	01 2b       	or	r16, r17
    2ace:	19 f4       	brne	.+6      	; 0x2ad6 <uip_process+0x924>
  uip_len = uip_len - c - UIP_IPH_LEN;

  /* First, check if the sequence number of the incoming packet is
     what we're expecting next. If not, we send out an ACK with the
     correct numbers in. */
  if(!(((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_SENT) &&
    2ad0:	89 2f       	mov	r24, r25
    2ad2:	83 70       	andi	r24, 0x03	; 3
       ((BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)))) {
    if((uip_len > 0 || ((BUF->flags & (TCP_SYN | TCP_FIN)) != 0)) &&
    2ad4:	a1 f0       	breq	.+40     	; 0x2afe <uip_process+0x94c>
    2ad6:	20 91 f1 07 	lds	r18, 0x07F1
    2ada:	88 85       	ldd	r24, Y+8	; 0x08
    2adc:	28 13       	cpse	r18, r24
    2ade:	3b c2       	rjmp	.+1142   	; 0x2f56 <uip_process+0xda4>
    2ae0:	20 91 f2 07 	lds	r18, 0x07F2
    2ae4:	89 85       	ldd	r24, Y+9	; 0x09
    2ae6:	28 13       	cpse	r18, r24
       (BUF->seqno[0] != uip_connr->rcv_nxt[0] ||
    2ae8:	36 c2       	rjmp	.+1132   	; 0x2f56 <uip_process+0xda4>
    2aea:	20 91 f3 07 	lds	r18, 0x07F3
    2aee:	8a 85       	ldd	r24, Y+10	; 0x0a
    2af0:	28 13       	cpse	r18, r24
	BUF->seqno[1] != uip_connr->rcv_nxt[1] ||
    2af2:	31 c2       	rjmp	.+1122   	; 0x2f56 <uip_process+0xda4>
    2af4:	20 91 f4 07 	lds	r18, 0x07F4
    2af8:	8b 85       	ldd	r24, Y+11	; 0x0b
    2afa:	28 13       	cpse	r18, r24
	BUF->seqno[2] != uip_connr->rcv_nxt[2] ||
    2afc:	2c c2       	rjmp	.+1112   	; 0x2f56 <uip_process+0xda4>
    2afe:	94 ff       	sbrs	r25, 4
    2b00:	49 c0       	rjmp	.+146    	; 0x2b94 <uip_process+0x9e2>
    2b02:	68 89       	ldd	r22, Y+16	; 0x10
    2b04:	79 89       	ldd	r23, Y+17	; 0x11

  /* Next, check if the incoming segment acknowledges any outstanding
     data. If so, we update the sequence number, reset the length of
     the outstanding data, calculate RTT estimations, and reset the
     retransmission timer. */
  if((BUF->flags & TCP_ACK) && uip_outstanding(uip_connr)) {
    2b06:	61 15       	cp	r22, r1
    2b08:	71 05       	cpc	r23, r1
    2b0a:	09 f4       	brne	.+2      	; 0x2b0e <uip_process+0x95c>
    2b0c:	43 c0       	rjmp	.+134    	; 0x2b94 <uip_process+0x9e2>
    2b0e:	ce 01       	movw	r24, r28
    2b10:	0c 96       	adiw	r24, 0x0c	; 12
    2b12:	3c da       	rcall	.-2952   	; 0x1f8c <uip_add32>
    2b14:	30 91 f5 07 	lds	r19, 0x07F5
    uip_add32(uip_connr->snd_nxt, uip_connr->len);
    2b18:	80 91 57 06 	lds	r24, 0x0657
    2b1c:	38 13       	cpse	r19, r24

    if(BUF->ackno[0] == uip_acc32[0] &&
    2b1e:	3a c0       	rjmp	.+116    	; 0x2b94 <uip_process+0x9e2>
    2b20:	20 91 f6 07 	lds	r18, 0x07F6
    2b24:	80 91 58 06 	lds	r24, 0x0658
    2b28:	28 13       	cpse	r18, r24
       BUF->ackno[1] == uip_acc32[1] &&
    2b2a:	34 c0       	rjmp	.+104    	; 0x2b94 <uip_process+0x9e2>
    2b2c:	90 91 f7 07 	lds	r25, 0x07F7
     the outstanding data, calculate RTT estimations, and reset the
     retransmission timer. */
  if((BUF->flags & TCP_ACK) && uip_outstanding(uip_connr)) {
    uip_add32(uip_connr->snd_nxt, uip_connr->len);

    if(BUF->ackno[0] == uip_acc32[0] &&
    2b30:	80 91 59 06 	lds	r24, 0x0659
    2b34:	98 13       	cpse	r25, r24
       BUF->ackno[1] == uip_acc32[1] &&
       BUF->ackno[2] == uip_acc32[2] &&
    2b36:	2e c0       	rjmp	.+92     	; 0x2b94 <uip_process+0x9e2>
    2b38:	80 91 f8 07 	lds	r24, 0x07F8
     retransmission timer. */
  if((BUF->flags & TCP_ACK) && uip_outstanding(uip_connr)) {
    uip_add32(uip_connr->snd_nxt, uip_connr->len);

    if(BUF->ackno[0] == uip_acc32[0] &&
       BUF->ackno[1] == uip_acc32[1] &&
    2b3c:	40 91 5a 06 	lds	r20, 0x065A
    2b40:	84 13       	cpse	r24, r20
       BUF->ackno[2] == uip_acc32[2] &&
       BUF->ackno[3] == uip_acc32[3]) {
    2b42:	28 c0       	rjmp	.+80     	; 0x2b94 <uip_process+0x9e2>
    2b44:	3c 87       	std	Y+12, r19	; 0x0c
  if((BUF->flags & TCP_ACK) && uip_outstanding(uip_connr)) {
    uip_add32(uip_connr->snd_nxt, uip_connr->len);

    if(BUF->ackno[0] == uip_acc32[0] &&
       BUF->ackno[1] == uip_acc32[1] &&
       BUF->ackno[2] == uip_acc32[2] &&
    2b46:	2d 87       	std	Y+13, r18	; 0x0d
    2b48:	9e 87       	std	Y+14, r25	; 0x0e
    2b4a:	8f 87       	std	Y+15, r24	; 0x0f
    2b4c:	8b 8d       	ldd	r24, Y+27	; 0x1b
       BUF->ackno[3] == uip_acc32[3]) {
      /* Update sequence number. */
      uip_connr->snd_nxt[0] = uip_acc32[0];
    2b4e:	81 11       	cpse	r24, r1
      uip_connr->snd_nxt[1] = uip_acc32[1];
    2b50:	1a c0       	rjmp	.+52     	; 0x2b86 <uip_process+0x9d4>
      uip_connr->snd_nxt[2] = uip_acc32[2];
    2b52:	2e 89       	ldd	r18, Y+22	; 0x16
      uip_connr->snd_nxt[3] = uip_acc32[3];
    2b54:	88 8d       	ldd	r24, Y+24	; 0x18

      /* Do RTT estimation, unless we have done retransmissions. */
      if(uip_connr->nrtx == 0) {
    2b56:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2b58:	89 1b       	sub	r24, r25
    2b5a:	92 2f       	mov	r25, r18
	signed char m;
	m = uip_connr->rto - uip_connr->timer;
	/* This is taken directly from VJs original code in his paper */
	m = m - (uip_connr->sa >> 3);
    2b5c:	96 95       	lsr	r25
      uip_connr->snd_nxt[3] = uip_acc32[3];

      /* Do RTT estimation, unless we have done retransmissions. */
      if(uip_connr->nrtx == 0) {
	signed char m;
	m = uip_connr->rto - uip_connr->timer;
    2b5e:	96 95       	lsr	r25
    2b60:	96 95       	lsr	r25
    2b62:	89 1b       	sub	r24, r25
	/* This is taken directly from VJs original code in his paper */
	m = m - (uip_connr->sa >> 3);
    2b64:	28 0f       	add	r18, r24
    2b66:	2e 8b       	std	Y+22, r18	; 0x16
    2b68:	87 fd       	sbrc	r24, 7
    2b6a:	81 95       	neg	r24
    2b6c:	9f 89       	ldd	r25, Y+23	; 0x17
	uip_connr->sa += m;
    2b6e:	39 2f       	mov	r19, r25
    2b70:	36 95       	lsr	r19
	if(m < 0) {
	  m = -m;
    2b72:	36 95       	lsr	r19
    2b74:	93 1b       	sub	r25, r19
	}
	m = m - (uip_connr->sv >> 2);
    2b76:	98 0f       	add	r25, r24
    2b78:	9f 8b       	std	Y+23, r25	; 0x17
    2b7a:	82 2f       	mov	r24, r18
    2b7c:	86 95       	lsr	r24
    2b7e:	86 95       	lsr	r24
	uip_connr->sv += m;
    2b80:	86 95       	lsr	r24
    2b82:	89 0f       	add	r24, r25
	uip_connr->rto = (uip_connr->sa >> 3) + uip_connr->sv;
    2b84:	88 8f       	std	Y+24, r24	; 0x18
    2b86:	81 e0       	ldi	r24, 0x01	; 1
    2b88:	80 93 5b 06 	sts	0x065B, r24
    2b8c:	88 8d       	ldd	r24, Y+24	; 0x18
    2b8e:	8a 8f       	std	Y+26, r24	; 0x1a

      }
      /* Set the acknowledged flag. */
      uip_flags = UIP_ACKDATA;
    2b90:	19 8a       	std	Y+17, r1	; 0x11
    2b92:	18 8a       	std	Y+16, r1	; 0x10
    2b94:	49 8d       	ldd	r20, Y+25	; 0x19
      /* Reset the retransmission timer. */
      uip_connr->timer = uip_connr->rto;
    2b96:	84 2f       	mov	r24, r20
    2b98:	8f 70       	andi	r24, 0x0F	; 15

      /* Reset length of outstanding data. */
      uip_connr->len = 0;
    2b9a:	84 30       	cpi	r24, 0x04	; 4
    2b9c:	09 f4       	brne	.+2      	; 0x2ba0 <uip_process+0x9ee>
    }

  }

  /* Do different things depending on in what state the connection is. */
  switch(uip_connr->tcpstateflags & UIP_TS_MASK) {
    2b9e:	96 c1       	rjmp	.+812    	; 0x2ecc <uip_process+0xd1a>
    2ba0:	38 f4       	brcc	.+14     	; 0x2bb0 <uip_process+0x9fe>
    2ba2:	82 30       	cpi	r24, 0x02	; 2
    2ba4:	41 f1       	breq	.+80     	; 0x2bf6 <uip_process+0xa44>
    2ba6:	08 f0       	brcs	.+2      	; 0x2baa <uip_process+0x9f8>
    2ba8:	a4 c0       	rjmp	.+328    	; 0x2cf2 <uip_process+0xb40>
    2baa:	81 30       	cpi	r24, 0x01	; 1
    2bac:	69 f0       	breq	.+26     	; 0x2bc8 <uip_process+0xa16>
    2bae:	6d c2       	rjmp	.+1242   	; 0x308a <uip_process+0xed8>
    2bb0:	86 30       	cpi	r24, 0x06	; 6
    2bb2:	09 f4       	brne	.+2      	; 0x2bb6 <uip_process+0xa04>
    2bb4:	c8 c1       	rjmp	.+912    	; 0x2f46 <uip_process+0xd94>
    2bb6:	08 f4       	brcc	.+2      	; 0x2bba <uip_process+0xa08>
    2bb8:	a8 c1       	rjmp	.+848    	; 0x2f0a <uip_process+0xd58>
    2bba:	87 30       	cpi	r24, 0x07	; 7
    2bbc:	09 f4       	brne	.+2      	; 0x2bc0 <uip_process+0xa0e>
    2bbe:	cb c1       	rjmp	.+918    	; 0x2f56 <uip_process+0xda4>
    2bc0:	88 30       	cpi	r24, 0x08	; 8
    2bc2:	09 f4       	brne	.+2      	; 0x2bc6 <uip_process+0xa14>
    2bc4:	78 c1       	rjmp	.+752    	; 0x2eb6 <uip_process+0xd04>
    2bc6:	61 c2       	rjmp	.+1218   	; 0x308a <uip_process+0xed8>
    2bc8:	80 91 5b 06 	lds	r24, 0x065B
    2bcc:	80 ff       	sbrs	r24, 0
    2bce:	5d c2       	rjmp	.+1210   	; 0x308a <uip_process+0xed8>
    2bd0:	83 e0       	ldi	r24, 0x03	; 3
  case UIP_SYN_RCVD:
    /* In SYN_RCVD we have sent out a SYNACK in response to a SYN, and
       we are waiting for an ACK that acknowledges the data we sent
       out the last time. Therefore, we want to have the UIP_ACKDATA
       flag set. If so, we enter the ESTABLISHED state. */
    if(uip_flags & UIP_ACKDATA) {
    2bd2:	89 8f       	std	Y+25, r24	; 0x19
    2bd4:	80 e4       	ldi	r24, 0x40	; 64
    2bd6:	80 93 5b 06 	sts	0x065B, r24
      uip_connr->tcpstateflags = UIP_ESTABLISHED;
    2bda:	19 8a       	std	Y+17, r1	; 0x11
    2bdc:	18 8a       	std	Y+16, r1	; 0x10
      uip_flags = UIP_CONNECTED;
    2bde:	80 91 53 06 	lds	r24, 0x0653
    2be2:	90 91 54 06 	lds	r25, 0x0654
      uip_connr->len = 0;
    2be6:	00 97       	sbiw	r24, 0x00	; 0
      if(uip_len > 0) {
    2be8:	09 f4       	brne	.+2      	; 0x2bec <uip_process+0xa3a>
    2bea:	fd c0       	rjmp	.+506    	; 0x2de6 <uip_process+0xc34>
    2bec:	22 e4       	ldi	r18, 0x42	; 66
    2bee:	20 93 5b 06 	sts	0x065B, r18
    2bf2:	03 da       	rcall	.-3066   	; 0x1ffa <uip_add_rcv_nxt>
    2bf4:	f8 c0       	rjmp	.+496    	; 0x2de6 <uip_process+0xc34>
        uip_flags |= UIP_NEWDATA;
    2bf6:	80 91 5b 06 	lds	r24, 0x065B
    2bfa:	80 ff       	sbrs	r24, 0
        uip_add_rcv_nxt(uip_len);
    2bfc:	6f c0       	rjmp	.+222    	; 0x2cdc <uip_process+0xb2a>
    2bfe:	80 91 fa 07 	lds	r24, 0x07FA
  case UIP_SYN_SENT:
    /* In SYN_SENT, we wait for a SYNACK that is sent in response to
       our SYN. The rcv_nxt is set to sequence number in the SYNACK
       plus one, and we send an ACK. We move into the ESTABLISHED
       state. */
    if((uip_flags & UIP_ACKDATA) &&
    2c02:	8f 73       	andi	r24, 0x3F	; 63
    2c04:	82 31       	cpi	r24, 0x12	; 18
    2c06:	09 f0       	breq	.+2      	; 0x2c0a <uip_process+0xa58>
    2c08:	69 c0       	rjmp	.+210    	; 0x2cdc <uip_process+0xb2a>
       (BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)) {
    2c0a:	80 91 f9 07 	lds	r24, 0x07F9
    2c0e:	28 2f       	mov	r18, r24
  case UIP_SYN_SENT:
    /* In SYN_SENT, we wait for a SYNACK that is sent in response to
       our SYN. The rcv_nxt is set to sequence number in the SYNACK
       plus one, and we send an ACK. We move into the ESTABLISHED
       state. */
    if((uip_flags & UIP_ACKDATA) &&
    2c10:	20 7f       	andi	r18, 0xF0	; 240
    2c12:	30 e0       	ldi	r19, 0x00	; 0
    2c14:	21 35       	cpi	r18, 0x51	; 81
       (BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)) {

      /* Parse the TCP MSS option, if present. */
      if((BUF->tcpoffset & 0xf0) > 0x50) {
    2c16:	31 05       	cpc	r19, r1
    2c18:	0c f4       	brge	.+2      	; 0x2c1c <uip_process+0xa6a>
    2c1a:	45 c0       	rjmp	.+138    	; 0x2ca6 <uip_process+0xaf4>
    2c1c:	82 95       	swap	r24
    2c1e:	8f 70       	andi	r24, 0x0F	; 15
    2c20:	90 e0       	ldi	r25, 0x00	; 0
    2c22:	05 97       	sbiw	r24, 0x05	; 5
    2c24:	88 0f       	add	r24, r24
    2c26:	99 1f       	adc	r25, r25
	for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
    2c28:	88 0f       	add	r24, r24
    2c2a:	99 1f       	adc	r25, r25
    2c2c:	30 91 94 03 	lds	r19, 0x0394
    2c30:	20 e0       	ldi	r18, 0x00	; 0
    2c32:	e2 2f       	mov	r30, r18
    2c34:	f0 e0       	ldi	r31, 0x00	; 0
    2c36:	e8 17       	cp	r30, r24
    2c38:	f9 07       	cpc	r31, r25
    2c3a:	8c f5       	brge	.+98     	; 0x2c9e <uip_process+0xaec>
    2c3c:	e5 53       	subi	r30, 0x35	; 53
    2c3e:	f8 4f       	sbci	r31, 0xF8	; 248
    2c40:	36 a9       	ldd	r19, Z+54	; 0x36
    2c42:	31 11       	cpse	r19, r1
    2c44:	05 c0       	rjmp	.+10     	; 0x2c50 <uip_process+0xa9e>
    2c46:	20 93 95 03 	sts	0x0395, r18
	  opt = uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + c];
    2c4a:	10 92 94 03 	sts	0x0394, r1
	  if(opt == TCP_OPT_END) {
    2c4e:	2b c0       	rjmp	.+86     	; 0x2ca6 <uip_process+0xaf4>
    2c50:	31 30       	cpi	r19, 0x01	; 1
    2c52:	11 f4       	brne	.+4      	; 0x2c58 <uip_process+0xaa6>
    2c54:	2f 5f       	subi	r18, 0xFF	; 255
    2c56:	ed cf       	rjmp	.-38     	; 0x2c32 <uip_process+0xa80>
    2c58:	32 30       	cpi	r19, 0x02	; 2
    2c5a:	e1 f4       	brne	.+56     	; 0x2c94 <uip_process+0xae2>
	    /* End of options. */
	    break;
	  } else if(opt == TCP_OPT_NOOP) {
    2c5c:	47 a9       	ldd	r20, Z+55	; 0x37
    2c5e:	44 30       	cpi	r20, 0x04	; 4
	    ++c;
    2c60:	c9 f4       	brne	.+50     	; 0x2c94 <uip_process+0xae2>
    2c62:	20 93 95 03 	sts	0x0395, r18
	    /* NOP option. */
	  } else if(opt == TCP_OPT_MSS &&
    2c66:	30 93 94 03 	sts	0x0394, r19
    2c6a:	80 ad       	ldd	r24, Z+56	; 0x38
    2c6c:	90 e0       	ldi	r25, 0x00	; 0
    2c6e:	98 2f       	mov	r25, r24
    2c70:	88 27       	eor	r24, r24
    2c72:	21 ad       	ldd	r18, Z+57	; 0x39
    2c74:	82 2b       	or	r24, r18
		    uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
	    /* An MSS option with the right option length. */
	    tmp16 = (uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
    2c76:	90 93 93 03 	sts	0x0393, r25
    2c7a:	80 93 92 03 	sts	0x0392, r24
    2c7e:	85 3b       	cpi	r24, 0xB5	; 181
    2c80:	a5 e0       	ldi	r26, 0x05	; 5
    2c82:	9a 07       	cpc	r25, r26
    2c84:	10 f0       	brcs	.+4      	; 0x2c8a <uip_process+0xad8>
    2c86:	84 eb       	ldi	r24, 0xB4	; 180
    2c88:	95 e0       	ldi	r25, 0x05	; 5
	      uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 3 + c];
	    uip_connr->initialmss =
	      uip_connr->mss = tmp16 > UIP_TCP_MSS? UIP_TCP_MSS: tmp16;
    2c8a:	9b 8b       	std	Y+19, r25	; 0x13
    2c8c:	8a 8b       	std	Y+18, r24	; 0x12
    2c8e:	9d 8b       	std	Y+21, r25	; 0x15
    2c90:	8c 8b       	std	Y+20, r24	; 0x14
    2c92:	09 c0       	rjmp	.+18     	; 0x2ca6 <uip_process+0xaf4>
    2c94:	47 a9       	ldd	r20, Z+55	; 0x37
    2c96:	44 23       	and	r20, r20
    2c98:	11 f0       	breq	.+4      	; 0x2c9e <uip_process+0xaec>
	  } else if(opt == TCP_OPT_MSS &&
		    uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
	    /* An MSS option with the right option length. */
	    tmp16 = (uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
	      uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 3 + c];
	    uip_connr->initialmss =
    2c9a:	24 0f       	add	r18, r20
    2c9c:	ca cf       	rjmp	.-108    	; 0x2c32 <uip_process+0xa80>
	      uip_connr->mss = tmp16 > UIP_TCP_MSS? UIP_TCP_MSS: tmp16;

	    /* And we are done processing options. */
	    break;
    2c9e:	20 93 95 03 	sts	0x0395, r18
	  } else {
	    /* All other options have a length field, so that we easily
	       can skip past them. */
	    if(uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0) {
    2ca2:	30 93 94 03 	sts	0x0394, r19
	      /* If the length field is zero, the options are malformed
		 and we don't process them further. */
	      break;
	    }
	    c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
    2ca6:	83 e0       	ldi	r24, 0x03	; 3
    2ca8:	89 8f       	std	Y+25, r24	; 0x19
    2caa:	80 91 f1 07 	lds	r24, 0x07F1
    2cae:	88 87       	std	Y+8, r24	; 0x08
    2cb0:	80 91 f2 07 	lds	r24, 0x07F2
	  }
	}
      }
      uip_connr->tcpstateflags = UIP_ESTABLISHED;
    2cb4:	89 87       	std	Y+9, r24	; 0x09
      uip_connr->rcv_nxt[0] = BUF->seqno[0];
    2cb6:	80 91 f3 07 	lds	r24, 0x07F3
    2cba:	8a 87       	std	Y+10, r24	; 0x0a
      uip_connr->rcv_nxt[1] = BUF->seqno[1];
    2cbc:	80 91 f4 07 	lds	r24, 0x07F4
    2cc0:	8b 87       	std	Y+11, r24	; 0x0b
      uip_connr->rcv_nxt[2] = BUF->seqno[2];
    2cc2:	81 e0       	ldi	r24, 0x01	; 1
    2cc4:	90 e0       	ldi	r25, 0x00	; 0
    2cc6:	99 d9       	rcall	.-3278   	; 0x1ffa <uip_add_rcv_nxt>
      uip_connr->rcv_nxt[3] = BUF->seqno[3];
    2cc8:	82 e4       	ldi	r24, 0x42	; 66
    2cca:	80 93 5b 06 	sts	0x065B, r24
      uip_add_rcv_nxt(1);
    2cce:	19 8a       	std	Y+17, r1	; 0x11
    2cd0:	18 8a       	std	Y+16, r1	; 0x10
    2cd2:	10 92 54 06 	sts	0x0654, r1
      uip_flags = UIP_CONNECTED | UIP_NEWDATA;
    2cd6:	10 92 53 06 	sts	0x0653, r1
    2cda:	85 c0       	rjmp	.+266    	; 0x2de6 <uip_process+0xc34>
      uip_connr->len = 0;
    2cdc:	80 e2       	ldi	r24, 0x20	; 32
    2cde:	80 93 5b 06 	sts	0x065B, r24
      uip_len = 0;
    2ce2:	0e 94 4a 09 	call	0x1294	; 0x1294 <uIPManagement_TCPCallback>
    2ce6:	e0 91 60 06 	lds	r30, 0x0660
      uip_slen = 0;
      UIP_APPCALL();
      goto appsend;
    }
    /* Inform the application that the connection failed */
    uip_flags = UIP_ABORT;
    2cea:	f0 91 61 06 	lds	r31, 0x0661
    2cee:	11 8e       	std	Z+25, r1	; 0x19
    UIP_APPCALL();
    2cf0:	79 cd       	rjmp	.-1294   	; 0x27e4 <uip_process+0x632>
    2cf2:	80 91 fa 07 	lds	r24, 0x07FA
    /* The connection is closed after we send the RST */
    uip_conn->tcpstateflags = UIP_CLOSED;
    2cf6:	80 ff       	sbrs	r24, 0
    2cf8:	27 c0       	rjmp	.+78     	; 0x2d48 <uip_process+0xb96>
    2cfa:	44 fd       	sbrc	r20, 4
    2cfc:	25 c0       	rjmp	.+74     	; 0x2d48 <uip_process+0xb96>
    goto reset;
    2cfe:	88 89       	ldd	r24, Y+16	; 0x10
    If the incoming packet is a FIN, we should close the connection on
    this side as well, and we send out a FIN and enter the LAST_ACK
    state. We require that there is no outstanding data; otherwise the
    sequence numbers will be screwed up. */

    if(BUF->flags & TCP_FIN && !(uip_connr->tcpstateflags & UIP_STOPPED)) {
    2d00:	99 89       	ldd	r25, Y+17	; 0x11
    2d02:	89 2b       	or	r24, r25
    2d04:	09 f0       	breq	.+2      	; 0x2d08 <uip_process+0xb56>
    2d06:	c1 c1       	rjmp	.+898    	; 0x308a <uip_process+0xed8>
    2d08:	80 91 53 06 	lds	r24, 0x0653
      if(uip_outstanding(uip_connr)) {
    2d0c:	90 91 54 06 	lds	r25, 0x0654
    2d10:	01 96       	adiw	r24, 0x01	; 1
    2d12:	73 d9       	rcall	.-3354   	; 0x1ffa <uip_add_rcv_nxt>
    2d14:	20 91 5b 06 	lds	r18, 0x065B
	goto drop;
      }
      uip_add_rcv_nxt(1 + uip_len);
    2d18:	82 2f       	mov	r24, r18
    2d1a:	80 61       	ori	r24, 0x10	; 16
    2d1c:	80 93 5b 06 	sts	0x065B, r24
    2d20:	80 91 53 06 	lds	r24, 0x0653
      uip_flags |= UIP_CLOSE;
    2d24:	90 91 54 06 	lds	r25, 0x0654
    2d28:	89 2b       	or	r24, r25
    2d2a:	19 f0       	breq	.+6      	; 0x2d32 <uip_process+0xb80>
    2d2c:	22 61       	ori	r18, 0x12	; 18
    2d2e:	20 93 5b 06 	sts	0x065B, r18
      if(uip_len > 0) {
    2d32:	0e 94 4a 09 	call	0x1294	; 0x1294 <uIPManagement_TCPCallback>
    2d36:	81 e0       	ldi	r24, 0x01	; 1
    2d38:	90 e0       	ldi	r25, 0x00	; 0
    2d3a:	99 8b       	std	Y+17, r25	; 0x11
	uip_flags |= UIP_NEWDATA;
    2d3c:	88 8b       	std	Y+16, r24	; 0x10
    2d3e:	88 e0       	ldi	r24, 0x08	; 8
    2d40:	89 8f       	std	Y+25, r24	; 0x19
      }
      UIP_APPCALL();
    2d42:	1b 8e       	std	Y+27, r1	; 0x1b
    2d44:	81 e1       	ldi	r24, 0x11	; 17
      uip_connr->len = 1;
    2d46:	08 c1       	rjmp	.+528    	; 0x2f58 <uip_process+0xda6>
    2d48:	85 ff       	sbrs	r24, 5
    2d4a:	1c c0       	rjmp	.+56     	; 0x2d84 <uip_process+0xbd2>
    2d4c:	80 91 ff 07 	lds	r24, 0x07FF
      uip_connr->tcpstateflags = UIP_LAST_ACK;
    2d50:	90 e0       	ldi	r25, 0x00	; 0
      uip_connr->nrtx = 0;
    2d52:	98 2f       	mov	r25, r24
    tcp_send_finack:
      BUF->flags = TCP_FIN | TCP_ACK;
    2d54:	88 27       	eor	r24, r24
    2d56:	20 91 00 08 	lds	r18, 0x0800
      goto tcp_send_nodata;
    }

    /* Check the URG flag. If this is set, the segment carries urgent
       data that we must pass to the application. */
    if((BUF->flags & TCP_URG) != 0) {
    2d5a:	82 2b       	or	r24, r18
      uip_urgdata = uip_appdata;
      uip_appdata += uip_urglen;
    } else {
      uip_urglen = 0;
#else /* UIP_URGDATA > 0 */
      uip_appdata = ((char *)uip_appdata) + ((BUF->urgp[0] << 8) | BUF->urgp[1]);
    2d5c:	20 91 5e 06 	lds	r18, 0x065E
    2d60:	30 91 5f 06 	lds	r19, 0x065F
    2d64:	28 0f       	add	r18, r24
    2d66:	39 1f       	adc	r19, r25
    2d68:	30 93 5f 06 	sts	0x065F, r19
    2d6c:	20 93 5e 06 	sts	0x065E, r18
    2d70:	20 91 53 06 	lds	r18, 0x0653
    2d74:	30 91 54 06 	lds	r19, 0x0654
    2d78:	28 1b       	sub	r18, r24
    2d7a:	39 0b       	sbc	r19, r25
    2d7c:	30 93 54 06 	sts	0x0654, r19
      uip_len -= (BUF->urgp[0] << 8) | BUF->urgp[1];
    2d80:	20 93 53 06 	sts	0x0653, r18
    2d84:	80 91 53 06 	lds	r24, 0x0653
    2d88:	90 91 54 06 	lds	r25, 0x0654
    2d8c:	00 97       	sbiw	r24, 0x00	; 0
    2d8e:	41 f0       	breq	.+16     	; 0x2da0 <uip_process+0xbee>
    2d90:	44 fd       	sbrc	r20, 4
    2d92:	06 c0       	rjmp	.+12     	; 0x2da0 <uip_process+0xbee>
    /* If uip_len > 0 we have TCP data in the packet, and we flag this
       by setting the UIP_NEWDATA flag and update the sequence number
       we acknowledge. If the application has stopped the dataflow
       using uip_stop(), we must not accept any data packets from the
       remote host. */
    if(uip_len > 0 && !(uip_connr->tcpstateflags & UIP_STOPPED)) {
    2d94:	20 91 5b 06 	lds	r18, 0x065B
    2d98:	22 60       	ori	r18, 0x02	; 2
    2d9a:	20 93 5b 06 	sts	0x065B, r18
    2d9e:	2d d9       	rcall	.-3494   	; 0x1ffa <uip_add_rcv_nxt>
    2da0:	80 91 fb 07 	lds	r24, 0x07FB
      uip_flags |= UIP_NEWDATA;
    2da4:	90 e0       	ldi	r25, 0x00	; 0
    2da6:	98 2f       	mov	r25, r24
    2da8:	88 27       	eor	r24, r24
    2daa:	20 91 fc 07 	lds	r18, 0x07FC
      uip_add_rcv_nxt(uip_len);
    2dae:	82 0f       	add	r24, r18
    2db0:	91 1d       	adc	r25, r1
       the initial MSS so that the application will send an entire MSS
       of data. This data will not be acknowledged by the receiver,
       and the application will retransmit it. This is called the
       "persistent timer" and uses the retransmission mechanism.
    */
    tmp16 = ((u16_t)BUF->wnd[0] << 8) + (u16_t)BUF->wnd[1];
    2db2:	90 93 93 03 	sts	0x0393, r25
    2db6:	80 93 92 03 	sts	0x0392, r24
    2dba:	2c 89       	ldd	r18, Y+20	; 0x14
    2dbc:	3d 89       	ldd	r19, Y+21	; 0x15
    2dbe:	28 17       	cp	r18, r24
    2dc0:	39 07       	cpc	r19, r25
    2dc2:	10 f0       	brcs	.+4      	; 0x2dc8 <uip_process+0xc16>
    2dc4:	89 2b       	or	r24, r25
    2dc6:	21 f4       	brne	.+8      	; 0x2dd0 <uip_process+0xc1e>
    2dc8:	30 93 93 03 	sts	0x0393, r19
    if(tmp16 > uip_connr->initialmss ||
    2dcc:	20 93 92 03 	sts	0x0392, r18
    2dd0:	80 91 92 03 	lds	r24, 0x0392
    2dd4:	90 91 93 03 	lds	r25, 0x0393
    2dd8:	9b 8b       	std	Y+19, r25	; 0x13
       tmp16 == 0) {
      tmp16 = uip_connr->initialmss;
    2dda:	8a 8b       	std	Y+18, r24	; 0x12
    2ddc:	80 91 5b 06 	lds	r24, 0x065B
    2de0:	83 70       	andi	r24, 0x03	; 3
    }
    uip_connr->mss = tmp16;
    2de2:	09 f4       	brne	.+2      	; 0x2de6 <uip_process+0xc34>
    2de4:	52 c1       	rjmp	.+676    	; 0x308a <uip_process+0xed8>
    2de6:	10 92 b8 0d 	sts	0x0DB8, r1
    2dea:	10 92 b7 0d 	sts	0x0DB7, r1

       If the application wishes to send any data, this data should be
       put into the uip_appdata and the length of the data should be
       put into uip_len. If the application don't have any data to
       send, uip_len must be set to 0. */
    if(uip_flags & (UIP_NEWDATA | UIP_ACKDATA)) {
    2dee:	0e 94 4a 09 	call	0x1294	; 0x1294 <uIPManagement_TCPCallback>
    2df2:	80 91 5b 06 	lds	r24, 0x065B
    2df6:	85 ff       	sbrs	r24, 5
      uip_slen = 0;
    2df8:	07 c0       	rjmp	.+14     	; 0x2e08 <uip_process+0xc56>
    2dfa:	10 92 b8 0d 	sts	0x0DB8, r1
    2dfe:	10 92 b7 0d 	sts	0x0DB7, r1
      UIP_APPCALL();
    2e02:	19 8e       	std	Y+25, r1	; 0x19

    appsend:

      if(uip_flags & UIP_ABORT) {
    2e04:	84 e1       	ldi	r24, 0x14	; 20
    2e06:	a8 c0       	rjmp	.+336    	; 0x2f58 <uip_process+0xda6>
    2e08:	84 ff       	sbrs	r24, 4
    2e0a:	0a c0       	rjmp	.+20     	; 0x2e20 <uip_process+0xc6e>
	uip_slen = 0;
    2e0c:	10 92 b8 0d 	sts	0x0DB8, r1
    2e10:	10 92 b7 0d 	sts	0x0DB7, r1
	uip_connr->tcpstateflags = UIP_CLOSED;
    2e14:	81 e0       	ldi	r24, 0x01	; 1
	BUF->flags = TCP_RST | TCP_ACK;
    2e16:	90 e0       	ldi	r25, 0x00	; 0
    2e18:	99 8b       	std	Y+17, r25	; 0x11
	goto tcp_send_nodata;
      }

      if(uip_flags & UIP_CLOSE) {
    2e1a:	88 8b       	std	Y+16, r24	; 0x10
    2e1c:	84 e0       	ldi	r24, 0x04	; 4
	uip_slen = 0;
    2e1e:	90 cf       	rjmp	.-224    	; 0x2d40 <uip_process+0xb8e>
    2e20:	20 91 b7 0d 	lds	r18, 0x0DB7
    2e24:	30 91 b8 0d 	lds	r19, 0x0DB8
	uip_connr->len = 1;
    2e28:	21 15       	cp	r18, r1
    2e2a:	31 05       	cpc	r19, r1
    2e2c:	e1 f0       	breq	.+56     	; 0x2e66 <uip_process+0xcb4>
	uip_connr->tcpstateflags = UIP_FIN_WAIT_1;
    2e2e:	80 ff       	sbrs	r24, 0
    2e30:	02 c0       	rjmp	.+4      	; 0x2e36 <uip_process+0xc84>
	BUF->flags = TCP_FIN | TCP_ACK;
	goto tcp_send_nodata;
      }

      /* If uip_slen > 0, the application has data to be sent. */
      if(uip_slen > 0) {
    2e32:	19 8a       	std	Y+17, r1	; 0x11
    2e34:	18 8a       	std	Y+16, r1	; 0x10
    2e36:	88 89       	ldd	r24, Y+16	; 0x10
    2e38:	99 89       	ldd	r25, Y+17	; 0x11
    2e3a:	00 97       	sbiw	r24, 0x00	; 0
    2e3c:	81 f4       	brne	.+32     	; 0x2e5e <uip_process+0xcac>
    2e3e:	8a 89       	ldd	r24, Y+18	; 0x12

	/* If the connection has acknowledged data, the contents of
	   the ->len variable should be discarded. */
	if((uip_flags & UIP_ACKDATA) != 0) {
    2e40:	9b 89       	ldd	r25, Y+19	; 0x13
    2e42:	82 17       	cp	r24, r18
	  uip_connr->len = 0;
    2e44:	93 07       	cpc	r25, r19
    2e46:	20 f4       	brcc	.+8      	; 0x2e50 <uip_process+0xc9e>
	}

	/* If the ->len variable is non-zero the connection has
	   already data in transit and cannot send anymore right
	   now. */
	if(uip_connr->len == 0) {
    2e48:	90 93 b8 0d 	sts	0x0DB8, r25
    2e4c:	80 93 b7 0d 	sts	0x0DB7, r24

	  /* The application cannot send more than what is allowed by
	     the mss (the minumum of the MSS and the available
	     window). */
	  if(uip_slen > uip_connr->mss) {
    2e50:	80 91 b7 0d 	lds	r24, 0x0DB7
    2e54:	90 91 b8 0d 	lds	r25, 0x0DB8
    2e58:	99 8b       	std	Y+17, r25	; 0x11
	    uip_slen = uip_connr->mss;
    2e5a:	88 8b       	std	Y+16, r24	; 0x10
    2e5c:	04 c0       	rjmp	.+8      	; 0x2e66 <uip_process+0xcb4>
    2e5e:	90 93 b8 0d 	sts	0x0DB8, r25
	  }

	  /* Remember how much data we send out now so that we know
	     when everything has been acknowledged. */
	  uip_connr->len = uip_slen;
    2e62:	80 93 b7 0d 	sts	0x0DB7, r24
    2e66:	1b 8e       	std	Y+27, r1	; 0x1b
    2e68:	80 91 55 06 	lds	r24, 0x0655
    2e6c:	90 91 56 06 	lds	r25, 0x0656
	} else {

	  /* If the application already had unacknowledged data, we
	     make sure that the application does not send (i.e.,
	     retransmit) out more than it previously sent out. */
	  uip_slen = uip_connr->len;
    2e70:	90 93 5f 06 	sts	0x065F, r25
    2e74:	80 93 5e 06 	sts	0x065E, r24
	}
      }
      uip_connr->nrtx = 0;
    2e78:	80 91 b7 0d 	lds	r24, 0x0DB7
    apprexmit:
      uip_appdata = uip_sappdata;
    2e7c:	90 91 b8 0d 	lds	r25, 0x0DB8
    2e80:	89 2b       	or	r24, r25
    2e82:	59 f0       	breq	.+22     	; 0x2e9a <uip_process+0xce8>
    2e84:	88 89       	ldd	r24, Y+16	; 0x10
    2e86:	99 89       	ldd	r25, Y+17	; 0x11
    2e88:	00 97       	sbiw	r24, 0x00	; 0

      /* If the application has data to be sent, or if the incoming
         packet had new data in it, we must send out a packet. */
      if(uip_slen > 0 && uip_connr->len > 0) {
    2e8a:	39 f0       	breq	.+14     	; 0x2e9a <uip_process+0xce8>
    2e8c:	88 96       	adiw	r24, 0x28	; 40
    2e8e:	90 93 54 06 	sts	0x0654, r25
    2e92:	80 93 53 06 	sts	0x0653, r24
    2e96:	88 e1       	ldi	r24, 0x18	; 24
    2e98:	0b c0       	rjmp	.+22     	; 0x2eb0 <uip_process+0xcfe>
    2e9a:	80 91 5b 06 	lds	r24, 0x065B
	/* Add the length of the IP and TCP headers. */
	uip_len = uip_connr->len + UIP_TCPIP_HLEN;
    2e9e:	81 ff       	sbrs	r24, 1
    2ea0:	f4 c0       	rjmp	.+488    	; 0x308a <uip_process+0xed8>
    2ea2:	88 e2       	ldi	r24, 0x28	; 40
    2ea4:	90 e0       	ldi	r25, 0x00	; 0
    2ea6:	90 93 54 06 	sts	0x0654, r25
	/* We always set the ACK flag in response packets. */
	BUF->flags = TCP_ACK | TCP_PSH;
    2eaa:	80 93 53 06 	sts	0x0653, r24
	/* Send the packet. */
	goto tcp_send_noopts;
      }
      /* If there is no data to send, just send out a pure ACK if
	 there is newdata. */
      if(uip_flags & UIP_NEWDATA) {
    2eae:	80 e1       	ldi	r24, 0x10	; 16
    2eb0:	80 93 fa 07 	sts	0x07FA, r24
	uip_len = UIP_TCPIP_HLEN;
    2eb4:	59 c0       	rjmp	.+178    	; 0x2f68 <uip_process+0xdb6>
    2eb6:	80 91 5b 06 	lds	r24, 0x065B
    2eba:	80 ff       	sbrs	r24, 0
    2ebc:	e6 c0       	rjmp	.+460    	; 0x308a <uip_process+0xed8>
    2ebe:	19 8e       	std	Y+25, r1	; 0x19
	BUF->flags = TCP_ACK;
    2ec0:	80 e1       	ldi	r24, 0x10	; 16
    2ec2:	80 93 5b 06 	sts	0x065B, r24
	goto tcp_send_noopts;
    2ec6:	0e 94 4a 09 	call	0x1294	; 0x1294 <uIPManagement_TCPCallback>
    }
    goto drop;
  case UIP_LAST_ACK:
    /* We can close this connection if the peer has acknowledged our
       FIN. This is indicated by the UIP_ACKDATA flag. */
    if(uip_flags & UIP_ACKDATA) {
    2eca:	df c0       	rjmp	.+446    	; 0x308a <uip_process+0xed8>
    2ecc:	80 91 53 06 	lds	r24, 0x0653
      uip_connr->tcpstateflags = UIP_CLOSED;
    2ed0:	90 91 54 06 	lds	r25, 0x0654
      uip_flags = UIP_CLOSE;
    2ed4:	00 97       	sbiw	r24, 0x00	; 0
    2ed6:	09 f0       	breq	.+2      	; 0x2eda <uip_process+0xd28>
      UIP_APPCALL();
    2ed8:	90 d8       	rcall	.-3808   	; 0x1ffa <uip_add_rcv_nxt>
    2eda:	90 91 fa 07 	lds	r25, 0x07FA

  case UIP_FIN_WAIT_1:
    /* The application has closed the connection, but the remote host
       hasn't closed its end yet. Thus we do nothing but wait for a
       FIN from the other side. */
    if(uip_len > 0) {
    2ede:	80 91 5b 06 	lds	r24, 0x065B
    2ee2:	90 ff       	sbrs	r25, 0
    2ee4:	0b c0       	rjmp	.+22     	; 0x2efc <uip_process+0xd4a>
    2ee6:	80 ff       	sbrs	r24, 0
    2ee8:	06 c0       	rjmp	.+12     	; 0x2ef6 <uip_process+0xd44>
      uip_add_rcv_nxt(uip_len);
    2eea:	87 e0       	ldi	r24, 0x07	; 7
    2eec:	89 8f       	std	Y+25, r24	; 0x19
    }
    if(BUF->flags & TCP_FIN) {
    2eee:	1a 8e       	std	Y+26, r1	; 0x1a
    2ef0:	19 8a       	std	Y+17, r1	; 0x11
    2ef2:	18 8a       	std	Y+16, r1	; 0x10
    2ef4:	18 c0       	rjmp	.+48     	; 0x2f26 <uip_process+0xd74>
    2ef6:	86 e0       	ldi	r24, 0x06	; 6
    2ef8:	89 8f       	std	Y+25, r24	; 0x19
      if(uip_flags & UIP_ACKDATA) {
    2efa:	15 c0       	rjmp	.+42     	; 0x2f26 <uip_process+0xd74>
    2efc:	80 ff       	sbrs	r24, 0
	uip_connr->tcpstateflags = UIP_TIME_WAIT;
    2efe:	1c c0       	rjmp	.+56     	; 0x2f38 <uip_process+0xd86>
    2f00:	85 e0       	ldi	r24, 0x05	; 5
	uip_connr->timer = 0;
    2f02:	89 8f       	std	Y+25, r24	; 0x19
	uip_connr->len = 0;
    2f04:	19 8a       	std	Y+17, r1	; 0x11
    2f06:	18 8a       	std	Y+16, r1	; 0x10
    2f08:	c0 c0       	rjmp	.+384    	; 0x308a <uip_process+0xed8>
      } else {
	uip_connr->tcpstateflags = UIP_CLOSING;
    2f0a:	80 91 53 06 	lds	r24, 0x0653
    2f0e:	90 91 54 06 	lds	r25, 0x0654
      }
      uip_add_rcv_nxt(1);
      uip_flags = UIP_CLOSE;
      UIP_APPCALL();
      goto tcp_send_ack;
    } else if(uip_flags & UIP_ACKDATA) {
    2f12:	00 97       	sbiw	r24, 0x00	; 0
      uip_connr->tcpstateflags = UIP_FIN_WAIT_2;
    2f14:	09 f0       	breq	.+2      	; 0x2f18 <uip_process+0xd66>
    2f16:	71 d8       	rcall	.-3870   	; 0x1ffa <uip_add_rcv_nxt>
      uip_connr->len = 0;
    2f18:	80 91 fa 07 	lds	r24, 0x07FA
      goto drop;
    2f1c:	80 ff       	sbrs	r24, 0
      goto tcp_send_ack;
    }
    goto drop;

  case UIP_FIN_WAIT_2:
    if(uip_len > 0) {
    2f1e:	0c c0       	rjmp	.+24     	; 0x2f38 <uip_process+0xd86>
    2f20:	87 e0       	ldi	r24, 0x07	; 7
    2f22:	89 8f       	std	Y+25, r24	; 0x19
    2f24:	1a 8e       	std	Y+26, r1	; 0x1a
    2f26:	81 e0       	ldi	r24, 0x01	; 1
    2f28:	90 e0       	ldi	r25, 0x00	; 0
      uip_add_rcv_nxt(uip_len);
    2f2a:	67 d8       	rcall	.-3890   	; 0x1ffa <uip_add_rcv_nxt>
    2f2c:	80 e1       	ldi	r24, 0x10	; 16
    }
    if(BUF->flags & TCP_FIN) {
    2f2e:	80 93 5b 06 	sts	0x065B, r24
    2f32:	0e 94 4a 09 	call	0x1294	; 0x1294 <uIPManagement_TCPCallback>
      uip_connr->tcpstateflags = UIP_TIME_WAIT;
    2f36:	0f c0       	rjmp	.+30     	; 0x2f56 <uip_process+0xda4>
    2f38:	80 91 53 06 	lds	r24, 0x0653
      uip_connr->timer = 0;
      uip_add_rcv_nxt(1);
    2f3c:	90 91 54 06 	lds	r25, 0x0654
    2f40:	89 2b       	or	r24, r25
    2f42:	49 f4       	brne	.+18     	; 0x2f56 <uip_process+0xda4>
      uip_flags = UIP_CLOSE;
    2f44:	a2 c0       	rjmp	.+324    	; 0x308a <uip_process+0xed8>
    2f46:	80 91 5b 06 	lds	r24, 0x065B
      UIP_APPCALL();
    2f4a:	80 ff       	sbrs	r24, 0
    2f4c:	9e c0       	rjmp	.+316    	; 0x308a <uip_process+0xed8>
      goto tcp_send_ack;
    2f4e:	87 e0       	ldi	r24, 0x07	; 7
    }
    if(uip_len > 0) {
    2f50:	89 8f       	std	Y+25, r24	; 0x19
    2f52:	1a 8e       	std	Y+26, r1	; 0x1a
    2f54:	9a c0       	rjmp	.+308    	; 0x308a <uip_process+0xed8>
    2f56:	80 e1       	ldi	r24, 0x10	; 16
    2f58:	80 93 fa 07 	sts	0x07FA, r24
    2f5c:	88 e2       	ldi	r24, 0x28	; 40

  case UIP_TIME_WAIT:
    goto tcp_send_ack;

  case UIP_CLOSING:
    if(uip_flags & UIP_ACKDATA) {
    2f5e:	90 e0       	ldi	r25, 0x00	; 0
    2f60:	90 93 54 06 	sts	0x0654, r25
    2f64:	80 93 53 06 	sts	0x0653, r24
      uip_connr->tcpstateflags = UIP_TIME_WAIT;
    2f68:	80 e5       	ldi	r24, 0x50	; 80
      uip_connr->timer = 0;
    2f6a:	80 93 f9 07 	sts	0x07F9, r24
  goto drop;

  /* We jump here when we are ready to send the packet, and just want
     to set the appropriate TCP sequence numbers in the TCP header. */
 tcp_send_ack:
  BUF->flags = TCP_ACK;
    2f6e:	88 85       	ldd	r24, Y+8	; 0x08
    2f70:	80 93 f5 07 	sts	0x07F5, r24

 tcp_send_nodata:
  uip_len = UIP_IPTCPH_LEN;
    2f74:	89 85       	ldd	r24, Y+9	; 0x09
    2f76:	80 93 f6 07 	sts	0x07F6, r24
    2f7a:	8a 85       	ldd	r24, Y+10	; 0x0a
    2f7c:	80 93 f7 07 	sts	0x07F7, r24

 tcp_send_noopts:
  BUF->tcpoffset = (UIP_TCPH_LEN / 4) << 4;
    2f80:	8b 85       	ldd	r24, Y+11	; 0x0b
    2f82:	80 93 f8 07 	sts	0x07F8, r24
  /* We're done with the input processing. We are now ready to send a
     reply. Our job is to fill in all the fields of the TCP and IP
     headers before calculating the checksum and finally send the
     packet. */
 tcp_send:
  BUF->ackno[0] = uip_connr->rcv_nxt[0];
    2f86:	8c 85       	ldd	r24, Y+12	; 0x0c
    2f88:	80 93 f1 07 	sts	0x07F1, r24
  BUF->ackno[1] = uip_connr->rcv_nxt[1];
    2f8c:	8d 85       	ldd	r24, Y+13	; 0x0d
    2f8e:	80 93 f2 07 	sts	0x07F2, r24
  BUF->ackno[2] = uip_connr->rcv_nxt[2];
    2f92:	8e 85       	ldd	r24, Y+14	; 0x0e
    2f94:	80 93 f3 07 	sts	0x07F3, r24
  BUF->ackno[3] = uip_connr->rcv_nxt[3];
    2f98:	8f 85       	ldd	r24, Y+15	; 0x0f
    2f9a:	80 93 f4 07 	sts	0x07F4, r24

  BUF->seqno[0] = uip_connr->snd_nxt[0];
    2f9e:	86 e0       	ldi	r24, 0x06	; 6
    2fa0:	80 93 e2 07 	sts	0x07E2, r24
  BUF->seqno[1] = uip_connr->snd_nxt[1];
    2fa4:	8c 81       	ldd	r24, Y+4	; 0x04
    2fa6:	9d 81       	ldd	r25, Y+5	; 0x05
    2fa8:	90 93 ee 07 	sts	0x07EE, r25
  BUF->seqno[2] = uip_connr->snd_nxt[2];
    2fac:	80 93 ed 07 	sts	0x07ED, r24
  BUF->seqno[3] = uip_connr->snd_nxt[3];
    2fb0:	8e 81       	ldd	r24, Y+6	; 0x06
    2fb2:	9f 81       	ldd	r25, Y+7	; 0x07
    2fb4:	90 93 f0 07 	sts	0x07F0, r25

  BUF->proto = UIP_PROTO_TCP;
    2fb8:	80 93 ef 07 	sts	0x07EF, r24

  BUF->srcport  = uip_connr->lport;
    2fbc:	80 91 c7 07 	lds	r24, 0x07C7
    2fc0:	90 91 c8 07 	lds	r25, 0x07C8
    2fc4:	a0 91 c9 07 	lds	r26, 0x07C9
  BUF->destport = uip_connr->rport;
    2fc8:	b0 91 ca 07 	lds	r27, 0x07CA
    2fcc:	80 93 e5 07 	sts	0x07E5, r24
    2fd0:	90 93 e6 07 	sts	0x07E6, r25

  uip_ipaddr_copy(&BUF->srcipaddr, &uip_hostaddr);
    2fd4:	a0 93 e7 07 	sts	0x07E7, r26
    2fd8:	b0 93 e8 07 	sts	0x07E8, r27
    2fdc:	88 81       	ld	r24, Y
    2fde:	99 81       	ldd	r25, Y+1	; 0x01
    2fe0:	aa 81       	ldd	r26, Y+2	; 0x02
    2fe2:	bb 81       	ldd	r27, Y+3	; 0x03
    2fe4:	80 93 e9 07 	sts	0x07E9, r24
    2fe8:	90 93 ea 07 	sts	0x07EA, r25
    2fec:	a0 93 eb 07 	sts	0x07EB, r26
    2ff0:	b0 93 ec 07 	sts	0x07EC, r27
  uip_ipaddr_copy(&BUF->destipaddr, &uip_connr->ripaddr);
    2ff4:	89 8d       	ldd	r24, Y+25	; 0x19
    2ff6:	84 ff       	sbrs	r24, 4
    2ff8:	05 c0       	rjmp	.+10     	; 0x3004 <uip_process+0xe52>
    2ffa:	10 92 fc 07 	sts	0x07FC, r1
    2ffe:	10 92 fb 07 	sts	0x07FB, r1
    3002:	06 c0       	rjmp	.+12     	; 0x3010 <uip_process+0xe5e>
    3004:	85 e0       	ldi	r24, 0x05	; 5
    3006:	80 93 fb 07 	sts	0x07FB, r24
    300a:	84 eb       	ldi	r24, 0xB4	; 180

  if(uip_connr->tcpstateflags & UIP_STOPPED) {
    300c:	80 93 fc 07 	sts	0x07FC, r24
    3010:	80 e4       	ldi	r24, 0x40	; 64
    /* If the connection has issued uip_stop(), we advertise a zero
       window so that the remote host will stop sending data. */
    BUF->wnd[0] = BUF->wnd[1] = 0;
    3012:	80 93 e1 07 	sts	0x07E1, r24
    3016:	80 91 53 06 	lds	r24, 0x0653
    301a:	90 91 54 06 	lds	r25, 0x0654
  } else {
    BUF->wnd[0] = ((UIP_RECEIVE_WINDOW) >> 8);
    301e:	90 93 db 07 	sts	0x07DB, r25
    BUF->wnd[1] = ((UIP_RECEIVE_WINDOW) & 0xff);
    3022:	80 93 dc 07 	sts	0x07DC, r24
    3026:	10 92 00 08 	sts	0x0800, r1
  }

 tcp_send_noconn:
  BUF->ttl = UIP_TTL;
    302a:	10 92 ff 07 	sts	0x07FF, r1
  /* For IPv6, the IP length field does not include the IPv6 IP header
     length. */
  BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
  BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
#else /* UIP_CONF_IPV6 */
  BUF->len[0] = (uip_len >> 8);
    302e:	10 92 fe 07 	sts	0x07FE, r1
    3032:	10 92 fd 07 	sts	0x07FD, r1
    3036:	13 d8       	rcall	.-4058   	; 0x205e <uip_tcpchksum>
    3038:	80 95       	com	r24
  BUF->len[1] = (uip_len & 0xff);
    303a:	90 95       	com	r25
    303c:	90 93 fe 07 	sts	0x07FE, r25
#endif /* UIP_CONF_IPV6 */

  BUF->urgp[0] = BUF->urgp[1] = 0;
    3040:	80 93 fd 07 	sts	0x07FD, r24
    3044:	85 e4       	ldi	r24, 0x45	; 69

  /* Calculate TCP checksum. */
  BUF->tcpchksum = 0;
    3046:	80 93 d9 07 	sts	0x07D9, r24
    304a:	10 92 da 07 	sts	0x07DA, r1
  BUF->tcpchksum = ~(uip_tcpchksum());
    304e:	10 92 e0 07 	sts	0x07E0, r1
    3052:	10 92 df 07 	sts	0x07DF, r1
    3056:	80 91 9c 03 	lds	r24, 0x039C
    305a:	90 91 9d 03 	lds	r25, 0x039D
#if UIP_CONF_IPV6
  BUF->vtc = 0x60;
  BUF->tcflow = 0x00;
  BUF->flow = 0x00;
#else /* UIP_CONF_IPV6 */
  BUF->vhl = 0x45;
    305e:	01 96       	adiw	r24, 0x01	; 1
    3060:	90 93 9d 03 	sts	0x039D, r25
  BUF->tos = 0;
    3064:	80 93 9c 03 	sts	0x039C, r24
  BUF->ipoffset[0] = BUF->ipoffset[1] = 0;
    3068:	90 93 dd 07 	sts	0x07DD, r25
    306c:	80 93 de 07 	sts	0x07DE, r24
  ++ipid;
    3070:	10 92 e4 07 	sts	0x07E4, r1
    3074:	10 92 e3 07 	sts	0x07E3, r1
    3078:	0e 94 1f 10 	call	0x203e	; 0x203e <uip_ipchksum>
    307c:	80 95       	com	r24
    307e:	90 95       	com	r25
    3080:	90 93 e4 07 	sts	0x07E4, r25
  BUF->ipid[0] = ipid >> 8;
    3084:	80 93 e3 07 	sts	0x07E3, r24
  BUF->ipid[1] = ipid & 0xff;
    3088:	04 c0       	rjmp	.+8      	; 0x3092 <uip_process+0xee0>
  /* Calculate IP checksum. */
  BUF->ipchksum = 0;
    308a:	10 92 54 06 	sts	0x0654, r1
    308e:	10 92 53 06 	sts	0x0653, r1
  BUF->ipchksum = ~(uip_ipchksum());
    3092:	10 92 5b 06 	sts	0x065B, r1
    3096:	df 91       	pop	r29
    3098:	cf 91       	pop	r28
    309a:	1f 91       	pop	r17
    309c:	0f 91       	pop	r16
    309e:	ff 90       	pop	r15
    30a0:	ef 90       	pop	r14
    30a2:	df 90       	pop	r13
  /* Return and let the caller do the actual transmission. */
  uip_flags = 0;
  return;

 drop:
  uip_len = 0;
    30a4:	cf 90       	pop	r12
    30a6:	bf 90       	pop	r11
    30a8:	af 90       	pop	r10
    30aa:	08 95       	ret

000030ac <uip_send>:
  uip_flags = 0;
    30ac:	fc 01       	movw	r30, r24
    30ae:	80 91 55 06 	lds	r24, 0x0655
  return;
}
    30b2:	90 91 56 06 	lds	r25, 0x0656
    30b6:	25 eb       	ldi	r18, 0xB5	; 181
    30b8:	3d e0       	ldi	r19, 0x0D	; 13
    30ba:	28 1b       	sub	r18, r24
    30bc:	39 0b       	sbc	r19, r25
    30be:	ab 01       	movw	r20, r22
    30c0:	26 17       	cp	r18, r22
    30c2:	37 07       	cpc	r19, r23
    30c4:	0c f4       	brge	.+2      	; 0x30c8 <uip_send+0x1c>
void
uip_send(const void *data, int len)
{
  int copylen;
#define MIN(a,b) ((a) < (b)? (a): (b))
  copylen = MIN(len, UIP_BUFSIZE - UIP_LLH_LEN - UIP_TCPIP_HLEN -
    30c6:	a9 01       	movw	r20, r18
		(int)((char *)uip_sappdata - (char *)&uip_buf[UIP_LLH_LEN + UIP_TCPIP_HLEN]));
  if(copylen > 0) {
    30c8:	14 16       	cp	r1, r20
    30ca:	15 06       	cpc	r1, r21
    30cc:	54 f4       	brge	.+20     	; 0x30e2 <uip_send+0x36>
    uip_slen = copylen;
    30ce:	50 93 b8 0d 	sts	0x0DB8, r21
    30d2:	40 93 b7 0d 	sts	0x0DB7, r20
    if(data != uip_sappdata) {
    30d6:	e8 17       	cp	r30, r24
    30d8:	f9 07       	cpc	r31, r25
    30da:	19 f0       	breq	.+6      	; 0x30e2 <uip_send+0x36>
      memcpy(uip_sappdata, (data), uip_slen);
    30dc:	bf 01       	movw	r22, r30
    30de:	0c 94 9c 3a 	jmp	0x7538	; 0x7538 <memcpy>
    30e2:	08 95       	ret

000030e4 <uip_arp_update.constprop.0>:
  }

}
/*-----------------------------------------------------------------------------------*/
static void
uip_arp_update(uip_ipaddr_t *ipaddr, struct uip_eth_addr *ethaddr)
    30e4:	0f 93       	push	r16
    30e6:	1f 93       	push	r17
    30e8:	cf 93       	push	r28
    30ea:	df 93       	push	r29
{
  register struct arp_entry *tabptr = NULL;
  /* Walk through the ARP mapping table and try to find an entry to
     update. If none is found, the IP -> MAC address mapping is
     inserted in the ARP table. */
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    30ec:	10 92 a1 03 	sts	0x03A1, r1

    tabptr = &arp_table[i];
    /* Only check those entries that are actually in use. */
    if(!uip_ipaddr_cmp(&tabptr->ipaddr, &uip_all_zeroes_addr)) {
    30f0:	80 91 da 01 	lds	r24, 0x01DA
    30f4:	90 91 db 01 	lds	r25, 0x01DB
    30f8:	20 91 dc 01 	lds	r18, 0x01DC
    30fc:	30 91 dd 01 	lds	r19, 0x01DD

      /* Check if the source IP address of the incoming packet matches
         the IP address in this ARP table entry. */
      if(uip_ipaddr_cmp(ipaddr, &tabptr->ipaddr)) {
    3100:	60 91 e7 07 	lds	r22, 0x07E7
    3104:	70 91 e8 07 	lds	r23, 0x07E8
    3108:	e0 91 e9 07 	lds	r30, 0x07E9
    310c:	f0 91 ea 07 	lds	r31, 0x07EA
    3110:	10 e0       	ldi	r17, 0x00	; 0
}
/*-----------------------------------------------------------------------------------*/
static void
uip_arp_update(uip_ipaddr_t *ipaddr, struct uip_eth_addr *ethaddr)
{
  register struct arp_entry *tabptr = NULL;
    3112:	c0 e0       	ldi	r28, 0x00	; 0
    3114:	d0 e0       	ldi	r29, 0x00	; 0
  /* Walk through the ARP mapping table and try to find an entry to
     update. If none is found, the IP -> MAC address mapping is
     inserted in the ARP table. */
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {

    tabptr = &arp_table[i];
    3116:	0b e0       	ldi	r16, 0x0B	; 11
{
  register struct arp_entry *tabptr = NULL;
  /* Walk through the ARP mapping table and try to find an entry to
     update. If none is found, the IP -> MAC address mapping is
     inserted in the ARP table. */
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    3118:	18 30       	cpi	r17, 0x08	; 8
    311a:	08 f5       	brcc	.+66     	; 0x315e <uip_arp_update.constprop.0+0x7a>

    tabptr = &arp_table[i];
    311c:	01 9f       	mul	r16, r17
    311e:	e0 01       	movw	r28, r0
    3120:	11 24       	eor	r1, r1
    3122:	ca 55       	subi	r28, 0x5A	; 90
    3124:	dc 4f       	sbci	r29, 0xFC	; 252
    /* Only check those entries that are actually in use. */
    if(!uip_ipaddr_cmp(&tabptr->ipaddr, &uip_all_zeroes_addr)) {
    3126:	48 81       	ld	r20, Y
    3128:	59 81       	ldd	r21, Y+1	; 0x01
    312a:	48 17       	cp	r20, r24
    312c:	59 07       	cpc	r21, r25
    312e:	29 f4       	brne	.+10     	; 0x313a <uip_arp_update.constprop.0+0x56>
    3130:	aa 81       	ldd	r26, Y+2	; 0x02
    3132:	bb 81       	ldd	r27, Y+3	; 0x03
    3134:	a2 17       	cp	r26, r18
    3136:	b3 07       	cpc	r27, r19
    3138:	81 f0       	breq	.+32     	; 0x315a <uip_arp_update.constprop.0+0x76>

      /* Check if the source IP address of the incoming packet matches
         the IP address in this ARP table entry. */
      if(uip_ipaddr_cmp(ipaddr, &tabptr->ipaddr)) {
    313a:	64 17       	cp	r22, r20
    313c:	75 07       	cpc	r23, r21
    313e:	69 f4       	brne	.+26     	; 0x315a <uip_arp_update.constprop.0+0x76>
    3140:	4a 81       	ldd	r20, Y+2	; 0x02
    3142:	5b 81       	ldd	r21, Y+3	; 0x03
    3144:	e4 17       	cp	r30, r20
    3146:	f5 07       	cpc	r31, r21
    3148:	41 f4       	brne	.+16     	; 0x315a <uip_arp_update.constprop.0+0x76>
    314a:	10 93 a1 03 	sts	0x03A1, r17

	/* An old entry found, update this and return. */
	memcpy(tabptr->ethaddr.addr, ethaddr->addr, 6);
    314e:	de 01       	movw	r26, r28
    3150:	14 96       	adiw	r26, 0x04	; 4
    3152:	86 e0       	ldi	r24, 0x06	; 6
    3154:	e1 ee       	ldi	r30, 0xE1	; 225
    3156:	f7 e0       	ldi	r31, 0x07	; 7
    3158:	5b c0       	rjmp	.+182    	; 0x3210 <uip_arp_update.constprop.0+0x12c>
    315a:	1f 5f       	subi	r17, 0xFF	; 255
    315c:	dd cf       	rjmp	.-70     	; 0x3118 <uip_arp_update.constprop.0+0x34>

  /* If we get here, no existing ARP table entry was found, so we
     create one. */

  /* First, we try to find an unused entry in the ARP table. */
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    315e:	10 92 a1 03 	sts	0x03A1, r1
    tabptr = &arp_table[i];
    if(uip_ipaddr_cmp(&tabptr->ipaddr, &uip_all_zeroes_addr)) {
    3162:	60 e0       	ldi	r22, 0x00	; 0
  /* If we get here, no existing ARP table entry was found, so we
     create one. */

  /* First, we try to find an unused entry in the ARP table. */
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    tabptr = &arp_table[i];
    3164:	7b e0       	ldi	r23, 0x0B	; 11

  /* If we get here, no existing ARP table entry was found, so we
     create one. */

  /* First, we try to find an unused entry in the ARP table. */
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    3166:	68 30       	cpi	r22, 0x08	; 8
    3168:	a0 f4       	brcc	.+40     	; 0x3192 <uip_arp_update.constprop.0+0xae>
    tabptr = &arp_table[i];
    316a:	76 9f       	mul	r23, r22
    316c:	e0 01       	movw	r28, r0
    316e:	11 24       	eor	r1, r1
    3170:	ca 55       	subi	r28, 0x5A	; 90
    3172:	dc 4f       	sbci	r29, 0xFC	; 252
    if(uip_ipaddr_cmp(&tabptr->ipaddr, &uip_all_zeroes_addr)) {
    3174:	48 81       	ld	r20, Y
    3176:	59 81       	ldd	r21, Y+1	; 0x01
    3178:	48 17       	cp	r20, r24
    317a:	59 07       	cpc	r21, r25
    317c:	41 f4       	brne	.+16     	; 0x318e <uip_arp_update.constprop.0+0xaa>
    317e:	4a 81       	ldd	r20, Y+2	; 0x02
    3180:	5b 81       	ldd	r21, Y+3	; 0x03
    3182:	42 17       	cp	r20, r18
    3184:	53 07       	cpc	r21, r19
    3186:	19 f4       	brne	.+6      	; 0x318e <uip_arp_update.constprop.0+0xaa>
    3188:	60 93 a1 03 	sts	0x03A1, r22
    318c:	2f c0       	rjmp	.+94     	; 0x31ec <uip_arp_update.constprop.0+0x108>
    318e:	6f 5f       	subi	r22, 0xFF	; 255
    3190:	ea cf       	rjmp	.-44     	; 0x3166 <uip_arp_update.constprop.0+0x82>
    3192:	60 93 a1 03 	sts	0x03A1, r22
    }
  }

  /* If no unused entry is found, we try to find the oldest entry and
     throw it away. */
  if(i == UIP_ARPTAB_SIZE) {
    3196:	68 30       	cpi	r22, 0x08	; 8
    3198:	49 f5       	brne	.+82     	; 0x31ec <uip_arp_update.constprop.0+0x108>
    tmpage = 0;
    c = 0;
    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
      tabptr = &arp_table[i];
      if(arptime - tabptr->time > tmpage) {
    319a:	a0 91 9f 03 	lds	r26, 0x039F
    319e:	8a 2f       	mov	r24, r26
    31a0:	90 e0       	ldi	r25, 0x00	; 0
    31a2:	70 e0       	ldi	r23, 0x00	; 0
    31a4:	c0 e0       	ldi	r28, 0x00	; 0
    31a6:	60 e0       	ldi	r22, 0x00	; 0
     throw it away. */
  if(i == UIP_ARPTAB_SIZE) {
    tmpage = 0;
    c = 0;
    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
      tabptr = &arp_table[i];
    31a8:	bb e0       	ldi	r27, 0x0B	; 11
  /* If no unused entry is found, we try to find the oldest entry and
     throw it away. */
  if(i == UIP_ARPTAB_SIZE) {
    tmpage = 0;
    c = 0;
    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    31aa:	68 30       	cpi	r22, 0x08	; 8
    31ac:	98 f4       	brcc	.+38     	; 0x31d4 <uip_arp_update.constprop.0+0xf0>
      tabptr = &arp_table[i];
    31ae:	b6 9f       	mul	r27, r22
    31b0:	f0 01       	movw	r30, r0
    31b2:	11 24       	eor	r1, r1
      if(arptime - tabptr->time > tmpage) {
    31b4:	ea 55       	subi	r30, 0x5A	; 90
    31b6:	fc 4f       	sbci	r31, 0xFC	; 252
    31b8:	e2 85       	ldd	r30, Z+10	; 0x0a
    31ba:	ac 01       	movw	r20, r24
    31bc:	4e 1b       	sub	r20, r30
    31be:	51 09       	sbc	r21, r1
    31c0:	27 2f       	mov	r18, r23
    31c2:	30 e0       	ldi	r19, 0x00	; 0
    31c4:	24 17       	cp	r18, r20
    31c6:	35 07       	cpc	r19, r21
    31c8:	1c f4       	brge	.+6      	; 0x31d0 <uip_arp_update.constprop.0+0xec>
	tmpage = arptime - tabptr->time;
	c = i;
    31ca:	c6 2f       	mov	r28, r22
    tmpage = 0;
    c = 0;
    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
      tabptr = &arp_table[i];
      if(arptime - tabptr->time > tmpage) {
	tmpage = arptime - tabptr->time;
    31cc:	7a 2f       	mov	r23, r26
    31ce:	7e 1b       	sub	r23, r30
    31d0:	6f 5f       	subi	r22, 0xFF	; 255
    31d2:	eb cf       	rjmp	.-42     	; 0x31aa <uip_arp_update.constprop.0+0xc6>
    31d4:	70 93 9e 03 	sts	0x039E, r23
    31d8:	c0 93 a0 03 	sts	0x03A0, r28
	c = i;
      }
    }
    i = c;
    31dc:	c0 93 a1 03 	sts	0x03A1, r28
    tabptr = &arp_table[i];
    31e0:	8b e0       	ldi	r24, 0x0B	; 11
    31e2:	c8 9f       	mul	r28, r24
    31e4:	e0 01       	movw	r28, r0
    31e6:	11 24       	eor	r1, r1
    31e8:	ca 55       	subi	r28, 0x5A	; 90
    31ea:	dc 4f       	sbci	r29, 0xFC	; 252
  }

  /* Now, i is the ARP table entry which we will fill with the new
     information. */
  uip_ipaddr_copy(&tabptr->ipaddr, ipaddr);
    31ec:	80 91 e7 07 	lds	r24, 0x07E7
    31f0:	90 91 e8 07 	lds	r25, 0x07E8
    31f4:	a0 91 e9 07 	lds	r26, 0x07E9
    31f8:	b0 91 ea 07 	lds	r27, 0x07EA
    31fc:	fe 01       	movw	r30, r28
    31fe:	81 93       	st	Z+, r24
    3200:	91 93       	st	Z+, r25
    3202:	a1 93       	st	Z+, r26
    3204:	b1 93       	st	Z+, r27
    3206:	9f 01       	movw	r18, r30
  memcpy(tabptr->ethaddr.addr, ethaddr->addr, 6);
    3208:	86 e0       	ldi	r24, 0x06	; 6
    320a:	e1 ee       	ldi	r30, 0xE1	; 225
    320c:	f7 e0       	ldi	r31, 0x07	; 7
    320e:	d9 01       	movw	r26, r18
    3210:	01 90       	ld	r0, Z+
    3212:	0d 92       	st	X+, r0
    3214:	8a 95       	dec	r24
    3216:	e1 f7       	brne	.-8      	; 0x3210 <uip_arp_update.constprop.0+0x12c>
  tabptr->time = arptime;
    3218:	80 91 9f 03 	lds	r24, 0x039F
    321c:	8a 87       	std	Y+10, r24	; 0x0a
}
    321e:	df 91       	pop	r29
    3220:	cf 91       	pop	r28
    3222:	1f 91       	pop	r17
    3224:	0f 91       	pop	r16
    3226:	08 95       	ret

00003228 <uip_arp_init>:
 */
/*-----------------------------------------------------------------------------------*/
void
uip_arp_init(void)
{
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    3228:	10 92 a1 03 	sts	0x03A1, r1
    memset(&arp_table[i].ipaddr, 0, 4);
    322c:	9b e0       	ldi	r25, 0x0B	; 11
 */
/*-----------------------------------------------------------------------------------*/
void
uip_arp_init(void)
{
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    322e:	80 91 a1 03 	lds	r24, 0x03A1
    3232:	88 30       	cpi	r24, 0x08	; 8
    3234:	68 f4       	brcc	.+26     	; 0x3250 <uip_arp_init+0x28>
    memset(&arp_table[i].ipaddr, 0, 4);
    3236:	98 9f       	mul	r25, r24
    3238:	f0 01       	movw	r30, r0
    323a:	11 24       	eor	r1, r1
    323c:	ea 55       	subi	r30, 0x5A	; 90
    323e:	fc 4f       	sbci	r31, 0xFC	; 252
    3240:	10 82       	st	Z, r1
    3242:	11 82       	std	Z+1, r1	; 0x01
    3244:	12 82       	std	Z+2, r1	; 0x02
    3246:	13 82       	std	Z+3, r1	; 0x03
 */
/*-----------------------------------------------------------------------------------*/
void
uip_arp_init(void)
{
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    3248:	8f 5f       	subi	r24, 0xFF	; 255
    324a:	80 93 a1 03 	sts	0x03A1, r24
    324e:	ef cf       	rjmp	.-34     	; 0x322e <uip_arp_init+0x6>
    memset(&arp_table[i].ipaddr, 0, 4);
  }
}
    3250:	08 95       	ret

00003252 <uip_arp_timer>:
 *
 */
/*-----------------------------------------------------------------------------------*/
void
uip_arp_timer(void)
{
    3252:	cf 93       	push	r28
    3254:	df 93       	push	r29
  struct arp_entry *tabptr = NULL;

  ++arptime;
    3256:	40 91 9f 03 	lds	r20, 0x039F
    325a:	4f 5f       	subi	r20, 0xFF	; 255
    325c:	40 93 9f 03 	sts	0x039F, r20
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    3260:	10 92 a1 03 	sts	0x03A1, r1
    tabptr = &arp_table[i];
    3264:	bb e0       	ldi	r27, 0x0B	; 11
    if(uip_ipaddr_cmp(&tabptr->ipaddr, &uip_all_zeroes_addr) &&
    3266:	80 91 da 01 	lds	r24, 0x01DA
    326a:	90 91 db 01 	lds	r25, 0x01DB
    326e:	20 91 dc 01 	lds	r18, 0x01DC
    3272:	30 91 dd 01 	lds	r19, 0x01DD
       arptime - tabptr->time >= UIP_ARP_MAXAGE) {
    3276:	50 e0       	ldi	r21, 0x00	; 0
uip_arp_timer(void)
{
  struct arp_entry *tabptr = NULL;

  ++arptime;
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    3278:	a0 91 a1 03 	lds	r26, 0x03A1
    327c:	a8 30       	cpi	r26, 0x08	; 8
    327e:	f0 f4       	brcc	.+60     	; 0x32bc <uip_arp_timer+0x6a>
    tabptr = &arp_table[i];
    3280:	ba 9f       	mul	r27, r26
    3282:	f0 01       	movw	r30, r0
    3284:	11 24       	eor	r1, r1
    3286:	ea 55       	subi	r30, 0x5A	; 90
    3288:	fc 4f       	sbci	r31, 0xFC	; 252
    if(uip_ipaddr_cmp(&tabptr->ipaddr, &uip_all_zeroes_addr) &&
    328a:	60 81       	ld	r22, Z
    328c:	71 81       	ldd	r23, Z+1	; 0x01
    328e:	68 17       	cp	r22, r24
    3290:	79 07       	cpc	r23, r25
    3292:	81 f4       	brne	.+32     	; 0x32b4 <uip_arp_timer+0x62>
    3294:	62 81       	ldd	r22, Z+2	; 0x02
    3296:	73 81       	ldd	r23, Z+3	; 0x03
    3298:	62 17       	cp	r22, r18
    329a:	73 07       	cpc	r23, r19
    329c:	59 f4       	brne	.+22     	; 0x32b4 <uip_arp_timer+0x62>
       arptime - tabptr->time >= UIP_ARP_MAXAGE) {
    329e:	62 85       	ldd	r22, Z+10	; 0x0a
    32a0:	ea 01       	movw	r28, r20
    32a2:	c6 1b       	sub	r28, r22
    32a4:	d1 09       	sbc	r29, r1
  struct arp_entry *tabptr = NULL;

  ++arptime;
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    tabptr = &arp_table[i];
    if(uip_ipaddr_cmp(&tabptr->ipaddr, &uip_all_zeroes_addr) &&
    32a6:	c8 37       	cpi	r28, 0x78	; 120
    32a8:	d1 05       	cpc	r29, r1
    32aa:	24 f0       	brlt	.+8      	; 0x32b4 <uip_arp_timer+0x62>
       arptime - tabptr->time >= UIP_ARP_MAXAGE) {
      memset(&tabptr->ipaddr, 0, 4);
    32ac:	10 82       	st	Z, r1
    32ae:	11 82       	std	Z+1, r1	; 0x01
    32b0:	12 82       	std	Z+2, r1	; 0x02
    32b2:	13 82       	std	Z+3, r1	; 0x03
uip_arp_timer(void)
{
  struct arp_entry *tabptr = NULL;

  ++arptime;
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    32b4:	af 5f       	subi	r26, 0xFF	; 255
    32b6:	a0 93 a1 03 	sts	0x03A1, r26
    32ba:	de cf       	rjmp	.-68     	; 0x3278 <uip_arp_timer+0x26>
       arptime - tabptr->time >= UIP_ARP_MAXAGE) {
      memset(&tabptr->ipaddr, 0, 4);
    }
  }

}
    32bc:	df 91       	pop	r29
    32be:	cf 91       	pop	r28
    32c0:	08 95       	ret

000032c2 <uip_arp_arpin>:
 */
/*-----------------------------------------------------------------------------------*/
void
uip_arp_arpin(void)
{
  if(uip_len < sizeof(struct arp_hdr)) {
    32c2:	80 91 53 06 	lds	r24, 0x0653
    32c6:	90 91 54 06 	lds	r25, 0x0654
    uip_len = 0;
    32ca:	10 92 54 06 	sts	0x0654, r1
    32ce:	10 92 53 06 	sts	0x0653, r1
 */
/*-----------------------------------------------------------------------------------*/
void
uip_arp_arpin(void)
{
  if(uip_len < sizeof(struct arp_hdr)) {
    32d2:	8a 97       	sbiw	r24, 0x2a	; 42
    32d4:	08 f4       	brcc	.+2      	; 0x32d8 <uip_arp_arpin+0x16>
    uip_len = 0;
    return;
    32d6:	08 95       	ret
  }
  uip_len = 0;

  switch(BUF->opcode) {
    32d8:	80 91 df 07 	lds	r24, 0x07DF
    32dc:	90 91 e0 07 	lds	r25, 0x07E0
    32e0:	81 15       	cp	r24, r1
    32e2:	21 e0       	ldi	r18, 0x01	; 1
    32e4:	92 07       	cpc	r25, r18
    32e6:	29 f0       	breq	.+10     	; 0x32f2 <uip_arp_arpin+0x30>
    32e8:	81 15       	cp	r24, r1
    32ea:	92 40       	sbci	r25, 0x02	; 2
    32ec:	09 f4       	brne	.+2      	; 0x32f0 <uip_arp_arpin+0x2e>
    32ee:	71 c0       	rjmp	.+226    	; 0x33d2 <uip_arp_arpin+0x110>
    32f0:	08 95       	ret
    PRINTF("uip_arp_arpin: request for %d.%d.%d.%d (we are %d.%d.%d.%d)\n",
	   BUF->dipaddr.u8[0], BUF->dipaddr.u8[1],
	   BUF->dipaddr.u8[2], BUF->dipaddr.u8[3],
	   uip_hostaddr.u8[0], uip_hostaddr.u8[1],
	   uip_hostaddr.u8[2], uip_hostaddr.u8[3]);
    if(uip_ipaddr_cmp(&BUF->dipaddr, &uip_hostaddr)) {
    32f2:	20 91 f1 07 	lds	r18, 0x07F1
    32f6:	30 91 f2 07 	lds	r19, 0x07F2
    32fa:	80 91 c7 07 	lds	r24, 0x07C7
    32fe:	90 91 c8 07 	lds	r25, 0x07C8
    3302:	28 17       	cp	r18, r24
    3304:	39 07       	cpc	r19, r25
    3306:	09 f0       	breq	.+2      	; 0x330a <uip_arp_arpin+0x48>
    3308:	7b c0       	rjmp	.+246    	; 0x3400 <uip_arp_arpin+0x13e>
    330a:	20 91 f3 07 	lds	r18, 0x07F3
    330e:	30 91 f4 07 	lds	r19, 0x07F4
    3312:	80 91 c9 07 	lds	r24, 0x07C9
    3316:	90 91 ca 07 	lds	r25, 0x07CA
    331a:	28 17       	cp	r18, r24
    331c:	39 07       	cpc	r19, r25
    331e:	09 f0       	breq	.+2      	; 0x3322 <uip_arp_arpin+0x60>
    3320:	6f c0       	rjmp	.+222    	; 0x3400 <uip_arp_arpin+0x13e>
      /* First, we register the one who made the request in our ARP
	 table, since it is likely that we will do more communication
	 with this host in the future. */
      uip_arp_update(&BUF->sipaddr, &BUF->shwaddr);
    3322:	e0 de       	rcall	.-576    	; 0x30e4 <uip_arp_update.constprop.0>
    3324:	80 e0       	ldi	r24, 0x00	; 0

      BUF->opcode = HTONS(ARP_REPLY);
    3326:	92 e0       	ldi	r25, 0x02	; 2
    3328:	90 93 e0 07 	sts	0x07E0, r25
    332c:	80 93 df 07 	sts	0x07DF, r24
    3330:	86 e0       	ldi	r24, 0x06	; 6

      memcpy(BUF->dhwaddr.addr, BUF->shwaddr.addr, 6);
    3332:	e1 ee       	ldi	r30, 0xE1	; 225
    3334:	f7 e0       	ldi	r31, 0x07	; 7
    3336:	ab ee       	ldi	r26, 0xEB	; 235
    3338:	b7 e0       	ldi	r27, 0x07	; 7
    333a:	01 90       	ld	r0, Z+
    333c:	0d 92       	st	X+, r0
    333e:	8a 95       	dec	r24
    3340:	e1 f7       	brne	.-8      	; 0x333a <uip_arp_arpin+0x78>
    3342:	86 e0       	ldi	r24, 0x06	; 6
      memcpy(BUF->shwaddr.addr, uip_ethaddr.addr, 6);
    3344:	ec e8       	ldi	r30, 0x8C	; 140
    3346:	f3 e0       	ldi	r31, 0x03	; 3
    3348:	a1 ee       	ldi	r26, 0xE1	; 225
    334a:	b7 e0       	ldi	r27, 0x07	; 7
    334c:	01 90       	ld	r0, Z+
    334e:	0d 92       	st	X+, r0
    3350:	8a 95       	dec	r24
    3352:	e1 f7       	brne	.-8      	; 0x334c <uip_arp_arpin+0x8a>
    3354:	86 e0       	ldi	r24, 0x06	; 6
      memcpy(BUF->ethhdr.src.addr, uip_ethaddr.addr, 6);
    3356:	ec e8       	ldi	r30, 0x8C	; 140
    3358:	f3 e0       	ldi	r31, 0x03	; 3
    335a:	a1 ed       	ldi	r26, 0xD1	; 209
    335c:	b7 e0       	ldi	r27, 0x07	; 7
    335e:	01 90       	ld	r0, Z+
    3360:	0d 92       	st	X+, r0
    3362:	8a 95       	dec	r24
    3364:	e1 f7       	brne	.-8      	; 0x335e <uip_arp_arpin+0x9c>
    3366:	86 e0       	ldi	r24, 0x06	; 6
      memcpy(BUF->ethhdr.dest.addr, BUF->dhwaddr.addr, 6);
    3368:	eb ee       	ldi	r30, 0xEB	; 235
    336a:	f7 e0       	ldi	r31, 0x07	; 7
    336c:	ab ec       	ldi	r26, 0xCB	; 203
    336e:	b7 e0       	ldi	r27, 0x07	; 7
    3370:	01 90       	ld	r0, Z+
    3372:	0d 92       	st	X+, r0
    3374:	8a 95       	dec	r24
    3376:	e1 f7       	brne	.-8      	; 0x3370 <uip_arp_arpin+0xae>
    3378:	80 91 e7 07 	lds	r24, 0x07E7

      uip_ipaddr_copy(&BUF->dipaddr, &BUF->sipaddr);
    337c:	90 91 e8 07 	lds	r25, 0x07E8
    3380:	a0 91 e9 07 	lds	r26, 0x07E9
    3384:	b0 91 ea 07 	lds	r27, 0x07EA
    3388:	80 93 f1 07 	sts	0x07F1, r24
    338c:	90 93 f2 07 	sts	0x07F2, r25
    3390:	a0 93 f3 07 	sts	0x07F3, r26
    3394:	b0 93 f4 07 	sts	0x07F4, r27
    3398:	80 91 c7 07 	lds	r24, 0x07C7
      uip_ipaddr_copy(&BUF->sipaddr, &uip_hostaddr);
    339c:	90 91 c8 07 	lds	r25, 0x07C8
    33a0:	a0 91 c9 07 	lds	r26, 0x07C9
    33a4:	b0 91 ca 07 	lds	r27, 0x07CA
    33a8:	80 93 e7 07 	sts	0x07E7, r24
    33ac:	90 93 e8 07 	sts	0x07E8, r25
    33b0:	a0 93 e9 07 	sts	0x07E9, r26
    33b4:	b0 93 ea 07 	sts	0x07EA, r27
    33b8:	88 e0       	ldi	r24, 0x08	; 8

      BUF->ethhdr.type = HTONS(UIP_ETHTYPE_ARP);
    33ba:	96 e0       	ldi	r25, 0x06	; 6
    33bc:	90 93 d8 07 	sts	0x07D8, r25
    33c0:	80 93 d7 07 	sts	0x07D7, r24
    33c4:	8a e2       	ldi	r24, 0x2A	; 42
      uip_len = sizeof(struct arp_hdr);
    33c6:	90 e0       	ldi	r25, 0x00	; 0
    33c8:	90 93 54 06 	sts	0x0654, r25
    33cc:	80 93 53 06 	sts	0x0653, r24
    33d0:	08 95       	ret
    33d2:	20 91 f1 07 	lds	r18, 0x07F1
    }
    break;
  case HTONS(ARP_REPLY):
    /* ARP reply. We insert or update the ARP table if it was meant
       for us. */
    if(uip_ipaddr_cmp(&BUF->dipaddr, &uip_hostaddr)) {
    33d6:	30 91 f2 07 	lds	r19, 0x07F2
    33da:	80 91 c7 07 	lds	r24, 0x07C7
    33de:	90 91 c8 07 	lds	r25, 0x07C8
    33e2:	28 17       	cp	r18, r24
    33e4:	39 07       	cpc	r19, r25
    33e6:	61 f4       	brne	.+24     	; 0x3400 <uip_arp_arpin+0x13e>
    33e8:	20 91 f3 07 	lds	r18, 0x07F3
    33ec:	30 91 f4 07 	lds	r19, 0x07F4
    33f0:	80 91 c9 07 	lds	r24, 0x07C9
    33f4:	90 91 ca 07 	lds	r25, 0x07CA
    33f8:	28 17       	cp	r18, r24
    33fa:	39 07       	cpc	r19, r25
    33fc:	09 f4       	brne	.+2      	; 0x3400 <uip_arp_arpin+0x13e>
    33fe:	72 ce       	rjmp	.-796    	; 0x30e4 <uip_arp_update.constprop.0>
      uip_arp_update(&BUF->sipaddr, &BUF->shwaddr);
    3400:	08 95       	ret

00003402 <uip_arp_out>:
    3402:	20 91 e9 07 	lds	r18, 0x07E9

     If not ARP table entry is found, we overwrite the original IP
     packet with an ARP request for the IP address. */

  /* First check if destination is a local broadcast. */
  if(uip_ipaddr_cmp(&IPBUF->destipaddr, &uip_broadcast_addr)) {
    3406:	30 91 ea 07 	lds	r19, 0x07EA
    340a:	80 91 de 01 	lds	r24, 0x01DE
    340e:	90 91 df 01 	lds	r25, 0x01DF
    3412:	28 17       	cp	r18, r24
    3414:	39 07       	cpc	r19, r25
    3416:	79 f4       	brne	.+30     	; 0x3436 <uip_arp_out+0x34>
    3418:	40 91 eb 07 	lds	r20, 0x07EB
    341c:	50 91 ec 07 	lds	r21, 0x07EC
    3420:	80 91 e0 01 	lds	r24, 0x01E0
    3424:	90 91 e1 01 	lds	r25, 0x01E1
    3428:	48 17       	cp	r20, r24
    342a:	59 07       	cpc	r21, r25
    342c:	21 f4       	brne	.+8      	; 0x3436 <uip_arp_out+0x34>
    memcpy(IPBUF->ethhdr.dest.addr, broadcast_ethaddr.addr, 6);
    342e:	86 e0       	ldi	r24, 0x06	; 6
    3430:	e2 ee       	ldi	r30, 0xE2	; 226
    3432:	f1 e0       	ldi	r31, 0x01	; 1
    3434:	ca c0       	rjmp	.+404    	; 0x35ca <uip_arp_out+0x1c8>
  } else {
    /* Check if the destination address is on the local network. */
    if(!uip_ipaddr_maskcmp(&IPBUF->destipaddr, &uip_hostaddr, &uip_netmask)) {
    3436:	80 91 c7 07 	lds	r24, 0x07C7
    343a:	90 91 c8 07 	lds	r25, 0x07C8
    343e:	82 27       	eor	r24, r18
    3440:	93 27       	eor	r25, r19
    3442:	20 91 c3 07 	lds	r18, 0x07C3
    3446:	30 91 c4 07 	lds	r19, 0x07C4
    344a:	82 23       	and	r24, r18
    344c:	93 23       	and	r25, r19
    344e:	89 2b       	or	r24, r25
    3450:	91 f4       	brne	.+36     	; 0x3476 <uip_arp_out+0x74>
    3452:	80 91 c9 07 	lds	r24, 0x07C9
    3456:	90 91 ca 07 	lds	r25, 0x07CA
    345a:	20 91 eb 07 	lds	r18, 0x07EB
    345e:	30 91 ec 07 	lds	r19, 0x07EC
    3462:	82 27       	eor	r24, r18
    3464:	93 27       	eor	r25, r19
    3466:	20 91 c5 07 	lds	r18, 0x07C5
    346a:	30 91 c6 07 	lds	r19, 0x07C6
    346e:	82 23       	and	r24, r18
    3470:	93 23       	and	r25, r19
    3472:	89 2b       	or	r24, r25
    3474:	49 f0       	breq	.+18     	; 0x3488 <uip_arp_out+0x86>
      /* Destination address was not on the local network, so we need to
	 use the default router's IP address instead of the destination
	 address when determining the MAC address. */
      uip_ipaddr_copy(&ipaddr, &uip_draddr);
    3476:	80 91 bf 07 	lds	r24, 0x07BF
    347a:	90 91 c0 07 	lds	r25, 0x07C0
    347e:	a0 91 c1 07 	lds	r26, 0x07C1
    3482:	b0 91 c2 07 	lds	r27, 0x07C2
    3486:	08 c0       	rjmp	.+16     	; 0x3498 <uip_arp_out+0x96>
    } else {
      /* Else, we use the destination IP address. */
      uip_ipaddr_copy(&ipaddr, &IPBUF->destipaddr);
    3488:	80 91 e9 07 	lds	r24, 0x07E9
    348c:	90 91 ea 07 	lds	r25, 0x07EA
    3490:	a0 91 eb 07 	lds	r26, 0x07EB
    3494:	b0 91 ec 07 	lds	r27, 0x07EC
    3498:	80 93 a2 03 	sts	0x03A2, r24
    349c:	90 93 a3 03 	sts	0x03A3, r25
    34a0:	a0 93 a4 03 	sts	0x03A4, r26
    34a4:	b0 93 a5 03 	sts	0x03A5, r27
    }

    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    34a8:	10 92 a1 03 	sts	0x03A1, r1
      tabptr = &arp_table[i];
      if(uip_ipaddr_cmp(&ipaddr, &tabptr->ipaddr)) {
    34ac:	80 91 a2 03 	lds	r24, 0x03A2
    34b0:	90 91 a3 03 	lds	r25, 0x03A3
    34b4:	20 91 a4 03 	lds	r18, 0x03A4
    34b8:	30 91 a5 03 	lds	r19, 0x03A5
    } else {
      /* Else, we use the destination IP address. */
      uip_ipaddr_copy(&ipaddr, &IPBUF->destipaddr);
    }

    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    34bc:	60 e0       	ldi	r22, 0x00	; 0
 */
/*-----------------------------------------------------------------------------------*/
void
uip_arp_out(void)
{
  struct arp_entry *tabptr = NULL;
    34be:	e0 e0       	ldi	r30, 0x00	; 0
    34c0:	f0 e0       	ldi	r31, 0x00	; 0
      /* Else, we use the destination IP address. */
      uip_ipaddr_copy(&ipaddr, &IPBUF->destipaddr);
    }

    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
      tabptr = &arp_table[i];
    34c2:	7b e0       	ldi	r23, 0x0B	; 11
    } else {
      /* Else, we use the destination IP address. */
      uip_ipaddr_copy(&ipaddr, &IPBUF->destipaddr);
    }

    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    34c4:	68 30       	cpi	r22, 0x08	; 8
    34c6:	90 f4       	brcc	.+36     	; 0x34ec <uip_arp_out+0xea>
      tabptr = &arp_table[i];
    34c8:	76 9f       	mul	r23, r22
    34ca:	f0 01       	movw	r30, r0
    34cc:	11 24       	eor	r1, r1
    34ce:	ea 55       	subi	r30, 0x5A	; 90
    34d0:	fc 4f       	sbci	r31, 0xFC	; 252
      if(uip_ipaddr_cmp(&ipaddr, &tabptr->ipaddr)) {
    34d2:	40 81       	ld	r20, Z
    34d4:	51 81       	ldd	r21, Z+1	; 0x01
    34d6:	84 17       	cp	r24, r20
    34d8:	95 07       	cpc	r25, r21
    34da:	31 f4       	brne	.+12     	; 0x34e8 <uip_arp_out+0xe6>
    34dc:	42 81       	ldd	r20, Z+2	; 0x02
    34de:	53 81       	ldd	r21, Z+3	; 0x03
    34e0:	24 17       	cp	r18, r20
    34e2:	35 07       	cpc	r19, r21
    34e4:	09 f4       	brne	.+2      	; 0x34e8 <uip_arp_out+0xe6>
    34e6:	6d c0       	rjmp	.+218    	; 0x35c2 <uip_arp_out+0x1c0>
    34e8:	6f 5f       	subi	r22, 0xFF	; 255
    34ea:	ec cf       	rjmp	.-40     	; 0x34c4 <uip_arp_out+0xc2>
    34ec:	60 93 a1 03 	sts	0x03A1, r22
	break;
      }
    }

    if(i == UIP_ARPTAB_SIZE) {
    34f0:	68 30       	cpi	r22, 0x08	; 8
    34f2:	09 f0       	breq	.+2      	; 0x34f6 <uip_arp_out+0xf4>
    34f4:	68 c0       	rjmp	.+208    	; 0x35c6 <uip_arp_out+0x1c4>
      /* The destination address was not in our ARP table, so we
	 overwrite the IP packet with an ARP request. */

      memset(BUF->ethhdr.dest.addr, 0xff, 6);
    34f6:	46 e0       	ldi	r20, 0x06	; 6
    34f8:	50 e0       	ldi	r21, 0x00	; 0
    34fa:	6f ef       	ldi	r22, 0xFF	; 255
    34fc:	70 e0       	ldi	r23, 0x00	; 0
    34fe:	8b ec       	ldi	r24, 0xCB	; 203
    3500:	97 e0       	ldi	r25, 0x07	; 7
    3502:	0e 94 a5 3a 	call	0x754a	; 0x754a <memset>
      memset(BUF->dhwaddr.addr, 0x00, 6);
    3506:	26 e0       	ldi	r18, 0x06	; 6
    3508:	eb ee       	ldi	r30, 0xEB	; 235
    350a:	f7 e0       	ldi	r31, 0x07	; 7
    350c:	df 01       	movw	r26, r30
    350e:	82 2f       	mov	r24, r18
    3510:	1d 92       	st	X+, r1
    3512:	8a 95       	dec	r24
    3514:	e9 f7       	brne	.-6      	; 0x3510 <uip_arp_out+0x10e>
      memcpy(BUF->ethhdr.src.addr, uip_ethaddr.addr, 6);
    3516:	ec e8       	ldi	r30, 0x8C	; 140
    3518:	f3 e0       	ldi	r31, 0x03	; 3
    351a:	a1 ed       	ldi	r26, 0xD1	; 209
    351c:	b7 e0       	ldi	r27, 0x07	; 7
    351e:	82 2f       	mov	r24, r18
    3520:	01 90       	ld	r0, Z+
    3522:	0d 92       	st	X+, r0
    3524:	8a 95       	dec	r24
    3526:	e1 f7       	brne	.-8      	; 0x3520 <uip_arp_out+0x11e>
      memcpy(BUF->shwaddr.addr, uip_ethaddr.addr, 6);
    3528:	ec e8       	ldi	r30, 0x8C	; 140
    352a:	f3 e0       	ldi	r31, 0x03	; 3
    352c:	a1 ee       	ldi	r26, 0xE1	; 225
    352e:	b7 e0       	ldi	r27, 0x07	; 7
    3530:	82 2f       	mov	r24, r18
    3532:	01 90       	ld	r0, Z+
    3534:	0d 92       	st	X+, r0
    3536:	8a 95       	dec	r24
    3538:	e1 f7       	brne	.-8      	; 0x3532 <uip_arp_out+0x130>

      uip_ipaddr_copy(&BUF->dipaddr, &ipaddr);
    353a:	80 91 a2 03 	lds	r24, 0x03A2
    353e:	90 91 a3 03 	lds	r25, 0x03A3
    3542:	a0 91 a4 03 	lds	r26, 0x03A4
    3546:	b0 91 a5 03 	lds	r27, 0x03A5
    354a:	80 93 f1 07 	sts	0x07F1, r24
    354e:	90 93 f2 07 	sts	0x07F2, r25
    3552:	a0 93 f3 07 	sts	0x07F3, r26
    3556:	b0 93 f4 07 	sts	0x07F4, r27
      uip_ipaddr_copy(&BUF->sipaddr, &uip_hostaddr);
    355a:	80 91 c7 07 	lds	r24, 0x07C7
    355e:	90 91 c8 07 	lds	r25, 0x07C8
    3562:	a0 91 c9 07 	lds	r26, 0x07C9
    3566:	b0 91 ca 07 	lds	r27, 0x07CA
    356a:	80 93 e7 07 	sts	0x07E7, r24
    356e:	90 93 e8 07 	sts	0x07E8, r25
    3572:	a0 93 e9 07 	sts	0x07E9, r26
    3576:	b0 93 ea 07 	sts	0x07EA, r27
      BUF->opcode = HTONS(ARP_REQUEST); /* ARP request. */
    357a:	80 e0       	ldi	r24, 0x00	; 0
    357c:	91 e0       	ldi	r25, 0x01	; 1
    357e:	90 93 e0 07 	sts	0x07E0, r25
    3582:	80 93 df 07 	sts	0x07DF, r24
      BUF->hwtype = HTONS(ARP_HWTYPE_ETH);
    3586:	90 93 da 07 	sts	0x07DA, r25
    358a:	80 93 d9 07 	sts	0x07D9, r24
      BUF->protocol = HTONS(UIP_ETHTYPE_IP);
    358e:	88 e0       	ldi	r24, 0x08	; 8
    3590:	90 e0       	ldi	r25, 0x00	; 0
    3592:	90 93 dc 07 	sts	0x07DC, r25
    3596:	80 93 db 07 	sts	0x07DB, r24
      BUF->hwlen = 6;
    359a:	20 93 dd 07 	sts	0x07DD, r18
      BUF->protolen = 4;
    359e:	84 e0       	ldi	r24, 0x04	; 4
    35a0:	80 93 de 07 	sts	0x07DE, r24
      BUF->ethhdr.type = HTONS(UIP_ETHTYPE_ARP);
    35a4:	88 e0       	ldi	r24, 0x08	; 8
    35a6:	96 e0       	ldi	r25, 0x06	; 6
    35a8:	90 93 d8 07 	sts	0x07D8, r25
    35ac:	80 93 d7 07 	sts	0x07D7, r24

      uip_appdata = &uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN];
    35b0:	81 e0       	ldi	r24, 0x01	; 1
    35b2:	98 e0       	ldi	r25, 0x08	; 8
    35b4:	90 93 5f 06 	sts	0x065F, r25
    35b8:	80 93 5e 06 	sts	0x065E, r24

      uip_len = sizeof(struct arp_hdr);
    35bc:	8a e2       	ldi	r24, 0x2A	; 42
    35be:	90 e0       	ldi	r25, 0x00	; 0
    35c0:	1e c0       	rjmp	.+60     	; 0x35fe <uip_arp_out+0x1fc>
    35c2:	60 93 a1 03 	sts	0x03A1, r22
      return;
    }

    /* Build an ethernet header. */
    memcpy(IPBUF->ethhdr.dest.addr, tabptr->ethaddr.addr, 6);
    35c6:	34 96       	adiw	r30, 0x04	; 4
    35c8:	86 e0       	ldi	r24, 0x06	; 6
    35ca:	ab ec       	ldi	r26, 0xCB	; 203
    35cc:	b7 e0       	ldi	r27, 0x07	; 7
    35ce:	01 90       	ld	r0, Z+
    35d0:	0d 92       	st	X+, r0
    35d2:	8a 95       	dec	r24
    35d4:	e1 f7       	brne	.-8      	; 0x35ce <uip_arp_out+0x1cc>
  }
  memcpy(IPBUF->ethhdr.src.addr, uip_ethaddr.addr, 6);
    35d6:	86 e0       	ldi	r24, 0x06	; 6
    35d8:	ec e8       	ldi	r30, 0x8C	; 140
    35da:	f3 e0       	ldi	r31, 0x03	; 3
    35dc:	a1 ed       	ldi	r26, 0xD1	; 209
    35de:	b7 e0       	ldi	r27, 0x07	; 7
    35e0:	01 90       	ld	r0, Z+
    35e2:	0d 92       	st	X+, r0
    35e4:	8a 95       	dec	r24
    35e6:	e1 f7       	brne	.-8      	; 0x35e0 <uip_arp_out+0x1de>

  IPBUF->ethhdr.type = HTONS(UIP_ETHTYPE_IP);
    35e8:	88 e0       	ldi	r24, 0x08	; 8
    35ea:	90 e0       	ldi	r25, 0x00	; 0
    35ec:	90 93 d8 07 	sts	0x07D8, r25
    35f0:	80 93 d7 07 	sts	0x07D7, r24

  uip_len += sizeof(struct uip_eth_hdr);
    35f4:	80 91 53 06 	lds	r24, 0x0653
    35f8:	90 91 54 06 	lds	r25, 0x0654
    35fc:	0e 96       	adiw	r24, 0x0e	; 14
    35fe:	90 93 54 06 	sts	0x0654, r25
    3602:	80 93 53 06 	sts	0x0653, r24
    3606:	08 95       	ret

00003608 <timer_set>:
 * \param interval The interval before the timer expires.
 *
 */
void
timer_set(struct timer *t, clock_time_t interval)
{
    3608:	cf 93       	push	r28
    360a:	df 93       	push	r29
    360c:	ec 01       	movw	r28, r24
  t->interval = interval;
    360e:	7b 83       	std	Y+3, r23	; 0x03
    3610:	6a 83       	std	Y+2, r22	; 0x02
  t->start = clock_time();
    3612:	48 d0       	rcall	.+144    	; 0x36a4 <clock_time>
    3614:	99 83       	std	Y+1, r25	; 0x01
    3616:	88 83       	st	Y, r24
    3618:	df 91       	pop	r29
}
    361a:	cf 91       	pop	r28
    361c:	08 95       	ret

0000361e <timer_reset>:
    361e:	fc 01       	movw	r30, r24
 * \sa timer_restart()
 */
void
timer_reset(struct timer *t)
{
  t->start += t->interval;
    3620:	80 81       	ld	r24, Z
    3622:	91 81       	ldd	r25, Z+1	; 0x01
    3624:	22 81       	ldd	r18, Z+2	; 0x02
    3626:	33 81       	ldd	r19, Z+3	; 0x03
    3628:	82 0f       	add	r24, r18
    362a:	93 1f       	adc	r25, r19
    362c:	91 83       	std	Z+1, r25	; 0x01
    362e:	80 83       	st	Z, r24
    3630:	08 95       	ret

00003632 <timer_expired>:
 * \return Non-zero if the timer has expired, zero otherwise.
 *
 */
int
timer_expired(struct timer *t)
{
    3632:	cf 93       	push	r28
    3634:	df 93       	push	r29
    3636:	ec 01       	movw	r28, r24
  return (clock_time_t)(clock_time() - t->start) >= (clock_time_t)t->interval;
    3638:	35 d0       	rcall	.+106    	; 0x36a4 <clock_time>
    363a:	28 81       	ld	r18, Y
    363c:	39 81       	ldd	r19, Y+1	; 0x01
    363e:	ac 01       	movw	r20, r24
    3640:	42 1b       	sub	r20, r18
    3642:	53 0b       	sbc	r21, r19
    3644:	81 e0       	ldi	r24, 0x01	; 1
    3646:	90 e0       	ldi	r25, 0x00	; 0
    3648:	2a 81       	ldd	r18, Y+2	; 0x02
    364a:	3b 81       	ldd	r19, Y+3	; 0x03
    364c:	42 17       	cp	r20, r18
    364e:	53 07       	cpc	r21, r19
    3650:	10 f4       	brcc	.+4      	; 0x3656 <timer_expired+0x24>
    3652:	80 e0       	ldi	r24, 0x00	; 0
    3654:	90 e0       	ldi	r25, 0x00	; 0
    3656:	df 91       	pop	r29
}
    3658:	cf 91       	pop	r28
    365a:	08 95       	ret

0000365c <__vector_17>:
//Counted time
volatile clock_time_t clock_datetime = 0;

//Overflow interrupt
ISR(TIMER1_COMPA_vect, ISR_BLOCK)
{
    365c:	1f 92       	push	r1
    365e:	0f 92       	push	r0
    3660:	0f b6       	in	r0, 0x3f	; 63
    3662:	0f 92       	push	r0
    3664:	11 24       	eor	r1, r1
    3666:	8f 93       	push	r24
    3668:	9f 93       	push	r25
	clock_datetime += 1;
    366a:	80 91 fe 03 	lds	r24, 0x03FE
    366e:	90 91 ff 03 	lds	r25, 0x03FF
    3672:	01 96       	adiw	r24, 0x01	; 1
    3674:	90 93 ff 03 	sts	0x03FF, r25
    3678:	80 93 fe 03 	sts	0x03FE, r24
}
    367c:	9f 91       	pop	r25
    367e:	8f 91       	pop	r24
    3680:	0f 90       	pop	r0
    3682:	0f be       	out	0x3f, r0	; 63
    3684:	0f 90       	pop	r0
    3686:	1f 90       	pop	r1
    3688:	18 95       	reti

0000368a <clock_init>:

//Initialise the clock
void clock_init()
{
	OCR1A  = (((F_CPU / 1024) / 100) - 1);
    368a:	8d e4       	ldi	r24, 0x4D	; 77
    368c:	90 e0       	ldi	r25, 0x00	; 0
    368e:	90 93 89 00 	sts	0x0089, r25
    3692:	80 93 88 00 	sts	0x0088, r24
	TCCR1B = ((1 << WGM12) | (1 << CS12) | (1 << CS10));
    3696:	8d e0       	ldi	r24, 0x0D	; 13
    3698:	80 93 81 00 	sts	0x0081, r24
	TIMSK1 = (1 << OCIE1A);
    369c:	82 e0       	ldi	r24, 0x02	; 2
    369e:	80 93 6f 00 	sts	0x006F, r24
    36a2:	08 95       	ret

000036a4 <clock_time>:
			static inline void GlobalInterruptDisable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				cli();
    36a4:	f8 94       	cli
clock_time_t clock_time()
{
	clock_time_t time;

	GlobalInterruptDisable();
	time = clock_datetime;
    36a6:	80 91 fe 03 	lds	r24, 0x03FE
    36aa:	90 91 ff 03 	lds	r25, 0x03FF
			static inline void GlobalInterruptEnable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				sei();
    36ae:	78 94       	sei
	GlobalInterruptEnable();

	return time;
}
    36b0:	08 95       	ret

000036b2 <uip_split_output>:
{
#if UIP_TCP
  u16_t tcplen, len1, len2;

  /* We only try to split maximum sized TCP segments. */
  if(BUF->proto == UIP_PROTO_TCP  && uip_len == UIP_BUFSIZE) {
    36b2:	80 91 e2 07 	lds	r24, 0x07E2
    36b6:	40 91 53 06 	lds	r20, 0x0653
    36ba:	50 91 54 06 	lds	r21, 0x0654
    36be:	86 30       	cpi	r24, 0x06	; 6
    36c0:	09 f0       	breq	.+2      	; 0x36c4 <uip_split_output+0x12>
    36c2:	8a c0       	rjmp	.+276    	; 0x37d8 <uip_split_output+0x126>
    36c4:	4a 3e       	cpi	r20, 0xEA	; 234
    36c6:	85 e0       	ldi	r24, 0x05	; 5
    36c8:	58 07       	cpc	r21, r24
    36ca:	09 f0       	breq	.+2      	; 0x36ce <uip_split_output+0x1c>
    36cc:	85 c0       	rjmp	.+266    	; 0x37d8 <uip_split_output+0x126>
      ++len2;
    }

    /* Create the first packet. This is done by altering the length
       field of the IP header and updating the checksums. */
    uip_len = len1 + UIP_TCPIP_HLEN + UIP_LLH_LEN;
    36ce:	80 e1       	ldi	r24, 0x10	; 16
    36d0:	93 e0       	ldi	r25, 0x03	; 3
    36d2:	90 93 54 06 	sts	0x0654, r25
    36d6:	80 93 53 06 	sts	0x0653, r24
    /* For IPv6, the IP length field does not include the IPv6 IP header
       length. */
    BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
    BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
#else /* UIP_CONF_IPV6 */
    BUF->len[0] = (uip_len - UIP_LLH_LEN) >> 8;
    36da:	83 e0       	ldi	r24, 0x03	; 3
    36dc:	80 93 db 07 	sts	0x07DB, r24
    BUF->len[1] = (uip_len - UIP_LLH_LEN) & 0xff;
    36e0:	82 e0       	ldi	r24, 0x02	; 2
    36e2:	80 93 dc 07 	sts	0x07DC, r24
#endif /* UIP_CONF_IPV6 */

    /* Recalculate the TCP checksum. */
    BUF->tcpchksum = 0;
    36e6:	10 92 fe 07 	sts	0x07FE, r1
    36ea:	10 92 fd 07 	sts	0x07FD, r1
    BUF->tcpchksum = ~(uip_tcpchksum());
    36ee:	0e 94 2f 10 	call	0x205e	; 0x205e <uip_tcpchksum>
    36f2:	80 95       	com	r24
    36f4:	90 95       	com	r25
    36f6:	90 93 fe 07 	sts	0x07FE, r25
    36fa:	80 93 fd 07 	sts	0x07FD, r24

#if !UIP_CONF_IPV6
    /* Recalculate the IP checksum. */
    BUF->ipchksum = 0;
    36fe:	10 92 e4 07 	sts	0x07E4, r1
    3702:	10 92 e3 07 	sts	0x07E3, r1
    BUF->ipchksum = ~(uip_ipchksum());
    3706:	0e 94 1f 10 	call	0x203e	; 0x203e <uip_ipchksum>
    370a:	80 95       	com	r24
    370c:	90 95       	com	r25
    370e:	90 93 e4 07 	sts	0x07E4, r25
    3712:	80 93 e3 07 	sts	0x07E3, r24

    /* Transmit the first packet. */
#if UIP_CONF_IPV6
    tcpip_ipv6_output();
#else
	if (USB_CurrentMode == USB_MODE_Device)
    3716:	80 91 07 04 	lds	r24, 0x0407
    371a:	40 91 53 06 	lds	r20, 0x0653
    371e:	50 91 54 06 	lds	r21, 0x0654
	  RNDIS_Device_SendPacket(&Ethernet_RNDIS_Interface_Device, uip_buf, uip_len);
    3722:	6b ec       	ldi	r22, 0xCB	; 203
    3724:	77 e0       	ldi	r23, 0x07	; 7

    /* Transmit the first packet. */
#if UIP_CONF_IPV6
    tcpip_ipv6_output();
#else
	if (USB_CurrentMode == USB_MODE_Device)
    3726:	81 30       	cpi	r24, 0x01	; 1
    3728:	29 f4       	brne	.+10     	; 0x3734 <uip_split_output+0x82>
	  RNDIS_Device_SendPacket(&Ethernet_RNDIS_Interface_Device, uip_buf, uip_len);
    372a:	89 e3       	ldi	r24, 0x39	; 57
    372c:	91 e0       	ldi	r25, 0x01	; 1
    372e:	0e 94 b5 35 	call	0x6b6a	; 0x6b6a <RNDIS_Device_SendPacket>
    3732:	04 c0       	rjmp	.+8      	; 0x373c <uip_split_output+0x8a>
	else
	  RNDIS_Host_SendPacket(&Ethernet_RNDIS_Interface_Host, uip_buf, uip_len);
    3734:	8b e5       	ldi	r24, 0x5B	; 91
    3736:	91 e0       	ldi	r25, 0x01	; 1
    3738:	0e 94 ad 39 	call	0x735a	; 0x735a <RNDIS_Host_SendPacket>
    /* Now, create the second packet. To do this, it is not enough to
       just alter the length field, but we must also update the TCP
       sequence number and point the uip_appdata to a new place in
       memory. This place is determined by the length of the first
       packet (len1). */
    uip_len = len2 + UIP_TCPIP_HLEN + UIP_LLH_LEN;
    373c:	80 e1       	ldi	r24, 0x10	; 16
    373e:	93 e0       	ldi	r25, 0x03	; 3
    3740:	90 93 54 06 	sts	0x0654, r25
    3744:	80 93 53 06 	sts	0x0653, r24
    /* For IPv6, the IP length field does not include the IPv6 IP header
       length. */
    BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
    BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
#else /* UIP_CONF_IPV6 */
    BUF->len[0] = (uip_len  - UIP_LLH_LEN) >> 8;
    3748:	83 e0       	ldi	r24, 0x03	; 3
    374a:	80 93 db 07 	sts	0x07DB, r24
    BUF->len[1] = (uip_len - UIP_LLH_LEN) & 0xff;
    374e:	82 e0       	ldi	r24, 0x02	; 2
    3750:	80 93 dc 07 	sts	0x07DC, r24
#endif /* UIP_CONF_IPV6 */

    memcpy(uip_appdata, (u8_t *)uip_appdata + len1, len2);
    3754:	a0 91 5e 06 	lds	r26, 0x065E
    3758:	b0 91 5f 06 	lds	r27, 0x065F
    375c:	fd 01       	movw	r30, r26
    375e:	e6 52       	subi	r30, 0x26	; 38
    3760:	fd 4f       	sbci	r31, 0xFD	; 253
    3762:	8a ed       	ldi	r24, 0xDA	; 218
    3764:	92 e0       	ldi	r25, 0x02	; 2
    3766:	01 90       	ld	r0, Z+
    3768:	0d 92       	st	X+, r0
    376a:	01 97       	sbiw	r24, 0x01	; 1
    376c:	e1 f7       	brne	.-8      	; 0x3766 <uip_split_output+0xb4>

    uip_add32(BUF->seqno, len1);
    376e:	6a ed       	ldi	r22, 0xDA	; 218
    3770:	72 e0       	ldi	r23, 0x02	; 2
    3772:	81 ef       	ldi	r24, 0xF1	; 241
    3774:	97 e0       	ldi	r25, 0x07	; 7
    3776:	0e 94 c6 0f 	call	0x1f8c	; 0x1f8c <uip_add32>
    BUF->seqno[0] = uip_acc32[0];
    377a:	80 91 57 06 	lds	r24, 0x0657
    377e:	80 93 f1 07 	sts	0x07F1, r24
    BUF->seqno[1] = uip_acc32[1];
    3782:	80 91 58 06 	lds	r24, 0x0658
    3786:	80 93 f2 07 	sts	0x07F2, r24
    BUF->seqno[2] = uip_acc32[2];
    378a:	80 91 59 06 	lds	r24, 0x0659
    378e:	80 93 f3 07 	sts	0x07F3, r24
    BUF->seqno[3] = uip_acc32[3];
    3792:	80 91 5a 06 	lds	r24, 0x065A
    3796:	80 93 f4 07 	sts	0x07F4, r24

    /* Recalculate the TCP checksum. */
    BUF->tcpchksum = 0;
    379a:	10 92 fe 07 	sts	0x07FE, r1
    379e:	10 92 fd 07 	sts	0x07FD, r1
    BUF->tcpchksum = ~(uip_tcpchksum());
    37a2:	0e 94 2f 10 	call	0x205e	; 0x205e <uip_tcpchksum>
    37a6:	80 95       	com	r24
    37a8:	90 95       	com	r25
    37aa:	90 93 fe 07 	sts	0x07FE, r25
    37ae:	80 93 fd 07 	sts	0x07FD, r24

#if !UIP_CONF_IPV6
    /* Recalculate the IP checksum. */
    BUF->ipchksum = 0;
    37b2:	10 92 e4 07 	sts	0x07E4, r1
    37b6:	10 92 e3 07 	sts	0x07E3, r1
    BUF->ipchksum = ~(uip_ipchksum());
    37ba:	0e 94 1f 10 	call	0x203e	; 0x203e <uip_ipchksum>
    37be:	80 95       	com	r24
    37c0:	90 95       	com	r25
    37c2:	90 93 e4 07 	sts	0x07E4, r25
    37c6:	80 93 e3 07 	sts	0x07E3, r24

    /* Transmit the second packet. */
#if UIP_CONF_IPV6
    tcpip_ipv6_output();
#else
	if (USB_CurrentMode == USB_MODE_Device)
    37ca:	80 91 07 04 	lds	r24, 0x0407
    37ce:	40 91 53 06 	lds	r20, 0x0653
    37d2:	50 91 54 06 	lds	r21, 0x0654
    37d6:	02 c0       	rjmp	.+4      	; 0x37dc <uip_split_output+0x12a>

  /*    uip_fw_output();*/
#if UIP_CONF_IPV6
	tcpip_ipv6_output();
#else
	if (USB_CurrentMode == USB_MODE_Device)
    37d8:	80 91 07 04 	lds	r24, 0x0407
	  RNDIS_Device_SendPacket(&Ethernet_RNDIS_Interface_Device, uip_buf, uip_len);
    37dc:	6b ec       	ldi	r22, 0xCB	; 203
    37de:	77 e0       	ldi	r23, 0x07	; 7

  /*    uip_fw_output();*/
#if UIP_CONF_IPV6
	tcpip_ipv6_output();
#else
	if (USB_CurrentMode == USB_MODE_Device)
    37e0:	81 30       	cpi	r24, 0x01	; 1
    37e2:	21 f4       	brne	.+8      	; 0x37ec <uip_split_output+0x13a>
	  RNDIS_Device_SendPacket(&Ethernet_RNDIS_Interface_Device, uip_buf, uip_len);
    37e4:	89 e3       	ldi	r24, 0x39	; 57
    37e6:	91 e0       	ldi	r25, 0x01	; 1
    37e8:	0c 94 b5 35 	jmp	0x6b6a	; 0x6b6a <RNDIS_Device_SendPacket>
	else
	  RNDIS_Host_SendPacket(&Ethernet_RNDIS_Interface_Host, uip_buf, uip_len);
    37ec:	8b e5       	ldi	r24, 0x5B	; 91
    37ee:	91 e0       	ldi	r25, 0x01	; 1
    37f0:	0c 94 ad 39 	jmp	0x735a	; 0x735a <RNDIS_Host_SendPacket>

000037f4 <disk_initialize>:
DSTATUS disk_initialize (
	BYTE drv				/* Physical drive number (0..) */
)
{
	return FR_OK;
}
    37f4:	80 e0       	ldi	r24, 0x00	; 0
    37f6:	08 95       	ret

000037f8 <disk_status>:
DSTATUS disk_status (
	BYTE drv		/* Physical drive number (0..) */
)
{
	return FR_OK;
}
    37f8:	80 e0       	ldi	r24, 0x00	; 0
    37fa:	08 95       	ret

000037fc <disk_read>:
	BYTE drv,		/* Physical drive number (0..) */
	BYTE *buff,		/* Data buffer to store read data */
	DWORD sector,	/* Sector address (LBA) */
	BYTE count		/* Number of sectors to read (1..128) */
)
{
    37fc:	0f 93       	push	r16
    37fe:	fb 01       	movw	r30, r22
    3800:	ca 01       	movw	r24, r20
    3802:	b9 01       	movw	r22, r18
	DataflashManager_ReadBlocks_RAM(sector, count, buff);
    3804:	40 2f       	mov	r20, r16
    3806:	50 e0       	ldi	r21, 0x00	; 0
    3808:	9f 01       	movw	r18, r30
    380a:	0e 94 68 07 	call	0xed0	; 0xed0 <DataflashManager_ReadBlocks_RAM>
	return RES_OK;
}
    380e:	80 e0       	ldi	r24, 0x00	; 0
    3810:	0f 91       	pop	r16
    3812:	08 95       	ret

00003814 <move_window>:
static
FRESULT move_window (
	FATFS *fs,		/* File system object */
	DWORD sector	/* Sector number to make appearance in the fs->win[] */
)					/* Move to zero only writes back dirty window */
{
    3814:	cf 92       	push	r12
    3816:	df 92       	push	r13
    3818:	ef 92       	push	r14
    381a:	ff 92       	push	r15
    381c:	0f 93       	push	r16
    381e:	cf 93       	push	r28
    3820:	df 93       	push	r29
    3822:	ec 01       	movw	r28, r24
    3824:	6a 01       	movw	r12, r20
    3826:	7b 01       	movw	r14, r22
	DWORD wsect;


	wsect = fs->winsect;
	if (wsect != sector) {	/* Changed current window */
    3828:	4e 8d       	ldd	r20, Y+30	; 0x1e
    382a:	5f 8d       	ldd	r21, Y+31	; 0x1f
    382c:	68 a1       	ldd	r22, Y+32	; 0x20
    382e:	79 a1       	ldd	r23, Y+33	; 0x21
    3830:	4c 15       	cp	r20, r12
    3832:	5d 05       	cpc	r21, r13
    3834:	6e 05       	cpc	r22, r14
    3836:	7f 05       	cpc	r23, r15
    3838:	a1 f0       	breq	.+40     	; 0x3862 <move_window+0x4e>
					disk_write(fs->drv, fs->win, wsect, 1);
				}
			}
		}
#endif
		if (sector) {
    383a:	c1 14       	cp	r12, r1
    383c:	d1 04       	cpc	r13, r1
    383e:	e1 04       	cpc	r14, r1
    3840:	f1 04       	cpc	r15, r1
    3842:	79 f0       	breq	.+30     	; 0x3862 <move_window+0x4e>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
    3844:	01 e0       	ldi	r16, 0x01	; 1
    3846:	a7 01       	movw	r20, r14
    3848:	96 01       	movw	r18, r12
    384a:	bc 01       	movw	r22, r24
    384c:	6e 5d       	subi	r22, 0xDE	; 222
    384e:	7f 4f       	sbci	r23, 0xFF	; 255
    3850:	89 81       	ldd	r24, Y+1	; 0x01
    3852:	d4 df       	rcall	.-88     	; 0x37fc <disk_read>
    3854:	81 11       	cpse	r24, r1
    3856:	07 c0       	rjmp	.+14     	; 0x3866 <move_window+0x52>
    3858:	ce 8e       	std	Y+30, r12	; 0x1e
				return FR_DISK_ERR;
			fs->winsect = sector;
    385a:	df 8e       	std	Y+31, r13	; 0x1f
    385c:	e8 a2       	std	Y+32, r14	; 0x20
    385e:	f9 a2       	std	Y+33, r15	; 0x21
    3860:	03 c0       	rjmp	.+6      	; 0x3868 <move_window+0x54>
    3862:	80 e0       	ldi	r24, 0x00	; 0
		}
	}

	return FR_OK;
    3864:	01 c0       	rjmp	.+2      	; 0x3868 <move_window+0x54>
    3866:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
#endif
		if (sector) {
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
				return FR_DISK_ERR;
    3868:	df 91       	pop	r29
			fs->winsect = sector;
		}
	}

	return FR_OK;
}
    386a:	cf 91       	pop	r28
    386c:	0f 91       	pop	r16
    386e:	ff 90       	pop	r15
    3870:	ef 90       	pop	r14
    3872:	df 90       	pop	r13
    3874:	cf 90       	pop	r12
    3876:	08 95       	ret

00003878 <check_fs>:
    3878:	0f 93       	push	r16
static
BYTE check_fs (	/* 0:FAT-VBR, 1:Any BR but not FAT, 2:Not a BR, 3:Disk error */
	FATFS *fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
    387a:	cf 93       	push	r28
    387c:	df 93       	push	r29
    387e:	ec 01       	movw	r28, r24
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
    3880:	82 96       	adiw	r24, 0x22	; 34
    3882:	01 e0       	ldi	r16, 0x01	; 1
    3884:	9a 01       	movw	r18, r20
    3886:	ab 01       	movw	r20, r22
    3888:	bc 01       	movw	r22, r24
    388a:	89 81       	ldd	r24, Y+1	; 0x01
    388c:	b7 df       	rcall	.-146    	; 0x37fc <disk_read>
    388e:	81 11       	cpse	r24, r1
    3890:	23 c0       	rjmp	.+70     	; 0x38d8 <check_fs+0x60>
    3892:	fe 01       	movw	r30, r28
		return 3;
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
    3894:	e0 5e       	subi	r30, 0xE0	; 224
    3896:	fd 4f       	sbci	r31, 0xFD	; 253
    3898:	80 81       	ld	r24, Z
    389a:	91 81       	ldd	r25, Z+1	; 0x01
    389c:	85 35       	cpi	r24, 0x55	; 85
    389e:	9a 4a       	sbci	r25, 0xAA	; 170
    38a0:	e9 f4       	brne	.+58     	; 0x38dc <check_fs+0x64>
    38a2:	fe 01       	movw	r30, r28
		return 2;

	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
    38a4:	e8 5a       	subi	r30, 0xA8	; 168
    38a6:	ff 4f       	sbci	r31, 0xFF	; 255
    38a8:	40 81       	ld	r20, Z
    38aa:	51 81       	ldd	r21, Z+1	; 0x01
    38ac:	62 81       	ldd	r22, Z+2	; 0x02
    38ae:	73 81       	ldd	r23, Z+3	; 0x03
    38b0:	77 27       	eor	r23, r23
    38b2:	46 34       	cpi	r20, 0x46	; 70
    38b4:	51 44       	sbci	r21, 0x41	; 65
    38b6:	64 45       	sbci	r22, 0x54	; 84
    38b8:	71 05       	cpc	r23, r1
    38ba:	91 f0       	breq	.+36     	; 0x38e0 <check_fs+0x68>
    38bc:	cc 58       	subi	r28, 0x8C	; 140
		return 0;
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
    38be:	df 4f       	sbci	r29, 0xFF	; 255
    38c0:	48 81       	ld	r20, Y
    38c2:	59 81       	ldd	r21, Y+1	; 0x01
    38c4:	6a 81       	ldd	r22, Y+2	; 0x02
    38c6:	7b 81       	ldd	r23, Y+3	; 0x03
    38c8:	77 27       	eor	r23, r23
    38ca:	81 e0       	ldi	r24, 0x01	; 1
    38cc:	46 34       	cpi	r20, 0x46	; 70
    38ce:	51 44       	sbci	r21, 0x41	; 65
    38d0:	64 45       	sbci	r22, 0x54	; 84
    38d2:	71 05       	cpc	r23, r1
    38d4:	31 f4       	brne	.+12     	; 0x38e2 <check_fs+0x6a>
    38d6:	04 c0       	rjmp	.+8      	; 0x38e0 <check_fs+0x68>
    38d8:	83 e0       	ldi	r24, 0x03	; 3
	FATFS *fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
		return 3;
    38da:	03 c0       	rjmp	.+6      	; 0x38e2 <check_fs+0x6a>
    38dc:	82 e0       	ldi	r24, 0x02	; 2
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
		return 2;
    38de:	01 c0       	rjmp	.+2      	; 0x38e2 <check_fs+0x6a>
    38e0:	80 e0       	ldi	r24, 0x00	; 0

	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
		return 0;
    38e2:	df 91       	pop	r29
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
		return 0;

	return 1;
}
    38e4:	cf 91       	pop	r28
    38e6:	0f 91       	pop	r16
    38e8:	08 95       	ret

000038ea <validate>:
    38ea:	dc 01       	movw	r26, r24
{
	FIL *fil;


	fil = (FIL*)obj;	/* Assuming offset of fs and id in the FIL/DIR is identical */
	if (!fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
    38ec:	ed 91       	ld	r30, X+
    38ee:	fc 91       	ld	r31, X
    38f0:	11 97       	sbiw	r26, 0x01	; 1
    38f2:	30 97       	sbiw	r30, 0x00	; 0
    38f4:	91 f0       	breq	.+36     	; 0x391a <validate+0x30>
    38f6:	20 81       	ld	r18, Z
    38f8:	22 23       	and	r18, r18
    38fa:	79 f0       	breq	.+30     	; 0x391a <validate+0x30>
    38fc:	26 81       	ldd	r18, Z+6	; 0x06
    38fe:	37 81       	ldd	r19, Z+7	; 0x07
    3900:	12 96       	adiw	r26, 0x02	; 2
    3902:	8d 91       	ld	r24, X+
    3904:	9c 91       	ld	r25, X
    3906:	13 97       	sbiw	r26, 0x03	; 3
    3908:	28 17       	cp	r18, r24
    390a:	39 07       	cpc	r19, r25
    390c:	31 f4       	brne	.+12     	; 0x391a <validate+0x30>
		return FR_INVALID_OBJECT;

	ENTER_FF(fil->fs);		/* Lock file system */

	if (disk_status(fil->fs->drv) & STA_NOINIT)
    390e:	81 81       	ldd	r24, Z+1	; 0x01
    3910:	73 df       	rcall	.-282    	; 0x37f8 <disk_status>
    3912:	80 ff       	sbrs	r24, 0
    3914:	04 c0       	rjmp	.+8      	; 0x391e <validate+0x34>
    3916:	83 e0       	ldi	r24, 0x03	; 3
		return FR_NOT_READY;
    3918:	08 95       	ret
    391a:	89 e0       	ldi	r24, 0x09	; 9
	FIL *fil;


	fil = (FIL*)obj;	/* Assuming offset of fs and id in the FIL/DIR is identical */
	if (!fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
		return FR_INVALID_OBJECT;
    391c:	08 95       	ret
    391e:	80 e0       	ldi	r24, 0x00	; 0
	ENTER_FF(fil->fs);		/* Lock file system */

	if (disk_status(fil->fs->drv) & STA_NOINIT)
		return FR_NOT_READY;

	return FR_OK;
    3920:	08 95       	ret

00003922 <clust2sect>:
}
    3922:	0f 93       	push	r16

DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
    3924:	1f 93       	push	r17
    3926:	fc 01       	movw	r30, r24
	clst -= 2;
    3928:	42 50       	subi	r20, 0x02	; 2
    392a:	51 09       	sbc	r21, r1
    392c:	61 09       	sbc	r22, r1
    392e:	71 09       	sbc	r23, r1
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
    3930:	02 85       	ldd	r16, Z+10	; 0x0a
    3932:	13 85       	ldd	r17, Z+11	; 0x0b
    3934:	24 85       	ldd	r18, Z+12	; 0x0c
    3936:	35 85       	ldd	r19, Z+13	; 0x0d
    3938:	02 50       	subi	r16, 0x02	; 2
    393a:	11 09       	sbc	r17, r1
    393c:	21 09       	sbc	r18, r1
    393e:	31 09       	sbc	r19, r1
    3940:	40 17       	cp	r20, r16
    3942:	51 07       	cpc	r21, r17
    3944:	62 07       	cpc	r22, r18
    3946:	73 07       	cpc	r23, r19
    3948:	78 f4       	brcc	.+30     	; 0x3968 <clust2sect+0x46>
	return clst * fs->csize + fs->database;
    394a:	a2 81       	ldd	r26, Z+2	; 0x02
    394c:	b0 e0       	ldi	r27, 0x00	; 0
    394e:	9a 01       	movw	r18, r20
    3950:	ab 01       	movw	r20, r22
    3952:	0e 94 35 3a 	call	0x746a	; 0x746a <__muluhisi3>
    3956:	02 8d       	ldd	r16, Z+26	; 0x1a
    3958:	13 8d       	ldd	r17, Z+27	; 0x1b
    395a:	24 8d       	ldd	r18, Z+28	; 0x1c
    395c:	35 8d       	ldd	r19, Z+29	; 0x1d
    395e:	60 0f       	add	r22, r16
    3960:	71 1f       	adc	r23, r17
    3962:	82 1f       	adc	r24, r18
    3964:	93 1f       	adc	r25, r19
    3966:	03 c0       	rjmp	.+6      	; 0x396e <clust2sect+0x4c>
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
    3968:	60 e0       	ldi	r22, 0x00	; 0
    396a:	70 e0       	ldi	r23, 0x00	; 0
    396c:	cb 01       	movw	r24, r22
	return clst * fs->csize + fs->database;
}
    396e:	1f 91       	pop	r17
    3970:	0f 91       	pop	r16
    3972:	08 95       	ret

00003974 <get_fat>:

DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
	FATFS *fs,	/* File system object */
	DWORD clst	/* Cluster# to get the link information */
)
{
    3974:	bf 92       	push	r11
    3976:	cf 92       	push	r12
    3978:	df 92       	push	r13
    397a:	ef 92       	push	r14
    397c:	ff 92       	push	r15
    397e:	0f 93       	push	r16
    3980:	1f 93       	push	r17
    3982:	cf 93       	push	r28
    3984:	df 93       	push	r29
    3986:	ec 01       	movw	r28, r24
    3988:	6a 01       	movw	r12, r20
    398a:	7b 01       	movw	r14, r22
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
    398c:	42 30       	cpi	r20, 0x02	; 2
    398e:	51 05       	cpc	r21, r1
    3990:	61 05       	cpc	r22, r1
    3992:	71 05       	cpc	r23, r1
    3994:	08 f4       	brcc	.+2      	; 0x3998 <get_fat+0x24>
    3996:	9d c0       	rjmp	.+314    	; 0x3ad2 <get_fat+0x15e>
    3998:	8a 85       	ldd	r24, Y+10	; 0x0a
    399a:	9b 85       	ldd	r25, Y+11	; 0x0b
    399c:	ac 85       	ldd	r26, Y+12	; 0x0c
    399e:	bd 85       	ldd	r27, Y+13	; 0x0d
    39a0:	48 17       	cp	r20, r24
    39a2:	59 07       	cpc	r21, r25
    39a4:	6a 07       	cpc	r22, r26
    39a6:	7b 07       	cpc	r23, r27
    39a8:	08 f0       	brcs	.+2      	; 0x39ac <get_fat+0x38>
    39aa:	93 c0       	rjmp	.+294    	; 0x3ad2 <get_fat+0x15e>
		return 1;

	switch (fs->fs_type) {
    39ac:	88 81       	ld	r24, Y
    39ae:	82 30       	cpi	r24, 0x02	; 2
    39b0:	09 f4       	brne	.+2      	; 0x39b4 <get_fat+0x40>
    39b2:	46 c0       	rjmp	.+140    	; 0x3a40 <get_fat+0xcc>
    39b4:	83 30       	cpi	r24, 0x03	; 3
    39b6:	09 f4       	brne	.+2      	; 0x39ba <get_fat+0x46>
    39b8:	63 c0       	rjmp	.+198    	; 0x3a80 <get_fat+0x10c>
    39ba:	81 30       	cpi	r24, 0x01	; 1
    39bc:	09 f0       	breq	.+2      	; 0x39c0 <get_fat+0x4c>
    39be:	8e c0       	rjmp	.+284    	; 0x3adc <get_fat+0x168>
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
    39c0:	8a 01       	movw	r16, r20
    39c2:	16 95       	lsr	r17
    39c4:	07 95       	ror	r16
    39c6:	0c 0d       	add	r16, r12
    39c8:	1d 1d       	adc	r17, r13
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
    39ca:	c8 01       	movw	r24, r16
    39cc:	89 2f       	mov	r24, r25
    39ce:	99 27       	eor	r25, r25
    39d0:	86 95       	lsr	r24
    39d2:	4a 89       	ldd	r20, Y+18	; 0x12
    39d4:	5b 89       	ldd	r21, Y+19	; 0x13
    39d6:	6c 89       	ldd	r22, Y+20	; 0x14
    39d8:	7d 89       	ldd	r23, Y+21	; 0x15
    39da:	48 0f       	add	r20, r24
    39dc:	59 1f       	adc	r21, r25
    39de:	61 1d       	adc	r22, r1
    39e0:	71 1d       	adc	r23, r1
    39e2:	ce 01       	movw	r24, r28
    39e4:	17 df       	rcall	.-466    	; 0x3814 <move_window>
    39e6:	81 11       	cpse	r24, r1
    39e8:	79 c0       	rjmp	.+242    	; 0x3adc <get_fat+0x168>
    39ea:	f8 01       	movw	r30, r16
		wc = fs->win[bc % SS(fs)]; bc++;
    39ec:	f1 70       	andi	r31, 0x01	; 1
    39ee:	ec 0f       	add	r30, r28
    39f0:	fd 1f       	adc	r31, r29
    39f2:	b2 a0       	ldd	r11, Z+34	; 0x22
    39f4:	0f 5f       	subi	r16, 0xFF	; 255
    39f6:	1f 4f       	sbci	r17, 0xFF	; 255
    39f8:	c8 01       	movw	r24, r16
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
    39fa:	89 2f       	mov	r24, r25
    39fc:	99 27       	eor	r25, r25
    39fe:	86 95       	lsr	r24
    3a00:	4a 89       	ldd	r20, Y+18	; 0x12
    3a02:	5b 89       	ldd	r21, Y+19	; 0x13
    3a04:	6c 89       	ldd	r22, Y+20	; 0x14
    3a06:	7d 89       	ldd	r23, Y+21	; 0x15
    3a08:	48 0f       	add	r20, r24
    3a0a:	59 1f       	adc	r21, r25
    3a0c:	61 1d       	adc	r22, r1
    3a0e:	71 1d       	adc	r23, r1
    3a10:	ce 01       	movw	r24, r28
    3a12:	00 df       	rcall	.-512    	; 0x3814 <move_window>
    3a14:	81 11       	cpse	r24, r1
    3a16:	62 c0       	rjmp	.+196    	; 0x3adc <get_fat+0x168>
    3a18:	f8 01       	movw	r30, r16
    3a1a:	f1 70       	andi	r31, 0x01	; 1
		wc |= fs->win[bc % SS(fs)] << 8;
    3a1c:	ec 0f       	add	r30, r28
    3a1e:	fd 1f       	adc	r31, r29
    3a20:	82 a1       	ldd	r24, Z+34	; 0x22
    3a22:	6b 2d       	mov	r22, r11
    3a24:	70 e0       	ldi	r23, 0x00	; 0
    3a26:	78 2b       	or	r23, r24
    3a28:	c0 fe       	sbrs	r12, 0
    3a2a:	06 c0       	rjmp	.+12     	; 0x3a38 <get_fat+0xc4>
		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
    3a2c:	44 e0       	ldi	r20, 0x04	; 4
    3a2e:	76 95       	lsr	r23
    3a30:	67 95       	ror	r22
    3a32:	4a 95       	dec	r20
    3a34:	e1 f7       	brne	.-8      	; 0x3a2e <get_fat+0xba>
    3a36:	01 c0       	rjmp	.+2      	; 0x3a3a <get_fat+0xc6>
    3a38:	7f 70       	andi	r23, 0x0F	; 15
    3a3a:	80 e0       	ldi	r24, 0x00	; 0
    3a3c:	90 e0       	ldi	r25, 0x00	; 0
    3a3e:	51 c0       	rjmp	.+162    	; 0x3ae2 <get_fat+0x16e>
    3a40:	45 2f       	mov	r20, r21
    3a42:	56 2f       	mov	r21, r22

	case FS_FAT16 :
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
    3a44:	67 2f       	mov	r22, r23
    3a46:	77 27       	eor	r23, r23
    3a48:	8a 89       	ldd	r24, Y+18	; 0x12
    3a4a:	9b 89       	ldd	r25, Y+19	; 0x13
    3a4c:	ac 89       	ldd	r26, Y+20	; 0x14
    3a4e:	bd 89       	ldd	r27, Y+21	; 0x15
    3a50:	48 0f       	add	r20, r24
    3a52:	59 1f       	adc	r21, r25
    3a54:	6a 1f       	adc	r22, r26
    3a56:	7b 1f       	adc	r23, r27
    3a58:	ce 01       	movw	r24, r28
    3a5a:	dc de       	rcall	.-584    	; 0x3814 <move_window>
    3a5c:	81 11       	cpse	r24, r1
    3a5e:	3e c0       	rjmp	.+124    	; 0x3adc <get_fat+0x168>
    3a60:	cc 0c       	add	r12, r12
    3a62:	dd 1c       	adc	r13, r13
    3a64:	ee 1c       	adc	r14, r14
		p = &fs->win[clst * 2 % SS(fs)];
    3a66:	ff 1c       	adc	r15, r15
    3a68:	e8 94       	clt
    3a6a:	c0 f8       	bld	r12, 0
    3a6c:	81 e0       	ldi	r24, 0x01	; 1
    3a6e:	d8 22       	and	r13, r24
    3a70:	ee 24       	eor	r14, r14
    3a72:	ff 24       	eor	r15, r15
    3a74:	fe 01       	movw	r30, r28
    3a76:	ec 0d       	add	r30, r12
    3a78:	fd 1d       	adc	r31, r13
		return LD_WORD(p);
    3a7a:	62 a1       	ldd	r22, Z+34	; 0x22
    3a7c:	73 a1       	ldd	r23, Z+35	; 0x23
    3a7e:	dd cf       	rjmp	.-70     	; 0x3a3a <get_fat+0xc6>
    3a80:	97 e0       	ldi	r25, 0x07	; 7
    3a82:	76 95       	lsr	r23
    3a84:	67 95       	ror	r22

	case FS_FAT32 :
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
    3a86:	57 95       	ror	r21
    3a88:	47 95       	ror	r20
    3a8a:	9a 95       	dec	r25
    3a8c:	d1 f7       	brne	.-12     	; 0x3a82 <get_fat+0x10e>
    3a8e:	8a 89       	ldd	r24, Y+18	; 0x12
    3a90:	9b 89       	ldd	r25, Y+19	; 0x13
    3a92:	ac 89       	ldd	r26, Y+20	; 0x14
    3a94:	bd 89       	ldd	r27, Y+21	; 0x15
    3a96:	48 0f       	add	r20, r24
    3a98:	59 1f       	adc	r21, r25
    3a9a:	6a 1f       	adc	r22, r26
    3a9c:	7b 1f       	adc	r23, r27
    3a9e:	ce 01       	movw	r24, r28
    3aa0:	b9 de       	rcall	.-654    	; 0x3814 <move_window>
    3aa2:	81 11       	cpse	r24, r1
    3aa4:	1b c0       	rjmp	.+54     	; 0x3adc <get_fat+0x168>
    3aa6:	82 e0       	ldi	r24, 0x02	; 2
    3aa8:	cc 0c       	add	r12, r12
    3aaa:	dd 1c       	adc	r13, r13
    3aac:	ee 1c       	adc	r14, r14
		p = &fs->win[clst * 4 % SS(fs)];
    3aae:	ff 1c       	adc	r15, r15
    3ab0:	8a 95       	dec	r24
    3ab2:	d1 f7       	brne	.-12     	; 0x3aa8 <get_fat+0x134>
    3ab4:	8c ef       	ldi	r24, 0xFC	; 252
    3ab6:	c8 22       	and	r12, r24
    3ab8:	81 e0       	ldi	r24, 0x01	; 1
    3aba:	d8 22       	and	r13, r24
    3abc:	ee 24       	eor	r14, r14
    3abe:	ff 24       	eor	r15, r15
    3ac0:	fe 01       	movw	r30, r28
    3ac2:	ec 0d       	add	r30, r12
    3ac4:	fd 1d       	adc	r31, r13
    3ac6:	62 a1       	ldd	r22, Z+34	; 0x22
		return LD_DWORD(p) & 0x0FFFFFFF;
    3ac8:	73 a1       	ldd	r23, Z+35	; 0x23
    3aca:	84 a1       	ldd	r24, Z+36	; 0x24
    3acc:	95 a1       	ldd	r25, Z+37	; 0x25
    3ace:	9f 70       	andi	r25, 0x0F	; 15
    3ad0:	08 c0       	rjmp	.+16     	; 0x3ae2 <get_fat+0x16e>
    3ad2:	61 e0       	ldi	r22, 0x01	; 1
    3ad4:	70 e0       	ldi	r23, 0x00	; 0
    3ad6:	80 e0       	ldi	r24, 0x00	; 0
    3ad8:	90 e0       	ldi	r25, 0x00	; 0
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
		return 1;
    3ada:	03 c0       	rjmp	.+6      	; 0x3ae2 <get_fat+0x16e>
    3adc:	6f ef       	ldi	r22, 0xFF	; 255
    3ade:	7f ef       	ldi	r23, 0xFF	; 255
    3ae0:	cb 01       	movw	r24, r22
    3ae2:	df 91       	pop	r29
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
		p = &fs->win[clst * 4 % SS(fs)];
		return LD_DWORD(p) & 0x0FFFFFFF;
	}

	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
    3ae4:	cf 91       	pop	r28
    3ae6:	1f 91       	pop	r17
    3ae8:	0f 91       	pop	r16
}
    3aea:	ff 90       	pop	r15
    3aec:	ef 90       	pop	r14
    3aee:	df 90       	pop	r13
    3af0:	cf 90       	pop	r12
    3af2:	bf 90       	pop	r11
    3af4:	08 95       	ret

00003af6 <dir_sdi.constprop.4>:
    3af6:	0f 93       	push	r16
    3af8:	1f 93       	push	r17
    3afa:	cf 93       	push	r28
    3afc:	df 93       	push	r29
/*-----------------------------------------------------------------------*/
/* Directory handling - Set directory index                              */
/*-----------------------------------------------------------------------*/

static
FRESULT dir_sdi (
    3afe:	ec 01       	movw	r28, r24
{
	DWORD clst;
	WORD ic;


	dj->index = idx;
    3b00:	1d 82       	std	Y+5, r1	; 0x05
    3b02:	1c 82       	std	Y+4, r1	; 0x04
	clst = dj->sclust;
    3b04:	4e 81       	ldd	r20, Y+6	; 0x06
    3b06:	5f 81       	ldd	r21, Y+7	; 0x07
    3b08:	68 85       	ldd	r22, Y+8	; 0x08
    3b0a:	79 85       	ldd	r23, Y+9	; 0x09
	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
    3b0c:	41 30       	cpi	r20, 0x01	; 1
    3b0e:	51 05       	cpc	r21, r1
    3b10:	61 05       	cpc	r22, r1
    3b12:	71 05       	cpc	r23, r1
    3b14:	11 f4       	brne	.+4      	; 0x3b1a <dir_sdi.constprop.4+0x24>
		return FR_INT_ERR;
    3b16:	82 e0       	ldi	r24, 0x02	; 2
    3b18:	61 c0       	rjmp	.+194    	; 0x3bdc <dir_sdi.constprop.4+0xe6>
	WORD ic;


	dj->index = idx;
	clst = dj->sclust;
	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
    3b1a:	08 81       	ld	r16, Y
    3b1c:	19 81       	ldd	r17, Y+1	; 0x01
    3b1e:	f8 01       	movw	r30, r16
    3b20:	82 85       	ldd	r24, Z+10	; 0x0a
    3b22:	93 85       	ldd	r25, Z+11	; 0x0b
    3b24:	a4 85       	ldd	r26, Z+12	; 0x0c
    3b26:	b5 85       	ldd	r27, Z+13	; 0x0d
    3b28:	48 17       	cp	r20, r24
    3b2a:	59 07       	cpc	r21, r25
    3b2c:	6a 07       	cpc	r22, r26
    3b2e:	7b 07       	cpc	r23, r27
    3b30:	90 f7       	brcc	.-28     	; 0x3b16 <dir_sdi.constprop.4+0x20>
		return FR_INT_ERR;
	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
    3b32:	41 15       	cp	r20, r1
    3b34:	51 05       	cpc	r21, r1
    3b36:	61 05       	cpc	r22, r1
    3b38:	71 05       	cpc	r23, r1
    3b3a:	f1 f4       	brne	.+60     	; 0x3b78 <dir_sdi.constprop.4+0x82>
    3b3c:	80 81       	ld	r24, Z
    3b3e:	83 30       	cpi	r24, 0x03	; 3
    3b40:	49 f4       	brne	.+18     	; 0x3b54 <dir_sdi.constprop.4+0x5e>
		clst = dj->fs->dirbase;
    3b42:	46 89       	ldd	r20, Z+22	; 0x16
    3b44:	57 89       	ldd	r21, Z+23	; 0x17
    3b46:	60 8d       	ldd	r22, Z+24	; 0x18
    3b48:	71 8d       	ldd	r23, Z+25	; 0x19

	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
    3b4a:	41 15       	cp	r20, r1
    3b4c:	51 05       	cpc	r21, r1
    3b4e:	61 05       	cpc	r22, r1
    3b50:	71 05       	cpc	r23, r1
    3b52:	91 f4       	brne	.+36     	; 0x3b78 <dir_sdi.constprop.4+0x82>
		dj->clust = clst;
    3b54:	1a 86       	std	Y+10, r1	; 0x0a
    3b56:	1b 86       	std	Y+11, r1	; 0x0b
    3b58:	1c 86       	std	Y+12, r1	; 0x0c
    3b5a:	1d 86       	std	Y+13, r1	; 0x0d
		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
    3b5c:	f8 01       	movw	r30, r16
    3b5e:	80 85       	ldd	r24, Z+8	; 0x08
    3b60:	91 85       	ldd	r25, Z+9	; 0x09
    3b62:	89 2b       	or	r24, r25
    3b64:	c1 f2       	breq	.-80     	; 0x3b16 <dir_sdi.constprop.4+0x20>
			return FR_INT_ERR;
		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
    3b66:	86 89       	ldd	r24, Z+22	; 0x16
    3b68:	97 89       	ldd	r25, Z+23	; 0x17
    3b6a:	a0 8d       	ldd	r26, Z+24	; 0x18
    3b6c:	b1 8d       	ldd	r27, Z+25	; 0x19
    3b6e:	8e 87       	std	Y+14, r24	; 0x0e
    3b70:	9f 87       	std	Y+15, r25	; 0x0f
    3b72:	a8 8b       	std	Y+16, r26	; 0x10
    3b74:	b9 8b       	std	Y+17, r27	; 0x11
    3b76:	2b c0       	rjmp	.+86     	; 0x3bce <dir_sdi.constprop.4+0xd8>
	}
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
    3b78:	f8 01       	movw	r30, r16
    3b7a:	82 81       	ldd	r24, Z+2	; 0x02
		while (idx >= ic) {	/* Follow cluster chain */
    3b7c:	81 11       	cpse	r24, r1
    3b7e:	1d c0       	rjmp	.+58     	; 0x3bba <dir_sdi.constprop.4+0xc4>
			clst = get_fat(dj->fs, clst);				/* Get next cluster */
    3b80:	88 81       	ld	r24, Y
    3b82:	99 81       	ldd	r25, Y+1	; 0x01
    3b84:	f7 de       	rcall	.-530    	; 0x3974 <get_fat>
    3b86:	ab 01       	movw	r20, r22
    3b88:	bc 01       	movw	r22, r24
    3b8a:	4f 3f       	cpi	r20, 0xFF	; 255
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
    3b8c:	ff ef       	ldi	r31, 0xFF	; 255
    3b8e:	5f 07       	cpc	r21, r31
    3b90:	6f 07       	cpc	r22, r31
    3b92:	7f 07       	cpc	r23, r31
    3b94:	11 f1       	breq	.+68     	; 0x3bda <dir_sdi.constprop.4+0xe4>
    3b96:	42 30       	cpi	r20, 0x02	; 2
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
    3b98:	51 05       	cpc	r21, r1
    3b9a:	61 05       	cpc	r22, r1
    3b9c:	71 05       	cpc	r23, r1
    3b9e:	08 f4       	brcc	.+2      	; 0x3ba2 <dir_sdi.constprop.4+0xac>
    3ba0:	ba cf       	rjmp	.-140    	; 0x3b16 <dir_sdi.constprop.4+0x20>
    3ba2:	e8 81       	ld	r30, Y
    3ba4:	f9 81       	ldd	r31, Y+1	; 0x01
    3ba6:	82 85       	ldd	r24, Z+10	; 0x0a
    3ba8:	93 85       	ldd	r25, Z+11	; 0x0b
    3baa:	a4 85       	ldd	r26, Z+12	; 0x0c
    3bac:	b5 85       	ldd	r27, Z+13	; 0x0d
    3bae:	48 17       	cp	r20, r24
    3bb0:	59 07       	cpc	r21, r25
    3bb2:	6a 07       	cpc	r22, r26
    3bb4:	7b 07       	cpc	r23, r27
    3bb6:	20 f3       	brcs	.-56     	; 0x3b80 <dir_sdi.constprop.4+0x8a>
    3bb8:	ae cf       	rjmp	.-164    	; 0x3b16 <dir_sdi.constprop.4+0x20>
    3bba:	4a 87       	std	Y+10, r20	; 0x0a
				return FR_INT_ERR;
			idx -= ic;
		}
		dj->clust = clst;
    3bbc:	5b 87       	std	Y+11, r21	; 0x0b
    3bbe:	6c 87       	std	Y+12, r22	; 0x0c
    3bc0:	7d 87       	std	Y+13, r23	; 0x0d
    3bc2:	c8 01       	movw	r24, r16
		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
    3bc4:	ae de       	rcall	.-676    	; 0x3922 <clust2sect>
    3bc6:	6e 87       	std	Y+14, r22	; 0x0e
    3bc8:	7f 87       	std	Y+15, r23	; 0x0f
    3bca:	88 8b       	std	Y+16, r24	; 0x10
    3bcc:	99 8b       	std	Y+17, r25	; 0x11
    3bce:	0e 5d       	subi	r16, 0xDE	; 222
    3bd0:	1f 4f       	sbci	r17, 0xFF	; 255
	}

	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */
    3bd2:	1b 8b       	std	Y+19, r17	; 0x13
    3bd4:	0a 8b       	std	Y+18, r16	; 0x12
    3bd6:	80 e0       	ldi	r24, 0x00	; 0
    3bd8:	01 c0       	rjmp	.+2      	; 0x3bdc <dir_sdi.constprop.4+0xe6>

	return FR_OK;	/* Seek succeeded */
    3bda:	81 e0       	ldi	r24, 0x01	; 1
    3bdc:	df 91       	pop	r29
	}
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
			clst = get_fat(dj->fs, clst);				/* Get next cluster */
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
    3bde:	cf 91       	pop	r28
	}

	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */

	return FR_OK;	/* Seek succeeded */
}
    3be0:	1f 91       	pop	r17
    3be2:	0f 91       	pop	r16
    3be4:	08 95       	ret

00003be6 <f_mount>:
    3be6:	81 11       	cpse	r24, r1
    3be8:	12 c0       	rjmp	.+36     	; 0x3c0e <f_mount+0x28>
	FATFS *rfs;


	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
		return FR_INVALID_DRIVE;
	rfs = FatFs[vol];			/* Get current fs object */
    3bea:	e0 91 02 04 	lds	r30, 0x0402
    3bee:	f0 91 03 04 	lds	r31, 0x0403

	if (rfs) {
    3bf2:	30 97       	sbiw	r30, 0x00	; 0
    3bf4:	09 f0       	breq	.+2      	; 0x3bf8 <f_mount+0x12>
		clear_lock(rfs);
#endif
#if _FS_REENTRANT				/* Discard sync object of the current volume */
		if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;
#endif
		rfs->fs_type = 0;		/* Clear old fs object */
    3bf6:	10 82       	st	Z, r1
	}

	if (fs) {
    3bf8:	61 15       	cp	r22, r1
    3bfa:	71 05       	cpc	r23, r1
    3bfc:	11 f0       	breq	.+4      	; 0x3c02 <f_mount+0x1c>
		fs->fs_type = 0;		/* Clear new fs object */
    3bfe:	fb 01       	movw	r30, r22
    3c00:	10 82       	st	Z, r1
#if _FS_REENTRANT				/* Create sync object for the new volume */
		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;			/* Register new fs object */
    3c02:	70 93 03 04 	sts	0x0403, r23
    3c06:	60 93 02 04 	sts	0x0402, r22

	return FR_OK;
    3c0a:	80 e0       	ldi	r24, 0x00	; 0
    3c0c:	08 95       	ret
{
	FATFS *rfs;


	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
		return FR_INVALID_DRIVE;
    3c0e:	8b e0       	ldi	r24, 0x0B	; 11
#endif
	}
	FatFs[vol] = fs;			/* Register new fs object */

	return FR_OK;
}
    3c10:	08 95       	ret

00003c12 <f_open>:
FRESULT f_open (
	FIL *fp,			/* Pointer to the blank file object */
	const TCHAR *path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
    3c12:	2f 92       	push	r2
    3c14:	3f 92       	push	r3
    3c16:	4f 92       	push	r4
    3c18:	5f 92       	push	r5
    3c1a:	6f 92       	push	r6
    3c1c:	7f 92       	push	r7
    3c1e:	8f 92       	push	r8
    3c20:	9f 92       	push	r9
    3c22:	af 92       	push	r10
    3c24:	bf 92       	push	r11
    3c26:	cf 92       	push	r12
    3c28:	df 92       	push	r13
    3c2a:	ef 92       	push	r14
    3c2c:	ff 92       	push	r15
    3c2e:	0f 93       	push	r16
    3c30:	1f 93       	push	r17
    3c32:	cf 93       	push	r28
    3c34:	df 93       	push	r29
    3c36:	cd b7       	in	r28, 0x3d	; 61
    3c38:	de b7       	in	r29, 0x3e	; 62
    3c3a:	e4 97       	sbiw	r28, 0x34	; 52
    3c3c:	0f b6       	in	r0, 0x3f	; 63
    3c3e:	f8 94       	cli
    3c40:	de bf       	out	0x3e, r29	; 62
    3c42:	0f be       	out	0x3f, r0	; 63
    3c44:	cd bf       	out	0x3d, r28	; 61
    3c46:	9c a3       	std	Y+36, r25	; 0x24
    3c48:	8b a3       	std	Y+35, r24	; 0x23
    3c4a:	1b 01       	movw	r2, r22
    3c4c:	4b ab       	std	Y+51, r20	; 0x33
	DIR dj;
	BYTE *dir;
	DEF_NAMEBUF;


	if (!fp) return FR_INVALID_OBJECT;
    3c4e:	00 97       	sbiw	r24, 0x00	; 0
    3c50:	09 f4       	brne	.+2      	; 0x3c54 <f_open+0x42>
    3c52:	b3 c1       	rjmp	.+870    	; 0x3fba <f_open+0x3a8>
	fp->fs = 0;			/* Clear file object */
    3c54:	dc 01       	movw	r26, r24
    3c56:	1d 92       	st	X+, r1
    3c58:	1c 92       	st	X, r1
	const TCHAR *p = *path;
	FATFS *fs;


	/* Get logical drive number from the path name */
	vol = p[0] - '0';					/* Is there a drive number? */
    3c5a:	fb 01       	movw	r30, r22
    3c5c:	80 81       	ld	r24, Z
    3c5e:	90 e0       	ldi	r25, 0x00	; 0
    3c60:	c0 97       	sbiw	r24, 0x30	; 48
	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
    3c62:	8a 30       	cpi	r24, 0x0A	; 10
    3c64:	91 05       	cpc	r25, r1
    3c66:	38 f4       	brcc	.+14     	; 0x3c76 <f_open+0x64>
    3c68:	21 81       	ldd	r18, Z+1	; 0x01
    3c6a:	2a 33       	cpi	r18, 0x3A	; 58
    3c6c:	21 f4       	brne	.+8      	; 0x3c76 <f_open+0x64>
		p += 2; *path = p;				/* Return pointer to the path name */
    3c6e:	f2 e0       	ldi	r31, 0x02	; 2
    3c70:	2f 0e       	add	r2, r31
    3c72:	31 1c       	adc	r3, r1
    3c74:	02 c0       	rjmp	.+4      	; 0x3c7a <f_open+0x68>
	} else {							/* No drive number is given */
#if _FS_RPATH
		vol = CurrVol;					/* Use current drive */
#else
		vol = 0;						/* Use drive 0 */
    3c76:	80 e0       	ldi	r24, 0x00	; 0
    3c78:	90 e0       	ldi	r25, 0x00	; 0
#endif
	}

	/* Check if the file system object is valid or not */
	*rfs = 0;
	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
    3c7a:	89 2b       	or	r24, r25
    3c7c:	09 f0       	breq	.+2      	; 0x3c80 <f_open+0x6e>
    3c7e:	9f c1       	rjmp	.+830    	; 0x3fbe <f_open+0x3ac>
		return FR_INVALID_DRIVE;
	fs = FatFs[vol];					/* Get corresponding file system object */
    3c80:	00 91 02 04 	lds	r16, 0x0402
    3c84:	10 91 03 04 	lds	r17, 0x0403
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
    3c88:	01 15       	cp	r16, r1
    3c8a:	11 05       	cpc	r17, r1
    3c8c:	09 f4       	brne	.+2      	; 0x3c90 <f_open+0x7e>
    3c8e:	99 c1       	rjmp	.+818    	; 0x3fc2 <f_open+0x3b0>

	ENTER_FF(fs);						/* Lock file system */

	*rfs = fs;							/* Return pointer to the corresponding file system object */
    3c90:	1a 83       	std	Y+2, r17	; 0x02
    3c92:	09 83       	std	Y+1, r16	; 0x01
	if (fs->fs_type) {					/* If the volume has been mounted */
    3c94:	d8 01       	movw	r26, r16
    3c96:	8c 91       	ld	r24, X
    3c98:	81 11       	cpse	r24, r1
    3c9a:	08 c0       	rjmp	.+16     	; 0x3cac <f_open+0x9a>
	}

	/* The file system object is not valid. */
	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */

	fs->fs_type = 0;					/* Clear the file system object */
    3c9c:	f8 01       	movw	r30, r16
    3c9e:	10 82       	st	Z, r1
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
    3ca0:	11 82       	std	Z+1, r1	; 0x01
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
    3ca2:	80 e0       	ldi	r24, 0x00	; 0
    3ca4:	a7 dd       	rcall	.-1202   	; 0x37f4 <disk_initialize>
    3ca6:	80 fd       	sbrc	r24, 0
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
    3ca8:	8e c1       	rjmp	.+796    	; 0x3fc6 <f_open+0x3b4>
    3caa:	07 c0       	rjmp	.+14     	; 0x3cba <f_open+0xa8>
    3cac:	d8 01       	movw	r26, r16

	ENTER_FF(fs);						/* Lock file system */

	*rfs = fs;							/* Return pointer to the corresponding file system object */
	if (fs->fs_type) {					/* If the volume has been mounted */
		stat = disk_status(fs->drv);
    3cae:	11 96       	adiw	r26, 0x01	; 1
    3cb0:	8c 91       	ld	r24, X
    3cb2:	a2 dd       	rcall	.-1212   	; 0x37f8 <disk_status>
    3cb4:	80 fd       	sbrc	r24, 0
    3cb6:	f2 cf       	rjmp	.-28     	; 0x3c9c <f_open+0x8a>
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
    3cb8:	8a c1       	rjmp	.+788    	; 0x3fce <f_open+0x3bc>
    3cba:	40 e0       	ldi	r20, 0x00	; 0
    3cbc:	50 e0       	ldi	r21, 0x00	; 0
#if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
		return FR_DISK_ERR;
#endif
	/* Search FAT partition on the drive. Supports only generic partitions, FDISK and SFD. */
	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
    3cbe:	ba 01       	movw	r22, r20
    3cc0:	c8 01       	movw	r24, r16
    3cc2:	da dd       	rcall	.-1100   	; 0x3878 <check_fs>
    3cc4:	81 30       	cpi	r24, 0x01	; 1
    3cc6:	c1 f4       	brne	.+48     	; 0x3cf8 <f_open+0xe6>
    3cc8:	f8 01       	movw	r30, r16
	if (LD2PT(vol) && !fmt) fmt = 1;	/* Force non-SFD if the volume is forced partition */
	if (fmt == 1) {						/* Not an FAT-VBR, the physical drive can be partitioned */
    3cca:	ec 51       	subi	r30, 0x1C	; 28
    3ccc:	fe 4f       	sbci	r31, 0xFE	; 254
		/* Check the partition listed in the partition table */
		pi = LD2PT(vol);
		if (pi) pi--;
		tbl = &fs->win[MBR_Table + pi * SZ_PTE];/* Partition table */
		if (tbl[4]) {						/* Is the partition existing? */
    3cce:	80 81       	ld	r24, Z
    3cd0:	81 11       	cpse	r24, r1
    3cd2:	02 c0       	rjmp	.+4      	; 0x3cd8 <f_open+0xc6>
    3cd4:	8d e0       	ldi	r24, 0x0D	; 13
    3cd6:	78 c3       	rjmp	.+1776   	; 0x43c8 <f_open+0x7b6>
    3cd8:	f8 01       	movw	r30, r16
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
			fmt = check_fs(fs, bsect);		/* Check the partition */
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
    3cda:	e8 51       	subi	r30, 0x18	; 24
    3cdc:	fe 4f       	sbci	r31, 0xFE	; 254
		/* Check the partition listed in the partition table */
		pi = LD2PT(vol);
		if (pi) pi--;
		tbl = &fs->win[MBR_Table + pi * SZ_PTE];/* Partition table */
		if (tbl[4]) {						/* Is the partition existing? */
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
    3cde:	80 80       	ld	r8, Z
    3ce0:	91 80       	ldd	r9, Z+1	; 0x01
    3ce2:	a2 80       	ldd	r10, Z+2	; 0x02
    3ce4:	b3 80       	ldd	r11, Z+3	; 0x03
    3ce6:	8f a2       	std	Y+39, r8	; 0x27
    3ce8:	98 a6       	std	Y+40, r9	; 0x28
    3cea:	a9 a6       	std	Y+41, r10	; 0x29
    3cec:	ba a6       	std	Y+42, r11	; 0x2a
    3cee:	b5 01       	movw	r22, r10
    3cf0:	a4 01       	movw	r20, r8
    3cf2:	c8 01       	movw	r24, r16
			fmt = check_fs(fs, bsect);		/* Check the partition */
    3cf4:	c1 dd       	rcall	.-1150   	; 0x3878 <check_fs>
    3cf6:	04 c0       	rjmp	.+8      	; 0x3d00 <f_open+0xee>
    3cf8:	1f a2       	std	Y+39, r1	; 0x27
    3cfa:	18 a6       	std	Y+40, r1	; 0x28
    3cfc:	19 a6       	std	Y+41, r1	; 0x29
    3cfe:	1a a6       	std	Y+42, r1	; 0x2a
#if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
		return FR_DISK_ERR;
#endif
	/* Search FAT partition on the drive. Supports only generic partitions, FDISK and SFD. */
	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
    3d00:	83 30       	cpi	r24, 0x03	; 3
    3d02:	09 f4       	brne	.+2      	; 0x3d06 <f_open+0xf4>
    3d04:	62 c1       	rjmp	.+708    	; 0x3fca <f_open+0x3b8>
    3d06:	81 11       	cpse	r24, r1
		if (tbl[4]) {						/* Is the partition existing? */
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
			fmt = check_fs(fs, bsect);		/* Check the partition */
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
    3d08:	e5 cf       	rjmp	.-54     	; 0x3cd4 <f_open+0xc2>
    3d0a:	d8 01       	movw	r26, r16
    3d0c:	9d 96       	adiw	r26, 0x2d	; 45
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
    3d0e:	8d 91       	ld	r24, X+
    3d10:	9c 91       	ld	r25, X

	/* An FAT volume is found. Following code initializes the file system object */

	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
    3d12:	9e 97       	sbiw	r26, 0x2e	; 46
    3d14:	81 15       	cp	r24, r1
    3d16:	92 40       	sbci	r25, 0x02	; 2
    3d18:	e9 f6       	brne	.-70     	; 0x3cd4 <f_open+0xc2>
    3d1a:	f8 01       	movw	r30, r16
    3d1c:	c0 ac       	ldd	r12, Z+56	; 0x38
    3d1e:	d1 ac       	ldd	r13, Z+57	; 0x39
    3d20:	e1 2c       	mov	r14, r1
		return FR_NO_FILESYSTEM;

	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
    3d22:	f1 2c       	mov	r15, r1
    3d24:	c1 14       	cp	r12, r1
    3d26:	d1 04       	cpc	r13, r1
    3d28:	e1 04       	cpc	r14, r1
    3d2a:	f1 04       	cpc	r15, r1
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
    3d2c:	31 f4       	brne	.+12     	; 0x3d3a <f_open+0x128>
    3d2e:	ea 5b       	subi	r30, 0xBA	; 186
    3d30:	ff 4f       	sbci	r31, 0xFF	; 255
    3d32:	c0 80       	ld	r12, Z
    3d34:	d1 80       	ldd	r13, Z+1	; 0x01
    3d36:	e2 80       	ldd	r14, Z+2	; 0x02
    3d38:	f3 80       	ldd	r15, Z+3	; 0x03
    3d3a:	d8 01       	movw	r26, r16
    3d3c:	1e 96       	adiw	r26, 0x0e	; 14
    3d3e:	cd 92       	st	X+, r12
    3d40:	dd 92       	st	X+, r13
	fs->fsize = fasize;
    3d42:	ed 92       	st	X+, r14
    3d44:	fc 92       	st	X, r15
    3d46:	51 97       	sbiw	r26, 0x11	; 17
    3d48:	d2 96       	adiw	r26, 0x32	; 50
    3d4a:	ac 91       	ld	r26, X
    3d4c:	f8 01       	movw	r30, r16
    3d4e:	a3 83       	std	Z+3, r26	; 0x03

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
    3d50:	8f ef       	ldi	r24, 0xFF	; 255
    3d52:	8a 0f       	add	r24, r26
    3d54:	82 30       	cpi	r24, 0x02	; 2
    3d56:	08 f0       	brcs	.+2      	; 0x3d5a <f_open+0x148>
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
    3d58:	bd cf       	rjmp	.-134    	; 0x3cd4 <f_open+0xc2>
    3d5a:	b0 e0       	ldi	r27, 0x00	; 0
    3d5c:	a7 01       	movw	r20, r14
    3d5e:	96 01       	movw	r18, r12
    3d60:	0e 94 35 3a 	call	0x746a	; 0x746a <__muluhisi3>
	fasize *= b;										/* Number of sectors for FAT area */
    3d64:	6b a7       	std	Y+43, r22	; 0x2b
    3d66:	7c a7       	std	Y+44, r23	; 0x2c
    3d68:	8d a7       	std	Y+45, r24	; 0x2d
    3d6a:	9e a7       	std	Y+46, r25	; 0x2e
    3d6c:	e7 a5       	ldd	r30, Z+47	; 0x2f
    3d6e:	d8 01       	movw	r26, r16
    3d70:	12 96       	adiw	r26, 0x02	; 2
    3d72:	ec 93       	st	X, r30

	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
    3d74:	12 97       	sbiw	r26, 0x02	; 2
    3d76:	ee 23       	and	r30, r30
    3d78:	09 f4       	brne	.+2      	; 0x3d7c <f_open+0x16a>
    3d7a:	ac cf       	rjmp	.-168    	; 0x3cd4 <f_open+0xc2>
    3d7c:	2e 2f       	mov	r18, r30
	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
    3d7e:	30 e0       	ldi	r19, 0x00	; 0
    3d80:	c9 01       	movw	r24, r18
    3d82:	01 97       	sbiw	r24, 0x01	; 1
    3d84:	82 23       	and	r24, r18
    3d86:	93 23       	and	r25, r19
    3d88:	89 2b       	or	r24, r25
    3d8a:	09 f0       	breq	.+2      	; 0x3d8e <f_open+0x17c>
    3d8c:	a3 cf       	rjmp	.-186    	; 0x3cd4 <f_open+0xc2>
    3d8e:	d3 96       	adiw	r26, 0x33	; 51
    3d90:	8d 90       	ld	r8, X+
    3d92:	9c 90       	ld	r9, X
    3d94:	d4 97       	sbiw	r26, 0x34	; 52

	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
    3d96:	9e a2       	std	Y+38, r9	; 0x26
    3d98:	8d a2       	std	Y+37, r8	; 0x25
    3d9a:	19 96       	adiw	r26, 0x09	; 9
    3d9c:	9c 92       	st	X, r9
    3d9e:	8e 92       	st	-X, r8
    3da0:	18 97       	sbiw	r26, 0x08	; 8
    3da2:	c4 01       	movw	r24, r8
    3da4:	8f 70       	andi	r24, 0x0F	; 15
    3da6:	99 27       	eor	r25, r25
    3da8:	89 2b       	or	r24, r25
	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
    3daa:	09 f0       	breq	.+2      	; 0x3dae <f_open+0x19c>
    3dac:	93 cf       	rjmp	.-218    	; 0x3cd4 <f_open+0xc2>
    3dae:	d5 96       	adiw	r26, 0x35	; 53
    3db0:	2d 91       	ld	r18, X+
    3db2:	3c 91       	ld	r19, X
    3db4:	d6 97       	sbiw	r26, 0x36	; 54

	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
    3db6:	a9 01       	movw	r20, r18
    3db8:	60 e0       	ldi	r22, 0x00	; 0
    3dba:	70 e0       	ldi	r23, 0x00	; 0
    3dbc:	41 15       	cp	r20, r1
    3dbe:	51 05       	cpc	r21, r1
    3dc0:	61 05       	cpc	r22, r1
    3dc2:	71 05       	cpc	r23, r1
	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
    3dc4:	31 f4       	brne	.+12     	; 0x3dd2 <f_open+0x1c0>
    3dc6:	ae 5b       	subi	r26, 0xBE	; 190
    3dc8:	bf 4f       	sbci	r27, 0xFF	; 255
    3dca:	4d 91       	ld	r20, X+
    3dcc:	5d 91       	ld	r21, X+
    3dce:	6d 91       	ld	r22, X+
    3dd0:	7c 91       	ld	r23, X
    3dd2:	d8 01       	movw	r26, r16
    3dd4:	d0 96       	adiw	r26, 0x30	; 48
    3dd6:	8d 91       	ld	r24, X+
    3dd8:	9c 91       	ld	r25, X

	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
    3dda:	d1 97       	sbiw	r26, 0x31	; 49
    3ddc:	00 97       	sbiw	r24, 0x00	; 0
    3dde:	09 f4       	brne	.+2      	; 0x3de2 <f_open+0x1d0>
    3de0:	79 cf       	rjmp	.-270    	; 0x3cd4 <f_open+0xc2>
    3de2:	4c 01       	movw	r8, r24
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
    3de4:	a1 2c       	mov	r10, r1
    3de6:	b1 2c       	mov	r11, r1
    3de8:	8f a6       	std	Y+47, r8	; 0x2f

	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
    3dea:	98 aa       	std	Y+48, r9	; 0x30
    3dec:	a9 aa       	std	Y+49, r10	; 0x31
    3dee:	ba aa       	std	Y+50, r11	; 0x32
    3df0:	8d a1       	ldd	r24, Y+37	; 0x25
    3df2:	9e a1       	ldd	r25, Y+38	; 0x26
    3df4:	f4 e0       	ldi	r31, 0x04	; 4
    3df6:	96 95       	lsr	r25
    3df8:	87 95       	ror	r24
    3dfa:	fa 95       	dec	r31
    3dfc:	e1 f7       	brne	.-8      	; 0x3df6 <f_open+0x1e4>
    3dfe:	24 01       	movw	r4, r8
    3e00:	35 01       	movw	r6, r10
    3e02:	48 0e       	add	r4, r24
    3e04:	59 1e       	adc	r5, r25
    3e06:	61 1c       	adc	r6, r1
    3e08:	71 1c       	adc	r7, r1
    3e0a:	8b a4       	ldd	r8, Y+43	; 0x2b
    3e0c:	9c a4       	ldd	r9, Y+44	; 0x2c
    3e0e:	ad a4       	ldd	r10, Y+45	; 0x2d
    3e10:	be a4       	ldd	r11, Y+46	; 0x2e
    3e12:	48 0c       	add	r4, r8
    3e14:	59 1c       	adc	r5, r9
    3e16:	6a 1c       	adc	r6, r10
    3e18:	7b 1c       	adc	r7, r11
    3e1a:	44 15       	cp	r20, r4
    3e1c:	55 05       	cpc	r21, r5
    3e1e:	66 05       	cpc	r22, r6
    3e20:	77 05       	cpc	r23, r7
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
    3e22:	08 f4       	brcc	.+2      	; 0x3e26 <f_open+0x214>
    3e24:	57 cf       	rjmp	.-338    	; 0x3cd4 <f_open+0xc2>
    3e26:	cb 01       	movw	r24, r22
    3e28:	ba 01       	movw	r22, r20
    3e2a:	64 19       	sub	r22, r4
    3e2c:	75 09       	sbc	r23, r5
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
    3e2e:	86 09       	sbc	r24, r6
    3e30:	97 09       	sbc	r25, r7
    3e32:	2e 2f       	mov	r18, r30
    3e34:	30 e0       	ldi	r19, 0x00	; 0
    3e36:	40 e0       	ldi	r20, 0x00	; 0
    3e38:	50 e0       	ldi	r21, 0x00	; 0
    3e3a:	0e 94 3f 3a 	call	0x747e	; 0x747e <__udivmodsi4>
    3e3e:	21 15       	cp	r18, r1
    3e40:	31 05       	cpc	r19, r1
    3e42:	41 05       	cpc	r20, r1
    3e44:	51 05       	cpc	r21, r1
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
    3e46:	09 f4       	brne	.+2      	; 0x3e4a <f_open+0x238>
    3e48:	45 cf       	rjmp	.-374    	; 0x3cd4 <f_open+0xc2>
    3e4a:	26 3f       	cpi	r18, 0xF6	; 246
    3e4c:	8f e0       	ldi	r24, 0x0F	; 15
    3e4e:	38 07       	cpc	r19, r24
    3e50:	41 05       	cpc	r20, r1
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
    3e52:	51 05       	cpc	r21, r1
    3e54:	40 f0       	brcs	.+16     	; 0x3e66 <f_open+0x254>
    3e56:	26 3f       	cpi	r18, 0xF6	; 246
    3e58:	9f ef       	ldi	r25, 0xFF	; 255
    3e5a:	39 07       	cpc	r19, r25
    3e5c:	41 05       	cpc	r20, r1
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
    3e5e:	51 05       	cpc	r21, r1
    3e60:	28 f4       	brcc	.+10     	; 0x3e6c <f_open+0x25a>
    3e62:	e2 e0       	ldi	r30, 0x02	; 2
    3e64:	04 c0       	rjmp	.+8      	; 0x3e6e <f_open+0x25c>
    3e66:	f1 e0       	ldi	r31, 0x01	; 1
    3e68:	fc ab       	std	Y+52, r31	; 0x34
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
    3e6a:	02 c0       	rjmp	.+4      	; 0x3e70 <f_open+0x25e>
    3e6c:	e3 e0       	ldi	r30, 0x03	; 3
	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
	fmt = FS_FAT12;
    3e6e:	ec ab       	std	Y+52, r30	; 0x34
    3e70:	49 01       	movw	r8, r18
    3e72:	5a 01       	movw	r10, r20
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
    3e74:	f2 e0       	ldi	r31, 0x02	; 2
    3e76:	8f 0e       	add	r8, r31

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
    3e78:	91 1c       	adc	r9, r1
    3e7a:	a1 1c       	adc	r10, r1
    3e7c:	b1 1c       	adc	r11, r1
    3e7e:	d8 01       	movw	r26, r16
    3e80:	1a 96       	adiw	r26, 0x0a	; 10
    3e82:	8d 92       	st	X+, r8
    3e84:	9d 92       	st	X+, r9
    3e86:	ad 92       	st	X+, r10
    3e88:	bc 92       	st	X, r11
    3e8a:	1d 97       	sbiw	r26, 0x0d	; 13
    3e8c:	8f a1       	ldd	r24, Y+39	; 0x27
    3e8e:	98 a5       	ldd	r25, Y+40	; 0x28
    3e90:	a9 a5       	ldd	r26, Y+41	; 0x29
    3e92:	ba a5       	ldd	r27, Y+42	; 0x2a
	fs->database = bsect + sysect;						/* Data start sector */
    3e94:	84 0d       	add	r24, r4
    3e96:	95 1d       	adc	r25, r5
    3e98:	a6 1d       	adc	r26, r6
    3e9a:	b7 1d       	adc	r27, r7
    3e9c:	f8 01       	movw	r30, r16
    3e9e:	82 8f       	std	Z+26, r24	; 0x1a
    3ea0:	93 8f       	std	Z+27, r25	; 0x1b
    3ea2:	a4 8f       	std	Z+28, r26	; 0x1c
    3ea4:	b5 8f       	std	Z+29, r27	; 0x1d
    3ea6:	8f a1       	ldd	r24, Y+39	; 0x27
    3ea8:	98 a5       	ldd	r25, Y+40	; 0x28
    3eaa:	a9 a5       	ldd	r26, Y+41	; 0x29
    3eac:	ba a5       	ldd	r27, Y+42	; 0x2a
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
    3eae:	2f a5       	ldd	r18, Y+47	; 0x2f
    3eb0:	38 a9       	ldd	r19, Y+48	; 0x30
    3eb2:	49 a9       	ldd	r20, Y+49	; 0x31
    3eb4:	5a a9       	ldd	r21, Y+50	; 0x32
    3eb6:	82 0f       	add	r24, r18
    3eb8:	93 1f       	adc	r25, r19
    3eba:	a4 1f       	adc	r26, r20
    3ebc:	b5 1f       	adc	r27, r21
    3ebe:	82 8b       	std	Z+18, r24	; 0x12
    3ec0:	93 8b       	std	Z+19, r25	; 0x13
    3ec2:	a4 8b       	std	Z+20, r26	; 0x14
    3ec4:	b5 8b       	std	Z+21, r27	; 0x15
    3ec6:	fc a9       	ldd	r31, Y+52	; 0x34
    3ec8:	2d a1       	ldd	r18, Y+37	; 0x25
    3eca:	3e a1       	ldd	r19, Y+38	; 0x26
    3ecc:	f3 30       	cpi	r31, 0x03	; 3
	if (fmt == FS_FAT32) {
    3ece:	d1 f4       	brne	.+52     	; 0x3f04 <f_open+0x2f2>
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
    3ed0:	23 2b       	or	r18, r19
    3ed2:	09 f0       	breq	.+2      	; 0x3ed6 <f_open+0x2c4>

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
	fs->database = bsect + sysect;						/* Data start sector */
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
	if (fmt == FS_FAT32) {
    3ed4:	ff ce       	rjmp	.-514    	; 0x3cd4 <f_open+0xc2>
    3ed6:	d8 01       	movw	r26, r16
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
    3ed8:	a2 5b       	subi	r26, 0xB2	; 178
    3eda:	bf 4f       	sbci	r27, 0xFF	; 255
    3edc:	8d 91       	ld	r24, X+
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
    3ede:	9d 91       	ld	r25, X+
    3ee0:	0d 90       	ld	r0, X+
    3ee2:	bc 91       	ld	r27, X
    3ee4:	a0 2d       	mov	r26, r0
    3ee6:	f8 01       	movw	r30, r16
    3ee8:	86 8b       	std	Z+22, r24	; 0x16
    3eea:	97 8b       	std	Z+23, r25	; 0x17
    3eec:	a0 8f       	std	Z+24, r26	; 0x18
    3eee:	b1 8f       	std	Z+25, r27	; 0x19
    3ef0:	c5 01       	movw	r24, r10
    3ef2:	b4 01       	movw	r22, r8
    3ef4:	52 e0       	ldi	r21, 0x02	; 2
    3ef6:	66 0f       	add	r22, r22
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
    3ef8:	77 1f       	adc	r23, r23
    3efa:	88 1f       	adc	r24, r24
    3efc:	99 1f       	adc	r25, r25
    3efe:	5a 95       	dec	r21
    3f00:	d1 f7       	brne	.-12     	; 0x3ef6 <f_open+0x2e4>
    3f02:	2f c0       	rjmp	.+94     	; 0x3f62 <f_open+0x350>
    3f04:	23 2b       	or	r18, r19
    3f06:	09 f4       	brne	.+2      	; 0x3f0a <f_open+0x2f8>
    3f08:	e5 ce       	rjmp	.-566    	; 0x3cd4 <f_open+0xc2>
    3f0a:	4b a4       	ldd	r4, Y+43	; 0x2b
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
    3f0c:	5c a4       	ldd	r5, Y+44	; 0x2c
    3f0e:	6d a4       	ldd	r6, Y+45	; 0x2d
    3f10:	7e a4       	ldd	r7, Y+46	; 0x2e
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
    3f12:	48 0e       	add	r4, r24
    3f14:	59 1e       	adc	r5, r25
    3f16:	6a 1e       	adc	r6, r26
    3f18:	7b 1e       	adc	r7, r27
    3f1a:	d8 01       	movw	r26, r16
    3f1c:	56 96       	adiw	r26, 0x16	; 22
    3f1e:	4d 92       	st	X+, r4
    3f20:	5d 92       	st	X+, r5
    3f22:	6d 92       	st	X+, r6
    3f24:	7c 92       	st	X, r7
    3f26:	59 97       	sbiw	r26, 0x19	; 25
    3f28:	ec a9       	ldd	r30, Y+52	; 0x34
    3f2a:	e2 30       	cpi	r30, 0x02	; 2
    3f2c:	39 f4       	brne	.+14     	; 0x3f3c <f_open+0x32a>
    3f2e:	c5 01       	movw	r24, r10
		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
    3f30:	b4 01       	movw	r22, r8
    3f32:	66 0f       	add	r22, r22
    3f34:	77 1f       	adc	r23, r23
    3f36:	88 1f       	adc	r24, r24
    3f38:	99 1f       	adc	r25, r25
    3f3a:	13 c0       	rjmp	.+38     	; 0x3f62 <f_open+0x350>
    3f3c:	a3 e0       	ldi	r26, 0x03	; 3
    3f3e:	b0 e0       	ldi	r27, 0x00	; 0
    3f40:	a5 01       	movw	r20, r10
    3f42:	94 01       	movw	r18, r8
    3f44:	0e 94 35 3a 	call	0x746a	; 0x746a <__muluhisi3>
    3f48:	96 95       	lsr	r25
    3f4a:	87 95       	ror	r24
    3f4c:	77 95       	ror	r23
    3f4e:	67 95       	ror	r22
    3f50:	f1 e0       	ldi	r31, 0x01	; 1
    3f52:	8f 22       	and	r8, r31
    3f54:	99 24       	eor	r9, r9
    3f56:	aa 24       	eor	r10, r10
    3f58:	bb 24       	eor	r11, r11
    3f5a:	68 0d       	add	r22, r8
    3f5c:	79 1d       	adc	r23, r9
    3f5e:	8a 1d       	adc	r24, r10
    3f60:	9b 1d       	adc	r25, r11
    3f62:	dc 01       	movw	r26, r24
    3f64:	cb 01       	movw	r24, r22
    3f66:	81 50       	subi	r24, 0x01	; 1
    3f68:	9e 4f       	sbci	r25, 0xFE	; 254
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
    3f6a:	af 4f       	sbci	r26, 0xFF	; 255
    3f6c:	bf 4f       	sbci	r27, 0xFF	; 255
    3f6e:	29 e0       	ldi	r18, 0x09	; 9
    3f70:	b6 95       	lsr	r27
    3f72:	a7 95       	ror	r26
    3f74:	97 95       	ror	r25
    3f76:	87 95       	ror	r24
    3f78:	2a 95       	dec	r18
    3f7a:	d1 f7       	brne	.-12     	; 0x3f70 <f_open+0x35e>
    3f7c:	c8 16       	cp	r12, r24
    3f7e:	d9 06       	cpc	r13, r25
    3f80:	ea 06       	cpc	r14, r26
    3f82:	fb 06       	cpc	r15, r27
    3f84:	08 f4       	brcc	.+2      	; 0x3f88 <f_open+0x376>
    3f86:	a6 ce       	rjmp	.-692    	; 0x3cd4 <f_open+0xc2>
    3f88:	ec a9       	ldd	r30, Y+52	; 0x34
    3f8a:	d8 01       	movw	r26, r16
    3f8c:	ec 93       	st	X, r30
    3f8e:	80 91 00 04 	lds	r24, 0x0400
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
		}
	}
#endif
	fs->fs_type = fmt;		/* FAT sub-type */
    3f92:	90 91 01 04 	lds	r25, 0x0401
	fs->id = ++Fsid;		/* File system mount ID */
    3f96:	01 96       	adiw	r24, 0x01	; 1
    3f98:	90 93 01 04 	sts	0x0401, r25
    3f9c:	80 93 00 04 	sts	0x0400, r24
    3fa0:	17 96       	adiw	r26, 0x07	; 7
    3fa2:	9c 93       	st	X, r25
    3fa4:	8e 93       	st	-X, r24
    3fa6:	16 97       	sbiw	r26, 0x06	; 6
    3fa8:	5e 96       	adiw	r26, 0x1e	; 30
    3faa:	1d 92       	st	X+, r1
    3fac:	1d 92       	st	X+, r1
    3fae:	1d 92       	st	X+, r1
	fs->winsect = 0;		/* Invalidate sector cache */
    3fb0:	1c 92       	st	X, r1
    3fb2:	91 97       	sbiw	r26, 0x21	; 33
    3fb4:	14 96       	adiw	r26, 0x04	; 4
    3fb6:	1c 92       	st	X, r1
    3fb8:	0a c0       	rjmp	.+20     	; 0x3fce <f_open+0x3bc>
    3fba:	89 e0       	ldi	r24, 0x09	; 9
	fs->wflag = 0;
    3fbc:	05 c2       	rjmp	.+1034   	; 0x43c8 <f_open+0x7b6>
    3fbe:	8b e0       	ldi	r24, 0x0B	; 11
    3fc0:	03 c2       	rjmp	.+1030   	; 0x43c8 <f_open+0x7b6>
	DIR dj;
	BYTE *dir;
	DEF_NAMEBUF;


	if (!fp) return FR_INVALID_OBJECT;
    3fc2:	8c e0       	ldi	r24, 0x0C	; 12
    3fc4:	01 c2       	rjmp	.+1026   	; 0x43c8 <f_open+0x7b6>
	}

	/* Check if the file system object is valid or not */
	*rfs = 0;
	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
		return FR_INVALID_DRIVE;
    3fc6:	83 e0       	ldi	r24, 0x03	; 3
    3fc8:	ff c1       	rjmp	.+1022   	; 0x43c8 <f_open+0x7b6>
	fs = FatFs[vol];					/* Get corresponding file system object */
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
    3fca:	81 e0       	ldi	r24, 0x01	; 1
    3fcc:	fd c1       	rjmp	.+1018   	; 0x43c8 <f_open+0x7b6>

	fs->fs_type = 0;					/* Clear the file system object */
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
    3fce:	ce 01       	movw	r24, r28
    3fd0:	47 96       	adiw	r24, 0x17	; 23
		if (tbl[4]) {						/* Is the partition existing? */
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
			fmt = check_fs(fs, bsect);		/* Check the partition */
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
    3fd2:	9e 8b       	std	Y+22, r25	; 0x16
    3fd4:	8d 8b       	std	Y+21, r24	; 0x15
#else
	mode &= FA_READ;
	res = chk_mounted(&path, &dj.fs, 0);
#endif
	if (res == FR_OK) {
		INIT_BUF(dj);
    3fd6:	d1 01       	movw	r26, r2
    3fd8:	8c 91       	ld	r24, X
    3fda:	8f 32       	cpi	r24, 0x2F	; 47
    3fdc:	11 f0       	breq	.+4      	; 0x3fe2 <f_open+0x3d0>
		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
	} else {							/* No heading separator */
		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
	}
#else
	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
    3fde:	8c 35       	cpi	r24, 0x5C	; 92
    3fe0:	19 f4       	brne	.+6      	; 0x3fe8 <f_open+0x3d6>
    3fe2:	bf ef       	ldi	r27, 0xFF	; 255
    3fe4:	2b 1a       	sub	r2, r27
    3fe6:	3b 0a       	sbc	r3, r27
    3fe8:	1f 82       	std	Y+7, r1	; 0x07
		path++;
    3fea:	18 86       	std	Y+8, r1	; 0x08
    3fec:	19 86       	std	Y+9, r1	; 0x09
    3fee:	1a 86       	std	Y+10, r1	; 0x0a
	dj->sclust = 0;						/* Start from the root dir */
    3ff0:	f1 01       	movw	r30, r2
    3ff2:	80 81       	ld	r24, Z
    3ff4:	80 32       	cpi	r24, 0x20	; 32
    3ff6:	30 f4       	brcc	.+12     	; 0x4004 <f_open+0x3f2>
#endif

	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
    3ff8:	ce 01       	movw	r24, r28
    3ffa:	01 96       	adiw	r24, 0x01	; 1
    3ffc:	7c dd       	rcall	.-1288   	; 0x3af6 <dir_sdi.constprop.4>
    3ffe:	1c 8a       	std	Y+20, r1	; 0x14
		res = dir_sdi(dj, 0);
    4000:	1b 8a       	std	Y+19, r1	; 0x13
    4002:	6a c1       	rjmp	.+724    	; 0x42d8 <f_open+0x6c6>
    4004:	10 e2       	ldi	r17, 0x20	; 32
    4006:	71 2e       	mov	r7, r17
		dj->dir = 0;
    4008:	05 e0       	ldi	r16, 0x05	; 5
    400a:	60 2e       	mov	r6, r16
    400c:	61 01       	movw	r12, r2
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
		*d++ = (BYTE)val;
    400e:	d1 01       	movw	r26, r2
    4010:	8c 91       	ld	r24, X
	}
	*path = &p[si];						/* Return pointer to the next segment */
	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */

	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
	if (sfn[0] == DDE) sfn[0] = NDDE;	/* When first char collides with DDE, replace it with 0x05 */
    4012:	bf ef       	ldi	r27, 0xFF	; 255
    4014:	2b 1a       	sub	r2, r27
    4016:	3b 0a       	sbc	r3, r27
	BYTE b, c, d, *sfn;
	UINT ni, si, i;
	const char *p;

	/* Create file name in directory form */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
    4018:	8f 32       	cpi	r24, 0x2F	; 47
    401a:	c1 f3       	breq	.-16     	; 0x400c <f_open+0x3fa>
    401c:	8c 35       	cpi	r24, 0x5C	; 92
    401e:	b1 f3       	breq	.-20     	; 0x400c <f_open+0x3fa>
    4020:	ed 89       	ldd	r30, Y+21	; 0x15
    4022:	fe 89       	ldd	r31, Y+22	; 0x16
    4024:	cf 01       	movw	r24, r30
    4026:	9f 01       	movw	r18, r30
    4028:	25 5f       	subi	r18, 0xF5	; 245
	sfn = dj->fn;
    402a:	3f 4f       	sbci	r19, 0xFF	; 255
    402c:	82 17       	cp	r24, r18
    402e:	93 07       	cpc	r25, r19
    4030:	21 f0       	breq	.+8      	; 0x403a <f_open+0x428>
    4032:	dc 01       	movw	r26, r24
    4034:	7d 92       	st	X+, r7
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
    4036:	cd 01       	movw	r24, r26
    4038:	f9 cf       	rjmp	.-14     	; 0x402c <f_open+0x41a>
    403a:	80 e0       	ldi	r24, 0x00	; 0
		*d++ = (BYTE)val;
    403c:	90 e0       	ldi	r25, 0x00	; 0
    403e:	60 e0       	ldi	r22, 0x00	; 0
    4040:	70 e0       	ldi	r23, 0x00	; 0
    4042:	28 e0       	ldi	r18, 0x08	; 8
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
    4044:	30 e0       	ldi	r19, 0x00	; 0
    4046:	10 e0       	ldi	r17, 0x00	; 0
    4048:	1b 01       	movw	r2, r22
    404a:	bf ef       	ldi	r27, 0xFF	; 255
    404c:	2b 1a       	sub	r2, r27
    404e:	3b 0a       	sbc	r3, r27
    4050:	a6 01       	movw	r20, r12
		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
		return FR_OK;
	}
#endif
	for (;;) {
		c = (BYTE)p[si++];
    4052:	46 0f       	add	r20, r22
    4054:	57 1f       	adc	r21, r23
    4056:	da 01       	movw	r26, r20
    4058:	0c 91       	ld	r16, X
    405a:	01 32       	cpi	r16, 0x21	; 33
    405c:	08 f4       	brcc	.+2      	; 0x4060 <f_open+0x44e>
    405e:	4c c0       	rjmp	.+152    	; 0x40f8 <f_open+0x4e6>
    4060:	0f 32       	cpi	r16, 0x2F	; 47
    4062:	09 f4       	brne	.+2      	; 0x4066 <f_open+0x454>
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
    4064:	49 c0       	rjmp	.+146    	; 0x40f8 <f_open+0x4e6>
    4066:	0c 35       	cpi	r16, 0x5C	; 92
    4068:	09 f4       	brne	.+2      	; 0x406c <f_open+0x45a>
    406a:	46 c0       	rjmp	.+140    	; 0x40f8 <f_open+0x4e6>
    406c:	0e 32       	cpi	r16, 0x2E	; 46
    406e:	09 f4       	brne	.+2      	; 0x4072 <f_open+0x460>
    4070:	9a c1       	rjmp	.+820    	; 0x43a6 <f_open+0x794>
    4072:	82 17       	cp	r24, r18
    4074:	93 07       	cpc	r25, r19
		if (c == '.' || i >= ni) {
    4076:	08 f0       	brcs	.+2      	; 0x407a <f_open+0x468>
    4078:	2e c1       	rjmp	.+604    	; 0x42d6 <f_open+0x6c4>
    407a:	07 fd       	sbrc	r16, 7
    407c:	13 60       	ori	r17, 0x03	; 3
    407e:	4f e7       	ldi	r20, 0x7F	; 127
    4080:	40 0f       	add	r20, r16
    4082:	4f 31       	cpi	r20, 0x1F	; 31
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
			i = 8; ni = 11;
			b <<= 2; continue;
		}
		if (c >= 0x80) {				/* Extended char? */
    4084:	20 f0       	brcs	.+8      	; 0x408e <f_open+0x47c>
			b |= 3;						/* Eliminate NT flag */
    4086:	40 e2       	ldi	r20, 0x20	; 32
#if !_DF1S	/* ASCII only cfg */
			return FR_INVALID_NAME;
#endif
#endif
		}
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
    4088:	40 0f       	add	r20, r16
    408a:	4d 31       	cpi	r20, 0x1D	; 29
    408c:	30 f5       	brcc	.+76     	; 0x40da <f_open+0x4c8>
    408e:	6e 5f       	subi	r22, 0xFE	; 254
    4090:	7f 4f       	sbci	r23, 0xFF	; 255
    4092:	2c 0c       	add	r2, r12
    4094:	3d 1c       	adc	r3, r13
    4096:	d1 01       	movw	r26, r2
			d = (BYTE)p[si++];			/* Get 2nd byte */
    4098:	bc 90       	ld	r11, X
    409a:	40 ec       	ldi	r20, 0xC0	; 192
    409c:	4b 0d       	add	r20, r11
    409e:	4f 33       	cpi	r20, 0x3F	; 63
    40a0:	28 f0       	brcs	.+10     	; 0x40ac <f_open+0x49a>
    40a2:	40 e8       	ldi	r20, 0x80	; 128
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
    40a4:	4b 0d       	add	r20, r11
    40a6:	4d 37       	cpi	r20, 0x7D	; 125
    40a8:	08 f0       	brcs	.+2      	; 0x40ac <f_open+0x49a>
    40aa:	15 c1       	rjmp	.+554    	; 0x42d6 <f_open+0x6c4>
    40ac:	a9 01       	movw	r20, r18
    40ae:	41 50       	subi	r20, 0x01	; 1
    40b0:	51 09       	sbc	r21, r1
    40b2:	84 17       	cp	r24, r20
    40b4:	95 07       	cpc	r25, r21
    40b6:	08 f0       	brcs	.+2      	; 0x40ba <f_open+0x4a8>
    40b8:	0e c1       	rjmp	.+540    	; 0x42d6 <f_open+0x6c4>
    40ba:	ac 01       	movw	r20, r24
    40bc:	4f 5f       	subi	r20, 0xFF	; 255
    40be:	5f 4f       	sbci	r21, 0xFF	; 255
    40c0:	7f 01       	movw	r14, r30
    40c2:	e8 0e       	add	r14, r24
				return FR_INVALID_NAME;
			sfn[i++] = c;
    40c4:	f9 1e       	adc	r15, r25
    40c6:	d7 01       	movw	r26, r14
    40c8:	0c 93       	st	X, r16
    40ca:	02 96       	adiw	r24, 0x02	; 2
    40cc:	4e 0f       	add	r20, r30
    40ce:	5f 1f       	adc	r21, r31
    40d0:	da 01       	movw	r26, r20
    40d2:	bc 92       	st	X, r11
			sfn[i++] = d;
    40d4:	1b 01       	movw	r2, r22
    40d6:	b1 01       	movw	r22, r2
    40d8:	b7 cf       	rjmp	.-146    	; 0x4048 <f_open+0x436>
    40da:	60 2f       	mov	r22, r16
    40dc:	70 e0       	ldi	r23, 0x00	; 0
			return FR_INVALID_NAME;
#endif
#endif
		}
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
			d = (BYTE)p[si++];			/* Get 2nd byte */
    40de:	44 eb       	ldi	r20, 0xB4	; 180
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
    40e0:	52 e0       	ldi	r21, 0x02	; 2
    40e2:	da 01       	movw	r26, r20
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
				return FR_INVALID_NAME;
			sfn[i++] = c;
			sfn[i++] = d;
		} else {						/* Single byte code */
			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
    40e4:	ed 90       	ld	r14, X+
    40e6:	ad 01       	movw	r20, r26
    40e8:	ee 20       	and	r14, r14
    40ea:	09 f4       	brne	.+2      	; 0x40ee <f_open+0x4dc>
}

/* Check if chr is contained in the string */
static
int chk_chr (const char* str, int chr) {
	while (*str && *str != chr) str++;
    40ec:	03 c1       	rjmp	.+518    	; 0x42f4 <f_open+0x6e2>
    40ee:	f1 2c       	mov	r15, r1
    40f0:	e6 16       	cp	r14, r22
    40f2:	f7 06       	cpc	r15, r23
    40f4:	b1 f7       	brne	.-20     	; 0x40e2 <f_open+0x4d0>
    40f6:	ef c0       	rjmp	.+478    	; 0x42d6 <f_open+0x6c4>
    40f8:	2c 0c       	add	r2, r12
    40fa:	3d 1c       	adc	r3, r13
    40fc:	01 32       	cpi	r16, 0x21	; 33
    40fe:	10 f4       	brcc	.+4      	; 0x4104 <f_open+0x4f2>
    4100:	44 e0       	ldi	r20, 0x04	; 4
				}
			}
			sfn[i++] = c;
		}
	}
	*path = &p[si];						/* Return pointer to the next segment */
    4102:	01 c0       	rjmp	.+2      	; 0x4106 <f_open+0x4f4>
    4104:	40 e0       	ldi	r20, 0x00	; 0
	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
    4106:	89 2b       	or	r24, r25
    4108:	09 f4       	brne	.+2      	; 0x410c <f_open+0x4fa>
    410a:	e5 c0       	rjmp	.+458    	; 0x42d6 <f_open+0x6c4>
    410c:	80 81       	ld	r24, Z
    410e:	85 3e       	cpi	r24, 0xE5	; 229

	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
    4110:	09 f4       	brne	.+2      	; 0x4114 <f_open+0x502>
    4112:	60 82       	st	Z, r6
    4114:	28 30       	cpi	r18, 0x08	; 8
	if (sfn[0] == DDE) sfn[0] = NDDE;	/* When first char collides with DDE, replace it with 0x05 */
    4116:	31 05       	cpc	r19, r1
    4118:	11 f4       	brne	.+4      	; 0x411e <f_open+0x50c>
    411a:	11 0f       	add	r17, r17
    411c:	11 0f       	add	r17, r17

	if (ni == 8) b <<= 2;
    411e:	81 2f       	mov	r24, r17
    4120:	83 70       	andi	r24, 0x03	; 3
    4122:	81 30       	cpi	r24, 0x01	; 1
    4124:	09 f4       	brne	.+2      	; 0x4128 <f_open+0x516>
    4126:	40 61       	ori	r20, 0x10	; 16
	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
    4128:	81 2f       	mov	r24, r17
    412a:	8c 70       	andi	r24, 0x0C	; 12
    412c:	84 30       	cpi	r24, 0x04	; 4
    412e:	09 f4       	brne	.+2      	; 0x4132 <f_open+0x520>
    4130:	48 60       	ori	r20, 0x08	; 8
	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
    4132:	43 87       	std	Z+11, r20	; 0x0b
    4134:	ce 01       	movw	r24, r28
    4136:	01 96       	adiw	r24, 0x01	; 1
    4138:	de dc       	rcall	.-1604   	; 0x3af6 <dir_sdi.constprop.4>
    413a:	81 11       	cpse	r24, r1

	sfn[NS] = c;		/* Store NT flag, File name is created */
    413c:	9d c0       	rjmp	.+314    	; 0x4278 <f_open+0x666>
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord, sum;
#endif

	res = dir_sdi(dj, 0);			/* Rewind directory object */
    413e:	4f 85       	ldd	r20, Y+15	; 0x0f
    4140:	58 89       	ldd	r21, Y+16	; 0x10
    4142:	69 89       	ldd	r22, Y+17	; 0x11
    4144:	7a 89       	ldd	r23, Y+18	; 0x12
	if (res != FR_OK) return res;
    4146:	89 81       	ldd	r24, Y+1	; 0x01
    4148:	9a 81       	ldd	r25, Y+2	; 0x02

#if _USE_LFN
	ord = sum = 0xFF;
#endif
	do {
		res = move_window(dj->fs, dj->sect);
    414a:	64 db       	rcall	.-2360   	; 0x3814 <move_window>
    414c:	81 11       	cpse	r24, r1
    414e:	94 c0       	rjmp	.+296    	; 0x4278 <f_open+0x666>
    4150:	eb 89       	ldd	r30, Y+19	; 0x13
    4152:	fc 89       	ldd	r31, Y+20	; 0x14
    4154:	80 81       	ld	r24, Z
    4156:	88 23       	and	r24, r24
    4158:	09 f4       	brne	.+2      	; 0x415c <f_open+0x54a>
		if (res != FR_OK) break;
    415a:	30 c1       	rjmp	.+608    	; 0x43bc <f_open+0x7aa>
    415c:	83 85       	ldd	r24, Z+11	; 0x0b
		dir = dj->dir;					/* Ptr to the directory entry of current index */
    415e:	83 fd       	sbrc	r24, 3
    4160:	0c c0       	rjmp	.+24     	; 0x417a <f_open+0x568>
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
    4162:	ad 89       	ldd	r26, Y+21	; 0x15
    4164:	be 89       	ldd	r27, Y+22	; 0x16
    4166:	cf 01       	movw	r24, r30
    4168:	0b 96       	adiw	r24, 0x0b	; 11
				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;	/* SFN matched? */
			}
		}
#else		/* Non LFN configuration */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
    416a:	e8 17       	cp	r30, r24
    416c:	f9 07       	cpc	r31, r25
    416e:	09 f4       	brne	.+2      	; 0x4172 <f_open+0x560>
    4170:	82 c0       	rjmp	.+260    	; 0x4276 <f_open+0x664>
    4172:	31 91       	ld	r19, Z+
    4174:	2d 91       	ld	r18, X+
    4176:	32 17       	cp	r19, r18
static
int mem_cmp (const void* dst, const void* src, UINT cnt) {
	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
	int r = 0;

	while (cnt-- && (r = *d++ - *s++) == 0) ;
    4178:	c1 f3       	breq	.-16     	; 0x416a <f_open+0x558>
    417a:	cd 80       	ldd	r12, Y+5	; 0x05
    417c:	de 80       	ldd	r13, Y+6	; 0x06
    417e:	bf ef       	ldi	r27, 0xFF	; 255
    4180:	cb 1a       	sub	r12, r27
    4182:	db 0a       	sbc	r13, r27
    4184:	c1 14       	cp	r12, r1
    4186:	d1 04       	cpc	r13, r1
	DWORD clst;
	WORD i;


	stretch = stretch;		/* To suppress warning on read-only cfg. */
	i = dj->index + 1;
    4188:	09 f4       	brne	.+2      	; 0x418c <f_open+0x57a>
    418a:	18 c1       	rjmp	.+560    	; 0x43bc <f_open+0x7aa>
    418c:	8f 85       	ldd	r24, Y+15	; 0x0f
    418e:	98 89       	ldd	r25, Y+16	; 0x10
    4190:	a9 89       	ldd	r26, Y+17	; 0x11
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
    4192:	ba 89       	ldd	r27, Y+18	; 0x12
    4194:	00 97       	sbiw	r24, 0x00	; 0
    4196:	a1 05       	cpc	r26, r1
    4198:	b1 05       	cpc	r27, r1
    419a:	09 f4       	brne	.+2      	; 0x419e <f_open+0x58c>
    419c:	0f c1       	rjmp	.+542    	; 0x43bc <f_open+0x7aa>
    419e:	76 01       	movw	r14, r12
    41a0:	ef e0       	ldi	r30, 0x0F	; 15
    41a2:	ee 22       	and	r14, r30
    41a4:	ff 24       	eor	r15, r15
    41a6:	e1 14       	cp	r14, r1
    41a8:	f1 04       	cpc	r15, r1
    41aa:	09 f0       	breq	.+2      	; 0x41ae <f_open+0x59c>
		return FR_NO_FILE;

	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
    41ac:	53 c0       	rjmp	.+166    	; 0x4254 <f_open+0x642>
    41ae:	01 96       	adiw	r24, 0x01	; 1
    41b0:	a1 1d       	adc	r26, r1
    41b2:	b1 1d       	adc	r27, r1
    41b4:	8f 87       	std	Y+15, r24	; 0x0f
    41b6:	98 8b       	std	Y+16, r25	; 0x10
    41b8:	a9 8b       	std	Y+17, r26	; 0x11
    41ba:	ba 8b       	std	Y+18, r27	; 0x12
		dj->sect++;					/* Next sector */
    41bc:	4b 85       	ldd	r20, Y+11	; 0x0b
    41be:	5c 85       	ldd	r21, Y+12	; 0x0c
    41c0:	6d 85       	ldd	r22, Y+13	; 0x0d
    41c2:	7e 85       	ldd	r23, Y+14	; 0x0e
    41c4:	89 81       	ldd	r24, Y+1	; 0x01
    41c6:	9a 81       	ldd	r25, Y+2	; 0x02
    41c8:	41 15       	cp	r20, r1

		if (dj->clust == 0) {	/* Static table */
    41ca:	51 05       	cpc	r21, r1
    41cc:	61 05       	cpc	r22, r1
    41ce:	71 05       	cpc	r23, r1
    41d0:	51 f4       	brne	.+20     	; 0x41e6 <f_open+0x5d4>
    41d2:	dc 01       	movw	r26, r24
    41d4:	18 96       	adiw	r26, 0x08	; 8
    41d6:	8d 91       	ld	r24, X+
    41d8:	9c 91       	ld	r25, X
    41da:	19 97       	sbiw	r26, 0x09	; 9
    41dc:	c8 16       	cp	r12, r24
    41de:	d9 06       	cpc	r13, r25
			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
    41e0:	08 f0       	brcs	.+2      	; 0x41e4 <f_open+0x5d2>
    41e2:	ec c0       	rjmp	.+472    	; 0x43bc <f_open+0x7aa>
    41e4:	37 c0       	rjmp	.+110    	; 0x4254 <f_open+0x642>
    41e6:	fc 01       	movw	r30, r24
    41e8:	22 81       	ldd	r18, Z+2	; 0x02
    41ea:	30 e0       	ldi	r19, 0x00	; 0
    41ec:	21 50       	subi	r18, 0x01	; 1
    41ee:	31 09       	sbc	r19, r1
    41f0:	f6 01       	movw	r30, r12
    41f2:	b4 e0       	ldi	r27, 0x04	; 4
				return FR_NO_FILE;
		}
		else {					/* Dynamic table */
			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
    41f4:	f6 95       	lsr	r31
    41f6:	e7 95       	ror	r30
    41f8:	ba 95       	dec	r27
    41fa:	e1 f7       	brne	.-8      	; 0x41f4 <f_open+0x5e2>
    41fc:	2e 23       	and	r18, r30
    41fe:	3f 23       	and	r19, r31
    4200:	23 2b       	or	r18, r19
    4202:	41 f5       	brne	.+80     	; 0x4254 <f_open+0x642>
    4204:	b7 db       	rcall	.-2194   	; 0x3974 <get_fat>
    4206:	ab 01       	movw	r20, r22
    4208:	bc 01       	movw	r22, r24
    420a:	42 30       	cpi	r20, 0x02	; 2
    420c:	51 05       	cpc	r21, r1
    420e:	61 05       	cpc	r22, r1
    4210:	71 05       	cpc	r23, r1
				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
    4212:	08 f4       	brcc	.+2      	; 0x4216 <f_open+0x604>
    4214:	d5 c0       	rjmp	.+426    	; 0x43c0 <f_open+0x7ae>
    4216:	4f 3f       	cpi	r20, 0xFF	; 255
    4218:	ff ef       	ldi	r31, 0xFF	; 255
				if (clst <= 1) return FR_INT_ERR;
    421a:	5f 07       	cpc	r21, r31
    421c:	6f 07       	cpc	r22, r31
    421e:	7f 07       	cpc	r23, r31
    4220:	09 f4       	brne	.+2      	; 0x4224 <f_open+0x612>
    4222:	d0 c0       	rjmp	.+416    	; 0x43c4 <f_open+0x7b2>
    4224:	89 81       	ldd	r24, Y+1	; 0x01
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    4226:	9a 81       	ldd	r25, Y+2	; 0x02
    4228:	dc 01       	movw	r26, r24
    422a:	1a 96       	adiw	r26, 0x0a	; 10
    422c:	8d 90       	ld	r8, X+
    422e:	9d 90       	ld	r9, X+
    4230:	ad 90       	ld	r10, X+
    4232:	bc 90       	ld	r11, X
				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
    4234:	1d 97       	sbiw	r26, 0x0d	; 13
    4236:	48 15       	cp	r20, r8
    4238:	59 05       	cpc	r21, r9
    423a:	6a 05       	cpc	r22, r10
    423c:	7b 05       	cpc	r23, r11
    423e:	08 f0       	brcs	.+2      	; 0x4242 <f_open+0x630>
    4240:	bd c0       	rjmp	.+378    	; 0x43bc <f_open+0x7aa>
    4242:	4b 87       	std	Y+11, r20	; 0x0b
    4244:	5c 87       	std	Y+12, r21	; 0x0c
    4246:	6d 87       	std	Y+13, r22	; 0x0d
    4248:	7e 87       	std	Y+14, r23	; 0x0e
    424a:	6b db       	rcall	.-2346   	; 0x3922 <clust2sect>
    424c:	6f 87       	std	Y+15, r22	; 0x0f
    424e:	78 8b       	std	Y+16, r23	; 0x10
    4250:	89 8b       	std	Y+17, r24	; 0x11
					dj->fs->winsect -= c;						/* Rewind window address */
#else
					return FR_NO_FILE;			/* Report EOT */
#endif
				}
				dj->clust = clst;				/* Initialize data for new cluster */
    4252:	9a 8b       	std	Y+18, r25	; 0x12
    4254:	de 82       	std	Y+6, r13	; 0x06
    4256:	cd 82       	std	Y+5, r12	; 0x05
    4258:	a5 e0       	ldi	r26, 0x05	; 5
				dj->sect = clust2sect(dj->fs, clst);
    425a:	ee 0c       	add	r14, r14
    425c:	ff 1c       	adc	r15, r15
    425e:	aa 95       	dec	r26
    4260:	e1 f7       	brne	.-8      	; 0x425a <f_open+0x648>
    4262:	b2 e2       	ldi	r27, 0x22	; 34
    4264:	eb 0e       	add	r14, r27
			}
		}
	}

	dj->index = i;
    4266:	f1 1c       	adc	r15, r1
    4268:	89 81       	ldd	r24, Y+1	; 0x01
	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
    426a:	9a 81       	ldd	r25, Y+2	; 0x02
    426c:	8e 0d       	add	r24, r14
    426e:	9f 1d       	adc	r25, r15
    4270:	9c 8b       	std	Y+20, r25	; 0x14
    4272:	8b 8b       	std	Y+19, r24	; 0x13
    4274:	64 cf       	rjmp	.-312    	; 0x413e <f_open+0x52c>
    4276:	80 e0       	ldi	r24, 0x00	; 0
    4278:	ed 89       	ldd	r30, Y+21	; 0x15
    427a:	fe 89       	ldd	r31, Y+22	; 0x16
    427c:	93 85       	ldd	r25, Z+11	; 0x0b
    427e:	88 23       	and	r24, r24
    4280:	29 f0       	breq	.+10     	; 0x428c <f_open+0x67a>
    4282:	84 30       	cpi	r24, 0x04	; 4
    4284:	49 f5       	brne	.+82     	; 0x42d8 <f_open+0x6c6>
    4286:	92 ff       	sbrs	r25, 2
static
int mem_cmp (const void* dst, const void* src, UINT cnt) {
	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
	int r = 0;

	while (cnt-- && (r = *d++ - *s++) == 0) ;
    4288:	24 c0       	rjmp	.+72     	; 0x42d2 <f_open+0x6c0>
	} else {							/* Follow path */
		for (;;) {
			res = create_name(dj, &path);	/* Get a segment */
			if (res != FR_OK) break;
			res = dir_find(dj);				/* Find it */
			ns = *(dj->fn+NS);
    428a:	26 c0       	rjmp	.+76     	; 0x42d8 <f_open+0x6c6>
    428c:	92 fd       	sbrc	r25, 2
    428e:	24 c0       	rjmp	.+72     	; 0x42d8 <f_open+0x6c6>
			if (res != FR_OK) {				/* Failed to find the object */
    4290:	4b 89       	ldd	r20, Y+19	; 0x13
    4292:	5c 89       	ldd	r21, Y+20	; 0x14
				if (res != FR_NO_FILE) break;	/* Abort if any hard error occurred */
    4294:	fa 01       	movw	r30, r20
    4296:	83 85       	ldd	r24, Z+11	; 0x0b
				if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exit */
					dj->sclust = 0; dj->dir = 0;	/* It is the root dir */
					res = FR_OK;
					if (!(ns & NS_LAST)) continue;
				} else {							/* Could not find the object */
					if (!(ns & NS_LAST)) res = FR_NO_PATH;
    4298:	84 ff       	sbrs	r24, 4
    429a:	1b c0       	rjmp	.+54     	; 0x42d2 <f_open+0x6c0>
    429c:	82 8d       	ldd	r24, Z+26	; 0x1a
				}
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
    429e:	93 8d       	ldd	r25, Z+27	; 0x1b
    42a0:	a0 e0       	ldi	r26, 0x00	; 0
			dir = dj->dir;						/* There is next segment. Follow the sub directory */
    42a2:	b0 e0       	ldi	r27, 0x00	; 0
    42a4:	29 81       	ldd	r18, Y+1	; 0x01
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
    42a6:	3a 81       	ldd	r19, Y+2	; 0x02
    42a8:	f9 01       	movw	r30, r18
    42aa:	20 81       	ld	r18, Z
    42ac:	23 30       	cpi	r18, 0x03	; 3
	BYTE *dir	/* Pointer to the directory entry */
)
{
	DWORD cl;

	cl = LD_WORD(dir+DIR_FstClusLO);
    42ae:	61 f4       	brne	.+24     	; 0x42c8 <f_open+0x6b6>
    42b0:	fa 01       	movw	r30, r20
    42b2:	44 89       	ldd	r20, Z+20	; 0x14
    42b4:	55 89       	ldd	r21, Z+21	; 0x15
			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
			dir = dj->dir;						/* There is next segment. Follow the sub directory */
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
				res = FR_NO_PATH; break;
			}
			dj->sclust = ld_clust(dj->fs, dir);
    42b6:	60 e0       	ldi	r22, 0x00	; 0
    42b8:	70 e0       	ldi	r23, 0x00	; 0
)
{
	DWORD cl;

	cl = LD_WORD(dir+DIR_FstClusLO);
	if (fs->fs_type == FS_FAT32)
    42ba:	ba 01       	movw	r22, r20
    42bc:	55 27       	eor	r21, r21
    42be:	44 27       	eor	r20, r20
    42c0:	84 2b       	or	r24, r20
		cl |= (DWORD)LD_WORD(dir+DIR_FstClusHI) << 16;
    42c2:	95 2b       	or	r25, r21
    42c4:	a6 2b       	or	r26, r22
    42c6:	b7 2b       	or	r27, r23
    42c8:	8f 83       	std	Y+7, r24	; 0x07
    42ca:	98 87       	std	Y+8, r25	; 0x08
    42cc:	a9 87       	std	Y+9, r26	; 0x09
    42ce:	ba 87       	std	Y+10, r27	; 0x0a
    42d0:	9d ce       	rjmp	.-710    	; 0x400c <f_open+0x3fa>
    42d2:	85 e0       	ldi	r24, 0x05	; 5
    42d4:	01 c0       	rjmp	.+2      	; 0x42d8 <f_open+0x6c6>
    42d6:	86 e0       	ldi	r24, 0x06	; 6
    42d8:	2b 89       	ldd	r18, Y+19	; 0x13
			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
			dir = dj->dir;						/* There is next segment. Follow the sub directory */
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
				res = FR_NO_PATH; break;
			}
			dj->sclust = ld_clust(dj->fs, dir);
    42da:	3c 89       	ldd	r19, Y+20	; 0x14
    42dc:	81 11       	cpse	r24, r1
    42de:	74 c0       	rjmp	.+232    	; 0x43c8 <f_open+0x7b6>
    42e0:	21 15       	cp	r18, r1
    42e2:	31 05       	cpc	r19, r1
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
			dir = dj->dir;						/* There is next segment. Follow the sub directory */
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
				res = FR_NO_PATH; break;
    42e4:	09 f4       	brne	.+2      	; 0x42e8 <f_open+0x6d6>
    42e6:	5b c0       	rjmp	.+182    	; 0x439e <f_open+0x78c>
#endif
	for (;;) {
		c = (BYTE)p[si++];
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
		if (c == '.' || i >= ni) {
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
    42e8:	d9 01       	movw	r26, r18
	res = chk_mounted(&path, &dj.fs, 0);
#endif
	if (res == FR_OK) {
		INIT_BUF(dj);
		res = follow_path(&dj, path);	/* Follow the file path */
		dir = dj.dir;
    42ea:	1b 96       	adiw	r26, 0x0b	; 11
    42ec:	8c 91       	ld	r24, X
			if (!fp->lockid) res = FR_INT_ERR;
#endif
		}

#else				/* R/O configuration */
		if (res == FR_OK) {					/* Follow succeeded */
    42ee:	84 fd       	sbrc	r24, 4
    42f0:	58 c0       	rjmp	.+176    	; 0x43a2 <f_open+0x790>
			dir = dj.dir;
			if (!dir) {						/* Current dir itself */
    42f2:	13 c0       	rjmp	.+38     	; 0x431a <f_open+0x708>
    42f4:	4f eb       	ldi	r20, 0xBF	; 191
    42f6:	40 0f       	add	r20, r16
    42f8:	4a 31       	cpi	r20, 0x1A	; 26
				res = FR_INVALID_NAME;
			} else {
				if (dir[DIR_Attr] & AM_DIR)	/* It is a directory */
    42fa:	10 f4       	brcc	.+4      	; 0x4300 <f_open+0x6ee>
    42fc:	12 60       	ori	r17, 0x02	; 2
    42fe:	06 c0       	rjmp	.+12     	; 0x430c <f_open+0x6fa>
    4300:	4f e9       	ldi	r20, 0x9F	; 159
    4302:	40 0f       	add	r20, r16
    4304:	4a 31       	cpi	r20, 0x1A	; 26
			sfn[i++] = c;
			sfn[i++] = d;
		} else {						/* Single byte code */
			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
				return FR_INVALID_NAME;
			if (IsUpper(c)) {			/* ASCII large capital? */
    4306:	10 f4       	brcc	.+4      	; 0x430c <f_open+0x6fa>
    4308:	11 60       	ori	r17, 0x01	; 1
    430a:	00 52       	subi	r16, 0x20	; 32
    430c:	af 01       	movw	r20, r30
				b |= 2;
    430e:	48 0f       	add	r20, r24
    4310:	59 1f       	adc	r21, r25
			} else {
				if (IsLower(c)) {		/* ASCII small capital? */
    4312:	da 01       	movw	r26, r20
    4314:	0c 93       	st	X, r16
    4316:	01 96       	adiw	r24, 0x01	; 1
    4318:	de ce       	rjmp	.-580    	; 0x40d6 <f_open+0x4c4>
					b |= 1; c -= 0x20;
    431a:	8b a9       	ldd	r24, Y+51	; 0x33
    431c:	81 70       	andi	r24, 0x01	; 1
				}
			}
			sfn[i++] = c;
    431e:	eb a1       	ldd	r30, Y+35	; 0x23
    4320:	fc a1       	ldd	r31, Y+36	; 0x24
    4322:	84 83       	std	Z+4, r24	; 0x04
    4324:	09 81       	ldd	r16, Y+1	; 0x01
    4326:	1a 81       	ldd	r17, Y+2	; 0x02
    4328:	d9 01       	movw	r26, r18
    432a:	5a 96       	adiw	r26, 0x1a	; 26

#if !_FS_READONLY
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & ~FA_READ));
#else
	mode &= FA_READ;
    432c:	8d 91       	ld	r24, X+
    432e:	9c 91       	ld	r25, X
		}
#endif
		FREE_BUF();

		if (res == FR_OK) {
			fp->flag = mode;					/* File access mode */
    4330:	5b 97       	sbiw	r26, 0x1b	; 27
    4332:	a0 e0       	ldi	r26, 0x00	; 0
    4334:	b0 e0       	ldi	r27, 0x00	; 0
			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
    4336:	f8 01       	movw	r30, r16
    4338:	40 81       	ld	r20, Z
	BYTE *dir	/* Pointer to the directory entry */
)
{
	DWORD cl;

	cl = LD_WORD(dir+DIR_FstClusLO);
    433a:	43 30       	cpi	r20, 0x03	; 3
    433c:	61 f4       	brne	.+24     	; 0x4356 <f_open+0x744>
    433e:	f9 01       	movw	r30, r18
    4340:	44 89       	ldd	r20, Z+20	; 0x14
    4342:	55 89       	ldd	r21, Z+21	; 0x15
    4344:	60 e0       	ldi	r22, 0x00	; 0
    4346:	70 e0       	ldi	r23, 0x00	; 0
	if (fs->fs_type == FS_FAT32)
    4348:	ba 01       	movw	r22, r20
    434a:	55 27       	eor	r21, r21
    434c:	44 27       	eor	r20, r20
    434e:	84 2b       	or	r24, r20
		cl |= (DWORD)LD_WORD(dir+DIR_FstClusHI) << 16;
    4350:	95 2b       	or	r25, r21
    4352:	a6 2b       	or	r26, r22
    4354:	b7 2b       	or	r27, r23
    4356:	eb a1       	ldd	r30, Y+35	; 0x23
    4358:	fc a1       	ldd	r31, Y+36	; 0x24
    435a:	86 87       	std	Z+14, r24	; 0x0e
    435c:	97 87       	std	Z+15, r25	; 0x0f
    435e:	a0 8b       	std	Z+16, r26	; 0x10
    4360:	b1 8b       	std	Z+17, r27	; 0x11
    4362:	f9 01       	movw	r30, r18
    4364:	84 8d       	ldd	r24, Z+28	; 0x1c
    4366:	95 8d       	ldd	r25, Z+29	; 0x1d
#endif
		FREE_BUF();

		if (res == FR_OK) {
			fp->flag = mode;					/* File access mode */
			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
    4368:	a6 8d       	ldd	r26, Z+30	; 0x1e
    436a:	b7 8d       	ldd	r27, Z+31	; 0x1f
    436c:	eb a1       	ldd	r30, Y+35	; 0x23
    436e:	fc a1       	ldd	r31, Y+36	; 0x24
    4370:	82 87       	std	Z+10, r24	; 0x0a
    4372:	93 87       	std	Z+11, r25	; 0x0b
			fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
    4374:	a4 87       	std	Z+12, r26	; 0x0c
    4376:	b5 87       	std	Z+13, r27	; 0x0d
    4378:	16 82       	std	Z+6, r1	; 0x06
    437a:	17 82       	std	Z+7, r1	; 0x07
    437c:	10 86       	std	Z+8, r1	; 0x08
    437e:	11 86       	std	Z+9, r1	; 0x09
    4380:	16 8a       	std	Z+22, r1	; 0x16
    4382:	17 8a       	std	Z+23, r1	; 0x17
    4384:	10 8e       	std	Z+24, r1	; 0x18
    4386:	11 8e       	std	Z+25, r1	; 0x19
    4388:	11 83       	std	Z+1, r17	; 0x01
			fp->fptr = 0;						/* File pointer */
    438a:	00 83       	st	Z, r16
    438c:	d8 01       	movw	r26, r16
    438e:	16 96       	adiw	r26, 0x06	; 6
    4390:	8d 91       	ld	r24, X+
			fp->dsect = 0;
    4392:	9c 91       	ld	r25, X
    4394:	17 97       	sbiw	r26, 0x07	; 7
    4396:	93 83       	std	Z+3, r25	; 0x03
    4398:	82 83       	std	Z+2, r24	; 0x02
#if _USE_FASTSEEK
			fp->cltbl = 0;						/* Normal seek mode */
#endif
			fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
    439a:	80 e0       	ldi	r24, 0x00	; 0
    439c:	15 c0       	rjmp	.+42     	; 0x43c8 <f_open+0x7b6>
    439e:	86 e0       	ldi	r24, 0x06	; 6
    43a0:	13 c0       	rjmp	.+38     	; 0x43c8 <f_open+0x7b6>
    43a2:	84 e0       	ldi	r24, 0x04	; 4
    43a4:	11 c0       	rjmp	.+34     	; 0x43c8 <f_open+0x7b6>
    43a6:	28 30       	cpi	r18, 0x08	; 8
    43a8:	31 05       	cpc	r19, r1
    43aa:	09 f0       	breq	.+2      	; 0x43ae <f_open+0x79c>
    43ac:	94 cf       	rjmp	.-216    	; 0x42d6 <f_open+0x6c4>
    43ae:	11 0f       	add	r17, r17

#else				/* R/O configuration */
		if (res == FR_OK) {					/* Follow succeeded */
			dir = dj.dir;
			if (!dir) {						/* Current dir itself */
				res = FR_INVALID_NAME;
    43b0:	11 0f       	add	r17, r17
    43b2:	88 e0       	ldi	r24, 0x08	; 8
			} else {
				if (dir[DIR_Attr] & AM_DIR)	/* It is a directory */
					res = FR_NO_FILE;
    43b4:	90 e0       	ldi	r25, 0x00	; 0
    43b6:	2b e0       	ldi	r18, 0x0B	; 11
#endif
	for (;;) {
		c = (BYTE)p[si++];
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
		if (c == '.' || i >= ni) {
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
    43b8:	30 e0       	ldi	r19, 0x00	; 0
    43ba:	8d ce       	rjmp	.-742    	; 0x40d6 <f_open+0x4c4>
    43bc:	84 e0       	ldi	r24, 0x04	; 4
    43be:	5c cf       	rjmp	.-328    	; 0x4278 <f_open+0x666>
			i = 8; ni = 11;
			b <<= 2; continue;
    43c0:	82 e0       	ldi	r24, 0x02	; 2
    43c2:	5a cf       	rjmp	.-332    	; 0x4278 <f_open+0x666>
	for (;;) {
		c = (BYTE)p[si++];
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
		if (c == '.' || i >= ni) {
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
			i = 8; ni = 11;
    43c4:	81 e0       	ldi	r24, 0x01	; 1
    43c6:	58 cf       	rjmp	.-336    	; 0x4278 <f_open+0x666>
    43c8:	e4 96       	adiw	r28, 0x34	; 52
    43ca:	0f b6       	in	r0, 0x3f	; 63
    43cc:	f8 94       	cli


	stretch = stretch;		/* To suppress warning on read-only cfg. */
	i = dj->index + 1;
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
		return FR_NO_FILE;
    43ce:	de bf       	out	0x3e, r29	; 62
    43d0:	0f be       	out	0x3f, r0	; 63
				return FR_NO_FILE;
		}
		else {					/* Dynamic table */
			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
				if (clst <= 1) return FR_INT_ERR;
    43d2:	cd bf       	out	0x3d, r28	; 61
    43d4:	df 91       	pop	r29
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    43d6:	cf 91       	pop	r28
    43d8:	1f 91       	pop	r17
			fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
		}
	}

	LEAVE_FF(dj.fs, res);
}
    43da:	0f 91       	pop	r16
    43dc:	ff 90       	pop	r15
    43de:	ef 90       	pop	r14
    43e0:	df 90       	pop	r13
    43e2:	cf 90       	pop	r12
    43e4:	bf 90       	pop	r11
    43e6:	af 90       	pop	r10
    43e8:	9f 90       	pop	r9
    43ea:	8f 90       	pop	r8
    43ec:	7f 90       	pop	r7
    43ee:	6f 90       	pop	r6
    43f0:	5f 90       	pop	r5
    43f2:	4f 90       	pop	r4
    43f4:	3f 90       	pop	r3
    43f6:	2f 90       	pop	r2
    43f8:	08 95       	ret

000043fa <f_read>:
    43fa:	4f 92       	push	r4
    43fc:	5f 92       	push	r5
    43fe:	6f 92       	push	r6
    4400:	7f 92       	push	r7
    4402:	8f 92       	push	r8
    4404:	9f 92       	push	r9
    4406:	af 92       	push	r10
    4408:	bf 92       	push	r11
    440a:	cf 92       	push	r12
	FIL *fp, 		/* Pointer to the file object */
	void *buff,		/* Pointer to data buffer */
	UINT btr,		/* Number of bytes to read */
	UINT *br		/* Pointer to number of bytes read */
)
{
    440c:	df 92       	push	r13
    440e:	ef 92       	push	r14
    4410:	ff 92       	push	r15
    4412:	0f 93       	push	r16
    4414:	1f 93       	push	r17
    4416:	cf 93       	push	r28
    4418:	df 93       	push	r29
    441a:	ec 01       	movw	r28, r24
    441c:	6b 01       	movw	r12, r22
    441e:	7a 01       	movw	r14, r20
    4420:	59 01       	movw	r10, r18
	DWORD clst, sect, remain;
	UINT rcnt, cc;
	BYTE csect, *rbuff = buff;


	*br = 0;	/* Clear read byte counter */
    4422:	f9 01       	movw	r30, r18
    4424:	11 82       	std	Z+1, r1	; 0x01
    4426:	10 82       	st	Z, r1

	res = validate(fp);							/* Check validity */
    4428:	60 da       	rcall	.-2880   	; 0x38ea <validate>
    442a:	81 11       	cpse	r24, r1
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
    442c:	fc c0       	rjmp	.+504    	; 0x4626 <f_read+0x22c>
    442e:	8c 81       	ldd	r24, Y+4	; 0x04
	if (fp->flag & FA__ERROR)					/* Aborted file? */
    4430:	87 fd       	sbrc	r24, 7
    4432:	f6 c0       	rjmp	.+492    	; 0x4620 <f_read+0x226>
    4434:	80 ff       	sbrs	r24, 0
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
    4436:	f6 c0       	rjmp	.+492    	; 0x4624 <f_read+0x22a>
    4438:	8a 85       	ldd	r24, Y+10	; 0x0a
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
    443a:	9b 85       	ldd	r25, Y+11	; 0x0b
    443c:	ac 85       	ldd	r26, Y+12	; 0x0c
    443e:	bd 85       	ldd	r27, Y+13	; 0x0d
    4440:	4e 81       	ldd	r20, Y+6	; 0x06
    4442:	5f 81       	ldd	r21, Y+7	; 0x07
    4444:	68 85       	ldd	r22, Y+8	; 0x08
    4446:	79 85       	ldd	r23, Y+9	; 0x09
    4448:	84 1b       	sub	r24, r20
    444a:	95 0b       	sbc	r25, r21
    444c:	a6 0b       	sbc	r26, r22
    444e:	b7 0b       	sbc	r27, r23
    4450:	a7 01       	movw	r20, r14
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */
    4452:	60 e0       	ldi	r22, 0x00	; 0
    4454:	70 e0       	ldi	r23, 0x00	; 0
    4456:	84 17       	cp	r24, r20
    4458:	95 07       	cpc	r25, r21
    445a:	a6 07       	cpc	r26, r22
    445c:	b7 07       	cpc	r27, r23
    445e:	08 f4       	brcc	.+2      	; 0x4462 <f_read+0x68>
    4460:	7c 01       	movw	r14, r24
    4462:	41 2c       	mov	r4, r1
					ABORT(fp->fs, FR_DISK_ERR);
			}
#endif
			fp->dsect = sect;
		}
		rcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
    4464:	82 e0       	ldi	r24, 0x02	; 2
    4466:	58 2e       	mov	r5, r24
    4468:	e1 14       	cp	r14, r1
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
    446a:	f1 04       	cpc	r15, r1
    446c:	09 f4       	brne	.+2      	; 0x4470 <f_read+0x76>
    446e:	d6 c0       	rjmp	.+428    	; 0x461c <f_read+0x222>
    4470:	4e 81       	ldd	r20, Y+6	; 0x06
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
    4472:	5f 81       	ldd	r21, Y+7	; 0x07
    4474:	68 85       	ldd	r22, Y+8	; 0x08
    4476:	79 85       	ldd	r23, Y+9	; 0x09
    4478:	db 01       	movw	r26, r22
    447a:	ca 01       	movw	r24, r20
    447c:	91 70       	andi	r25, 0x01	; 1
    447e:	aa 27       	eor	r26, r26
    4480:	bb 27       	eor	r27, r27
    4482:	89 2b       	or	r24, r25
    4484:	8a 2b       	or	r24, r26
    4486:	8b 2b       	or	r24, r27
    4488:	09 f0       	breq	.+2      	; 0x448c <f_read+0x92>
    448a:	6a c0       	rjmp	.+212    	; 0x4560 <f_read+0x166>
    448c:	88 81       	ld	r24, Y
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
    448e:	99 81       	ldd	r25, Y+1	; 0x01
    4490:	fc 01       	movw	r30, r24
    4492:	12 81       	ldd	r17, Z+2	; 0x02
    4494:	11 50       	subi	r17, 0x01	; 1
    4496:	3a 01       	movw	r6, r20
    4498:	4b 01       	movw	r8, r22
    449a:	09 e0       	ldi	r16, 0x09	; 9
    449c:	96 94       	lsr	r9
    449e:	87 94       	ror	r8
    44a0:	77 94       	ror	r7
    44a2:	67 94       	ror	r6
    44a4:	0a 95       	dec	r16
    44a6:	d1 f7       	brne	.-12     	; 0x449c <f_read+0xa2>
    44a8:	16 21       	and	r17, r6
    44aa:	f1 f4       	brne	.+60     	; 0x44e8 <f_read+0xee>
			if (!csect) {						/* On the cluster boundary? */
    44ac:	45 2b       	or	r20, r21
				if (fp->fptr == 0) {			/* On the top of the file? */
    44ae:	46 2b       	or	r20, r22
    44b0:	47 2b       	or	r20, r23
    44b2:	29 f4       	brne	.+10     	; 0x44be <f_read+0xc4>
    44b4:	6e 85       	ldd	r22, Y+14	; 0x0e
					clst = fp->sclust;			/* Follow from the origin */
    44b6:	7f 85       	ldd	r23, Y+15	; 0x0f
    44b8:	88 89       	ldd	r24, Y+16	; 0x10
    44ba:	99 89       	ldd	r25, Y+17	; 0x11
    44bc:	05 c0       	rjmp	.+10     	; 0x44c8 <f_read+0xce>
    44be:	4a 89       	ldd	r20, Y+18	; 0x12
#if _USE_FASTSEEK
					if (fp->cltbl)
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
					else
#endif
						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
    44c0:	5b 89       	ldd	r21, Y+19	; 0x13
    44c2:	6c 89       	ldd	r22, Y+20	; 0x14
    44c4:	7d 89       	ldd	r23, Y+21	; 0x15
    44c6:	56 da       	rcall	.-2900   	; 0x3974 <get_fat>
    44c8:	62 30       	cpi	r22, 0x02	; 2
    44ca:	71 05       	cpc	r23, r1
				}
				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
    44cc:	81 05       	cpc	r24, r1
    44ce:	91 05       	cpc	r25, r1
    44d0:	c0 f0       	brcs	.+48     	; 0x4502 <f_read+0x108>
    44d2:	6f 3f       	cpi	r22, 0xFF	; 255
    44d4:	ff ef       	ldi	r31, 0xFF	; 255
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    44d6:	7f 07       	cpc	r23, r31
    44d8:	8f 07       	cpc	r24, r31
    44da:	9f 07       	cpc	r25, r31
    44dc:	09 f4       	brne	.+2      	; 0x44e0 <f_read+0xe6>
    44de:	54 c0       	rjmp	.+168    	; 0x4588 <f_read+0x18e>
    44e0:	6a 8b       	std	Y+18, r22	; 0x12
    44e2:	7b 8b       	std	Y+19, r23	; 0x13
				fp->clust = clst;				/* Update current cluster */
    44e4:	8c 8b       	std	Y+20, r24	; 0x14
    44e6:	9d 8b       	std	Y+21, r25	; 0x15
    44e8:	68 80       	ld	r6, Y
    44ea:	79 80       	ldd	r7, Y+1	; 0x01
			}
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
    44ec:	4a 89       	ldd	r20, Y+18	; 0x12
    44ee:	5b 89       	ldd	r21, Y+19	; 0x13
    44f0:	6c 89       	ldd	r22, Y+20	; 0x14
    44f2:	7d 89       	ldd	r23, Y+21	; 0x15
    44f4:	c3 01       	movw	r24, r6
    44f6:	15 da       	rcall	.-3030   	; 0x3922 <clust2sect>
    44f8:	61 15       	cp	r22, r1
    44fa:	71 05       	cpc	r23, r1
    44fc:	81 05       	cpc	r24, r1
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
    44fe:	91 05       	cpc	r25, r1
    4500:	21 f4       	brne	.+8      	; 0x450a <f_read+0x110>
    4502:	8c 81       	ldd	r24, Y+4	; 0x04
    4504:	80 68       	ori	r24, 0x80	; 128
    4506:	8c 83       	std	Y+4, r24	; 0x04
    4508:	8b c0       	rjmp	.+278    	; 0x4620 <f_read+0x226>
    450a:	9b 01       	movw	r18, r22
    450c:	ac 01       	movw	r20, r24
    450e:	21 0f       	add	r18, r17
			sect += csect;
    4510:	31 1d       	adc	r19, r1
    4512:	41 1d       	adc	r20, r1
    4514:	51 1d       	adc	r21, r1
    4516:	47 01       	movw	r8, r14
    4518:	89 2c       	mov	r8, r9
    451a:	99 24       	eor	r9, r9
			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
    451c:	86 94       	lsr	r8
    451e:	81 14       	cp	r8, r1
    4520:	91 04       	cpc	r9, r1
    4522:	d1 f0       	breq	.+52     	; 0x4558 <f_read+0x15e>
			if (cc) {							/* Read maximum contiguous sectors directly */
    4524:	f3 01       	movw	r30, r6
    4526:	82 81       	ldd	r24, Z+2	; 0x02
    4528:	61 2f       	mov	r22, r17
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
    452a:	70 e0       	ldi	r23, 0x00	; 0
    452c:	f4 01       	movw	r30, r8
    452e:	e6 0f       	add	r30, r22
    4530:	f7 1f       	adc	r31, r23
    4532:	90 e0       	ldi	r25, 0x00	; 0
    4534:	8e 17       	cp	r24, r30
    4536:	9f 07       	cpc	r25, r31
    4538:	18 f4       	brcc	.+6      	; 0x4540 <f_read+0x146>
    453a:	4c 01       	movw	r8, r24
    453c:	86 1a       	sub	r8, r22
    453e:	97 0a       	sbc	r9, r23
					cc = fp->fs->csize - csect;
    4540:	08 2d       	mov	r16, r8
    4542:	b6 01       	movw	r22, r12
    4544:	f3 01       	movw	r30, r6
				if (disk_read(fp->fs->drv, rbuff, sect, (BYTE)cc) != RES_OK)
    4546:	81 81       	ldd	r24, Z+1	; 0x01
    4548:	59 d9       	rcall	.-3406   	; 0x37fc <disk_read>
    454a:	81 11       	cpse	r24, r1
    454c:	1d c0       	rjmp	.+58     	; 0x4588 <f_read+0x18e>
    454e:	84 01       	movw	r16, r8
    4550:	10 2f       	mov	r17, r16
    4552:	00 27       	eor	r16, r16
    4554:	11 0f       	add	r17, r17
#else
				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
#endif
#endif
				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
    4556:	4a c0       	rjmp	.+148    	; 0x45ec <f_read+0x1f2>
    4558:	2e 8b       	std	Y+22, r18	; 0x16
    455a:	3f 8b       	std	Y+23, r19	; 0x17
    455c:	48 8f       	std	Y+24, r20	; 0x18
				continue;
    455e:	59 8f       	std	Y+25, r21	; 0x19
#endif
				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
					ABORT(fp->fs, FR_DISK_ERR);
			}
#endif
			fp->dsect = sect;
    4560:	8e 81       	ldd	r24, Y+6	; 0x06
    4562:	9f 81       	ldd	r25, Y+7	; 0x07
    4564:	91 70       	andi	r25, 0x01	; 1
    4566:	92 01       	movw	r18, r4
		}
		rcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
    4568:	28 1b       	sub	r18, r24
    456a:	39 0b       	sbc	r19, r25
    456c:	87 01       	movw	r16, r14
    456e:	2e 15       	cp	r18, r14
    4570:	3f 05       	cpc	r19, r15
    4572:	08 f4       	brcc	.+2      	; 0x4576 <f_read+0x17c>
    4574:	89 01       	movw	r16, r18
    4576:	4e 89       	ldd	r20, Y+22	; 0x16
    4578:	5f 89       	ldd	r21, Y+23	; 0x17
    457a:	68 8d       	ldd	r22, Y+24	; 0x18
    457c:	79 8d       	ldd	r23, Y+25	; 0x19
		if (rcnt > btr) rcnt = btr;
#if _FS_TINY
		if (move_window(fp->fs, fp->dsect))		/* Move sector window */
    457e:	88 81       	ld	r24, Y
    4580:	99 81       	ldd	r25, Y+1	; 0x01
    4582:	48 d9       	rcall	.-3440   	; 0x3814 <move_window>
    4584:	88 23       	and	r24, r24
    4586:	29 f0       	breq	.+10     	; 0x4592 <f_read+0x198>
    4588:	8c 81       	ldd	r24, Y+4	; 0x04
    458a:	80 68       	ori	r24, 0x80	; 128
    458c:	8c 83       	std	Y+4, r24	; 0x04
    458e:	81 e0       	ldi	r24, 0x01	; 1
    4590:	4a c0       	rjmp	.+148    	; 0x4626 <f_read+0x22c>
			ABORT(fp->fs, FR_DISK_ERR);
    4592:	8e 81       	ldd	r24, Y+6	; 0x06
    4594:	9f 81       	ldd	r25, Y+7	; 0x07
    4596:	a8 85       	ldd	r26, Y+8	; 0x08
    4598:	b9 85       	ldd	r27, Y+9	; 0x09
    459a:	91 70       	andi	r25, 0x01	; 1
		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
    459c:	aa 27       	eor	r26, r26
    459e:	bb 27       	eor	r27, r27
    45a0:	9c 01       	movw	r18, r24
    45a2:	2e 5d       	subi	r18, 0xDE	; 222
    45a4:	3f 4f       	sbci	r19, 0xFF	; 255
    45a6:	88 81       	ld	r24, Y
    45a8:	99 81       	ldd	r25, Y+1	; 0x01
    45aa:	82 0f       	add	r24, r18
    45ac:	93 1f       	adc	r25, r19
    45ae:	dc 01       	movw	r26, r24
    45b0:	f6 01       	movw	r30, r12
    45b2:	98 01       	movw	r18, r16
    45b4:	22 30       	cpi	r18, 0x02	; 2
    45b6:	31 05       	cpc	r19, r1
    45b8:	38 f0       	brcs	.+14     	; 0x45c8 <f_read+0x1ce>
/*-----------------------------------------------------------------------*/

/* Copy memory to memory */
static
void mem_cpy (void* dst, const void* src, UINT cnt) {
	BYTE *d = (BYTE*)dst;
    45ba:	4d 91       	ld	r20, X+
		rcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
		if (rcnt > btr) rcnt = btr;
#if _FS_TINY
		if (move_window(fp->fs, fp->dsect))		/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
    45bc:	5d 91       	ld	r21, X+
void mem_cpy (void* dst, const void* src, UINT cnt) {
	BYTE *d = (BYTE*)dst;
	const BYTE *s = (const BYTE*)src;

#if _WORD_ACCESS == 1
	while (cnt >= sizeof (int)) {
    45be:	41 93       	st	Z+, r20
    45c0:	51 93       	st	Z+, r21
    45c2:	22 50       	subi	r18, 0x02	; 2
		*(int*)d = *(int*)s;
    45c4:	31 09       	sbc	r19, r1
    45c6:	f6 cf       	rjmp	.-20     	; 0x45b4 <f_read+0x1ba>
    45c8:	d8 01       	movw	r26, r16
    45ca:	ae 7f       	andi	r26, 0xFE	; 254
		d += sizeof (int); s += sizeof (int);
		cnt -= sizeof (int);
    45cc:	fc 01       	movw	r30, r24
    45ce:	ea 0f       	add	r30, r26
    45d0:	fb 1f       	adc	r31, r27
    45d2:	ac 0d       	add	r26, r12
    45d4:	bd 1d       	adc	r27, r13
    45d6:	c8 01       	movw	r24, r16
    45d8:	81 70       	andi	r24, 0x01	; 1
    45da:	99 27       	eor	r25, r25
    45dc:	8e 0f       	add	r24, r30
    45de:	9f 1f       	adc	r25, r31
    45e0:	e8 17       	cp	r30, r24
    45e2:	f9 07       	cpc	r31, r25
    45e4:	19 f0       	breq	.+6      	; 0x45ec <f_read+0x1f2>
    45e6:	21 91       	ld	r18, Z+
    45e8:	2d 93       	st	X+, r18
	}
#endif
	while (cnt--)
    45ea:	fa cf       	rjmp	.-12     	; 0x45e0 <f_read+0x1e6>
    45ec:	c0 0e       	add	r12, r16
    45ee:	d1 1e       	adc	r13, r17
		*d++ = *s++;
    45f0:	8e 81       	ldd	r24, Y+6	; 0x06
    45f2:	9f 81       	ldd	r25, Y+7	; 0x07
    45f4:	a8 85       	ldd	r26, Y+8	; 0x08
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
    45f6:	b9 85       	ldd	r27, Y+9	; 0x09
    45f8:	80 0f       	add	r24, r16
    45fa:	91 1f       	adc	r25, r17
    45fc:	a1 1d       	adc	r26, r1
    45fe:	b1 1d       	adc	r27, r1
    4600:	8e 83       	std	Y+6, r24	; 0x06
    4602:	9f 83       	std	Y+7, r25	; 0x07
    4604:	a8 87       	std	Y+8, r26	; 0x08
    4606:	b9 87       	std	Y+9, r27	; 0x09
    4608:	f5 01       	movw	r30, r10
    460a:	80 81       	ld	r24, Z
    460c:	91 81       	ldd	r25, Z+1	; 0x01
    460e:	80 0f       	add	r24, r16
    4610:	91 1f       	adc	r25, r17
    4612:	91 83       	std	Z+1, r25	; 0x01
    4614:	80 83       	st	Z, r24
    4616:	e0 1a       	sub	r14, r16
    4618:	f1 0a       	sbc	r15, r17
    461a:	26 cf       	rjmp	.-436    	; 0x4468 <f_read+0x6e>
    461c:	80 e0       	ldi	r24, 0x00	; 0
    461e:	03 c0       	rjmp	.+6      	; 0x4626 <f_read+0x22c>
    4620:	82 e0       	ldi	r24, 0x02	; 2
    4622:	01 c0       	rjmp	.+2      	; 0x4626 <f_read+0x22c>
    4624:	87 e0       	ldi	r24, 0x07	; 7
#else
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#endif
	}

	LEAVE_FF(fp->fs, FR_OK);
    4626:	df 91       	pop	r29
    4628:	cf 91       	pop	r28
	*br = 0;	/* Clear read byte counter */

	res = validate(fp);							/* Check validity */
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->flag & FA__ERROR)					/* Aborted file? */
		LEAVE_FF(fp->fs, FR_INT_ERR);
    462a:	1f 91       	pop	r17
    462c:	0f 91       	pop	r16
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
    462e:	ff 90       	pop	r15
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#endif
	}

	LEAVE_FF(fp->fs, FR_OK);
}
    4630:	ef 90       	pop	r14
    4632:	df 90       	pop	r13
    4634:	cf 90       	pop	r12
    4636:	bf 90       	pop	r11
    4638:	af 90       	pop	r10
    463a:	9f 90       	pop	r9
    463c:	8f 90       	pop	r8
    463e:	7f 90       	pop	r7
    4640:	6f 90       	pop	r6
    4642:	5f 90       	pop	r5
    4644:	4f 90       	pop	r4
    4646:	08 95       	ret

00004648 <f_close>:
    4648:	cf 93       	push	r28
    464a:	df 93       	push	r29
    464c:	ec 01       	movw	r28, r24
    464e:	4d d9       	rcall	.-3430   	; 0x38ea <validate>
    4650:	81 11       	cpse	r24, r1
	res = validate(fp);
	{
#if _FS_REENTRANT
		FATFS *fs = fp->fs;
#endif
		if (res == FR_OK) fp->fs = 0;	/* Discard file object */
    4652:	02 c0       	rjmp	.+4      	; 0x4658 <f_close+0x10>
    4654:	19 82       	std	Y+1, r1	; 0x01
    4656:	18 82       	st	Y, r1
    4658:	df 91       	pop	r29
	}
#endif
	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
	return res;
#endif
}
    465a:	cf 91       	pop	r28
    465c:	08 95       	ret

0000465e <f_lseek>:
    465e:	2f 92       	push	r2

FRESULT f_lseek (
	FIL *fp,		/* Pointer to the file object */
	DWORD ofs		/* File pointer from top of file */
)
{
    4660:	3f 92       	push	r3
    4662:	4f 92       	push	r4
    4664:	5f 92       	push	r5
    4666:	6f 92       	push	r6
    4668:	7f 92       	push	r7
    466a:	8f 92       	push	r8
    466c:	9f 92       	push	r9
    466e:	af 92       	push	r10
    4670:	bf 92       	push	r11
    4672:	cf 92       	push	r12
    4674:	df 92       	push	r13
    4676:	ef 92       	push	r14
    4678:	ff 92       	push	r15
    467a:	0f 93       	push	r16
    467c:	1f 93       	push	r17
    467e:	cf 93       	push	r28
    4680:	df 93       	push	r29
    4682:	cd b7       	in	r28, 0x3d	; 61
    4684:	de b7       	in	r29, 0x3e	; 62
    4686:	28 97       	sbiw	r28, 0x08	; 8
    4688:	0f b6       	in	r0, 0x3f	; 63
    468a:	f8 94       	cli
    468c:	de bf       	out	0x3e, r29	; 62
    468e:	0f be       	out	0x3f, r0	; 63
    4690:	cd bf       	out	0x3d, r28	; 61
    4692:	1c 01       	movw	r2, r24
	FRESULT res;


	res = validate(fp);					/* Check validity of the object */
    4694:	4d 83       	std	Y+5, r20	; 0x05
    4696:	5e 83       	std	Y+6, r21	; 0x06
    4698:	6f 83       	std	Y+7, r22	; 0x07
    469a:	78 87       	std	Y+8, r23	; 0x08
    469c:	26 d9       	rcall	.-3508   	; 0x38ea <validate>
    469e:	4d 81       	ldd	r20, Y+5	; 0x05
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
    46a0:	5e 81       	ldd	r21, Y+6	; 0x06
    46a2:	6f 81       	ldd	r22, Y+7	; 0x07
    46a4:	78 85       	ldd	r23, Y+8	; 0x08
    46a6:	81 11       	cpse	r24, r1
    46a8:	27 c1       	rjmp	.+590    	; 0x48f8 <f_lseek+0x29a>
    46aa:	d1 01       	movw	r26, r2
	if (fp->flag & FA__ERROR)			/* Check abort flag */
    46ac:	14 96       	adiw	r26, 0x04	; 4
    46ae:	8c 91       	ld	r24, X
    46b0:	14 97       	sbiw	r26, 0x04	; 4
    46b2:	87 fd       	sbrc	r24, 7
    46b4:	1e c1       	rjmp	.+572    	; 0x48f2 <f_lseek+0x294>
    46b6:	1a 96       	adiw	r26, 0x0a	; 10

	/* Normal Seek */
	{
		DWORD clst, bcs, nsect, ifptr;

		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
    46b8:	0d 91       	ld	r16, X+
    46ba:	1d 91       	ld	r17, X+
    46bc:	2d 91       	ld	r18, X+
    46be:	3c 91       	ld	r19, X
    46c0:	1d 97       	sbiw	r26, 0x0d	; 13
    46c2:	6a 01       	movw	r12, r20
    46c4:	7b 01       	movw	r14, r22
    46c6:	0c 15       	cp	r16, r12
    46c8:	1d 05       	cpc	r17, r13
    46ca:	2e 05       	cpc	r18, r14
    46cc:	3f 05       	cpc	r19, r15
    46ce:	10 f4       	brcc	.+4      	; 0x46d4 <f_lseek+0x76>
    46d0:	68 01       	movw	r12, r16
    46d2:	79 01       	movw	r14, r18
    46d4:	f1 01       	movw	r30, r2
#if !_FS_READONLY
			 && !(fp->flag & FA_WRITE)
#endif
			) ofs = fp->fsize;

		ifptr = fp->fptr;
    46d6:	46 80       	ldd	r4, Z+6	; 0x06
    46d8:	57 80       	ldd	r5, Z+7	; 0x07
    46da:	60 84       	ldd	r6, Z+8	; 0x08
    46dc:	71 84       	ldd	r7, Z+9	; 0x09
    46de:	16 82       	std	Z+6, r1	; 0x06
		fp->fptr = nsect = 0;
    46e0:	17 82       	std	Z+7, r1	; 0x07
    46e2:	10 86       	std	Z+8, r1	; 0x08
    46e4:	11 86       	std	Z+9, r1	; 0x09
    46e6:	c1 14       	cp	r12, r1
		if (ofs) {
    46e8:	d1 04       	cpc	r13, r1
    46ea:	e1 04       	cpc	r14, r1
    46ec:	f1 04       	cpc	r15, r1
    46ee:	21 f4       	brne	.+8      	; 0x46f8 <f_lseek+0x9a>
    46f0:	c1 2c       	mov	r12, r1
			 && !(fp->flag & FA_WRITE)
#endif
			) ofs = fp->fsize;

		ifptr = fp->fptr;
		fp->fptr = nsect = 0;
    46f2:	d1 2c       	mov	r13, r1
    46f4:	76 01       	movw	r14, r12
    46f6:	e3 c0       	rjmp	.+454    	; 0x48be <f_lseek+0x260>
    46f8:	01 90       	ld	r0, Z+
		if (ofs) {
			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
    46fa:	f0 81       	ld	r31, Z
    46fc:	e0 2d       	mov	r30, r0
    46fe:	82 80       	ldd	r8, Z+2	; 0x02
    4700:	91 2c       	mov	r9, r1
    4702:	a1 2c       	mov	r10, r1
    4704:	b1 2c       	mov	r11, r1
    4706:	39 e0       	ldi	r19, 0x09	; 9
    4708:	88 0c       	add	r8, r8
    470a:	99 1c       	adc	r9, r9
    470c:	aa 1c       	adc	r10, r10
    470e:	bb 1c       	adc	r11, r11
    4710:	3a 95       	dec	r19
    4712:	d1 f7       	brne	.-12     	; 0x4708 <f_lseek+0xaa>
    4714:	41 14       	cp	r4, r1
			if (ifptr > 0 &&
    4716:	51 04       	cpc	r5, r1
    4718:	61 04       	cpc	r6, r1
    471a:	71 04       	cpc	r7, r1
    471c:	09 f4       	brne	.+2      	; 0x4720 <f_lseek+0xc2>
    471e:	3f c0       	rjmp	.+126    	; 0x479e <f_lseek+0x140>
    4720:	b1 e0       	ldi	r27, 0x01	; 1
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
    4722:	4b 1a       	sub	r4, r27
    4724:	51 08       	sbc	r5, r1
    4726:	61 08       	sbc	r6, r1
    4728:	71 08       	sbc	r7, r1
    472a:	c7 01       	movw	r24, r14
    472c:	b6 01       	movw	r22, r12
    472e:	61 50       	subi	r22, 0x01	; 1
    4730:	71 09       	sbc	r23, r1
    4732:	81 09       	sbc	r24, r1
    4734:	91 09       	sbc	r25, r1
    4736:	a5 01       	movw	r20, r10
    4738:	94 01       	movw	r18, r8
    473a:	0e 94 3f 3a 	call	0x747e	; 0x747e <__udivmodsi4>
    473e:	29 83       	std	Y+1, r18	; 0x01
    4740:	3a 83       	std	Y+2, r19	; 0x02
    4742:	4b 83       	std	Y+3, r20	; 0x03
    4744:	5c 83       	std	Y+4, r21	; 0x04
    4746:	c3 01       	movw	r24, r6
    4748:	b2 01       	movw	r22, r4
    474a:	a5 01       	movw	r20, r10
    474c:	94 01       	movw	r18, r8
    474e:	0e 94 3f 3a 	call	0x747e	; 0x747e <__udivmodsi4>
    4752:	89 81       	ldd	r24, Y+1	; 0x01

		ifptr = fp->fptr;
		fp->fptr = nsect = 0;
		if (ofs) {
			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
			if (ifptr > 0 &&
    4754:	9a 81       	ldd	r25, Y+2	; 0x02
    4756:	ab 81       	ldd	r26, Y+3	; 0x03
    4758:	bc 81       	ldd	r27, Y+4	; 0x04
    475a:	82 17       	cp	r24, r18
    475c:	93 07       	cpc	r25, r19
    475e:	a4 07       	cpc	r26, r20
    4760:	b5 07       	cpc	r27, r21
    4762:	e8 f0       	brcs	.+58     	; 0x479e <f_lseek+0x140>
    4764:	44 27       	eor	r20, r20
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
    4766:	55 27       	eor	r21, r21
    4768:	ba 01       	movw	r22, r20
    476a:	48 19       	sub	r20, r8
    476c:	59 09       	sbc	r21, r9
    476e:	6a 09       	sbc	r22, r10
    4770:	7b 09       	sbc	r23, r11
    4772:	44 21       	and	r20, r4
    4774:	55 21       	and	r21, r5
    4776:	66 21       	and	r22, r6
    4778:	77 21       	and	r23, r7
    477a:	d1 01       	movw	r26, r2
    477c:	16 96       	adiw	r26, 0x06	; 6
    477e:	4d 93       	st	X+, r20
    4780:	5d 93       	st	X+, r21
    4782:	6d 93       	st	X+, r22
    4784:	7c 93       	st	X, r23
    4786:	19 97       	sbiw	r26, 0x09	; 9
    4788:	c4 1a       	sub	r12, r20
				ofs -= fp->fptr;
    478a:	d5 0a       	sbc	r13, r21
    478c:	e6 0a       	sbc	r14, r22
    478e:	f7 0a       	sbc	r15, r23
    4790:	52 96       	adiw	r26, 0x12	; 18
				clst = fp->clust;
    4792:	4d 91       	ld	r20, X+
    4794:	5d 91       	ld	r21, X+
    4796:	6d 91       	ld	r22, X+
    4798:	7c 91       	ld	r23, X
    479a:	55 97       	sbiw	r26, 0x15	; 21
    479c:	09 c0       	rjmp	.+18     	; 0x47b0 <f_lseek+0x152>
    479e:	f1 01       	movw	r30, r2
			} else {									/* When seek to back cluster, */
				clst = fp->sclust;						/* start from the first cluster */
    47a0:	46 85       	ldd	r20, Z+14	; 0x0e
    47a2:	57 85       	ldd	r21, Z+15	; 0x0f
    47a4:	60 89       	ldd	r22, Z+16	; 0x10
    47a6:	71 89       	ldd	r23, Z+17	; 0x11
    47a8:	42 8b       	std	Z+18, r20	; 0x12
					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
					fp->sclust = clst;
				}
#endif
				fp->clust = clst;
    47aa:	53 8b       	std	Z+19, r21	; 0x13
    47ac:	64 8b       	std	Z+20, r22	; 0x14
    47ae:	75 8b       	std	Z+21, r23	; 0x15
    47b0:	41 15       	cp	r20, r1
			}
			if (clst != 0) {
    47b2:	51 05       	cpc	r21, r1
    47b4:	61 05       	cpc	r22, r1
    47b6:	71 05       	cpc	r23, r1
    47b8:	09 f4       	brne	.+2      	; 0x47bc <f_lseek+0x15e>
    47ba:	9a cf       	rjmp	.-204    	; 0x46f0 <f_lseek+0x92>
    47bc:	8c 14       	cp	r8, r12
				while (ofs > bcs) {						/* Cluster following loop */
    47be:	9d 04       	cpc	r9, r13
    47c0:	ae 04       	cpc	r10, r14
    47c2:	bf 04       	cpc	r11, r15
    47c4:	08 f0       	brcs	.+2      	; 0x47c8 <f_lseek+0x16a>
    47c6:	46 c0       	rjmp	.+140    	; 0x4854 <f_lseek+0x1f6>
    47c8:	f1 01       	movw	r30, r2
						if (clst == 0) {				/* When disk gets full, clip file size */
							ofs = bcs; break;
						}
					} else
#endif
						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
    47ca:	80 81       	ld	r24, Z
    47cc:	91 81       	ldd	r25, Z+1	; 0x01
    47ce:	d2 d8       	rcall	.-3676   	; 0x3974 <get_fat>
    47d0:	ab 01       	movw	r20, r22
    47d2:	bc 01       	movw	r22, r24
    47d4:	4f 3f       	cpi	r20, 0xFF	; 255
    47d6:	ff ef       	ldi	r31, 0xFF	; 255
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    47d8:	5f 07       	cpc	r21, r31
    47da:	6f 07       	cpc	r22, r31
    47dc:	7f 07       	cpc	r23, r31
    47de:	49 f4       	brne	.+18     	; 0x47f2 <f_lseek+0x194>
    47e0:	d1 01       	movw	r26, r2
    47e2:	14 96       	adiw	r26, 0x04	; 4
    47e4:	8c 91       	ld	r24, X
    47e6:	14 97       	sbiw	r26, 0x04	; 4
    47e8:	80 68       	ori	r24, 0x80	; 128
    47ea:	14 96       	adiw	r26, 0x04	; 4
    47ec:	8c 93       	st	X, r24
    47ee:	81 e0       	ldi	r24, 0x01	; 1
    47f0:	83 c0       	rjmp	.+262    	; 0x48f8 <f_lseek+0x29a>
    47f2:	42 30       	cpi	r20, 0x02	; 2
    47f4:	51 05       	cpc	r21, r1
					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
    47f6:	61 05       	cpc	r22, r1
    47f8:	71 05       	cpc	r23, r1
    47fa:	60 f0       	brcs	.+24     	; 0x4814 <f_lseek+0x1b6>
    47fc:	d1 01       	movw	r26, r2
    47fe:	ed 91       	ld	r30, X+
    4800:	fc 91       	ld	r31, X
    4802:	02 85       	ldd	r16, Z+10	; 0x0a
    4804:	13 85       	ldd	r17, Z+11	; 0x0b
    4806:	24 85       	ldd	r18, Z+12	; 0x0c
    4808:	35 85       	ldd	r19, Z+13	; 0x0d
    480a:	40 17       	cp	r20, r16
    480c:	51 07       	cpc	r21, r17
    480e:	62 07       	cpc	r22, r18
    4810:	73 07       	cpc	r23, r19
    4812:	28 f0       	brcs	.+10     	; 0x481e <f_lseek+0x1c0>
    4814:	f1 01       	movw	r30, r2
    4816:	84 81       	ldd	r24, Z+4	; 0x04
    4818:	80 68       	ori	r24, 0x80	; 128
    481a:	84 83       	std	Z+4, r24	; 0x04
    481c:	6a c0       	rjmp	.+212    	; 0x48f2 <f_lseek+0x294>
    481e:	d1 01       	movw	r26, r2
    4820:	52 96       	adiw	r26, 0x12	; 18
					fp->clust = clst;
    4822:	4d 93       	st	X+, r20
    4824:	5d 93       	st	X+, r21
    4826:	6d 93       	st	X+, r22
    4828:	7c 93       	st	X, r23
    482a:	55 97       	sbiw	r26, 0x15	; 21
    482c:	16 96       	adiw	r26, 0x06	; 6
    482e:	0d 91       	ld	r16, X+
					fp->fptr += bcs;
    4830:	1d 91       	ld	r17, X+
    4832:	2d 91       	ld	r18, X+
    4834:	3c 91       	ld	r19, X
    4836:	19 97       	sbiw	r26, 0x09	; 9
    4838:	08 0d       	add	r16, r8
    483a:	19 1d       	adc	r17, r9
    483c:	2a 1d       	adc	r18, r10
    483e:	3b 1d       	adc	r19, r11
    4840:	f1 01       	movw	r30, r2
    4842:	06 83       	std	Z+6, r16	; 0x06
    4844:	17 83       	std	Z+7, r17	; 0x07
    4846:	20 87       	std	Z+8, r18	; 0x08
    4848:	31 87       	std	Z+9, r19	; 0x09
    484a:	c8 18       	sub	r12, r8
    484c:	d9 08       	sbc	r13, r9
					ofs -= bcs;
    484e:	ea 08       	sbc	r14, r10
    4850:	fb 08       	sbc	r15, r11
    4852:	b4 cf       	rjmp	.-152    	; 0x47bc <f_lseek+0x15e>
    4854:	d1 01       	movw	r26, r2
    4856:	16 96       	adiw	r26, 0x06	; 6
				}
				fp->fptr += ofs;
    4858:	8d 90       	ld	r8, X+
    485a:	9d 90       	ld	r9, X+
    485c:	ad 90       	ld	r10, X+
    485e:	bc 90       	ld	r11, X
    4860:	19 97       	sbiw	r26, 0x09	; 9
    4862:	8c 0c       	add	r8, r12
    4864:	9d 1c       	adc	r9, r13
    4866:	ae 1c       	adc	r10, r14
    4868:	bf 1c       	adc	r11, r15
    486a:	f1 01       	movw	r30, r2
    486c:	86 82       	std	Z+6, r8	; 0x06
    486e:	97 82       	std	Z+7, r9	; 0x07
    4870:	a0 86       	std	Z+8, r10	; 0x08
    4872:	b1 86       	std	Z+9, r11	; 0x09
    4874:	97 01       	movw	r18, r14
    4876:	86 01       	movw	r16, r12
				if (ofs % SS(fp->fs)) {
    4878:	11 70       	andi	r17, 0x01	; 1
    487a:	22 27       	eor	r18, r18
    487c:	33 27       	eor	r19, r19
    487e:	01 2b       	or	r16, r17
    4880:	02 2b       	or	r16, r18
    4882:	03 2b       	or	r16, r19
    4884:	09 f4       	brne	.+2      	; 0x4888 <f_lseek+0x22a>
    4886:	34 cf       	rjmp	.-408    	; 0x46f0 <f_lseek+0x92>
    4888:	80 81       	ld	r24, Z
    488a:	91 81       	ldd	r25, Z+1	; 0x01
					nsect = clust2sect(fp->fs, clst);	/* Current sector */
    488c:	4a d8       	rcall	.-3948   	; 0x3922 <clust2sect>
    488e:	61 15       	cp	r22, r1
    4890:	71 05       	cpc	r23, r1
    4892:	81 05       	cpc	r24, r1
					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
    4894:	91 05       	cpc	r25, r1
    4896:	41 f4       	brne	.+16     	; 0x48a8 <f_lseek+0x24a>
    4898:	d1 01       	movw	r26, r2
    489a:	14 96       	adiw	r26, 0x04	; 4
    489c:	8c 91       	ld	r24, X
    489e:	14 97       	sbiw	r26, 0x04	; 4
    48a0:	80 68       	ori	r24, 0x80	; 128
    48a2:	14 96       	adiw	r26, 0x04	; 4
    48a4:	8c 93       	st	X, r24
    48a6:	25 c0       	rjmp	.+74     	; 0x48f2 <f_lseek+0x294>
    48a8:	29 e0       	ldi	r18, 0x09	; 9
    48aa:	f6 94       	lsr	r15
    48ac:	e7 94       	ror	r14
					nsect += ofs / SS(fp->fs);
    48ae:	d7 94       	ror	r13
    48b0:	c7 94       	ror	r12
    48b2:	2a 95       	dec	r18
    48b4:	d1 f7       	brne	.-12     	; 0x48aa <f_lseek+0x24c>
    48b6:	c6 0e       	add	r12, r22
    48b8:	d7 1e       	adc	r13, r23
    48ba:	e8 1e       	adc	r14, r24
    48bc:	f9 1e       	adc	r15, r25
    48be:	f1 01       	movw	r30, r2
    48c0:	46 81       	ldd	r20, Z+6	; 0x06
    48c2:	57 81       	ldd	r21, Z+7	; 0x07
				}
			}
		}
		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
    48c4:	60 85       	ldd	r22, Z+8	; 0x08
    48c6:	71 85       	ldd	r23, Z+9	; 0x09
    48c8:	51 70       	andi	r21, 0x01	; 1
    48ca:	66 27       	eor	r22, r22
    48cc:	77 27       	eor	r23, r23
    48ce:	45 2b       	or	r20, r21
    48d0:	46 2b       	or	r20, r22
    48d2:	47 2b       	or	r20, r23
    48d4:	81 f0       	breq	.+32     	; 0x48f6 <f_lseek+0x298>
    48d6:	46 89       	ldd	r20, Z+22	; 0x16
    48d8:	57 89       	ldd	r21, Z+23	; 0x17
    48da:	60 8d       	ldd	r22, Z+24	; 0x18
    48dc:	71 8d       	ldd	r23, Z+25	; 0x19
    48de:	c4 16       	cp	r12, r20
    48e0:	d5 06       	cpc	r13, r21
    48e2:	e6 06       	cpc	r14, r22
    48e4:	f7 06       	cpc	r15, r23
    48e6:	39 f0       	breq	.+14     	; 0x48f6 <f_lseek+0x298>
    48e8:	c6 8a       	std	Z+22, r12	; 0x16
    48ea:	d7 8a       	std	Z+23, r13	; 0x17
    48ec:	e0 8e       	std	Z+24, r14	; 0x18
			}
#endif
			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK)	/* Fill sector cache */
				ABORT(fp->fs, FR_DISK_ERR);
#endif
			fp->dsect = nsect;
    48ee:	f1 8e       	std	Z+25, r15	; 0x19
    48f0:	02 c0       	rjmp	.+4      	; 0x48f6 <f_lseek+0x298>
    48f2:	82 e0       	ldi	r24, 0x02	; 2
    48f4:	01 c0       	rjmp	.+2      	; 0x48f8 <f_lseek+0x29a>
    48f6:	80 e0       	ldi	r24, 0x00	; 0


	res = validate(fp);					/* Check validity of the object */
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->flag & FA__ERROR)			/* Check abort flag */
		LEAVE_FF(fp->fs, FR_INT_ERR);
    48f8:	28 96       	adiw	r28, 0x08	; 8
    48fa:	0f b6       	in	r0, 0x3f	; 63
    48fc:	f8 94       	cli
		}
#endif
	}

	LEAVE_FF(fp->fs, res);
}
    48fe:	de bf       	out	0x3e, r29	; 62
    4900:	0f be       	out	0x3f, r0	; 63
    4902:	cd bf       	out	0x3d, r28	; 61
    4904:	df 91       	pop	r29
    4906:	cf 91       	pop	r28
    4908:	1f 91       	pop	r17
    490a:	0f 91       	pop	r16
    490c:	ff 90       	pop	r15
    490e:	ef 90       	pop	r14
    4910:	df 90       	pop	r13
    4912:	cf 90       	pop	r12
    4914:	bf 90       	pop	r11
    4916:	af 90       	pop	r10
    4918:	9f 90       	pop	r9
    491a:	8f 90       	pop	r8
    491c:	7f 90       	pop	r7
    491e:	6f 90       	pop	r6
    4920:	5f 90       	pop	r5
    4922:	4f 90       	pop	r4
    4924:	3f 90       	pop	r3
    4926:	2f 90       	pop	r2
    4928:	08 95       	ret

0000492a <Endpoint_Null_Stream>:
    492a:	ef 92       	push	r14
    492c:	ff 92       	push	r15
    492e:	0f 93       	push	r16
	return ENDPOINT_RWSTREAM_NoError;
}

uint8_t Endpoint_Null_Stream(uint16_t Length,
                             uint16_t* const BytesProcessed)
{
    4930:	1f 93       	push	r17
    4932:	cf 93       	push	r28
    4934:	df 93       	push	r29
    4936:	8c 01       	movw	r16, r24
    4938:	eb 01       	movw	r28, r22
	uint8_t  ErrorCode;
	uint16_t BytesInTransfer = 0;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
    493a:	96 d2       	rcall	.+1324   	; 0x4e68 <Endpoint_WaitUntilReady>
    493c:	81 11       	cpse	r24, r1
    493e:	2b c0       	rjmp	.+86     	; 0x4996 <Endpoint_Null_Stream+0x6c>
    4940:	20 97       	sbiw	r28, 0x00	; 0
	  return ErrorCode;

	if (BytesProcessed != NULL)
    4942:	21 f0       	breq	.+8      	; 0x494c <Endpoint_Null_Stream+0x22>
    4944:	88 81       	ld	r24, Y
	  Length -= *BytesProcessed;
    4946:	99 81       	ldd	r25, Y+1	; 0x01
    4948:	08 1b       	sub	r16, r24
    494a:	19 0b       	sbc	r17, r25
    494c:	e1 2c       	mov	r14, r1
	return ENDPOINT_RWSTREAM_NoError;
}

uint8_t Endpoint_Null_Stream(uint16_t Length,
                             uint16_t* const BytesProcessed)
{
    494e:	f1 2c       	mov	r15, r1
    4950:	01 15       	cp	r16, r1
	  return ErrorCode;

	if (BytesProcessed != NULL)
	  Length -= *BytesProcessed;

	while (Length)
    4952:	11 05       	cpc	r17, r1
    4954:	f9 f0       	breq	.+62     	; 0x4994 <Endpoint_Null_Stream+0x6a>
    4956:	80 91 e8 00 	lds	r24, 0x00E8
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    495a:	85 fd       	sbrc	r24, 5
	{
		if (!(Endpoint_IsReadWriteAllowed()))
    495c:	13 c0       	rjmp	.+38     	; 0x4984 <Endpoint_Null_Stream+0x5a>
    495e:	80 91 e8 00 	lds	r24, 0x00E8
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    4962:	8e 77       	andi	r24, 0x7E	; 126
    4964:	80 93 e8 00 	sts	0x00E8, r24
    4968:	20 97       	sbiw	r28, 0x00	; 0
		{
			Endpoint_ClearIN();

			if (BytesProcessed != NULL)
    496a:	41 f0       	breq	.+16     	; 0x497c <Endpoint_Null_Stream+0x52>
    496c:	88 81       	ld	r24, Y
			{
				*BytesProcessed += BytesInTransfer;
    496e:	99 81       	ldd	r25, Y+1	; 0x01
    4970:	8e 0d       	add	r24, r14
    4972:	9f 1d       	adc	r25, r15
    4974:	99 83       	std	Y+1, r25	; 0x01
    4976:	88 83       	st	Y, r24
    4978:	85 e0       	ldi	r24, 0x05	; 5
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
    497a:	0d c0       	rjmp	.+26     	; 0x4996 <Endpoint_Null_Stream+0x6c>
    497c:	75 d2       	rcall	.+1258   	; 0x4e68 <Endpoint_WaitUntilReady>
			}

			if ((ErrorCode = Endpoint_WaitUntilReady()))
    497e:	88 23       	and	r24, r24
    4980:	39 f3       	breq	.-50     	; 0x4950 <Endpoint_Null_Stream+0x26>
    4982:	09 c0       	rjmp	.+18     	; 0x4996 <Endpoint_Null_Stream+0x6c>
    4984:	10 92 f1 00 	sts	0x00F1, r1
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    4988:	01 50       	subi	r16, 0x01	; 1
    498a:	11 09       	sbc	r17, r1
		}
		else
		{
			Endpoint_Write_8(0);

			Length--;
    498c:	8f ef       	ldi	r24, 0xFF	; 255
    498e:	e8 1a       	sub	r14, r24
			BytesInTransfer++;
    4990:	f8 0a       	sbc	r15, r24
    4992:	de cf       	rjmp	.-68     	; 0x4950 <Endpoint_Null_Stream+0x26>
    4994:	80 e0       	ldi	r24, 0x00	; 0
    4996:	df 91       	pop	r29
		}
	}

	return ENDPOINT_RWSTREAM_NoError;
    4998:	cf 91       	pop	r28
}
    499a:	1f 91       	pop	r17
    499c:	0f 91       	pop	r16
    499e:	ff 90       	pop	r15
    49a0:	ef 90       	pop	r14
    49a2:	08 95       	ret

000049a4 <Endpoint_Write_Stream_LE>:
    49a4:	cf 92       	push	r12
    49a6:	df 92       	push	r13
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
    49a8:	ef 92       	push	r14
    49aa:	ff 92       	push	r15
    49ac:	0f 93       	push	r16
    49ae:	1f 93       	push	r17
    49b0:	cf 93       	push	r28
    49b2:	df 93       	push	r29
    49b4:	7c 01       	movw	r14, r24
    49b6:	8b 01       	movw	r16, r22
    49b8:	ea 01       	movw	r28, r20
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	uint16_t BytesInTransfer = 0;
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
    49ba:	56 d2       	rcall	.+1196   	; 0x4e68 <Endpoint_WaitUntilReady>
    49bc:	81 11       	cpse	r24, r1
    49be:	30 c0       	rjmp	.+96     	; 0x4a20 <Endpoint_Write_Stream_LE+0x7c>
    49c0:	20 97       	sbiw	r28, 0x00	; 0
	  return ErrorCode;

	if (BytesProcessed != NULL)
    49c2:	31 f0       	breq	.+12     	; 0x49d0 <Endpoint_Write_Stream_LE+0x2c>
    49c4:	88 81       	ld	r24, Y
	{
		Length -= *BytesProcessed;
    49c6:	99 81       	ldd	r25, Y+1	; 0x01
    49c8:	08 1b       	sub	r16, r24
    49ca:	19 0b       	sbc	r17, r25
    49cc:	e8 0e       	add	r14, r24
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
    49ce:	f9 1e       	adc	r15, r25
    49d0:	c1 2c       	mov	r12, r1

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    49d2:	d1 2c       	mov	r13, r1
    49d4:	01 15       	cp	r16, r1
	{
		Length -= *BytesProcessed;
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
    49d6:	11 05       	cpc	r17, r1
    49d8:	11 f1       	breq	.+68     	; 0x4a1e <Endpoint_Write_Stream_LE+0x7a>
    49da:	80 91 e8 00 	lds	r24, 0x00E8
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    49de:	85 fd       	sbrc	r24, 5
	{
		if (!(Endpoint_IsReadWriteAllowed()))
    49e0:	13 c0       	rjmp	.+38     	; 0x4a08 <Endpoint_Write_Stream_LE+0x64>
    49e2:	80 91 e8 00 	lds	r24, 0x00E8
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    49e6:	8e 77       	andi	r24, 0x7E	; 126
    49e8:	80 93 e8 00 	sts	0x00E8, r24
    49ec:	20 97       	sbiw	r28, 0x00	; 0

			#if !defined(INTERRUPT_CONTROL_ENDPOINT)
			USB_USBTask();
			#endif

			if (BytesProcessed != NULL)
    49ee:	41 f0       	breq	.+16     	; 0x4a00 <Endpoint_Write_Stream_LE+0x5c>
    49f0:	88 81       	ld	r24, Y
			{
				*BytesProcessed += BytesInTransfer;
    49f2:	99 81       	ldd	r25, Y+1	; 0x01
    49f4:	8c 0d       	add	r24, r12
    49f6:	9d 1d       	adc	r25, r13
    49f8:	99 83       	std	Y+1, r25	; 0x01
    49fa:	88 83       	st	Y, r24
    49fc:	85 e0       	ldi	r24, 0x05	; 5
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
    49fe:	10 c0       	rjmp	.+32     	; 0x4a20 <Endpoint_Write_Stream_LE+0x7c>
    4a00:	33 d2       	rcall	.+1126   	; 0x4e68 <Endpoint_WaitUntilReady>
			}

			if ((ErrorCode = Endpoint_WaitUntilReady()))
    4a02:	88 23       	and	r24, r24
    4a04:	39 f3       	breq	.-50     	; 0x49d4 <Endpoint_Write_Stream_LE+0x30>
    4a06:	0c c0       	rjmp	.+24     	; 0x4a20 <Endpoint_Write_Stream_LE+0x7c>
    4a08:	f7 01       	movw	r30, r14
    4a0a:	81 91       	ld	r24, Z+
			  return ErrorCode;
		}
		else
		{
			TEMPLATE_TRANSFER_BYTE(DataStream);
    4a0c:	7f 01       	movw	r14, r30
    4a0e:	80 93 f1 00 	sts	0x00F1, r24
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    4a12:	01 50       	subi	r16, 0x01	; 1
    4a14:	11 09       	sbc	r17, r1
			TEMPLATE_BUFFER_MOVE(DataStream, 1);
			Length--;
    4a16:	ff ef       	ldi	r31, 0xFF	; 255
    4a18:	cf 1a       	sub	r12, r31
			BytesInTransfer++;
    4a1a:	df 0a       	sbc	r13, r31
    4a1c:	db cf       	rjmp	.-74     	; 0x49d4 <Endpoint_Write_Stream_LE+0x30>
    4a1e:	80 e0       	ldi	r24, 0x00	; 0
    4a20:	df 91       	pop	r29
		}
	}

	return ENDPOINT_RWSTREAM_NoError;
    4a22:	cf 91       	pop	r28
}
    4a24:	1f 91       	pop	r17
    4a26:	0f 91       	pop	r16
    4a28:	ff 90       	pop	r15
    4a2a:	ef 90       	pop	r14
    4a2c:	df 90       	pop	r13
    4a2e:	cf 90       	pop	r12
    4a30:	08 95       	ret

00004a32 <Endpoint_Write_Stream_BE>:
    4a32:	cf 92       	push	r12
    4a34:	df 92       	push	r13
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
    4a36:	ef 92       	push	r14
    4a38:	ff 92       	push	r15
    4a3a:	0f 93       	push	r16
    4a3c:	1f 93       	push	r17
    4a3e:	cf 93       	push	r28
    4a40:	df 93       	push	r29
    4a42:	6c 01       	movw	r12, r24
    4a44:	8b 01       	movw	r16, r22
    4a46:	7a 01       	movw	r14, r20
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	uint16_t BytesInTransfer = 0;
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
    4a48:	0f d2       	rcall	.+1054   	; 0x4e68 <Endpoint_WaitUntilReady>
    4a4a:	81 11       	cpse	r24, r1
    4a4c:	37 c0       	rjmp	.+110    	; 0x4abc <Endpoint_Write_Stream_BE+0x8a>
    4a4e:	e8 01       	movw	r28, r16

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    4a50:	21 97       	sbiw	r28, 0x01	; 1
    4a52:	cc 0d       	add	r28, r12
    4a54:	dd 1d       	adc	r29, r13
    4a56:	e1 14       	cp	r14, r1
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
	  return ErrorCode;

	if (BytesProcessed != NULL)
    4a58:	f1 04       	cpc	r15, r1
    4a5a:	39 f0       	breq	.+14     	; 0x4a6a <Endpoint_Write_Stream_BE+0x38>
    4a5c:	f7 01       	movw	r30, r14
	{
		Length -= *BytesProcessed;
    4a5e:	80 81       	ld	r24, Z
    4a60:	91 81       	ldd	r25, Z+1	; 0x01
    4a62:	08 1b       	sub	r16, r24
    4a64:	19 0b       	sbc	r17, r25
    4a66:	c8 1b       	sub	r28, r24
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
    4a68:	d9 0b       	sbc	r29, r25
    4a6a:	c1 2c       	mov	r12, r1
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
    4a6c:	d1 2c       	mov	r13, r1
    4a6e:	01 15       	cp	r16, r1
	{
		Length -= *BytesProcessed;
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
    4a70:	11 05       	cpc	r17, r1
    4a72:	19 f1       	breq	.+70     	; 0x4aba <Endpoint_Write_Stream_BE+0x88>
    4a74:	80 91 e8 00 	lds	r24, 0x00E8
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    4a78:	85 fd       	sbrc	r24, 5
	{
		if (!(Endpoint_IsReadWriteAllowed()))
    4a7a:	15 c0       	rjmp	.+42     	; 0x4aa6 <Endpoint_Write_Stream_BE+0x74>
    4a7c:	80 91 e8 00 	lds	r24, 0x00E8
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    4a80:	8e 77       	andi	r24, 0x7E	; 126
    4a82:	80 93 e8 00 	sts	0x00E8, r24
    4a86:	e1 14       	cp	r14, r1

			#if !defined(INTERRUPT_CONTROL_ENDPOINT)
			USB_USBTask();
			#endif

			if (BytesProcessed != NULL)
    4a88:	f1 04       	cpc	r15, r1
    4a8a:	49 f0       	breq	.+18     	; 0x4a9e <Endpoint_Write_Stream_BE+0x6c>
    4a8c:	f7 01       	movw	r30, r14
			{
				*BytesProcessed += BytesInTransfer;
    4a8e:	80 81       	ld	r24, Z
    4a90:	91 81       	ldd	r25, Z+1	; 0x01
    4a92:	8c 0d       	add	r24, r12
    4a94:	9d 1d       	adc	r25, r13
    4a96:	91 83       	std	Z+1, r25	; 0x01
    4a98:	80 83       	st	Z, r24
    4a9a:	85 e0       	ldi	r24, 0x05	; 5
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
    4a9c:	0f c0       	rjmp	.+30     	; 0x4abc <Endpoint_Write_Stream_BE+0x8a>
    4a9e:	e4 d1       	rcall	.+968    	; 0x4e68 <Endpoint_WaitUntilReady>
			}

			if ((ErrorCode = Endpoint_WaitUntilReady()))
    4aa0:	88 23       	and	r24, r24
    4aa2:	29 f3       	breq	.-54     	; 0x4a6e <Endpoint_Write_Stream_BE+0x3c>
    4aa4:	0b c0       	rjmp	.+22     	; 0x4abc <Endpoint_Write_Stream_BE+0x8a>
    4aa6:	88 81       	ld	r24, Y
    4aa8:	80 93 f1 00 	sts	0x00F1, r24
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    4aac:	21 97       	sbiw	r28, 0x01	; 1
    4aae:	01 50       	subi	r16, 0x01	; 1
			  return ErrorCode;
		}
		else
		{
			TEMPLATE_TRANSFER_BYTE(DataStream);
			TEMPLATE_BUFFER_MOVE(DataStream, 1);
    4ab0:	11 09       	sbc	r17, r1
			Length--;
    4ab2:	ff ef       	ldi	r31, 0xFF	; 255
    4ab4:	cf 1a       	sub	r12, r31
			BytesInTransfer++;
    4ab6:	df 0a       	sbc	r13, r31
    4ab8:	da cf       	rjmp	.-76     	; 0x4a6e <Endpoint_Write_Stream_BE+0x3c>
    4aba:	80 e0       	ldi	r24, 0x00	; 0
    4abc:	df 91       	pop	r29
		}
	}

	return ENDPOINT_RWSTREAM_NoError;
    4abe:	cf 91       	pop	r28
}
    4ac0:	1f 91       	pop	r17
    4ac2:	0f 91       	pop	r16
    4ac4:	ff 90       	pop	r15
    4ac6:	ef 90       	pop	r14
    4ac8:	df 90       	pop	r13
    4aca:	cf 90       	pop	r12
    4acc:	08 95       	ret

00004ace <Endpoint_Read_Stream_LE>:
    4ace:	cf 92       	push	r12
    4ad0:	df 92       	push	r13
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
    4ad2:	ef 92       	push	r14
    4ad4:	ff 92       	push	r15
    4ad6:	0f 93       	push	r16
    4ad8:	1f 93       	push	r17
    4ada:	cf 93       	push	r28
    4adc:	df 93       	push	r29
    4ade:	7c 01       	movw	r14, r24
    4ae0:	8b 01       	movw	r16, r22
    4ae2:	ea 01       	movw	r28, r20
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	uint16_t BytesInTransfer = 0;
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
    4ae4:	c1 d1       	rcall	.+898    	; 0x4e68 <Endpoint_WaitUntilReady>
    4ae6:	81 11       	cpse	r24, r1
    4ae8:	30 c0       	rjmp	.+96     	; 0x4b4a <Endpoint_Read_Stream_LE+0x7c>
    4aea:	20 97       	sbiw	r28, 0x00	; 0
	  return ErrorCode;

	if (BytesProcessed != NULL)
    4aec:	31 f0       	breq	.+12     	; 0x4afa <Endpoint_Read_Stream_LE+0x2c>
    4aee:	88 81       	ld	r24, Y
	{
		Length -= *BytesProcessed;
    4af0:	99 81       	ldd	r25, Y+1	; 0x01
    4af2:	08 1b       	sub	r16, r24
    4af4:	19 0b       	sbc	r17, r25
    4af6:	e8 0e       	add	r14, r24
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
    4af8:	f9 1e       	adc	r15, r25
    4afa:	c1 2c       	mov	r12, r1

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    4afc:	d1 2c       	mov	r13, r1
    4afe:	01 15       	cp	r16, r1
	{
		Length -= *BytesProcessed;
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
    4b00:	11 05       	cpc	r17, r1
    4b02:	11 f1       	breq	.+68     	; 0x4b48 <Endpoint_Read_Stream_LE+0x7a>
    4b04:	80 91 e8 00 	lds	r24, 0x00E8
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    4b08:	85 fd       	sbrc	r24, 5
	{
		if (!(Endpoint_IsReadWriteAllowed()))
    4b0a:	13 c0       	rjmp	.+38     	; 0x4b32 <Endpoint_Read_Stream_LE+0x64>
    4b0c:	80 91 e8 00 	lds	r24, 0x00E8
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    4b10:	8b 77       	andi	r24, 0x7B	; 123
    4b12:	80 93 e8 00 	sts	0x00E8, r24
    4b16:	20 97       	sbiw	r28, 0x00	; 0

			#if !defined(INTERRUPT_CONTROL_ENDPOINT)
			USB_USBTask();
			#endif

			if (BytesProcessed != NULL)
    4b18:	41 f0       	breq	.+16     	; 0x4b2a <Endpoint_Read_Stream_LE+0x5c>
    4b1a:	88 81       	ld	r24, Y
			{
				*BytesProcessed += BytesInTransfer;
    4b1c:	99 81       	ldd	r25, Y+1	; 0x01
    4b1e:	8c 0d       	add	r24, r12
    4b20:	9d 1d       	adc	r25, r13
    4b22:	99 83       	std	Y+1, r25	; 0x01
    4b24:	88 83       	st	Y, r24
    4b26:	85 e0       	ldi	r24, 0x05	; 5
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
    4b28:	10 c0       	rjmp	.+32     	; 0x4b4a <Endpoint_Read_Stream_LE+0x7c>
    4b2a:	9e d1       	rcall	.+828    	; 0x4e68 <Endpoint_WaitUntilReady>
			}

			if ((ErrorCode = Endpoint_WaitUntilReady()))
    4b2c:	88 23       	and	r24, r24
    4b2e:	39 f3       	breq	.-50     	; 0x4afe <Endpoint_Read_Stream_LE+0x30>
    4b30:	0c c0       	rjmp	.+24     	; 0x4b4a <Endpoint_Read_Stream_LE+0x7c>
    4b32:	80 91 f1 00 	lds	r24, 0x00F1
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    4b36:	f7 01       	movw	r30, r14
    4b38:	81 93       	st	Z+, r24
			  return ErrorCode;
		}
		else
		{
			TEMPLATE_TRANSFER_BYTE(DataStream);
    4b3a:	7f 01       	movw	r14, r30
    4b3c:	01 50       	subi	r16, 0x01	; 1
    4b3e:	11 09       	sbc	r17, r1
			TEMPLATE_BUFFER_MOVE(DataStream, 1);
			Length--;
    4b40:	ff ef       	ldi	r31, 0xFF	; 255
    4b42:	cf 1a       	sub	r12, r31
			BytesInTransfer++;
    4b44:	df 0a       	sbc	r13, r31
    4b46:	db cf       	rjmp	.-74     	; 0x4afe <Endpoint_Read_Stream_LE+0x30>
    4b48:	80 e0       	ldi	r24, 0x00	; 0
    4b4a:	df 91       	pop	r29
		}
	}

	return ENDPOINT_RWSTREAM_NoError;
    4b4c:	cf 91       	pop	r28
}
    4b4e:	1f 91       	pop	r17
    4b50:	0f 91       	pop	r16
    4b52:	ff 90       	pop	r15
    4b54:	ef 90       	pop	r14
    4b56:	df 90       	pop	r13
    4b58:	cf 90       	pop	r12
    4b5a:	08 95       	ret

00004b5c <Endpoint_Write_Control_Stream_LE>:
    4b5c:	20 91 e2 0d 	lds	r18, 0x0DE2
                            uint16_t Length)
{
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
    4b60:	30 91 e3 0d 	lds	r19, 0x0DE3
    4b64:	26 17       	cp	r18, r22
    4b66:	37 07       	cpc	r19, r23
    4b68:	48 f0       	brcs	.+18     	; 0x4b7c <Endpoint_Write_Control_Stream_LE+0x20>
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
    4b6a:	61 15       	cp	r22, r1
    4b6c:	71 05       	cpc	r23, r1
    4b6e:	39 f4       	brne	.+14     	; 0x4b7e <Endpoint_Write_Control_Stream_LE+0x22>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    4b70:	20 91 e8 00 	lds	r18, 0x00E8
    4b74:	2e 77       	andi	r18, 0x7E	; 126
    4b76:	20 93 e8 00 	sts	0x00E8, r18
    4b7a:	01 c0       	rjmp	.+2      	; 0x4b7e <Endpoint_Write_Control_Stream_LE+0x22>
    4b7c:	b9 01       	movw	r22, r18
    4b7e:	fc 01       	movw	r30, r24
    4b80:	20 e0       	ldi	r18, 0x00	; 0
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    4b82:	61 15       	cp	r22, r1
    4b84:	71 05       	cpc	r23, r1
    4b86:	91 f1       	breq	.+100    	; 0x4bec <Endpoint_Write_Control_Stream_LE+0x90>
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    4b88:	8e b3       	in	r24, 0x1e	; 30

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    4b8a:	88 23       	and	r24, r24
    4b8c:	e1 f1       	breq	.+120    	; 0x4c06 <Endpoint_Write_Control_Stream_LE+0xaa>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    4b8e:	85 30       	cpi	r24, 0x05	; 5
    4b90:	e1 f1       	breq	.+120    	; 0x4c0a <Endpoint_Write_Control_Stream_LE+0xae>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    4b92:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    4b96:	83 fd       	sbrc	r24, 3
    4b98:	3a c0       	rjmp	.+116    	; 0x4c0e <Endpoint_Write_Control_Stream_LE+0xb2>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    4b9a:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
    4b9e:	82 ff       	sbrs	r24, 2
    4ba0:	06 c0       	rjmp	.+12     	; 0x4bae <Endpoint_Write_Control_Stream_LE+0x52>
    4ba2:	80 91 e8 00 	lds	r24, 0x00E8
			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}

	while (!(Endpoint_IsOUTReceived()))
    4ba6:	82 ff       	sbrs	r24, 2
    4ba8:	24 c0       	rjmp	.+72     	; 0x4bf2 <Endpoint_Write_Control_Stream_LE+0x96>
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
	}

	return ENDPOINT_RWCSTREAM_NoError;
    4baa:	80 e0       	ldi	r24, 0x00	; 0
    4bac:	08 95       	ret
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    4bae:	80 91 e8 00 	lds	r24, 0x00E8
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
		  break;

		if (Endpoint_IsINReady())
    4bb2:	80 ff       	sbrs	r24, 0
    4bb4:	e6 cf       	rjmp	.-52     	; 0x4b82 <Endpoint_Write_Control_Stream_LE+0x26>
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					return UEBCX;
    4bb6:	80 91 f2 00 	lds	r24, 0x00F2
    4bba:	90 91 f3 00 	lds	r25, 0x00F3
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    4bbe:	61 15       	cp	r22, r1
    4bc0:	71 05       	cpc	r23, r1
    4bc2:	51 f0       	breq	.+20     	; 0x4bd8 <Endpoint_Write_Control_Stream_LE+0x7c>
    4bc4:	88 30       	cpi	r24, 0x08	; 8
    4bc6:	91 05       	cpc	r25, r1
    4bc8:	38 f4       	brcc	.+14     	; 0x4bd8 <Endpoint_Write_Control_Stream_LE+0x7c>
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    4bca:	21 91       	ld	r18, Z+
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    4bcc:	20 93 f1 00 	sts	0x00F1, r18
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
    4bd0:	61 50       	subi	r22, 0x01	; 1
    4bd2:	71 09       	sbc	r23, r1
				BytesInEndpoint++;
    4bd4:	01 96       	adiw	r24, 0x01	; 1
    4bd6:	f3 cf       	rjmp	.-26     	; 0x4bbe <Endpoint_Write_Control_Stream_LE+0x62>
			}

			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
    4bd8:	21 e0       	ldi	r18, 0x01	; 1
    4bda:	08 97       	sbiw	r24, 0x08	; 8
    4bdc:	09 f0       	breq	.+2      	; 0x4be0 <Endpoint_Write_Control_Stream_LE+0x84>
    4bde:	20 e0       	ldi	r18, 0x00	; 0
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    4be0:	80 91 e8 00 	lds	r24, 0x00E8
    4be4:	8e 77       	andi	r24, 0x7E	; 126
    4be6:	80 93 e8 00 	sts	0x00E8, r24
    4bea:	cb cf       	rjmp	.-106    	; 0x4b82 <Endpoint_Write_Control_Stream_LE+0x26>
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    4bec:	21 11       	cpse	r18, r1
    4bee:	cc cf       	rjmp	.-104    	; 0x4b88 <Endpoint_Write_Control_Stream_LE+0x2c>
    4bf0:	d8 cf       	rjmp	.-80     	; 0x4ba2 <Endpoint_Write_Control_Stream_LE+0x46>
		}
	}

	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    4bf2:	8e b3       	in	r24, 0x1e	; 30

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    4bf4:	88 23       	and	r24, r24
    4bf6:	39 f0       	breq	.+14     	; 0x4c06 <Endpoint_Write_Control_Stream_LE+0xaa>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    4bf8:	85 30       	cpi	r24, 0x05	; 5
    4bfa:	39 f0       	breq	.+14     	; 0x4c0a <Endpoint_Write_Control_Stream_LE+0xae>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    4bfc:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    4c00:	83 ff       	sbrs	r24, 3
    4c02:	cf cf       	rjmp	.-98     	; 0x4ba2 <Endpoint_Write_Control_Stream_LE+0x46>
    4c04:	04 c0       	rjmp	.+8      	; 0x4c0e <Endpoint_Write_Control_Stream_LE+0xb2>
	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
    4c06:	82 e0       	ldi	r24, 0x02	; 2
    4c08:	08 95       	ret
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    4c0a:	83 e0       	ldi	r24, 0x03	; 3
    4c0c:	08 95       	ret
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
    4c0e:	81 e0       	ldi	r24, 0x01	; 1
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    4c10:	08 95       	ret

00004c12 <Endpoint_Read_Control_Stream_LE>:
uint8_t TEMPLATE_FUNC_NAME (void* const Buffer,
                            uint16_t Length)
{
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));

	if (!(Length))
    4c12:	61 15       	cp	r22, r1
    4c14:	71 05       	cpc	r23, r1
    4c16:	29 f4       	brne	.+10     	; 0x4c22 <Endpoint_Read_Control_Stream_LE+0x10>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    4c18:	20 91 e8 00 	lds	r18, 0x00E8
    4c1c:	2b 77       	andi	r18, 0x7B	; 123
    4c1e:	20 93 e8 00 	sts	0x00E8, r18
	  Endpoint_ClearOUT();

	while (Length)
    4c22:	61 15       	cp	r22, r1
    4c24:	71 05       	cpc	r23, r1
    4c26:	21 f1       	breq	.+72     	; 0x4c70 <Endpoint_Read_Control_Stream_LE+0x5e>
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    4c28:	2e b3       	in	r18, 0x1e	; 30

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    4c2a:	22 23       	and	r18, r18
    4c2c:	51 f1       	breq	.+84     	; 0x4c82 <Endpoint_Read_Control_Stream_LE+0x70>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    4c2e:	25 30       	cpi	r18, 0x05	; 5
    4c30:	51 f1       	breq	.+84     	; 0x4c86 <Endpoint_Read_Control_Stream_LE+0x74>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    4c32:	20 91 e8 00 	lds	r18, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    4c36:	23 fd       	sbrc	r18, 3
    4c38:	20 c0       	rjmp	.+64     	; 0x4c7a <Endpoint_Read_Control_Stream_LE+0x68>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    4c3a:	20 91 e8 00 	lds	r18, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;

		if (Endpoint_IsOUTReceived())
    4c3e:	22 ff       	sbrs	r18, 2
    4c40:	f3 cf       	rjmp	.-26     	; 0x4c28 <Endpoint_Read_Control_Stream_LE+0x16>
    4c42:	fc 01       	movw	r30, r24
    4c44:	cf 01       	movw	r24, r30
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					return UEBCX;
    4c46:	20 91 f2 00 	lds	r18, 0x00F2
    4c4a:	30 91 f3 00 	lds	r19, 0x00F3
		{
			while (Length && Endpoint_BytesInEndpoint())
    4c4e:	23 2b       	or	r18, r19
    4c50:	19 f3       	breq	.-58     	; 0x4c18 <Endpoint_Read_Control_Stream_LE+0x6>
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    4c52:	80 91 f1 00 	lds	r24, 0x00F1
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    4c56:	81 93       	st	Z+, r24
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
    4c58:	cf 01       	movw	r24, r30
				Length--;
    4c5a:	61 50       	subi	r22, 0x01	; 1
    4c5c:	71 09       	sbc	r23, r1
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;

		if (Endpoint_IsOUTReceived())
		{
			while (Length && Endpoint_BytesInEndpoint())
    4c5e:	61 15       	cp	r22, r1
    4c60:	71 05       	cpc	r23, r1
    4c62:	81 f7       	brne	.-32     	; 0x4c44 <Endpoint_Read_Control_Stream_LE+0x32>
    4c64:	d9 cf       	rjmp	.-78     	; 0x4c18 <Endpoint_Read_Control_Stream_LE+0x6>
		}
	}

	while (!(Endpoint_IsINReady()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    4c66:	8e b3       	in	r24, 0x1e	; 30

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    4c68:	88 23       	and	r24, r24
    4c6a:	59 f0       	breq	.+22     	; 0x4c82 <Endpoint_Read_Control_Stream_LE+0x70>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    4c6c:	85 30       	cpi	r24, 0x05	; 5
    4c6e:	59 f0       	breq	.+22     	; 0x4c86 <Endpoint_Read_Control_Stream_LE+0x74>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    4c70:	80 91 e8 00 	lds	r24, 0x00E8

			Endpoint_ClearOUT();
		}
	}

	while (!(Endpoint_IsINReady()))
    4c74:	80 ff       	sbrs	r24, 0
    4c76:	f7 cf       	rjmp	.-18     	; 0x4c66 <Endpoint_Read_Control_Stream_LE+0x54>
    4c78:	02 c0       	rjmp	.+4      	; 0x4c7e <Endpoint_Read_Control_Stream_LE+0x6c>
		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
    4c7a:	81 e0       	ldi	r24, 0x01	; 1
    4c7c:	08 95       	ret
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
    4c7e:	80 e0       	ldi	r24, 0x00	; 0
    4c80:	08 95       	ret
	while (Length)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
    4c82:	82 e0       	ldi	r24, 0x02	; 2
    4c84:	08 95       	ret
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    4c86:	83 e0       	ldi	r24, 0x03	; 3
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    4c88:	08 95       	ret

00004c8a <Endpoint_Write_Control_PStream_LE>:
                            uint16_t Length)
{
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
    4c8a:	20 91 e2 0d 	lds	r18, 0x0DE2
    4c8e:	30 91 e3 0d 	lds	r19, 0x0DE3
    4c92:	26 17       	cp	r18, r22
    4c94:	37 07       	cpc	r19, r23
    4c96:	48 f0       	brcs	.+18     	; 0x4caa <Endpoint_Write_Control_PStream_LE+0x20>
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
    4c98:	61 15       	cp	r22, r1
    4c9a:	71 05       	cpc	r23, r1
    4c9c:	39 f4       	brne	.+14     	; 0x4cac <Endpoint_Write_Control_PStream_LE+0x22>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    4c9e:	20 91 e8 00 	lds	r18, 0x00E8
    4ca2:	2e 77       	andi	r18, 0x7E	; 126
    4ca4:	20 93 e8 00 	sts	0x00E8, r18
    4ca8:	01 c0       	rjmp	.+2      	; 0x4cac <Endpoint_Write_Control_PStream_LE+0x22>
    4caa:	b9 01       	movw	r22, r18
    4cac:	fc 01       	movw	r30, r24
    4cae:	20 e0       	ldi	r18, 0x00	; 0
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    4cb0:	61 15       	cp	r22, r1
    4cb2:	71 05       	cpc	r23, r1
    4cb4:	a9 f1       	breq	.+106    	; 0x4d20 <Endpoint_Write_Control_PStream_LE+0x96>
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    4cb6:	8e b3       	in	r24, 0x1e	; 30

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    4cb8:	88 23       	and	r24, r24
    4cba:	09 f4       	brne	.+2      	; 0x4cbe <Endpoint_Write_Control_PStream_LE+0x34>
    4cbc:	3e c0       	rjmp	.+124    	; 0x4d3a <Endpoint_Write_Control_PStream_LE+0xb0>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    4cbe:	85 30       	cpi	r24, 0x05	; 5
    4cc0:	09 f4       	brne	.+2      	; 0x4cc4 <Endpoint_Write_Control_PStream_LE+0x3a>
    4cc2:	3d c0       	rjmp	.+122    	; 0x4d3e <Endpoint_Write_Control_PStream_LE+0xb4>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    4cc4:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    4cc8:	83 fd       	sbrc	r24, 3
    4cca:	3b c0       	rjmp	.+118    	; 0x4d42 <Endpoint_Write_Control_PStream_LE+0xb8>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    4ccc:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
    4cd0:	82 ff       	sbrs	r24, 2
    4cd2:	06 c0       	rjmp	.+12     	; 0x4ce0 <Endpoint_Write_Control_PStream_LE+0x56>
    4cd4:	80 91 e8 00 	lds	r24, 0x00E8
			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}

	while (!(Endpoint_IsOUTReceived()))
    4cd8:	82 ff       	sbrs	r24, 2
    4cda:	25 c0       	rjmp	.+74     	; 0x4d26 <Endpoint_Write_Control_PStream_LE+0x9c>
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
	}

	return ENDPOINT_RWCSTREAM_NoError;
    4cdc:	80 e0       	ldi	r24, 0x00	; 0
    4cde:	08 95       	ret
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    4ce0:	80 91 e8 00 	lds	r24, 0x00E8
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
		  break;

		if (Endpoint_IsINReady())
    4ce4:	80 ff       	sbrs	r24, 0
    4ce6:	e4 cf       	rjmp	.-56     	; 0x4cb0 <Endpoint_Write_Control_PStream_LE+0x26>
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					return UEBCX;
    4ce8:	80 91 f2 00 	lds	r24, 0x00F2
    4cec:	90 91 f3 00 	lds	r25, 0x00F3
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    4cf0:	61 15       	cp	r22, r1
    4cf2:	71 05       	cpc	r23, r1
    4cf4:	59 f0       	breq	.+22     	; 0x4d0c <Endpoint_Write_Control_PStream_LE+0x82>
    4cf6:	88 30       	cpi	r24, 0x08	; 8
    4cf8:	91 05       	cpc	r25, r1
    4cfa:	40 f4       	brcc	.+16     	; 0x4d0c <Endpoint_Write_Control_PStream_LE+0x82>
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    4cfc:	24 91       	lpm	r18, Z
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    4cfe:	20 93 f1 00 	sts	0x00F1, r18
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
    4d02:	31 96       	adiw	r30, 0x01	; 1
				Length--;
    4d04:	61 50       	subi	r22, 0x01	; 1
    4d06:	71 09       	sbc	r23, r1
				BytesInEndpoint++;
    4d08:	01 96       	adiw	r24, 0x01	; 1
    4d0a:	f2 cf       	rjmp	.-28     	; 0x4cf0 <Endpoint_Write_Control_PStream_LE+0x66>
			}

			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
    4d0c:	21 e0       	ldi	r18, 0x01	; 1
    4d0e:	08 97       	sbiw	r24, 0x08	; 8
    4d10:	09 f0       	breq	.+2      	; 0x4d14 <Endpoint_Write_Control_PStream_LE+0x8a>
    4d12:	20 e0       	ldi	r18, 0x00	; 0
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    4d14:	80 91 e8 00 	lds	r24, 0x00E8
    4d18:	8e 77       	andi	r24, 0x7E	; 126
    4d1a:	80 93 e8 00 	sts	0x00E8, r24
    4d1e:	c8 cf       	rjmp	.-112    	; 0x4cb0 <Endpoint_Write_Control_PStream_LE+0x26>
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    4d20:	21 11       	cpse	r18, r1
    4d22:	c9 cf       	rjmp	.-110    	; 0x4cb6 <Endpoint_Write_Control_PStream_LE+0x2c>
    4d24:	d7 cf       	rjmp	.-82     	; 0x4cd4 <Endpoint_Write_Control_PStream_LE+0x4a>
		}
	}

	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    4d26:	8e b3       	in	r24, 0x1e	; 30

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    4d28:	88 23       	and	r24, r24
    4d2a:	39 f0       	breq	.+14     	; 0x4d3a <Endpoint_Write_Control_PStream_LE+0xb0>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    4d2c:	85 30       	cpi	r24, 0x05	; 5
    4d2e:	39 f0       	breq	.+14     	; 0x4d3e <Endpoint_Write_Control_PStream_LE+0xb4>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    4d30:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    4d34:	83 ff       	sbrs	r24, 3
    4d36:	ce cf       	rjmp	.-100    	; 0x4cd4 <Endpoint_Write_Control_PStream_LE+0x4a>
    4d38:	04 c0       	rjmp	.+8      	; 0x4d42 <Endpoint_Write_Control_PStream_LE+0xb8>
	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
    4d3a:	82 e0       	ldi	r24, 0x02	; 2
    4d3c:	08 95       	ret
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    4d3e:	83 e0       	ldi	r24, 0x03	; 3
    4d40:	08 95       	ret
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
    4d42:	81 e0       	ldi	r24, 0x01	; 1
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    4d44:	08 95       	ret

00004d46 <Endpoint_ConfigureEndpoint_Prv>:
	UECFG0X = UECFG0XData;
	UECFG1X = UECFG1XData;

	return Endpoint_IsConfigured();
#else
	for (uint8_t EPNum = Number; EPNum < ENDPOINT_TOTAL_ENDPOINTS; EPNum++)
    4d46:	98 2f       	mov	r25, r24
    4d48:	97 30       	cpi	r25, 0x07	; 7
    4d4a:	58 f5       	brcc	.+86     	; 0x4da2 <Endpoint_ConfigureEndpoint_Prv+0x5c>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    4d4c:	90 93 e9 00 	sts	0x00E9, r25
		uint8_t UECFG1XTemp;
		uint8_t UEIENXTemp;

		Endpoint_SelectEndpoint(EPNum);

		if (EPNum == Number)
    4d50:	98 17       	cp	r25, r24
    4d52:	39 f0       	breq	.+14     	; 0x4d62 <Endpoint_ConfigureEndpoint_Prv+0x1c>
			UECFG1XTemp = UECFG1XData;
			UEIENXTemp  = 0;
		}
		else
		{
			UECFG0XTemp = UECFG0X;
    4d54:	70 91 ec 00 	lds	r23, 0x00EC
			UECFG1XTemp = UECFG1X;
    4d58:	20 91 ed 00 	lds	r18, 0x00ED
			UEIENXTemp  = UEIENX;
    4d5c:	50 91 f0 00 	lds	r21, 0x00F0
    4d60:	03 c0       	rjmp	.+6      	; 0x4d68 <Endpoint_ConfigureEndpoint_Prv+0x22>
		Endpoint_SelectEndpoint(EPNum);

		if (EPNum == Number)
		{
			UECFG0XTemp = UECFG0XData;
			UECFG1XTemp = UECFG1XData;
    4d62:	24 2f       	mov	r18, r20

		Endpoint_SelectEndpoint(EPNum);

		if (EPNum == Number)
		{
			UECFG0XTemp = UECFG0XData;
    4d64:	76 2f       	mov	r23, r22
			UECFG1XTemp = UECFG1XData;
			UEIENXTemp  = 0;
    4d66:	50 e0       	ldi	r21, 0x00	; 0
			UECFG0XTemp = UECFG0X;
			UECFG1XTemp = UECFG1X;
			UEIENXTemp  = UEIENX;
		}

		if (!(UECFG1XTemp & (1 << ALLOC)))
    4d68:	21 ff       	sbrs	r18, 1
    4d6a:	19 c0       	rjmp	.+50     	; 0x4d9e <Endpoint_ConfigureEndpoint_Prv+0x58>
			 *  to and from a host.
			 */
			static inline void Endpoint_DisableEndpoint(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_DisableEndpoint(void)
			{
				UECONX &= ~(1 << EPEN);
    4d6c:	30 91 eb 00 	lds	r19, 0x00EB
    4d70:	3e 7f       	andi	r19, 0xFE	; 254
    4d72:	30 93 eb 00 	sts	0x00EB, r19
		  continue;

		Endpoint_DisableEndpoint();
		UECFG1X &= ~(1 << ALLOC);
    4d76:	30 91 ed 00 	lds	r19, 0x00ED
    4d7a:	3d 7f       	andi	r19, 0xFD	; 253
    4d7c:	30 93 ed 00 	sts	0x00ED, r19
			 *  \note Endpoints must first be configured properly via \ref Endpoint_ConfigureEndpoint().
			 */
			static inline void Endpoint_EnableEndpoint(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_EnableEndpoint(void)
			{
				UECONX |= (1 << EPEN);
    4d80:	30 91 eb 00 	lds	r19, 0x00EB
    4d84:	31 60       	ori	r19, 0x01	; 1
    4d86:	30 93 eb 00 	sts	0x00EB, r19

		Endpoint_EnableEndpoint();
		UECFG0X = UECFG0XTemp;
    4d8a:	70 93 ec 00 	sts	0x00EC, r23
		UECFG1X = UECFG1XTemp;
    4d8e:	20 93 ed 00 	sts	0x00ED, r18
		UEIENX  = UEIENXTemp;
    4d92:	50 93 f0 00 	sts	0x00F0, r21
			 *  \return Boolean \c true if the currently selected endpoint has been configured, \c false otherwise.
			 */
			static inline bool Endpoint_IsConfigured(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsConfigured(void)
			{
				return ((UESTA0X & (1 << CFGOK)) ? true : false);
    4d96:	20 91 ee 00 	lds	r18, 0x00EE

		if (!(Endpoint_IsConfigured()))
    4d9a:	27 ff       	sbrs	r18, 7
    4d9c:	07 c0       	rjmp	.+14     	; 0x4dac <Endpoint_ConfigureEndpoint_Prv+0x66>
	UECFG0X = UECFG0XData;
	UECFG1X = UECFG1XData;

	return Endpoint_IsConfigured();
#else
	for (uint8_t EPNum = Number; EPNum < ENDPOINT_TOTAL_ENDPOINTS; EPNum++)
    4d9e:	9f 5f       	subi	r25, 0xFF	; 255
    4da0:	d3 cf       	rjmp	.-90     	; 0x4d48 <Endpoint_ConfigureEndpoint_Prv+0x2>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    4da2:	8f 70       	andi	r24, 0x0F	; 15
    4da4:	80 93 e9 00 	sts	0x00E9, r24
		if (!(Endpoint_IsConfigured()))
		  return false;
	}

	Endpoint_SelectEndpoint(Number);
	return true;
    4da8:	81 e0       	ldi	r24, 0x01	; 1
    4daa:	08 95       	ret
		UECFG0X = UECFG0XTemp;
		UECFG1X = UECFG1XTemp;
		UEIENX  = UEIENXTemp;

		if (!(Endpoint_IsConfigured()))
		  return false;
    4dac:	80 e0       	ldi	r24, 0x00	; 0
	}

	Endpoint_SelectEndpoint(Number);
	return true;
#endif
}
    4dae:	08 95       	ret

00004db0 <Endpoint_ConfigureEndpointTable>:
uint8_t USB_Device_ControlEndpointSize = ENDPOINT_CONTROLEP_DEFAULT_SIZE;
#endif

bool Endpoint_ConfigureEndpointTable(const USB_Endpoint_Table_t* const Table,
                                     const uint8_t Entries)
{
    4db0:	0f 93       	push	r16
    4db2:	1f 93       	push	r17
    4db4:	cf 93       	push	r28
    4db6:	df 93       	push	r29
    4db8:	06 2f       	mov	r16, r22
    4dba:	ec 01       	movw	r28, r24
	for (uint8_t i = 0; i < Entries; i++)
    4dbc:	10 e0       	ldi	r17, 0x00	; 0
    4dbe:	10 17       	cp	r17, r16
    4dc0:	71 f1       	breq	.+92     	; 0x4e1e <Endpoint_ConfigureEndpointTable+0x6e>
	{
		if (!(Table[i].Address))
    4dc2:	98 81       	ld	r25, Y
    4dc4:	99 23       	and	r25, r25
    4dc6:	41 f1       	breq	.+80     	; 0x4e18 <Endpoint_ConfigureEndpointTable+0x68>
		  continue;

		if (!(Endpoint_ConfigureEndpoint(Table[i].Address, Table[i].Type, Table[i].Size, Table[i].Banks)))
    4dc8:	2c 81       	ldd	r18, Y+4	; 0x04
    4dca:	e9 81       	ldd	r30, Y+1	; 0x01
    4dcc:	fa 81       	ldd	r31, Y+2	; 0x02
    4dce:	7b 81       	ldd	r23, Y+3	; 0x03
			static inline bool Endpoint_ConfigureEndpoint(const uint8_t Address,
			                                              const uint8_t Type,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				uint8_t Number = (Address & ENDPOINT_EPNUM_MASK);
    4dd0:	89 2f       	mov	r24, r25
    4dd2:	8f 70       	andi	r24, 0x0F	; 15

				if (Number >= ENDPOINT_TOTAL_ENDPOINTS)
    4dd4:	87 30       	cpi	r24, 0x07	; 7
    4dd6:	10 f0       	brcs	.+4      	; 0x4ddc <Endpoint_ConfigureEndpointTable+0x2c>
		  return false;
    4dd8:	80 e0       	ldi	r24, 0x00	; 0
    4dda:	22 c0       	rjmp	.+68     	; 0x4e20 <Endpoint_ConfigureEndpointTable+0x70>
				  return false;

				return Endpoint_ConfigureEndpoint_Prv(Number,
    4ddc:	22 30       	cpi	r18, 0x02	; 2
    4dde:	10 f0       	brcs	.+4      	; 0x4de4 <Endpoint_ConfigureEndpointTable+0x34>
    4de0:	56 e0       	ldi	r21, 0x06	; 6
    4de2:	01 c0       	rjmp	.+2      	; 0x4de6 <Endpoint_ConfigureEndpointTable+0x36>
    4de4:	52 e0       	ldi	r21, 0x02	; 2
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes) ATTR_WARN_UNUSED_RESULT ATTR_CONST
			                                                                       ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes)
			{
				uint8_t  MaskVal    = 0;
				uint16_t CheckBytes = 8;
    4de6:	28 e0       	ldi	r18, 0x08	; 8
    4de8:	30 e0       	ldi	r19, 0x00	; 0
		/* Inline Functions: */
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes) ATTR_WARN_UNUSED_RESULT ATTR_CONST
			                                                                       ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes)
			{
				uint8_t  MaskVal    = 0;
    4dea:	40 e0       	ldi	r20, 0x00	; 0
				uint16_t CheckBytes = 8;

				while (CheckBytes < Bytes)
    4dec:	2e 17       	cp	r18, r30
    4dee:	3f 07       	cpc	r19, r31
    4df0:	20 f4       	brcc	.+8      	; 0x4dfa <Endpoint_ConfigureEndpointTable+0x4a>
				{
					MaskVal++;
    4df2:	4f 5f       	subi	r20, 0xFF	; 255
					CheckBytes <<= 1;
    4df4:	22 0f       	add	r18, r18
    4df6:	33 1f       	adc	r19, r19
    4df8:	f9 cf       	rjmp	.-14     	; 0x4dec <Endpoint_ConfigureEndpointTable+0x3c>
				}

				return (MaskVal << EPSIZE0);
    4dfa:	42 95       	swap	r20
    4dfc:	40 7f       	andi	r20, 0xF0	; 240
				uint8_t Number = (Address & ENDPOINT_EPNUM_MASK);

				if (Number >= ENDPOINT_TOTAL_ENDPOINTS)
				  return false;

				return Endpoint_ConfigureEndpoint_Prv(Number,
    4dfe:	45 2b       	or	r20, r21
				                                      ((Type << EPTYPE0) | ((Address & ENDPOINT_DIR_IN) ? (1 << EPDIR) : 0)),
    4e00:	69 2f       	mov	r22, r25
    4e02:	66 1f       	adc	r22, r22
    4e04:	66 27       	eor	r22, r22
    4e06:	66 1f       	adc	r22, r22
    4e08:	90 e4       	ldi	r25, 0x40	; 64
    4e0a:	79 9f       	mul	r23, r25
    4e0c:	90 01       	movw	r18, r0
    4e0e:	11 24       	eor	r1, r1
				uint8_t Number = (Address & ENDPOINT_EPNUM_MASK);

				if (Number >= ENDPOINT_TOTAL_ENDPOINTS)
				  return false;

				return Endpoint_ConfigureEndpoint_Prv(Number,
    4e10:	62 2b       	or	r22, r18
    4e12:	99 df       	rcall	.-206    	; 0x4d46 <Endpoint_ConfigureEndpoint_Prv>
    4e14:	88 23       	and	r24, r24
	for (uint8_t i = 0; i < Entries; i++)
	{
		if (!(Table[i].Address))
		  continue;

		if (!(Endpoint_ConfigureEndpoint(Table[i].Address, Table[i].Type, Table[i].Size, Table[i].Banks)))
    4e16:	01 f3       	breq	.-64     	; 0x4dd8 <Endpoint_ConfigureEndpointTable+0x28>
    4e18:	1f 5f       	subi	r17, 0xFF	; 255
#endif

bool Endpoint_ConfigureEndpointTable(const USB_Endpoint_Table_t* const Table,
                                     const uint8_t Entries)
{
	for (uint8_t i = 0; i < Entries; i++)
    4e1a:	25 96       	adiw	r28, 0x05	; 5
    4e1c:	d0 cf       	rjmp	.-96     	; 0x4dbe <Endpoint_ConfigureEndpointTable+0xe>
    4e1e:	81 e0       	ldi	r24, 0x01	; 1

		if (!(Endpoint_ConfigureEndpoint(Table[i].Address, Table[i].Type, Table[i].Size, Table[i].Banks)))
		  return false;
	}

	return true;
    4e20:	df 91       	pop	r29
}
    4e22:	cf 91       	pop	r28
    4e24:	1f 91       	pop	r17
    4e26:	0f 91       	pop	r16
    4e28:	08 95       	ret

00004e2a <Endpoint_ClearStatusStage>:
    4e2a:	80 91 dc 0d 	lds	r24, 0x0DDC
	}
}

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
    4e2e:	87 fd       	sbrc	r24, 7
    4e30:	05 c0       	rjmp	.+10     	; 0x4e3c <Endpoint_ClearStatusStage+0x12>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    4e32:	80 91 e8 00 	lds	r24, 0x00E8

		Endpoint_ClearOUT();
	}
	else
	{
		while (!(Endpoint_IsINReady()))
    4e36:	80 ff       	sbrs	r24, 0
    4e38:	0d c0       	rjmp	.+26     	; 0x4e54 <Endpoint_ClearStatusStage+0x2a>
    4e3a:	10 c0       	rjmp	.+32     	; 0x4e5c <Endpoint_ClearStatusStage+0x32>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    4e3c:	80 91 e8 00 	lds	r24, 0x00E8

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
	{
		while (!(Endpoint_IsOUTReceived()))
    4e40:	82 fd       	sbrc	r24, 2
    4e42:	04 c0       	rjmp	.+8      	; 0x4e4c <Endpoint_ClearStatusStage+0x22>
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    4e44:	8e b3       	in	r24, 0x1e	; 30
    4e46:	81 11       	cpse	r24, r1
    4e48:	f9 cf       	rjmp	.-14     	; 0x4e3c <Endpoint_ClearStatusStage+0x12>
    4e4a:	08 95       	ret
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    4e4c:	80 91 e8 00 	lds	r24, 0x00E8
    4e50:	8b 77       	andi	r24, 0x7B	; 123
    4e52:	07 c0       	rjmp	.+14     	; 0x4e62 <Endpoint_ClearStatusStage+0x38>
	}
	else
	{
		while (!(Endpoint_IsINReady()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    4e54:	8e b3       	in	r24, 0x1e	; 30
    4e56:	81 11       	cpse	r24, r1
    4e58:	ec cf       	rjmp	.-40     	; 0x4e32 <Endpoint_ClearStatusStage+0x8>
    4e5a:	08 95       	ret
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    4e5c:	80 91 e8 00 	lds	r24, 0x00E8
    4e60:	8e 77       	andi	r24, 0x7E	; 126
    4e62:	80 93 e8 00 	sts	0x00E8, r24
    4e66:	08 95       	ret

00004e68 <Endpoint_WaitUntilReady>:
			 *  \return Current USB frame number from the USB controller.
			 */
			static inline uint16_t USB_Device_GetFrameNumber(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint16_t USB_Device_GetFrameNumber(void)
			{
				return UDFNUM;
    4e68:	80 91 e4 00 	lds	r24, 0x00E4
    4e6c:	90 91 e5 00 	lds	r25, 0x00E5
    4e70:	45 e6       	ldi	r20, 0x65	; 101
			 *  \return The currently selected endpoint's direction, as a \c ENDPOINT_DIR_* mask.
			 */
			static inline uint8_t Endpoint_GetEndpointDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetEndpointDirection(void)
			{
				return (UECFG0X & (1 << EPDIR)) ? ENDPOINT_DIR_IN : ENDPOINT_DIR_OUT;
    4e72:	20 91 ec 00 	lds	r18, 0x00EC
    4e76:	20 ff       	sbrs	r18, 0
    4e78:	20 c0       	rjmp	.+64     	; 0x4eba <Endpoint_WaitUntilReady+0x52>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    4e7a:	20 91 e8 00 	lds	r18, 0x00E8

	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
		{
			if (Endpoint_IsINReady())
    4e7e:	20 fd       	sbrc	r18, 0
    4e80:	20 c0       	rjmp	.+64     	; 0x4ec2 <Endpoint_WaitUntilReady+0x5a>
		{
			if (Endpoint_IsOUTReceived())
			  return ENDPOINT_READYWAIT_NoError;
		}

		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    4e82:	2e b3       	in	r18, 0x1e	; 30

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    4e84:	22 23       	and	r18, r18
    4e86:	89 f0       	breq	.+34     	; 0x4eaa <Endpoint_WaitUntilReady+0x42>
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    4e88:	25 30       	cpi	r18, 0x05	; 5
    4e8a:	89 f0       	breq	.+34     	; 0x4eae <Endpoint_WaitUntilReady+0x46>
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    4e8c:	20 91 eb 00 	lds	r18, 0x00EB
		  return ENDPOINT_READYWAIT_BusSuspended;
		else if (Endpoint_IsStalled())
    4e90:	25 fd       	sbrc	r18, 5
    4e92:	0f c0       	rjmp	.+30     	; 0x4eb2 <Endpoint_WaitUntilReady+0x4a>
    4e94:	20 91 e4 00 	lds	r18, 0x00E4
    4e98:	30 91 e5 00 	lds	r19, 0x00E5
		  return ENDPOINT_READYWAIT_EndpointStalled;

		uint16_t CurrentFrameNumber = USB_Device_GetFrameNumber();

		if (CurrentFrameNumber != PreviousFrameNumber)
    4e9c:	28 17       	cp	r18, r24
    4e9e:	39 07       	cpc	r19, r25
    4ea0:	41 f3       	breq	.-48     	; 0x4e72 <Endpoint_WaitUntilReady+0xa>
    4ea2:	41 50       	subi	r20, 0x01	; 1
		{
			PreviousFrameNumber = CurrentFrameNumber;

			if (!(TimeoutMSRem--))
    4ea4:	41 f0       	breq	.+16     	; 0x4eb6 <Endpoint_WaitUntilReady+0x4e>
    4ea6:	c9 01       	movw	r24, r18
    4ea8:	e4 cf       	rjmp	.-56     	; 0x4e72 <Endpoint_WaitUntilReady+0xa>
		}

		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
    4eaa:	82 e0       	ldi	r24, 0x02	; 2
    4eac:	08 95       	ret
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_READYWAIT_BusSuspended;
    4eae:	83 e0       	ldi	r24, 0x03	; 3
    4eb0:	08 95       	ret
		else if (Endpoint_IsStalled())
		  return ENDPOINT_READYWAIT_EndpointStalled;
    4eb2:	81 e0       	ldi	r24, 0x01	; 1
    4eb4:	08 95       	ret
		if (CurrentFrameNumber != PreviousFrameNumber)
		{
			PreviousFrameNumber = CurrentFrameNumber;

			if (!(TimeoutMSRem--))
			  return ENDPOINT_READYWAIT_Timeout;
    4eb6:	84 e0       	ldi	r24, 0x04	; 4
    4eb8:	08 95       	ret
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    4eba:	20 91 e8 00 	lds	r18, 0x00E8
			if (Endpoint_IsINReady())
			  return ENDPOINT_READYWAIT_NoError;
		}
		else
		{
			if (Endpoint_IsOUTReceived())
    4ebe:	22 ff       	sbrs	r18, 2
    4ec0:	e0 cf       	rjmp	.-64     	; 0x4e82 <Endpoint_WaitUntilReady+0x1a>
	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
		{
			if (Endpoint_IsINReady())
			  return ENDPOINT_READYWAIT_NoError;
    4ec2:	80 e0       	ldi	r24, 0x00	; 0
    4ec4:	08 95       	ret

00004ec6 <USB_Host_ResetDevice>:
			 *  \return Boolean \c true if the bus is currently suspended, \c false otherwise.
			 */
			static inline bool USB_Host_IsBusSuspended(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool USB_Host_IsBusSuspended(void)
			{
				return ((UHCON & (1 << SOFEN)) ? false : true);
    4ec6:	80 91 9e 00 	lds	r24, 0x009E
    4eca:	81 70       	andi	r24, 0x01	; 1
						break;
					case USB_INT_DCONNI:
						UHIEN  &= ~(1 << DCONNE);
						break;
					case USB_INT_DDISCI:
						UHIEN  &= ~(1 << DDISCE);
    4ecc:	90 91 a0 00 	lds	r25, 0x00A0
    4ed0:	9d 7f       	andi	r25, 0xFD	; 253
    4ed2:	90 93 a0 00 	sts	0x00A0, r25
			 *  woken up automatically and the bus resumed after the reset has been correctly issued.
			 */
			static inline void USB_Host_ResetBus(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_ResetBus(void)
			{
				UHCON |=  (1 << RESET);
    4ed6:	90 91 9e 00 	lds	r25, 0x009E
    4eda:	92 60       	ori	r25, 0x02	; 2
    4edc:	90 93 9e 00 	sts	0x009E, r25
			 *  \return Boolean \c true if no bus reset is currently being sent, \c false otherwise.
			 */
			static inline bool USB_Host_IsBusResetComplete(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool USB_Host_IsBusResetComplete(void)
			{
				return ((UHCON & (1 << RESET)) ? false : true);
    4ee0:	90 91 9e 00 	lds	r25, 0x009E
	bool BusSuspended = USB_Host_IsBusSuspended();

	USB_INT_Disable(USB_INT_DDISCI);

	USB_Host_ResetBus();
	while (!(USB_Host_IsBusResetComplete()));
    4ee4:	91 fd       	sbrc	r25, 1
    4ee6:	fc cf       	rjmp	.-8      	; 0x4ee0 <USB_Host_ResetDevice+0x1a>
			 *  host and attached device may occur.
			 */
			static inline void USB_Host_ResumeBus(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_ResumeBus(void)
			{
				UHCON |=  (1 << SOFEN);
    4ee8:	90 91 9e 00 	lds	r25, 0x009E
    4eec:	91 60       	ori	r25, 0x01	; 1
    4eee:	90 93 9e 00 	sts	0x009E, r25
	USB_Host_ResumeBus();

	USB_Host_ConfigurationNumber = 0;
    4ef2:	10 92 da 0d 	sts	0x0DDA, r1
					case USB_INT_RXSTPI:
						return (UEIENX & (1 << RXSTPE));
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						return (UHIEN  & (1 << HSOFE));
    4ef6:	90 91 a0 00 	lds	r25, 0x00A0
    4efa:	90 72       	andi	r25, 0x20	; 32
						UEIENX &= ~(1 << RXSTPE);
						break;
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						UHIEN  &= ~(1 << HSOFE);
    4efc:	20 91 a0 00 	lds	r18, 0x00A0
    4f00:	2f 7d       	andi	r18, 0xDF	; 223
    4f02:	20 93 a0 00 	sts	0x00A0, r18
						UEINTX &= ~(1 << RXSTPI);
						break;
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						UHINT  &= ~(1 << HSOFI);
    4f06:	20 91 9f 00 	lds	r18, 0x009F
    4f0a:	2f 7d       	andi	r18, 0xDF	; 223
    4f0c:	20 93 9f 00 	sts	0x009F, r18
    4f10:	2a e0       	ldi	r18, 0x0A	; 10
					case USB_INT_RXSTPI:
						return (UEINTX & (1 << RXSTPI));
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						return (UHINT  & (1 << HSOFI));
    4f12:	30 91 9f 00 	lds	r19, 0x009F
		/* Workaround for powerless-pull-up devices. After a USB bus reset,
		   all disconnection interrupts are suppressed while a USB frame is
		   looked for - if it is found within 10ms, the device is still
		   present.                                                        */

		if (USB_INT_HasOccurred(USB_INT_HSOFI))
    4f16:	35 ff       	sbrs	r19, 5
    4f18:	0b c0       	rjmp	.+22     	; 0x4f30 <USB_Host_ResetDevice+0x6a>
						UEINTX &= ~(1 << RXSTPI);
						break;
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						UHINT  &= ~(1 << HSOFI);
    4f1a:	20 91 9f 00 	lds	r18, 0x009F
    4f1e:	2f 7d       	andi	r18, 0xDF	; 223
    4f20:	20 93 9f 00 	sts	0x009F, r18
						break;
					case USB_INT_DCONNI:
						UHINT  &= ~(1 << DCONNI);
						break;
					case USB_INT_DDISCI:
						UHINT  &= ~(1 << DDISCI);
    4f24:	20 91 9f 00 	lds	r18, 0x009F
    4f28:	2d 7f       	andi	r18, 0xFD	; 253
    4f2a:	20 93 9f 00 	sts	0x009F, r18
    4f2e:	08 c0       	rjmp	.+16     	; 0x4f40 <USB_Host_ResetDevice+0x7a>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    4f30:	ef ec       	ldi	r30, 0xCF	; 207
    4f32:	f7 e0       	ldi	r31, 0x07	; 7
    4f34:	31 97       	sbiw	r30, 0x01	; 1
    4f36:	f1 f7       	brne	.-4      	; 0x4f34 <USB_Host_ResetDevice+0x6e>
    4f38:	00 c0       	rjmp	.+0      	; 0x4f3a <USB_Host_ResetDevice+0x74>
    4f3a:	00 00       	nop
    4f3c:	21 50       	subi	r18, 0x01	; 1
	bool HSOFIEnabled = USB_INT_IsEnabled(USB_INT_HSOFI);

	USB_INT_Disable(USB_INT_HSOFI);
	USB_INT_Clear(USB_INT_HSOFI);

	for (uint8_t MSRem = 10; MSRem != 0; MSRem--)
    4f3e:	49 f7       	brne	.-46     	; 0x4f12 <USB_Host_ResetDevice+0x4c>
		}

		Delay_MS(1);
	}

	if (HSOFIEnabled)
    4f40:	99 23       	and	r25, r25
    4f42:	29 f0       	breq	.+10     	; 0x4f4e <USB_Host_ResetDevice+0x88>
						UEIENX |= (1 << RXSTPE);
						break;
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						UHIEN  |= (1 << HSOFE);
    4f44:	90 91 a0 00 	lds	r25, 0x00A0
    4f48:	90 62       	ori	r25, 0x20	; 32
    4f4a:	90 93 a0 00 	sts	0x00A0, r25
	  USB_INT_Enable(USB_INT_HSOFI);

	if (BusSuspended)
    4f4e:	81 11       	cpse	r24, r1
    4f50:	05 c0       	rjmp	.+10     	; 0x4f5c <USB_Host_ResetDevice+0x96>
			 *             some events (such as device disconnections) will not fire until the bus is resumed.
			 */
			static inline void USB_Host_SuspendBus(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_SuspendBus(void)
			{
				UHCON &= ~(1 << SOFEN);
    4f52:	80 91 9e 00 	lds	r24, 0x009E
    4f56:	8e 7f       	andi	r24, 0xFE	; 254
    4f58:	80 93 9e 00 	sts	0x009E, r24
						break;
					case USB_INT_DCONNI:
						UHIEN  |= (1 << DCONNE);
						break;
					case USB_INT_DDISCI:
						UHIEN  |= (1 << DDISCE);
    4f5c:	80 91 a0 00 	lds	r24, 0x00A0
    4f60:	82 60       	ori	r24, 0x02	; 2
    4f62:	80 93 a0 00 	sts	0x00A0, r24
    4f66:	08 95       	ret

00004f68 <USB_Host_WaitMS>:
			 *  \return Boolean \c true if the bus is currently suspended, \c false otherwise.
			 */
			static inline bool USB_Host_IsBusSuspended(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool USB_Host_IsBusSuspended(void)
			{
				return ((UHCON & (1 << SOFEN)) ? false : true);
    4f68:	20 91 9e 00 	lds	r18, 0x009E
    4f6c:	21 70       	andi	r18, 0x01	; 1
					case USB_INT_RXSTPI:
						return (UEIENX & (1 << RXSTPE));
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						return (UHIEN  & (1 << HSOFE));
    4f6e:	90 91 a0 00 	lds	r25, 0x00A0
    4f72:	90 72       	andi	r25, 0x20	; 32
						UEIENX &= ~(1 << RXSTPE);
						break;
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						UHIEN  &= ~(1 << HSOFE);
    4f74:	30 91 a0 00 	lds	r19, 0x00A0
    4f78:	3f 7d       	andi	r19, 0xDF	; 223
    4f7a:	30 93 a0 00 	sts	0x00A0, r19
						UEINTX &= ~(1 << RXSTPI);
						break;
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						UHINT  &= ~(1 << HSOFI);
    4f7e:	30 91 9f 00 	lds	r19, 0x009F
    4f82:	3f 7d       	andi	r19, 0xDF	; 223
    4f84:	30 93 9f 00 	sts	0x009F, r19
			 *  host and attached device may occur.
			 */
			static inline void USB_Host_ResumeBus(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_ResumeBus(void)
			{
				UHCON |=  (1 << SOFEN);
    4f88:	30 91 9e 00 	lds	r19, 0x009E
    4f8c:	31 60       	ori	r19, 0x01	; 1
    4f8e:	30 93 9e 00 	sts	0x009E, r19
	USB_INT_Disable(USB_INT_HSOFI);
	USB_INT_Clear(USB_INT_HSOFI);

	USB_Host_ResumeBus();

	while (MS)
    4f92:	88 23       	and	r24, r24
    4f94:	51 f1       	breq	.+84     	; 0x4fea <USB_Host_WaitMS+0x82>
					case USB_INT_RXSTPI:
						return (UEINTX & (1 << RXSTPI));
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						return (UHINT  & (1 << HSOFI));
    4f96:	30 91 9f 00 	lds	r19, 0x009F
	{
		if (USB_INT_HasOccurred(USB_INT_HSOFI))
    4f9a:	35 ff       	sbrs	r19, 5
    4f9c:	06 c0       	rjmp	.+12     	; 0x4faa <USB_Host_WaitMS+0x42>
						UEINTX &= ~(1 << RXSTPI);
						break;
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						UHINT  &= ~(1 << HSOFI);
    4f9e:	30 91 9f 00 	lds	r19, 0x009F
    4fa2:	3f 7d       	andi	r19, 0xDF	; 223
    4fa4:	30 93 9f 00 	sts	0x009F, r19
		{
			USB_INT_Clear(USB_INT_HSOFI);
			MS--;
    4fa8:	81 50       	subi	r24, 0x01	; 1
		}

		if ((USB_HostState == HOST_STATE_Unattached) || (USB_CurrentMode != USB_MODE_Host))
    4faa:	3e b3       	in	r19, 0x1e	; 30
    4fac:	31 30       	cpi	r19, 0x01	; 1
    4fae:	e1 f0       	breq	.+56     	; 0x4fe8 <USB_Host_WaitMS+0x80>
    4fb0:	30 91 07 04 	lds	r19, 0x0407
    4fb4:	32 30       	cpi	r19, 0x02	; 2
    4fb6:	c1 f4       	brne	.+48     	; 0x4fe8 <USB_Host_WaitMS+0x80>
			 *  \return Boolean \c true if an error has occurred on the selected pipe, \c false otherwise.
			 */
			static inline bool Pipe_IsError(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsError(void)
			{
				return ((UPINTX & (1 << PERRI)) ? true : false);
    4fb8:	30 91 a6 00 	lds	r19, 0x00A6
			ErrorCode = HOST_WAITERROR_DeviceDisconnect;

			break;
		}

		if (Pipe_IsError())
    4fbc:	34 ff       	sbrs	r19, 4
    4fbe:	09 c0       	rjmp	.+18     	; 0x4fd2 <USB_Host_WaitMS+0x6a>

			/** Clears the error flags for the currently selected pipe. */
			static inline void Pipe_ClearError(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearError(void)
			{
				UPERRX = 0;
    4fc0:	10 92 f5 00 	sts	0x00F5, r1
				UPINTX &= ~(1 << PERRI);
    4fc4:	80 91 a6 00 	lds	r24, 0x00A6
    4fc8:	8f 7e       	andi	r24, 0xEF	; 239
    4fca:	80 93 a6 00 	sts	0x00A6, r24
		{
			Pipe_ClearError();
			ErrorCode = HOST_WAITERROR_PipeError;
    4fce:	82 e0       	ldi	r24, 0x02	; 2

			break;
    4fd0:	0c c0       	rjmp	.+24     	; 0x4fea <USB_Host_WaitMS+0x82>
			 *  \return Boolean \c true if the current pipe has been stalled by the attached device, \c false otherwise.
			 */
			static inline bool Pipe_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsStalled(void)
			{
				return ((UPINTX & (1 << RXSTALLI)) ? true : false);
    4fd2:	30 91 a6 00 	lds	r19, 0x00A6
		}

		if (Pipe_IsStalled())
    4fd6:	31 ff       	sbrs	r19, 1
    4fd8:	dc cf       	rjmp	.-72     	; 0x4f92 <USB_Host_WaitMS+0x2a>
			 *  \ingroup Group_PipePacketManagement_AVR8
			 */
			static inline void Pipe_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearStall(void)
			{
				UPINTX &= ~(1 << RXSTALLI);
    4fda:	80 91 a6 00 	lds	r24, 0x00A6
    4fde:	8d 7f       	andi	r24, 0xFD	; 253
    4fe0:	80 93 a6 00 	sts	0x00A6, r24
		{
			Pipe_ClearStall();
			ErrorCode = HOST_WAITERROR_SetupStalled;
    4fe4:	83 e0       	ldi	r24, 0x03	; 3

			break;
    4fe6:	01 c0       	rjmp	.+2      	; 0x4fea <USB_Host_WaitMS+0x82>
			MS--;
		}

		if ((USB_HostState == HOST_STATE_Unattached) || (USB_CurrentMode != USB_MODE_Host))
		{
			ErrorCode = HOST_WAITERROR_DeviceDisconnect;
    4fe8:	81 e0       	ldi	r24, 0x01	; 1

			break;
		}
	}

	if (BusSuspended)
    4fea:	21 11       	cpse	r18, r1
    4fec:	05 c0       	rjmp	.+10     	; 0x4ff8 <USB_Host_WaitMS+0x90>
			 *             some events (such as device disconnections) will not fire until the bus is resumed.
			 */
			static inline void USB_Host_SuspendBus(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_SuspendBus(void)
			{
				UHCON &= ~(1 << SOFEN);
    4fee:	20 91 9e 00 	lds	r18, 0x009E
    4ff2:	2e 7f       	andi	r18, 0xFE	; 254
    4ff4:	20 93 9e 00 	sts	0x009E, r18
	  USB_Host_SuspendBus();

	if (HSOFIEnabled)
    4ff8:	99 23       	and	r25, r25
    4ffa:	29 f0       	breq	.+10     	; 0x5006 <USB_Host_WaitMS+0x9e>
						UEIENX |= (1 << RXSTPE);
						break;
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						UHIEN  |= (1 << HSOFE);
    4ffc:	90 91 a0 00 	lds	r25, 0x00A0
    5000:	90 62       	ori	r25, 0x20	; 32
    5002:	90 93 a0 00 	sts	0x00A0, r25
	  USB_INT_Enable(USB_INT_HSOFI);

	return ErrorCode;
}
    5006:	08 95       	ret

00005008 <USB_Host_ProcessNextHostState>:

#define  __INCLUDE_FROM_HOST_C
#include "../Host.h"

void USB_Host_ProcessNextHostState(void)
{
    5008:	0f 93       	push	r16
    500a:	1f 93       	push	r17
    500c:	cf 93       	push	r28
    500e:	df 93       	push	r29
    5010:	cd b7       	in	r28, 0x3d	; 61
    5012:	de b7       	in	r29, 0x3e	; 62
    5014:	28 97       	sbiw	r28, 0x08	; 8
    5016:	0f b6       	in	r0, 0x3f	; 63
    5018:	f8 94       	cli
    501a:	de bf       	out	0x3e, r29	; 62
    501c:	0f be       	out	0x3f, r0	; 63
    501e:	cd bf       	out	0x3d, r28	; 61
	uint8_t SubErrorCode = HOST_ENUMERROR_NoError;

	static uint16_t WaitMSRemaining;
	static uint8_t  PostWaitState;

	switch (USB_HostState)
    5020:	8e b3       	in	r24, 0x1e	; 30
    5022:	85 30       	cpi	r24, 0x05	; 5
    5024:	09 f4       	brne	.+2      	; 0x5028 <USB_Host_ProcessNextHostState+0x20>
    5026:	98 c0       	rjmp	.+304    	; 0x5158 <USB_Host_ProcessNextHostState+0x150>
    5028:	60 f4       	brcc	.+24     	; 0x5042 <USB_Host_ProcessNextHostState+0x3a>
    502a:	82 30       	cpi	r24, 0x02	; 2
    502c:	d1 f1       	breq	.+116    	; 0x50a2 <USB_Host_ProcessNextHostState+0x9a>
    502e:	18 f4       	brcc	.+6      	; 0x5036 <USB_Host_ProcessNextHostState+0x2e>
    5030:	88 23       	and	r24, r24
    5032:	d1 f0       	breq	.+52     	; 0x5068 <USB_Host_ProcessNextHostState+0x60>
    5034:	f9 c0       	rjmp	.+498    	; 0x5228 <USB_Host_ProcessNextHostState+0x220>
    5036:	83 30       	cpi	r24, 0x03	; 3
    5038:	e9 f1       	breq	.+122    	; 0x50b4 <USB_Host_ProcessNextHostState+0xac>
    503a:	84 30       	cpi	r24, 0x04	; 4
    503c:	09 f4       	brne	.+2      	; 0x5040 <USB_Host_ProcessNextHostState+0x38>
    503e:	65 c0       	rjmp	.+202    	; 0x510a <USB_Host_ProcessNextHostState+0x102>
    5040:	f3 c0       	rjmp	.+486    	; 0x5228 <USB_Host_ProcessNextHostState+0x220>
    5042:	87 30       	cpi	r24, 0x07	; 7
    5044:	09 f4       	brne	.+2      	; 0x5048 <USB_Host_ProcessNextHostState+0x40>
    5046:	a2 c0       	rjmp	.+324    	; 0x518c <USB_Host_ProcessNextHostState+0x184>
    5048:	08 f4       	brcc	.+2      	; 0x504c <USB_Host_ProcessNextHostState+0x44>
    504a:	92 c0       	rjmp	.+292    	; 0x5170 <USB_Host_ProcessNextHostState+0x168>
    504c:	88 30       	cpi	r24, 0x08	; 8
    504e:	09 f4       	brne	.+2      	; 0x5052 <USB_Host_ProcessNextHostState+0x4a>
    5050:	ba c0       	rjmp	.+372    	; 0x51c6 <USB_Host_ProcessNextHostState+0x1be>
    5052:	89 30       	cpi	r24, 0x09	; 9
    5054:	09 f0       	breq	.+2      	; 0x5058 <USB_Host_ProcessNextHostState+0x50>
    5056:	e8 c0       	rjmp	.+464    	; 0x5228 <USB_Host_ProcessNextHostState+0x220>
			}

			static inline void USB_Host_SetDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_SetDeviceAddress(const uint8_t Address)
			{
				UHADDR  =  (Address & 0x7F);
    5058:	81 e0       	ldi	r24, 0x01	; 1
    505a:	80 93 a1 00 	sts	0x00A1, r24
			HOST_TASK_NONBLOCK_WAIT(100, HOST_STATE_Default_PostAddressSet);
			break;
		case HOST_STATE_Default_PostAddressSet:
			USB_Host_SetDeviceAddress(USB_HOST_DEVICEADDRESS);

			USB_HostState = HOST_STATE_Addressed;
    505e:	8a e0       	ldi	r24, 0x0A	; 10
    5060:	8e bb       	out	0x1e, r24	; 30

			EVENT_USB_Host_DeviceEnumerationComplete();
    5062:	0e 94 e9 02 	call	0x5d2	; 0x5d2 <EVENT_USB_Host_DeviceEnumerationComplete>
			break;
    5066:	e0 c0       	rjmp	.+448    	; 0x5228 <USB_Host_ProcessNextHostState+0x220>
	static uint8_t  PostWaitState;

	switch (USB_HostState)
	{
		case HOST_STATE_WaitForDevice:
			if (WaitMSRemaining)
    5068:	00 91 05 04 	lds	r16, 0x0405
    506c:	10 91 06 04 	lds	r17, 0x0406
    5070:	01 15       	cp	r16, r1
    5072:	11 05       	cpc	r17, r1
    5074:	09 f4       	brne	.+2      	; 0x5078 <USB_Host_ProcessNextHostState+0x70>
    5076:	d8 c0       	rjmp	.+432    	; 0x5228 <USB_Host_ProcessNextHostState+0x220>
			{
				if ((SubErrorCode = USB_Host_WaitMS(1)) != HOST_WAITERROR_Successful)
    5078:	81 e0       	ldi	r24, 0x01	; 1
    507a:	76 df       	rcall	.-276    	; 0x4f68 <USB_Host_WaitMS>
    507c:	88 23       	and	r24, r24
    507e:	29 f0       	breq	.+10     	; 0x508a <USB_Host_ProcessNextHostState+0x82>
    5080:	90 91 04 04 	lds	r25, 0x0404
				{
					USB_HostState = PostWaitState;
    5084:	9e bb       	out	0x1e, r25	; 30
    5086:	91 e0       	ldi	r25, 0x01	; 1
					ErrorCode     = HOST_ENUMERROR_WaitStage;
    5088:	c0 c0       	rjmp	.+384    	; 0x520a <USB_Host_ProcessNextHostState+0x202>
					break;
    508a:	01 50       	subi	r16, 0x01	; 1
				}

				if (!(--WaitMSRemaining))
    508c:	11 09       	sbc	r17, r1
    508e:	10 93 06 04 	sts	0x0406, r17
    5092:	00 93 05 04 	sts	0x0405, r16
    5096:	01 2b       	or	r16, r17
    5098:	09 f0       	breq	.+2      	; 0x509c <USB_Host_ProcessNextHostState+0x94>
    509a:	c6 c0       	rjmp	.+396    	; 0x5228 <USB_Host_ProcessNextHostState+0x220>
    509c:	80 91 04 04 	lds	r24, 0x0404
				  USB_HostState = PostWaitState;
    50a0:	07 c0       	rjmp	.+14     	; 0x50b0 <USB_Host_ProcessNextHostState+0xa8>
    50a2:	88 ee       	ldi	r24, 0xE8	; 232
			}

			break;
		case HOST_STATE_Powered:
			WaitMSRemaining = HOST_DEVICE_SETTLE_DELAY_MS;
    50a4:	93 e0       	ldi	r25, 0x03	; 3
    50a6:	90 93 06 04 	sts	0x0406, r25
    50aa:	80 93 05 04 	sts	0x0405, r24
    50ae:	83 e0       	ldi	r24, 0x03	; 3

			USB_HostState = HOST_STATE_Powered_WaitForDeviceSettle;
    50b0:	8e bb       	out	0x1e, r24	; 30
    50b2:	ba c0       	rjmp	.+372    	; 0x5228 <USB_Host_ProcessNextHostState+0x220>
			break;
    50b4:	80 91 05 04 	lds	r24, 0x0405
		case HOST_STATE_Powered_WaitForDeviceSettle:
			if (WaitMSRemaining--)
    50b8:	90 91 06 04 	lds	r25, 0x0406
    50bc:	9c 01       	movw	r18, r24
    50be:	21 50       	subi	r18, 0x01	; 1
    50c0:	31 09       	sbc	r19, r1
    50c2:	30 93 06 04 	sts	0x0406, r19
    50c6:	20 93 05 04 	sts	0x0405, r18
    50ca:	89 2b       	or	r24, r25
    50cc:	39 f0       	breq	.+14     	; 0x50dc <USB_Host_ProcessNextHostState+0xd4>
    50ce:	8f ec       	ldi	r24, 0xCF	; 207
    50d0:	97 e0       	ldi	r25, 0x07	; 7
    50d2:	01 97       	sbiw	r24, 0x01	; 1
    50d4:	f1 f7       	brne	.-4      	; 0x50d2 <USB_Host_ProcessNextHostState+0xca>
    50d6:	00 c0       	rjmp	.+0      	; 0x50d8 <USB_Host_ProcessNextHostState+0xd0>
    50d8:	00 00       	nop
    50da:	a6 c0       	rjmp	.+332    	; 0x5228 <USB_Host_ProcessNextHostState+0x220>
    50dc:	77 98       	cbi	0x0e, 7	; 14
			static inline void USB_Host_VBUS_Manual_Off(void)
			{
				#if defined(INVERTED_VBUS_ENABLE_LINE)
				PORTE  |=  (1 << 7);
				#else
				PORTE  &= ~(1 << 7);
    50de:	80 91 d8 00 	lds	r24, 0x00D8

			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
			static inline void USB_OTGPAD_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_OTGPAD_On(void)
			{
				USBCON |=  (1 << OTGPADE);
    50e2:	80 61       	ori	r24, 0x10	; 16
    50e4:	80 93 d8 00 	sts	0x00D8, r24
    50e8:	80 91 dd 00 	lds	r24, 0x00DD
			}

			static inline void USB_Host_VBUS_Auto_Enable(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_VBUS_Auto_Enable(void)
			{
				OTGCON &= ~(1 << VBUSHWC);
    50ec:	8b 7f       	andi	r24, 0xFB	; 251
    50ee:	80 93 dd 00 	sts	0x00DD, r24
    50f2:	80 91 d7 00 	lds	r24, 0x00D7
				UHWCON |=  (1 << UVCONE);
    50f6:	80 61       	ori	r24, 0x10	; 16
    50f8:	80 93 d7 00 	sts	0x00D7, r24
    50fc:	80 91 dd 00 	lds	r24, 0x00DD
			}

			static inline void USB_Host_VBUS_Auto_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_VBUS_Auto_On(void)
			{
				OTGCON |=  (1 << VBUSREQ);
    5100:	82 60       	ori	r24, 0x02	; 2
    5102:	80 93 dd 00 	sts	0x00DD, r24
    5106:	84 e0       	ldi	r24, 0x04	; 4
				#if defined(NO_AUTO_VBUS_MANAGEMENT)
				USB_Host_VBUS_Manual_Enable();
				USB_Host_VBUS_Manual_On();
				#endif

				USB_HostState = HOST_STATE_Powered_WaitForConnect;
    5108:	d3 cf       	rjmp	.-90     	; 0x50b0 <USB_Host_ProcessNextHostState+0xa8>
    510a:	80 91 9f 00 	lds	r24, 0x009F
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						return (UHINT  & (1 << HSOFI));
					case USB_INT_DCONNI:
						return (UHINT  & (1 << DCONNI));
    510e:	80 ff       	sbrs	r24, 0
			}

			break;
		case HOST_STATE_Powered_WaitForConnect:
			if (USB_INT_HasOccurred(USB_INT_DCONNI))
    5110:	8b c0       	rjmp	.+278    	; 0x5228 <USB_Host_ProcessNextHostState+0x220>
    5112:	80 91 9f 00 	lds	r24, 0x009F
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						UHINT  &= ~(1 << HSOFI);
						break;
					case USB_INT_DCONNI:
						UHINT  &= ~(1 << DCONNI);
    5116:	8e 7f       	andi	r24, 0xFE	; 254
    5118:	80 93 9f 00 	sts	0x009F, r24
    511c:	80 91 9f 00 	lds	r24, 0x009F
						break;
					case USB_INT_DDISCI:
						UHINT  &= ~(1 << DDISCI);
    5120:	8d 7f       	andi	r24, 0xFD	; 253
    5122:	80 93 9f 00 	sts	0x009F, r24
    5126:	80 91 df 00 	lds	r24, 0x00DF
						break;
					case USB_INT_BCERRI:
						OTGINT &= ~(1 << BCERRI);
						break;
					case USB_INT_VBERRI:
						OTGINT &= ~(1 << VBERRI);
    512a:	8d 7f       	andi	r24, 0xFD	; 253
    512c:	80 93 df 00 	sts	0x00DF, r24
    5130:	80 91 de 00 	lds	r24, 0x00DE
						break;
					case USB_INT_BCERRI:
						OTGIEN |= (1 << BCERRE);
						break;
					case USB_INT_VBERRI:
						OTGIEN |= (1 << VBERRE);
    5134:	82 60       	ori	r24, 0x02	; 2
    5136:	80 93 de 00 	sts	0x00DE, r24
    513a:	80 91 9e 00 	lds	r24, 0x009E
			 *  host and attached device may occur.
			 */
			static inline void USB_Host_ResumeBus(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_ResumeBus(void)
			{
				UHCON |=  (1 << SOFEN);
    513e:	81 60       	ori	r24, 0x01	; 1
    5140:	80 93 9e 00 	sts	0x009E, r24
    5144:	e0 d1       	rcall	.+960    	; 0x5506 <Pipe_ClearPipes>

				USB_INT_Clear(USB_INT_VBERRI);
				USB_INT_Enable(USB_INT_VBERRI);

				USB_Host_ResumeBus();
				Pipe_ClearPipes();
    5146:	1e ba       	out	0x1e, r1	; 30
    5148:	84 e6       	ldi	r24, 0x64	; 100

				HOST_TASK_NONBLOCK_WAIT(100, HOST_STATE_Powered_DoReset);
    514a:	90 e0       	ldi	r25, 0x00	; 0
    514c:	90 93 06 04 	sts	0x0406, r25
    5150:	80 93 05 04 	sts	0x0405, r24
    5154:	85 e0       	ldi	r24, 0x05	; 5
    5156:	09 c0       	rjmp	.+18     	; 0x516a <USB_Host_ProcessNextHostState+0x162>
    5158:	b6 de       	rcall	.-660    	; 0x4ec6 <USB_Host_ResetDevice>
    515a:	1e ba       	out	0x1e, r1	; 30
			}

			break;
		case HOST_STATE_Powered_DoReset:
			USB_Host_ResetDevice();
    515c:	88 ec       	ldi	r24, 0xC8	; 200
    515e:	90 e0       	ldi	r25, 0x00	; 0

			HOST_TASK_NONBLOCK_WAIT(200, HOST_STATE_Powered_ConfigPipe);
    5160:	90 93 06 04 	sts	0x0406, r25
    5164:	80 93 05 04 	sts	0x0405, r24
    5168:	86 e0       	ldi	r24, 0x06	; 6
    516a:	80 93 04 04 	sts	0x0404, r24
    516e:	5c c0       	rjmp	.+184    	; 0x5228 <USB_Host_ProcessNextHostState+0x220>
    5170:	01 e0       	ldi	r16, 0x01	; 1
    5172:	20 e4       	ldi	r18, 0x40	; 64
			break;
    5174:	30 e0       	ldi	r19, 0x00	; 0
		case HOST_STATE_Powered_ConfigPipe:
			if (!(Pipe_ConfigurePipe(PIPE_CONTROLPIPE, EP_TYPE_CONTROL, ENDPOINT_CONTROLEP, PIPE_CONTROLPIPE_DEFAULT_SIZE, 1)))
    5176:	40 e0       	ldi	r20, 0x00	; 0
    5178:	60 e0       	ldi	r22, 0x00	; 0
    517a:	80 e0       	ldi	r24, 0x00	; 0
    517c:	3d d1       	rcall	.+634    	; 0x53f8 <Pipe_ConfigurePipe>
    517e:	81 11       	cpse	r24, r1
    5180:	03 c0       	rjmp	.+6      	; 0x5188 <USB_Host_ProcessNextHostState+0x180>
    5182:	80 e0       	ldi	r24, 0x00	; 0
    5184:	94 e0       	ldi	r25, 0x04	; 4
    5186:	41 c0       	rjmp	.+130    	; 0x520a <USB_Host_ProcessNextHostState+0x202>
    5188:	87 e0       	ldi	r24, 0x07	; 7
			{
				ErrorCode    = HOST_ENUMERROR_PipeConfigError;
				SubErrorCode = 0;
    518a:	92 cf       	rjmp	.-220    	; 0x50b0 <USB_Host_ProcessNextHostState+0xa8>
			HOST_TASK_NONBLOCK_WAIT(200, HOST_STATE_Powered_ConfigPipe);
			break;
		case HOST_STATE_Powered_ConfigPipe:
			if (!(Pipe_ConfigurePipe(PIPE_CONTROLPIPE, EP_TYPE_CONTROL, ENDPOINT_CONTROLEP, PIPE_CONTROLPIPE_DEFAULT_SIZE, 1)))
			{
				ErrorCode    = HOST_ENUMERROR_PipeConfigError;
    518c:	88 e0       	ldi	r24, 0x08	; 8
    518e:	e8 ee       	ldi	r30, 0xE8	; 232
				SubErrorCode = 0;
				break;
			}

			USB_HostState = HOST_STATE_Default;
    5190:	f1 e0       	ldi	r31, 0x01	; 1
    5192:	ac ed       	ldi	r26, 0xDC	; 220
			break;
		case HOST_STATE_Default:
			USB_ControlRequest = (USB_Request_Header_t)
    5194:	bd e0       	ldi	r27, 0x0D	; 13
    5196:	01 90       	ld	r0, Z+
    5198:	0d 92       	st	X+, r0
    519a:	8a 95       	dec	r24
    519c:	e1 f7       	brne	.-8      	; 0x5196 <USB_Host_ProcessNextHostState+0x18e>
    519e:	10 92 a7 00 	sts	0x00A7, r1
    51a2:	ce 01       	movw	r24, r28
    51a4:	01 96       	adiw	r24, 0x01	; 1
			 *  \param[in] Address  Address of the pipe to select.
			 */
			static inline void Pipe_SelectPipe(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SelectPipe(const uint8_t Address)
			{
				UPNUM = (Address & PIPE_PIPENUM_MASK);
    51a6:	c2 d6       	rcall	.+3460   	; 0x5f2c <USB_Host_SendControlRequest>
    51a8:	81 11       	cpse	r24, r1
				};

			uint8_t DataBuffer[8];

			Pipe_SelectPipe(PIPE_CONTROLPIPE);
			if ((SubErrorCode = USB_Host_SendControlRequest(DataBuffer)) != HOST_SENDCONTROL_Successful)
    51aa:	2e c0       	rjmp	.+92     	; 0x5208 <USB_Host_ProcessNextHostState+0x200>
    51ac:	88 85       	ldd	r24, Y+8	; 0x08
    51ae:	80 93 8d 01 	sts	0x018D, r24
    51b2:	89 de       	rcall	.-750    	; 0x4ec6 <USB_Host_ResetDevice>
    51b4:	1e ba       	out	0x1e, r1	; 30
			{
				ErrorCode = HOST_ENUMERROR_ControlError;
				break;
			}

			USB_Host_ControlPipeSize = DataBuffer[offsetof(USB_Descriptor_Device_t, Endpoint0Size)];
    51b6:	88 ec       	ldi	r24, 0xC8	; 200
    51b8:	90 e0       	ldi	r25, 0x00	; 0
    51ba:	90 93 06 04 	sts	0x0406, r25

			USB_Host_ResetDevice();
    51be:	80 93 05 04 	sts	0x0405, r24

			HOST_TASK_NONBLOCK_WAIT(200, HOST_STATE_Default_PostReset);
    51c2:	88 e0       	ldi	r24, 0x08	; 8
    51c4:	d2 cf       	rjmp	.-92     	; 0x516a <USB_Host_ProcessNextHostState+0x162>
    51c6:	20 91 8d 01 	lds	r18, 0x018D
    51ca:	30 e0       	ldi	r19, 0x00	; 0
    51cc:	01 e0       	ldi	r16, 0x01	; 1
    51ce:	40 e0       	ldi	r20, 0x00	; 0
    51d0:	60 e0       	ldi	r22, 0x00	; 0
			break;
		case HOST_STATE_Default_PostReset:
			if (!(Pipe_ConfigurePipe(PIPE_CONTROLPIPE, EP_TYPE_CONTROL, ENDPOINT_CONTROLEP, USB_Host_ControlPipeSize, 1)))
    51d2:	80 e0       	ldi	r24, 0x00	; 0
    51d4:	11 d1       	rcall	.+546    	; 0x53f8 <Pipe_ConfigurePipe>
    51d6:	88 23       	and	r24, r24
    51d8:	a1 f2       	breq	.-88     	; 0x5182 <USB_Host_ProcessNextHostState+0x17a>
    51da:	88 e0       	ldi	r24, 0x08	; 8
    51dc:	e0 ef       	ldi	r30, 0xF0	; 240
    51de:	f1 e0       	ldi	r31, 0x01	; 1
    51e0:	ac ed       	ldi	r26, 0xDC	; 220
    51e2:	bd e0       	ldi	r27, 0x0D	; 13
    51e4:	01 90       	ld	r0, Z+
    51e6:	0d 92       	st	X+, r0
				ErrorCode    = HOST_ENUMERROR_PipeConfigError;
				SubErrorCode = 0;
				break;
			}

			USB_ControlRequest = (USB_Request_Header_t)
    51e8:	8a 95       	dec	r24
    51ea:	e1 f7       	brne	.-8      	; 0x51e4 <USB_Host_ProcessNextHostState+0x1dc>
    51ec:	80 e0       	ldi	r24, 0x00	; 0
    51ee:	90 e0       	ldi	r25, 0x00	; 0
    51f0:	9d d6       	rcall	.+3386   	; 0x5f2c <USB_Host_SendControlRequest>
    51f2:	81 11       	cpse	r24, r1
    51f4:	09 c0       	rjmp	.+18     	; 0x5208 <USB_Host_ProcessNextHostState+0x200>
    51f6:	1e ba       	out	0x1e, r1	; 30
    51f8:	84 e6       	ldi	r24, 0x64	; 100
					.wValue        = USB_HOST_DEVICEADDRESS,
					.wIndex        = 0,
					.wLength       = 0,
				};

			if ((SubErrorCode = USB_Host_SendControlRequest(NULL)) != HOST_SENDCONTROL_Successful)
    51fa:	90 e0       	ldi	r25, 0x00	; 0
    51fc:	90 93 06 04 	sts	0x0406, r25
    5200:	80 93 05 04 	sts	0x0405, r24
    5204:	89 e0       	ldi	r24, 0x09	; 9
			{
				ErrorCode = HOST_ENUMERROR_ControlError;
				break;
			}

			HOST_TASK_NONBLOCK_WAIT(100, HOST_STATE_Default_PostAddressSet);
    5206:	b1 cf       	rjmp	.-158    	; 0x516a <USB_Host_ProcessNextHostState+0x162>
    5208:	93 e0       	ldi	r25, 0x03	; 3
    520a:	2e b3       	in	r18, 0x1e	; 30
    520c:	21 30       	cpi	r18, 0x01	; 1
    520e:	61 f0       	breq	.+24     	; 0x5228 <USB_Host_ProcessNextHostState+0x220>
    5210:	68 2f       	mov	r22, r24
    5212:	89 2f       	mov	r24, r25
    5214:	0e 94 64 03 	call	0x6c8	; 0x6c8 <EVENT_USB_Host_DeviceEnumerationFailed>
					.wLength       = 0,
				};

			if ((SubErrorCode = USB_Host_SendControlRequest(NULL)) != HOST_SENDCONTROL_Successful)
			{
				ErrorCode = HOST_ENUMERROR_ControlError;
    5218:	80 91 dd 00 	lds	r24, 0x00DD

		default:
			break;
	}

	if ((ErrorCode != HOST_ENUMERROR_NoError) && (USB_HostState != HOST_STATE_Unattached))
    521c:	81 60       	ori	r24, 0x01	; 1
    521e:	80 93 dd 00 	sts	0x00DD, r24
	{
		EVENT_USB_Host_DeviceEnumerationFailed(ErrorCode, SubErrorCode);
    5222:	0e 94 e7 02 	call	0x5ce	; 0x5ce <EVENT_USB_Host_DeviceUnattached>
    5226:	f4 d1       	rcall	.+1000   	; 0x5610 <USB_ResetInterface>
			}

			static inline void USB_Host_VBUS_Auto_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_VBUS_Auto_Off(void)
			{
				OTGCON |=  (1 << VBUSRQC);
    5228:	28 96       	adiw	r28, 0x08	; 8
    522a:	0f b6       	in	r0, 0x3f	; 63
    522c:	f8 94       	cli
    522e:	de bf       	out	0x3e, r29	; 62
    5230:	0f be       	out	0x3f, r0	; 63

		USB_Host_VBUS_Auto_Off();

		EVENT_USB_Host_DeviceUnattached();
    5232:	cd bf       	out	0x3d, r28	; 61
    5234:	df 91       	pop	r29

		USB_ResetInterface();
    5236:	cf 91       	pop	r28
    5238:	1f 91       	pop	r17
	}
}
    523a:	0f 91       	pop	r16
    523c:	08 95       	ret

0000523e <Pipe_Discard_Stream>:
    523e:	ef 92       	push	r14
    5240:	ff 92       	push	r15
    5242:	0f 93       	push	r16
    5244:	1f 93       	push	r17
    5246:	cf 93       	push	r28
    5248:	df 93       	push	r29
    524a:	8c 01       	movw	r16, r24
    524c:	eb 01       	movw	r28, r22
    524e:	80 91 aa 00 	lds	r24, 0x00AA
			 *  \param[in] Token  New pipe token to set the selected pipe to, as a \c PIPE_TOKEN_* mask.
			 */
			static inline void Pipe_SetPipeToken(const uint8_t Token) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SetPipeToken(const uint8_t Token)
			{
				UPCFG0X = ((UPCFG0X & ~(0x03 << PTOKEN0)) | Token);
    5252:	8f 7c       	andi	r24, 0xCF	; 207
    5254:	80 61       	ori	r24, 0x10	; 16
    5256:	80 93 aa 00 	sts	0x00AA, r24
	uint8_t  ErrorCode;
	uint16_t BytesInTransfer = 0;

	Pipe_SetPipeToken(PIPE_TOKEN_IN);

	if ((ErrorCode = Pipe_WaitUntilReady()))
    525a:	93 d1       	rcall	.+806    	; 0x5582 <Pipe_WaitUntilReady>
    525c:	81 11       	cpse	r24, r1
    525e:	2b c0       	rjmp	.+86     	; 0x52b6 <Pipe_Discard_Stream+0x78>
    5260:	20 97       	sbiw	r28, 0x00	; 0
	  return ErrorCode;

	if (BytesProcessed != NULL)
    5262:	21 f0       	breq	.+8      	; 0x526c <Pipe_Discard_Stream+0x2e>
    5264:	88 81       	ld	r24, Y
	  Length -= *BytesProcessed;
    5266:	99 81       	ldd	r25, Y+1	; 0x01
    5268:	08 1b       	sub	r16, r24
    526a:	19 0b       	sbc	r17, r25
    526c:	e1 2c       	mov	r14, r1

#include "PipeStream_AVR8.h"

uint8_t Pipe_Discard_Stream(uint16_t Length,
                            uint16_t* const BytesProcessed)
{
    526e:	f1 2c       	mov	r15, r1
    5270:	01 15       	cp	r16, r1
	  return ErrorCode;

	if (BytesProcessed != NULL)
	  Length -= *BytesProcessed;

	while (Length)
    5272:	11 05       	cpc	r17, r1
    5274:	f9 f0       	breq	.+62     	; 0x52b4 <Pipe_Discard_Stream+0x76>
    5276:	80 91 a6 00 	lds	r24, 0x00A6
			 *          on its direction.
			 */
			static inline bool Pipe_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsReadWriteAllowed(void)
			{
				return ((UPINTX & (1 << RWAL)) ? true : false);
    527a:	85 fd       	sbrc	r24, 5
	{
		if (!(Pipe_IsReadWriteAllowed()))
    527c:	13 c0       	rjmp	.+38     	; 0x52a4 <Pipe_Discard_Stream+0x66>
    527e:	80 91 a6 00 	lds	r24, 0x00A6
			 *  \ingroup Group_PipePacketManagement_AVR8
			 */
			static inline void Pipe_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearIN(void)
			{
				UPINTX &= ~((1 << RXINI) | (1 << FIFOCON));
    5282:	8e 77       	andi	r24, 0x7E	; 126
    5284:	80 93 a6 00 	sts	0x00A6, r24
    5288:	20 97       	sbiw	r28, 0x00	; 0
		{
			Pipe_ClearIN();

			if (BytesProcessed != NULL)
    528a:	41 f0       	breq	.+16     	; 0x529c <Pipe_Discard_Stream+0x5e>
    528c:	88 81       	ld	r24, Y
			{
				*BytesProcessed += BytesInTransfer;
    528e:	99 81       	ldd	r25, Y+1	; 0x01
    5290:	8e 0d       	add	r24, r14
    5292:	9f 1d       	adc	r25, r15
    5294:	99 83       	std	Y+1, r25	; 0x01
    5296:	88 83       	st	Y, r24
    5298:	84 e0       	ldi	r24, 0x04	; 4
				return PIPE_RWSTREAM_IncompleteTransfer;
    529a:	0d c0       	rjmp	.+26     	; 0x52b6 <Pipe_Discard_Stream+0x78>
    529c:	72 d1       	rcall	.+740    	; 0x5582 <Pipe_WaitUntilReady>
			}

			if ((ErrorCode = Pipe_WaitUntilReady()))
    529e:	88 23       	and	r24, r24
    52a0:	39 f3       	breq	.-50     	; 0x5270 <Pipe_Discard_Stream+0x32>
    52a2:	09 c0       	rjmp	.+18     	; 0x52b6 <Pipe_Discard_Stream+0x78>
    52a4:	80 91 af 00 	lds	r24, 0x00AF
			static inline void Pipe_Discard_8(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Discard_8(void)
			{
				uint8_t Dummy;

				Dummy = UPDATX;
    52a8:	01 50       	subi	r16, 0x01	; 1
    52aa:	11 09       	sbc	r17, r1
		}
		else
		{
			Pipe_Discard_8();

			Length--;
    52ac:	8f ef       	ldi	r24, 0xFF	; 255
    52ae:	e8 1a       	sub	r14, r24
			BytesInTransfer++;
    52b0:	f8 0a       	sbc	r15, r24
    52b2:	de cf       	rjmp	.-68     	; 0x5270 <Pipe_Discard_Stream+0x32>
    52b4:	80 e0       	ldi	r24, 0x00	; 0
    52b6:	df 91       	pop	r29
		}
	}

	return PIPE_RWSTREAM_NoError;
    52b8:	cf 91       	pop	r28
}
    52ba:	1f 91       	pop	r17
    52bc:	0f 91       	pop	r16
    52be:	ff 90       	pop	r15
    52c0:	ef 90       	pop	r14
    52c2:	08 95       	ret

000052c4 <Pipe_Write_Stream_LE>:
    52c4:	cf 92       	push	r12
    52c6:	df 92       	push	r13
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
    52c8:	ef 92       	push	r14
    52ca:	ff 92       	push	r15
    52cc:	0f 93       	push	r16
    52ce:	1f 93       	push	r17
    52d0:	cf 93       	push	r28
    52d2:	df 93       	push	r29
    52d4:	7c 01       	movw	r14, r24
    52d6:	8b 01       	movw	r16, r22
    52d8:	ea 01       	movw	r28, r20
			 *  \param[in] Token  New pipe token to set the selected pipe to, as a \c PIPE_TOKEN_* mask.
			 */
			static inline void Pipe_SetPipeToken(const uint8_t Token) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SetPipeToken(const uint8_t Token)
			{
				UPCFG0X = ((UPCFG0X & ~(0x03 << PTOKEN0)) | Token);
    52da:	80 91 aa 00 	lds	r24, 0x00AA
    52de:	8f 7c       	andi	r24, 0xCF	; 207
    52e0:	80 62       	ori	r24, 0x20	; 32
    52e2:	80 93 aa 00 	sts	0x00AA, r24
	uint16_t BytesInTransfer = 0;
	uint8_t  ErrorCode;

	Pipe_SetPipeToken(TEMPLATE_TOKEN);

	if ((ErrorCode = Pipe_WaitUntilReady()))
    52e6:	4d d1       	rcall	.+666    	; 0x5582 <Pipe_WaitUntilReady>
    52e8:	81 11       	cpse	r24, r1
    52ea:	30 c0       	rjmp	.+96     	; 0x534c <Pipe_Write_Stream_LE+0x88>
    52ec:	20 97       	sbiw	r28, 0x00	; 0
	  return ErrorCode;

	if (BytesProcessed != NULL)
    52ee:	31 f0       	breq	.+12     	; 0x52fc <Pipe_Write_Stream_LE+0x38>
    52f0:	88 81       	ld	r24, Y
	{
		Length -= *BytesProcessed;
    52f2:	99 81       	ldd	r25, Y+1	; 0x01
    52f4:	08 1b       	sub	r16, r24
    52f6:	19 0b       	sbc	r17, r25
    52f8:	e8 0e       	add	r14, r24
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
    52fa:	f9 1e       	adc	r15, r25
    52fc:	c1 2c       	mov	r12, r1

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    52fe:	d1 2c       	mov	r13, r1
    5300:	01 15       	cp	r16, r1
	{
		Length -= *BytesProcessed;
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
    5302:	11 05       	cpc	r17, r1
    5304:	11 f1       	breq	.+68     	; 0x534a <Pipe_Write_Stream_LE+0x86>
    5306:	80 91 a6 00 	lds	r24, 0x00A6
			 *          on its direction.
			 */
			static inline bool Pipe_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsReadWriteAllowed(void)
			{
				return ((UPINTX & (1 << RWAL)) ? true : false);
    530a:	85 fd       	sbrc	r24, 5
	{
		if (!(Pipe_IsReadWriteAllowed()))
    530c:	13 c0       	rjmp	.+38     	; 0x5334 <Pipe_Write_Stream_LE+0x70>
    530e:	80 91 a6 00 	lds	r24, 0x00A6
			 *  \ingroup Group_PipePacketManagement_AVR8
			 */
			static inline void Pipe_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearOUT(void)
			{
				UPINTX &= ~((1 << TXOUTI) | (1 << FIFOCON));
    5312:	8b 77       	andi	r24, 0x7B	; 123
    5314:	80 93 a6 00 	sts	0x00A6, r24
    5318:	20 97       	sbiw	r28, 0x00	; 0
		{
			TEMPLATE_CLEAR_PIPE();

			if (BytesProcessed != NULL)
    531a:	41 f0       	breq	.+16     	; 0x532c <Pipe_Write_Stream_LE+0x68>
    531c:	88 81       	ld	r24, Y
			{
				*BytesProcessed += BytesInTransfer;
    531e:	99 81       	ldd	r25, Y+1	; 0x01
    5320:	8c 0d       	add	r24, r12
    5322:	9d 1d       	adc	r25, r13
    5324:	99 83       	std	Y+1, r25	; 0x01
    5326:	88 83       	st	Y, r24
    5328:	84 e0       	ldi	r24, 0x04	; 4
				return PIPE_RWSTREAM_IncompleteTransfer;
    532a:	10 c0       	rjmp	.+32     	; 0x534c <Pipe_Write_Stream_LE+0x88>
    532c:	2a d1       	rcall	.+596    	; 0x5582 <Pipe_WaitUntilReady>
			}

			if ((ErrorCode = Pipe_WaitUntilReady()))
    532e:	88 23       	and	r24, r24
    5330:	39 f3       	breq	.-50     	; 0x5300 <Pipe_Write_Stream_LE+0x3c>
    5332:	0c c0       	rjmp	.+24     	; 0x534c <Pipe_Write_Stream_LE+0x88>
    5334:	f7 01       	movw	r30, r14
    5336:	81 91       	ld	r24, Z+
			  return ErrorCode;
		}
		else
		{
			TEMPLATE_TRANSFER_BYTE(DataStream);
    5338:	7f 01       	movw	r14, r30
    533a:	80 93 af 00 	sts	0x00AF, r24
			 *  \param[in] Data  Data to write into the the currently selected pipe's FIFO buffer.
			 */
			static inline void Pipe_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Write_8(const uint8_t Data)
			{
				UPDATX = Data;
    533e:	01 50       	subi	r16, 0x01	; 1
    5340:	11 09       	sbc	r17, r1
			TEMPLATE_BUFFER_MOVE(DataStream, 1);
			Length--;
    5342:	ff ef       	ldi	r31, 0xFF	; 255
    5344:	cf 1a       	sub	r12, r31
			BytesInTransfer++;
    5346:	df 0a       	sbc	r13, r31
    5348:	db cf       	rjmp	.-74     	; 0x5300 <Pipe_Write_Stream_LE+0x3c>
    534a:	80 e0       	ldi	r24, 0x00	; 0
    534c:	df 91       	pop	r29
		}
	}

	return PIPE_RWSTREAM_NoError;
    534e:	cf 91       	pop	r28
}
    5350:	1f 91       	pop	r17
    5352:	0f 91       	pop	r16
    5354:	ff 90       	pop	r15
    5356:	ef 90       	pop	r14
    5358:	df 90       	pop	r13
    535a:	cf 90       	pop	r12
    535c:	08 95       	ret

0000535e <Pipe_Read_Stream_LE>:
    535e:	cf 92       	push	r12
    5360:	df 92       	push	r13
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
    5362:	ef 92       	push	r14
    5364:	ff 92       	push	r15
    5366:	0f 93       	push	r16
    5368:	1f 93       	push	r17
    536a:	cf 93       	push	r28
    536c:	df 93       	push	r29
    536e:	7c 01       	movw	r14, r24
    5370:	8b 01       	movw	r16, r22
    5372:	ea 01       	movw	r28, r20
			 *  \param[in] Token  New pipe token to set the selected pipe to, as a \c PIPE_TOKEN_* mask.
			 */
			static inline void Pipe_SetPipeToken(const uint8_t Token) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SetPipeToken(const uint8_t Token)
			{
				UPCFG0X = ((UPCFG0X & ~(0x03 << PTOKEN0)) | Token);
    5374:	80 91 aa 00 	lds	r24, 0x00AA
    5378:	8f 7c       	andi	r24, 0xCF	; 207
    537a:	80 61       	ori	r24, 0x10	; 16
    537c:	80 93 aa 00 	sts	0x00AA, r24
	uint16_t BytesInTransfer = 0;
	uint8_t  ErrorCode;

	Pipe_SetPipeToken(TEMPLATE_TOKEN);

	if ((ErrorCode = Pipe_WaitUntilReady()))
    5380:	00 d1       	rcall	.+512    	; 0x5582 <Pipe_WaitUntilReady>
    5382:	81 11       	cpse	r24, r1
    5384:	30 c0       	rjmp	.+96     	; 0x53e6 <Pipe_Read_Stream_LE+0x88>
    5386:	20 97       	sbiw	r28, 0x00	; 0
	  return ErrorCode;

	if (BytesProcessed != NULL)
    5388:	31 f0       	breq	.+12     	; 0x5396 <Pipe_Read_Stream_LE+0x38>
    538a:	88 81       	ld	r24, Y
	{
		Length -= *BytesProcessed;
    538c:	99 81       	ldd	r25, Y+1	; 0x01
    538e:	08 1b       	sub	r16, r24
    5390:	19 0b       	sbc	r17, r25
    5392:	e8 0e       	add	r14, r24
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
    5394:	f9 1e       	adc	r15, r25
    5396:	c1 2c       	mov	r12, r1

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    5398:	d1 2c       	mov	r13, r1
    539a:	01 15       	cp	r16, r1
	{
		Length -= *BytesProcessed;
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
    539c:	11 05       	cpc	r17, r1
    539e:	11 f1       	breq	.+68     	; 0x53e4 <Pipe_Read_Stream_LE+0x86>
    53a0:	80 91 a6 00 	lds	r24, 0x00A6
			 *          on its direction.
			 */
			static inline bool Pipe_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsReadWriteAllowed(void)
			{
				return ((UPINTX & (1 << RWAL)) ? true : false);
    53a4:	85 fd       	sbrc	r24, 5
	{
		if (!(Pipe_IsReadWriteAllowed()))
    53a6:	13 c0       	rjmp	.+38     	; 0x53ce <Pipe_Read_Stream_LE+0x70>
    53a8:	80 91 a6 00 	lds	r24, 0x00A6
			 *  \ingroup Group_PipePacketManagement_AVR8
			 */
			static inline void Pipe_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearIN(void)
			{
				UPINTX &= ~((1 << RXINI) | (1 << FIFOCON));
    53ac:	8e 77       	andi	r24, 0x7E	; 126
    53ae:	80 93 a6 00 	sts	0x00A6, r24
    53b2:	20 97       	sbiw	r28, 0x00	; 0
		{
			TEMPLATE_CLEAR_PIPE();

			if (BytesProcessed != NULL)
    53b4:	41 f0       	breq	.+16     	; 0x53c6 <Pipe_Read_Stream_LE+0x68>
    53b6:	88 81       	ld	r24, Y
			{
				*BytesProcessed += BytesInTransfer;
    53b8:	99 81       	ldd	r25, Y+1	; 0x01
    53ba:	8c 0d       	add	r24, r12
    53bc:	9d 1d       	adc	r25, r13
    53be:	99 83       	std	Y+1, r25	; 0x01
    53c0:	88 83       	st	Y, r24
    53c2:	84 e0       	ldi	r24, 0x04	; 4
				return PIPE_RWSTREAM_IncompleteTransfer;
    53c4:	10 c0       	rjmp	.+32     	; 0x53e6 <Pipe_Read_Stream_LE+0x88>
    53c6:	dd d0       	rcall	.+442    	; 0x5582 <Pipe_WaitUntilReady>
			}

			if ((ErrorCode = Pipe_WaitUntilReady()))
    53c8:	88 23       	and	r24, r24
    53ca:	39 f3       	breq	.-50     	; 0x539a <Pipe_Read_Stream_LE+0x3c>
    53cc:	0c c0       	rjmp	.+24     	; 0x53e6 <Pipe_Read_Stream_LE+0x88>
    53ce:	80 91 af 00 	lds	r24, 0x00AF
			 *  \return Next byte in the currently selected pipe's FIFO buffer.
			 */
			static inline uint8_t Pipe_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Pipe_Read_8(void)
			{
				return UPDATX;
    53d2:	f7 01       	movw	r30, r14
    53d4:	81 93       	st	Z+, r24
			  return ErrorCode;
		}
		else
		{
			TEMPLATE_TRANSFER_BYTE(DataStream);
    53d6:	7f 01       	movw	r14, r30
    53d8:	01 50       	subi	r16, 0x01	; 1
    53da:	11 09       	sbc	r17, r1
			TEMPLATE_BUFFER_MOVE(DataStream, 1);
			Length--;
    53dc:	ff ef       	ldi	r31, 0xFF	; 255
    53de:	cf 1a       	sub	r12, r31
			BytesInTransfer++;
    53e0:	df 0a       	sbc	r13, r31
    53e2:	db cf       	rjmp	.-74     	; 0x539a <Pipe_Read_Stream_LE+0x3c>
    53e4:	80 e0       	ldi	r24, 0x00	; 0
    53e6:	df 91       	pop	r29
		}
	}

	return PIPE_RWSTREAM_NoError;
    53e8:	cf 91       	pop	r28
}
    53ea:	1f 91       	pop	r17
    53ec:	0f 91       	pop	r16
    53ee:	ff 90       	pop	r15
    53f0:	ef 90       	pop	r14
    53f2:	df 90       	pop	r13
    53f4:	cf 90       	pop	r12
    53f6:	08 95       	ret

000053f8 <Pipe_ConfigurePipe>:
    53f8:	0f 93       	push	r16
    53fa:	e8 2f       	mov	r30, r24
                        const uint8_t Type,
                        const uint8_t EndpointAddress,
                        const uint16_t Size,
                        const uint8_t Banks)
{
	uint8_t Number = (Address & PIPE_EPNUM_MASK);
    53fc:	ef 70       	andi	r30, 0x0F	; 15
	uint8_t Token  = (Address & PIPE_DIR_IN) ? PIPE_TOKEN_IN : PIPE_TOKEN_OUT;
    53fe:	87 ff       	sbrs	r24, 7
    5400:	02 c0       	rjmp	.+4      	; 0x5406 <Pipe_ConfigurePipe+0xe>
    5402:	80 e1       	ldi	r24, 0x10	; 16
    5404:	01 c0       	rjmp	.+2      	; 0x5408 <Pipe_ConfigurePipe+0x10>
    5406:	80 e2       	ldi	r24, 0x20	; 32

	if (Number >= PIPE_TOTAL_PIPES)
    5408:	e7 30       	cpi	r30, 0x07	; 7
    540a:	10 f0       	brcs	.+4      	; 0x5410 <Pipe_ConfigurePipe+0x18>
	  return false;
    540c:	80 e0       	ldi	r24, 0x00	; 0
    540e:	5a c0       	rjmp	.+180    	; 0x54c4 <Pipe_ConfigurePipe+0xcc>

	if (Type == EP_TYPE_CONTROL)
    5410:	61 11       	cpse	r22, r1
    5412:	01 c0       	rjmp	.+2      	; 0x5416 <Pipe_ConfigurePipe+0x1e>
	  Token = PIPE_TOKEN_SETUP;
    5414:	80 e0       	ldi	r24, 0x00	; 0

		Pipe_SelectPipe(PNum);

		if (PNum == Number)
		{
			UPCFG0XTemp = ((Type << EPTYPE0) | Token | ((EndpointAddress & PIPE_EPNUM_MASK) << PEPNUM0));
    5416:	90 e4       	ldi	r25, 0x40	; 64
    5418:	69 9f       	mul	r22, r25
    541a:	b0 01       	movw	r22, r0
    541c:	11 24       	eor	r1, r1
    541e:	4f 70       	andi	r20, 0x0F	; 15
    5420:	46 2b       	or	r20, r22
    5422:	48 2b       	or	r20, r24
    5424:	5e 2f       	mov	r21, r30
			 *  \param[in] Address  Address of the pipe to select.
			 */
			static inline void Pipe_SelectPipe(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SelectPipe(const uint8_t Address)
			{
				UPNUM = (Address & PIPE_PIPENUM_MASK);
    5426:	50 93 a7 00 	sts	0x00A7, r21
		uint8_t UPCFG2XTemp;
		uint8_t UPIENXTemp;

		Pipe_SelectPipe(PNum);

		if (PNum == Number)
    542a:	5e 13       	cpse	r21, r30
    542c:	19 c0       	rjmp	.+50     	; 0x5460 <Pipe_ConfigurePipe+0x68>
		{
			UPCFG0XTemp = ((Type << EPTYPE0) | Token | ((EndpointAddress & PIPE_EPNUM_MASK) << PEPNUM0));
			UPCFG1XTemp = ((1 << ALLOC) | ((Banks > 1) ? (1 << EPBK0) : 0) | Pipe_BytesToEPSizeMask(Size));
    542e:	02 30       	cpi	r16, 0x02	; 2
    5430:	10 f0       	brcs	.+4      	; 0x5436 <Pipe_ConfigurePipe+0x3e>
    5432:	76 e0       	ldi	r23, 0x06	; 6
    5434:	01 c0       	rjmp	.+2      	; 0x5438 <Pipe_ConfigurePipe+0x40>
    5436:	72 e0       	ldi	r23, 0x02	; 2
		/* Inline Functions: */
			static inline uint8_t Pipe_BytesToEPSizeMask(const uint16_t Bytes) ATTR_WARN_UNUSED_RESULT ATTR_CONST ATTR_ALWAYS_INLINE;
			static inline uint8_t Pipe_BytesToEPSizeMask(const uint16_t Bytes)
			{
				uint8_t  MaskVal    = 0;
				uint16_t CheckBytes = 8;
    5438:	88 e0       	ldi	r24, 0x08	; 8
    543a:	90 e0       	ldi	r25, 0x00	; 0

		/* Inline Functions: */
			static inline uint8_t Pipe_BytesToEPSizeMask(const uint16_t Bytes) ATTR_WARN_UNUSED_RESULT ATTR_CONST ATTR_ALWAYS_INLINE;
			static inline uint8_t Pipe_BytesToEPSizeMask(const uint16_t Bytes)
			{
				uint8_t  MaskVal    = 0;
    543c:	60 e0       	ldi	r22, 0x00	; 0
				uint16_t CheckBytes = 8;

				while ((CheckBytes < Bytes) && (CheckBytes < PIPE_MAX_SIZE))
    543e:	82 17       	cp	r24, r18
    5440:	93 07       	cpc	r25, r19
    5442:	40 f0       	brcs	.+16     	; 0x5454 <Pipe_ConfigurePipe+0x5c>
				{
					MaskVal++;
					CheckBytes <<= 1;
				}

				return (MaskVal << EPSIZE0);
    5444:	86 2f       	mov	r24, r22
    5446:	82 95       	swap	r24
    5448:	80 7f       	andi	r24, 0xF0	; 240
    544a:	87 2b       	or	r24, r23

		Pipe_SelectPipe(PNum);

		if (PNum == Number)
		{
			UPCFG0XTemp = ((Type << EPTYPE0) | Token | ((EndpointAddress & PIPE_EPNUM_MASK) << PEPNUM0));
    544c:	f4 2f       	mov	r31, r20
			UPCFG1XTemp = ((1 << ALLOC) | ((Banks > 1) ? (1 << EPBK0) : 0) | Pipe_BytesToEPSizeMask(Size));
			UPCFG2XTemp = 0;
			UPIENXTemp  = 0;
    544e:	60 e0       	ldi	r22, 0x00	; 0

		if (PNum == Number)
		{
			UPCFG0XTemp = ((Type << EPTYPE0) | Token | ((EndpointAddress & PIPE_EPNUM_MASK) << PEPNUM0));
			UPCFG1XTemp = ((1 << ALLOC) | ((Banks > 1) ? (1 << EPBK0) : 0) | Pipe_BytesToEPSizeMask(Size));
			UPCFG2XTemp = 0;
    5450:	70 e0       	ldi	r23, 0x00	; 0
    5452:	0e c0       	rjmp	.+28     	; 0x5470 <Pipe_ConfigurePipe+0x78>
			static inline uint8_t Pipe_BytesToEPSizeMask(const uint16_t Bytes)
			{
				uint8_t  MaskVal    = 0;
				uint16_t CheckBytes = 8;

				while ((CheckBytes < Bytes) && (CheckBytes < PIPE_MAX_SIZE))
    5454:	65 30       	cpi	r22, 0x05	; 5
    5456:	b1 f3       	breq	.-20     	; 0x5444 <Pipe_ConfigurePipe+0x4c>
				{
					MaskVal++;
    5458:	6f 5f       	subi	r22, 0xFF	; 255
					CheckBytes <<= 1;
    545a:	88 0f       	add	r24, r24
    545c:	99 1f       	adc	r25, r25
    545e:	ef cf       	rjmp	.-34     	; 0x543e <Pipe_ConfigurePipe+0x46>
			UPIENXTemp  = 0;
		}
		else
		{
			UPCFG0XTemp = UPCFG0X;
    5460:	f0 91 aa 00 	lds	r31, 0x00AA
			UPCFG1XTemp = UPCFG1X;
    5464:	80 91 ab 00 	lds	r24, 0x00AB
			UPCFG2XTemp = UPCFG2X;
    5468:	70 91 ad 00 	lds	r23, 0x00AD
			UPIENXTemp  = UPIENX;
    546c:	60 91 ae 00 	lds	r22, 0x00AE
		}

		if (!(UPCFG1XTemp & (1 << ALLOC)))
    5470:	81 fd       	sbrc	r24, 1
    5472:	07 c0       	rjmp	.+14     	; 0x5482 <Pipe_ConfigurePipe+0x8a>

	Pipe_SetInfiniteINRequests();

	return Pipe_IsConfigured();
#else
	for (uint8_t PNum = Number; PNum < PIPE_TOTAL_PIPES; PNum++)
    5474:	5f 5f       	subi	r21, 0xFF	; 255
    5476:	57 30       	cpi	r21, 0x07	; 7
    5478:	b1 f6       	brne	.-84     	; 0x5426 <Pipe_ConfigurePipe+0x2e>
			 *  \param[in] Address  Address of the pipe to select.
			 */
			static inline void Pipe_SelectPipe(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SelectPipe(const uint8_t Address)
			{
				UPNUM = (Address & PIPE_PIPENUM_MASK);
    547a:	e0 93 a7 00 	sts	0x00A7, r30
		if (!(Pipe_IsConfigured()))
		  return false;
	}

	Pipe_SelectPipe(Number);
	return true;
    547e:	81 e0       	ldi	r24, 0x01	; 1
    5480:	21 c0       	rjmp	.+66     	; 0x54c4 <Pipe_ConfigurePipe+0xcc>
			 *  from an attached device.
			 */
			static inline void Pipe_DisablePipe(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_DisablePipe(void)
			{
				UPCONX &= ~(1 << PEN);
    5482:	90 91 a9 00 	lds	r25, 0x00A9
    5486:	9e 7f       	andi	r25, 0xFE	; 254
    5488:	90 93 a9 00 	sts	0x00A9, r25

		if (!(UPCFG1XTemp & (1 << ALLOC)))
		  continue;

		Pipe_DisablePipe();
		UPCFG1X &= ~(1 << ALLOC);
    548c:	90 91 ab 00 	lds	r25, 0x00AB
    5490:	9d 7f       	andi	r25, 0xFD	; 253
    5492:	90 93 ab 00 	sts	0x00AB, r25
			 *  \pre The currently selected pipe must first be configured properly via \ref Pipe_ConfigurePipe().
			 */
			static inline void Pipe_EnablePipe(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_EnablePipe(void)
			{
				UPCONX |= (1 << PEN);
    5496:	90 91 a9 00 	lds	r25, 0x00A9
    549a:	91 60       	ori	r25, 0x01	; 1
    549c:	90 93 a9 00 	sts	0x00A9, r25

		Pipe_EnablePipe();
		UPCFG0X = UPCFG0XTemp;
    54a0:	f0 93 aa 00 	sts	0x00AA, r31
		UPCFG1X = UPCFG1XTemp;
    54a4:	80 93 ab 00 	sts	0x00AB, r24
		UPCFG2X = UPCFG2XTemp;
    54a8:	70 93 ad 00 	sts	0x00AD, r23
		UPIENX  = UPIENXTemp;
    54ac:	60 93 ae 00 	sts	0x00AE, r22

			/** Configures the currently selected pipe to allow for an unlimited number of IN requests. */
			static inline void Pipe_SetInfiniteINRequests(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SetInfiniteINRequests(void)
			{
				UPCONX |= (1 << INMODE);
    54b0:	80 91 a9 00 	lds	r24, 0x00A9
    54b4:	80 62       	ori	r24, 0x20	; 32
    54b6:	80 93 a9 00 	sts	0x00A9, r24
			 *  \return Boolean \c true if the selected pipe is configured, \c false otherwise.
			 */
			static inline bool Pipe_IsConfigured(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsConfigured(void)
			{
				return ((UPSTAX & (1 << CFGOK)) ? true : false);
    54ba:	80 91 ac 00 	lds	r24, 0x00AC

		Pipe_SetInfiniteINRequests();

		if (!(Pipe_IsConfigured()))
    54be:	87 fd       	sbrc	r24, 7
    54c0:	d9 cf       	rjmp	.-78     	; 0x5474 <Pipe_ConfigurePipe+0x7c>
    54c2:	a4 cf       	rjmp	.-184    	; 0x540c <Pipe_ConfigurePipe+0x14>
	}

	Pipe_SelectPipe(Number);
	return true;
#endif
}
    54c4:	0f 91       	pop	r16
    54c6:	08 95       	ret

000054c8 <Pipe_ConfigurePipeTable>:

uint8_t USB_Host_ControlPipeSize = PIPE_CONTROLPIPE_DEFAULT_SIZE;

bool Pipe_ConfigurePipeTable(const USB_Pipe_Table_t* const Table,
                             const uint8_t Entries)
{
    54c8:	ff 92       	push	r15
    54ca:	0f 93       	push	r16
    54cc:	1f 93       	push	r17
    54ce:	cf 93       	push	r28
    54d0:	df 93       	push	r29
    54d2:	f6 2e       	mov	r15, r22
    54d4:	ec 01       	movw	r28, r24
	for (uint8_t i = 0; i < Entries; i++)
    54d6:	10 e0       	ldi	r17, 0x00	; 0
    54d8:	1f 15       	cp	r17, r15
    54da:	71 f0       	breq	.+28     	; 0x54f8 <Pipe_ConfigurePipeTable+0x30>
	{
		if (!(Table[i].Address))
    54dc:	88 81       	ld	r24, Y
    54de:	88 23       	and	r24, r24
    54e0:	41 f0       	breq	.+16     	; 0x54f2 <Pipe_ConfigurePipeTable+0x2a>
		  continue;

		if (!(Pipe_ConfigurePipe(Table[i].Address, Table[i].Type, Table[i].EndpointAddress, Table[i].Size, Table[i].Banks)))
    54e2:	29 81       	ldd	r18, Y+1	; 0x01
    54e4:	3a 81       	ldd	r19, Y+2	; 0x02
    54e6:	0d 81       	ldd	r16, Y+5	; 0x05
    54e8:	4b 81       	ldd	r20, Y+3	; 0x03
    54ea:	6c 81       	ldd	r22, Y+4	; 0x04
    54ec:	85 df       	rcall	.-246    	; 0x53f8 <Pipe_ConfigurePipe>
    54ee:	88 23       	and	r24, r24
    54f0:	21 f0       	breq	.+8      	; 0x54fa <Pipe_ConfigurePipeTable+0x32>
    54f2:	1f 5f       	subi	r17, 0xFF	; 255
uint8_t USB_Host_ControlPipeSize = PIPE_CONTROLPIPE_DEFAULT_SIZE;

bool Pipe_ConfigurePipeTable(const USB_Pipe_Table_t* const Table,
                             const uint8_t Entries)
{
	for (uint8_t i = 0; i < Entries; i++)
    54f4:	26 96       	adiw	r28, 0x06	; 6
    54f6:	f0 cf       	rjmp	.-32     	; 0x54d8 <Pipe_ConfigurePipeTable+0x10>
    54f8:	81 e0       	ldi	r24, 0x01	; 1
		{
			return false;
		}
	}

	return true;
    54fa:	df 91       	pop	r29
}
    54fc:	cf 91       	pop	r28
    54fe:	1f 91       	pop	r17
    5500:	0f 91       	pop	r16
    5502:	ff 90       	pop	r15
    5504:	08 95       	ret

00005506 <Pipe_ClearPipes>:
    5506:	10 92 f8 00 	sts	0x00F8, r1

void Pipe_ClearPipes(void)
{
	UPINT = 0;

	for (uint8_t PNum = 0; PNum < PIPE_TOTAL_PIPES; PNum++)
    550a:	80 e0       	ldi	r24, 0x00	; 0
			 *  \param[in] Address  Address of the pipe to select.
			 */
			static inline void Pipe_SelectPipe(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SelectPipe(const uint8_t Address)
			{
				UPNUM = (Address & PIPE_PIPENUM_MASK);
    550c:	80 93 a7 00 	sts	0x00A7, r24
	{
		Pipe_SelectPipe(PNum);
		UPIENX  = 0;
    5510:	10 92 ae 00 	sts	0x00AE, r1
		UPINTX  = 0;
    5514:	10 92 a6 00 	sts	0x00A6, r1
		UPCFG1X = 0;
    5518:	10 92 ab 00 	sts	0x00AB, r1
			 *  from an attached device.
			 */
			static inline void Pipe_DisablePipe(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_DisablePipe(void)
			{
				UPCONX &= ~(1 << PEN);
    551c:	90 91 a9 00 	lds	r25, 0x00A9
    5520:	9e 7f       	andi	r25, 0xFE	; 254
    5522:	90 93 a9 00 	sts	0x00A9, r25

void Pipe_ClearPipes(void)
{
	UPINT = 0;

	for (uint8_t PNum = 0; PNum < PIPE_TOTAL_PIPES; PNum++)
    5526:	8f 5f       	subi	r24, 0xFF	; 255
    5528:	87 30       	cpi	r24, 0x07	; 7
    552a:	81 f7       	brne	.-32     	; 0x550c <Pipe_ClearPipes+0x6>
		UPIENX  = 0;
		UPINTX  = 0;
		UPCFG1X = 0;
		Pipe_DisablePipe();
	}
}
    552c:	08 95       	ret

0000552e <Pipe_IsEndpointBound>:
			 *  \return Index of the currently selected pipe.
			 */
			static inline uint8_t Pipe_GetCurrentPipe(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Pipe_GetCurrentPipe(void)
			{
				return ((UPNUM & PIPE_PIPENUM_MASK) | Pipe_GetPipeDirection());
    552e:	90 91 a7 00 	lds	r25, 0x00A7
    5532:	9f 70       	andi	r25, 0x0F	; 15
			 *  \return The currently selected pipe's direction, as a \c PIPE_DIR_* mask.
			 */
			static inline uint8_t Pipe_GetPipeDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Pipe_GetPipeDirection(void)
			{
				return (UPCFG0X & (1 << EPDIR)) ? PIPE_DIR_IN : PIPE_DIR_OUT;
    5534:	20 91 aa 00 	lds	r18, 0x00AA
    5538:	20 ff       	sbrs	r18, 0
    553a:	02 c0       	rjmp	.+4      	; 0x5540 <Pipe_IsEndpointBound+0x12>
    553c:	20 e8       	ldi	r18, 0x80	; 128
    553e:	01 c0       	rjmp	.+2      	; 0x5542 <Pipe_IsEndpointBound+0x14>
    5540:	20 e0       	ldi	r18, 0x00	; 0
			 *  \return Index of the currently selected pipe.
			 */
			static inline uint8_t Pipe_GetCurrentPipe(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Pipe_GetCurrentPipe(void)
			{
				return ((UPNUM & PIPE_PIPENUM_MASK) | Pipe_GetPipeDirection());
    5542:	42 2f       	mov	r20, r18
    5544:	49 2b       	or	r20, r25

bool Pipe_IsEndpointBound(const uint8_t EndpointAddress)
{
	uint8_t PrevPipeNumber = Pipe_GetCurrentPipe();

	for (uint8_t PNum = 0; PNum < PIPE_TOTAL_PIPES; PNum++)
    5546:	90 e0       	ldi	r25, 0x00	; 0
			 *  \param[in] Address  Address of the pipe to select.
			 */
			static inline void Pipe_SelectPipe(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SelectPipe(const uint8_t Address)
			{
				UPNUM = (Address & PIPE_PIPENUM_MASK);
    5548:	90 93 a7 00 	sts	0x00A7, r25
			 *  \return Boolean \c true if the selected pipe is configured, \c false otherwise.
			 */
			static inline bool Pipe_IsConfigured(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsConfigured(void)
			{
				return ((UPSTAX & (1 << CFGOK)) ? true : false);
    554c:	20 91 ac 00 	lds	r18, 0x00AC
	{
		Pipe_SelectPipe(PNum);

		if (!(Pipe_IsConfigured()))
    5550:	27 ff       	sbrs	r18, 7
    5552:	0c c0       	rjmp	.+24     	; 0x556c <Pipe_IsEndpointBound+0x3e>
			 *  \return Endpoint address the currently selected pipe is bound to.
			 */
			static inline uint8_t Pipe_GetBoundEndpointAddress(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Pipe_GetBoundEndpointAddress(void)
			{
				uint8_t UPCFG0X_Temp = UPCFG0X;
    5554:	30 91 aa 00 	lds	r19, 0x00AA

				return (((UPCFG0X_Temp >> PEPNUM0) & PIPE_EPNUM_MASK) |
    5558:	53 2f       	mov	r21, r19
    555a:	5f 70       	andi	r21, 0x0F	; 15
    555c:	35 ff       	sbrs	r19, 5
    555e:	02 c0       	rjmp	.+4      	; 0x5564 <Pipe_IsEndpointBound+0x36>
    5560:	20 e8       	ldi	r18, 0x80	; 128
    5562:	01 c0       	rjmp	.+2      	; 0x5566 <Pipe_IsEndpointBound+0x38>
    5564:	20 e0       	ldi	r18, 0x00	; 0
    5566:	25 2b       	or	r18, r21
		  continue;

		if (Pipe_GetBoundEndpointAddress() == EndpointAddress)
    5568:	28 17       	cp	r18, r24
    556a:	49 f0       	breq	.+18     	; 0x557e <Pipe_IsEndpointBound+0x50>

bool Pipe_IsEndpointBound(const uint8_t EndpointAddress)
{
	uint8_t PrevPipeNumber = Pipe_GetCurrentPipe();

	for (uint8_t PNum = 0; PNum < PIPE_TOTAL_PIPES; PNum++)
    556c:	9f 5f       	subi	r25, 0xFF	; 255
    556e:	97 30       	cpi	r25, 0x07	; 7
    5570:	59 f7       	brne	.-42     	; 0x5548 <Pipe_IsEndpointBound+0x1a>
			 *  \param[in] Address  Address of the pipe to select.
			 */
			static inline void Pipe_SelectPipe(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SelectPipe(const uint8_t Address)
			{
				UPNUM = (Address & PIPE_PIPENUM_MASK);
    5572:	94 2f       	mov	r25, r20
    5574:	9f 70       	andi	r25, 0x0F	; 15
    5576:	90 93 a7 00 	sts	0x00A7, r25
		if (Pipe_GetBoundEndpointAddress() == EndpointAddress)
		  return true;
	}

	Pipe_SelectPipe(PrevPipeNumber);
	return false;
    557a:	80 e0       	ldi	r24, 0x00	; 0
    557c:	08 95       	ret

		if (!(Pipe_IsConfigured()))
		  continue;

		if (Pipe_GetBoundEndpointAddress() == EndpointAddress)
		  return true;
    557e:	81 e0       	ldi	r24, 0x01	; 1
	}

	Pipe_SelectPipe(PrevPipeNumber);
	return false;
}
    5580:	08 95       	ret

00005582 <Pipe_WaitUntilReady>:
			 *  \return Current USB frame number from the USB controller.
			 */
			static inline uint16_t USB_Host_GetFrameNumber(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t USB_Host_GetFrameNumber(void)
			{
				return UHFNUM;
    5582:	80 91 a2 00 	lds	r24, 0x00A2
    5586:	90 91 a3 00 	lds	r25, 0x00A3
    558a:	45 e6       	ldi	r20, 0x65	; 101
			 *  \return The current pipe token, as a \c PIPE_TOKEN_* mask.
			 */
			static inline uint8_t Pipe_GetPipeToken(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Pipe_GetPipeToken(void)
			{
				return (UPCFG0X & (0x03 << PTOKEN0));
    558c:	20 91 aa 00 	lds	r18, 0x00AA
    5590:	20 73       	andi	r18, 0x30	; 48

	uint16_t PreviousFrameNumber = USB_Host_GetFrameNumber();

	for (;;)
	{
		if (Pipe_GetPipeToken() == PIPE_TOKEN_IN)
    5592:	20 31       	cpi	r18, 0x10	; 16
    5594:	29 f4       	brne	.+10     	; 0x55a0 <Pipe_WaitUntilReady+0x1e>
			 *  \return Boolean \c true if the current pipe has received an IN packet, \c false otherwise.
			 */
			static inline bool Pipe_IsINReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsINReceived(void)
			{
				return ((UPINTX & (1 << RXINI)) ? true : false);
    5596:	20 91 a6 00 	lds	r18, 0x00A6
		{
			if (Pipe_IsINReceived())
    559a:	20 ff       	sbrs	r18, 0
    559c:	05 c0       	rjmp	.+10     	; 0x55a8 <Pipe_WaitUntilReady+0x26>
    559e:	16 c0       	rjmp	.+44     	; 0x55cc <Pipe_WaitUntilReady+0x4a>
			 *  \return Boolean \c true if the current pipe is ready for an OUT packet, \c false otherwise.
			 */
			static inline bool Pipe_IsOUTReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsOUTReady(void)
			{
				return ((UPINTX & (1 << TXOUTI)) ? true : false);
    55a0:	20 91 a6 00 	lds	r18, 0x00A6
			  return PIPE_READYWAIT_NoError;
		}
		else
		{
			if (Pipe_IsOUTReady())
    55a4:	22 fd       	sbrc	r18, 2
    55a6:	12 c0       	rjmp	.+36     	; 0x55cc <Pipe_WaitUntilReady+0x4a>
			 *  \return Boolean \c true if the current pipe has been stalled by the attached device, \c false otherwise.
			 */
			static inline bool Pipe_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsStalled(void)
			{
				return ((UPINTX & (1 << RXSTALLI)) ? true : false);
    55a8:	20 91 a6 00 	lds	r18, 0x00A6
			  return PIPE_READYWAIT_NoError;
		}

		if (Pipe_IsStalled())
    55ac:	21 fd       	sbrc	r18, 1
    55ae:	10 c0       	rjmp	.+32     	; 0x55d0 <Pipe_WaitUntilReady+0x4e>
		  return PIPE_READYWAIT_PipeStalled;
		else if (USB_HostState == HOST_STATE_Unattached)
    55b0:	2e b3       	in	r18, 0x1e	; 30
    55b2:	21 30       	cpi	r18, 0x01	; 1
    55b4:	79 f0       	breq	.+30     	; 0x55d4 <Pipe_WaitUntilReady+0x52>
    55b6:	20 91 a2 00 	lds	r18, 0x00A2
    55ba:	30 91 a3 00 	lds	r19, 0x00A3
		  return PIPE_READYWAIT_DeviceDisconnected;

		uint16_t CurrentFrameNumber = USB_Host_GetFrameNumber();

		if (CurrentFrameNumber != PreviousFrameNumber)
    55be:	28 17       	cp	r18, r24
    55c0:	39 07       	cpc	r19, r25
    55c2:	21 f3       	breq	.-56     	; 0x558c <Pipe_WaitUntilReady+0xa>
    55c4:	41 50       	subi	r20, 0x01	; 1
		{
			PreviousFrameNumber = CurrentFrameNumber;

			if (!(TimeoutMSRem--))
    55c6:	41 f0       	breq	.+16     	; 0x55d8 <Pipe_WaitUntilReady+0x56>
    55c8:	c9 01       	movw	r24, r18
    55ca:	e0 cf       	rjmp	.-64     	; 0x558c <Pipe_WaitUntilReady+0xa>
	for (;;)
	{
		if (Pipe_GetPipeToken() == PIPE_TOKEN_IN)
		{
			if (Pipe_IsINReceived())
			  return PIPE_READYWAIT_NoError;
    55cc:	80 e0       	ldi	r24, 0x00	; 0
    55ce:	08 95       	ret
			if (Pipe_IsOUTReady())
			  return PIPE_READYWAIT_NoError;
		}

		if (Pipe_IsStalled())
		  return PIPE_READYWAIT_PipeStalled;
    55d0:	81 e0       	ldi	r24, 0x01	; 1
    55d2:	08 95       	ret
		else if (USB_HostState == HOST_STATE_Unattached)
		  return PIPE_READYWAIT_DeviceDisconnected;
    55d4:	82 e0       	ldi	r24, 0x02	; 2
    55d6:	08 95       	ret
		if (CurrentFrameNumber != PreviousFrameNumber)
		{
			PreviousFrameNumber = CurrentFrameNumber;

			if (!(TimeoutMSRem--))
			  return PIPE_READYWAIT_Timeout;
    55d8:	83 e0       	ldi	r24, 0x03	; 3
		}
	}
}
    55da:	08 95       	ret

000055dc <USB_Disable>:
	USB_ResetInterface();
}

void USB_Disable(void)
{
	USB_INT_DisableAllInterrupts();
    55dc:	cf d0       	rcall	.+414    	; 0x577c <USB_INT_DisableAllInterrupts>
    55de:	da d0       	rcall	.+436    	; 0x5794 <USB_INT_ClearAllInterrupts>
	USB_INT_ClearAllInterrupts();
    55e0:	e0 ee       	ldi	r30, 0xE0	; 224
    55e2:	f0 e0       	ldi	r31, 0x00	; 0
			 *  enumerating the device once attached until \ref USB_Attach() is called.
			 */
			static inline void USB_Detach(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Detach(void)
			{
				UDCON  |=  (1 << DETACH);
    55e4:	80 81       	ld	r24, Z
    55e6:	81 60       	ori	r24, 0x01	; 1
    55e8:	80 83       	st	Z, r24
    55ea:	e8 ed       	ldi	r30, 0xD8	; 216
    55ec:	f0 e0       	ldi	r31, 0x00	; 0
			}

			static inline void USB_Controller_Disable(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Controller_Disable(void)
			{
				USBCON &= ~(1 << USBE);
    55ee:	80 81       	ld	r24, Z
    55f0:	8f 77       	andi	r24, 0x7F	; 127
    55f2:	80 83       	st	Z, r24
    55f4:	19 bc       	out	0x29, r1	; 41
    55f6:	a7 ed       	ldi	r26, 0xD7	; 215
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    55f8:	b0 e0       	ldi	r27, 0x00	; 0

			static inline void USB_REG_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_REG_Off(void)
			{
			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
				UHWCON &= ~(1 << UVREGE);
    55fa:	8c 91       	ld	r24, X
    55fc:	8e 7f       	andi	r24, 0xFE	; 254
    55fe:	8c 93       	st	X, r24
    5600:	80 81       	ld	r24, Z
    5602:	8f 7e       	andi	r24, 0xEF	; 239
			}

			static inline void USB_OTGPAD_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_OTGPAD_Off(void)
			{
				USBCON &= ~(1 << OTGPADE);
    5604:	80 83       	st	Z, r24
    5606:	10 92 07 04 	sts	0x0407, r1
	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USB_OTGPAD_Off();
	#endif

	#if defined(USB_CAN_BE_BOTH)
	USB_CurrentMode = USB_MODE_None;
    560a:	10 92 db 0d 	sts	0x0DDB, r1
	#endif

	USB_IsInitialized = false;
    560e:	08 95       	ret

00005610 <USB_ResetInterface>:
    5610:	cf 93       	push	r28
    5612:	c0 91 d7 00 	lds	r28, 0x00D7
{
	#if defined(USB_CAN_BE_BOTH)
	bool UIDModeSelectEnabled = ((UHWCON & (1 << UIDE)) != 0);
	#endif

	USB_INT_DisableAllInterrupts();
    5616:	b2 d0       	rcall	.+356    	; 0x577c <USB_INT_DisableAllInterrupts>
    5618:	bd d0       	rcall	.+378    	; 0x5794 <USB_INT_ClearAllInterrupts>
	USB_INT_ClearAllInterrupts();
    561a:	80 91 d8 00 	lds	r24, 0x00D8
			}

			static inline void USB_Controller_Reset(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Controller_Reset(void)
			{
				USBCON &= ~(1 << USBE);
    561e:	8f 77       	andi	r24, 0x7F	; 127
    5620:	80 93 d8 00 	sts	0x00D8, r24
    5624:	80 91 d8 00 	lds	r24, 0x00D8
				USBCON |=  (1 << USBE);
    5628:	80 68       	ori	r24, 0x80	; 128
    562a:	80 93 d8 00 	sts	0x00D8, r24
    562e:	c6 ff       	sbrs	r28, 6
    5630:	05 c0       	rjmp	.+10     	; 0x563c <USB_ResetInterface+0x2c>

	USB_Controller_Reset();

	#if defined(USB_CAN_BE_BOTH)
	if (UIDModeSelectEnabled)
    5632:	80 91 d8 00 	lds	r24, 0x00D8
						USBCON |= (1 << VBUSTE);
						break;
					#endif
					#if defined(USB_CAN_BE_BOTH)
					case USB_INT_IDTI:
						USBCON |= (1 << IDTE);
    5636:	82 60       	ori	r24, 0x02	; 2
    5638:	80 93 d8 00 	sts	0x00D8, r24
    563c:	80 91 d8 00 	lds	r24, 0x00D8
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON &= ~(1 << FRZCLK);
    5640:	8f 7d       	andi	r24, 0xDF	; 223
    5642:	80 93 d8 00 	sts	0x00D8, r24
    5646:	80 91 07 04 	lds	r24, 0x0407
	  USB_INT_Enable(USB_INT_IDTI);
	#endif

	USB_CLK_Unfreeze();

	if (USB_CurrentMode == USB_MODE_Device)
    564a:	81 30       	cpi	r24, 0x01	; 1
    564c:	59 f5       	brne	.+86     	; 0x56a4 <USB_ResetInterface+0x94>
    564e:	80 91 d7 00 	lds	r24, 0x00D7
	{
		#if defined(USB_CAN_BE_DEVICE)
		#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
		UHWCON |=  (1 << UIMOD);
    5652:	80 68       	ori	r24, 0x80	; 128
    5654:	80 93 d7 00 	sts	0x00D7, r24
    5658:	19 bc       	out	0x29, r1	; 41
    565a:	1e ba       	out	0x1e, r1	; 30
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    565c:	10 92 d7 0d 	sts	0x0DD7, r1

#if defined(USB_CAN_BE_DEVICE)
static void USB_Init_Device(void)
{
	USB_DeviceState                 = DEVICE_STATE_Unattached;
	USB_Device_ConfigurationNumber  = 0;
    5660:	10 92 d9 0d 	sts	0x0DD9, r1

	#if !defined(NO_DEVICE_REMOTE_WAKEUP)
	USB_Device_RemoteWakeupEnabled  = false;
    5664:	10 92 d8 0d 	sts	0x0DD8, r1
	#endif

	#if !defined(NO_DEVICE_SELF_POWER)
	USB_Device_CurrentlySelfPowered = false;
    5668:	80 91 e0 00 	lds	r24, 0x00E0
			}

			static inline void USB_Device_SetFullSpeed(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetFullSpeed(void)
			{
				UDCON &= ~(1 << LSM);
    566c:	8b 7f       	andi	r24, 0xFB	; 251
    566e:	80 93 e0 00 	sts	0x00E0, r24
    5672:	80 91 d8 00 	lds	r24, 0x00D8
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						USBCON |= (1 << VBUSTE);
    5676:	81 60       	ori	r24, 0x01	; 1
    5678:	80 93 d8 00 	sts	0x00D8, r24
    567c:	42 e0       	ldi	r20, 0x02	; 2
    567e:	60 e0       	ldi	r22, 0x00	; 0
				uint8_t Number = (Address & ENDPOINT_EPNUM_MASK);

				if (Number >= ENDPOINT_TOTAL_ENDPOINTS)
				  return false;

				return Endpoint_ConfigureEndpoint_Prv(Number,
    5680:	80 e0       	ldi	r24, 0x00	; 0
    5682:	61 db       	rcall	.-2366   	; 0x4d46 <Endpoint_ConfigureEndpoint_Prv>
    5684:	80 91 e1 00 	lds	r24, 0x00E1
    5688:	8e 7f       	andi	r24, 0xFE	; 254
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
    568a:	80 93 e1 00 	sts	0x00E1, r24
    568e:	80 91 e2 00 	lds	r24, 0x00E2
    5692:	81 60       	ori	r24, 0x01	; 1
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  |= (1 << SUSPE);
    5694:	80 93 e2 00 	sts	0x00E2, r24
    5698:	80 91 e2 00 	lds	r24, 0x00E2
    569c:	88 60       	ori	r24, 0x08	; 8
						break;
					case USB_INT_EORSTI:
						UDIEN  |= (1 << EORSTE);
    569e:	80 93 e2 00 	sts	0x00E2, r24
    56a2:	37 c0       	rjmp	.+110    	; 0x5712 <USB_ResetInterface+0x102>
    56a4:	80 91 07 04 	lds	r24, 0x0407
    56a8:	82 30       	cpi	r24, 0x02	; 2
		}

		USB_Init_Device();
		#endif
	}
	else if (USB_CurrentMode == USB_MODE_Host)
    56aa:	c1 f5       	brne	.+112    	; 0x571c <USB_ResetInterface+0x10c>
    56ac:	80 91 d7 00 	lds	r24, 0x00D7
    56b0:	8f 77       	andi	r24, 0x7F	; 127
	{
		#if defined(USB_CAN_BE_HOST)
		UHWCON &= ~(1 << UIMOD);
    56b2:	80 93 d7 00 	sts	0x00D7, r24
    56b6:	8c e0       	ldi	r24, 0x0C	; 12
    56b8:	89 bd       	out	0x29, r24	; 41
    56ba:	8e e0       	ldi	r24, 0x0E	; 14

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR = USB_PLL_PSC;
    56bc:	89 bd       	out	0x29, r24	; 41
    56be:	09 b4       	in	r0, 0x29	; 41
				PLLCSR = (USB_PLL_PSC | (1 << PLLE));
    56c0:	00 fe       	sbrs	r0, 0
    56c2:	fd cf       	rjmp	.-6      	; 0x56be <USB_ResetInterface+0xae>

		if (!(USB_Options & USB_OPT_MANUAL_PLL))
		{
			#if defined(USB_CAN_BE_HOST)
			USB_PLL_On();
			while (!(USB_PLL_IsReady()));
    56c4:	81 e0       	ldi	r24, 0x01	; 1
    56c6:	8e bb       	out	0x1e, r24	; 30
    56c8:	10 92 da 0d 	sts	0x0DDA, r1
#endif

#if defined(USB_CAN_BE_HOST)
static void USB_Init_Host(void)
{
	USB_HostState                = HOST_STATE_Unattached;
    56cc:	80 e4       	ldi	r24, 0x40	; 64
	USB_Host_ConfigurationNumber = 0;
    56ce:	80 93 8d 01 	sts	0x018D, r24
	USB_Host_ControlPipeSize     = PIPE_CONTROLPIPE_DEFAULT_SIZE;
    56d2:	80 91 d8 00 	lds	r24, 0x00D8
    56d6:	80 64       	ori	r24, 0x40	; 64
	#if !defined(__DOXYGEN__)
		/* Macros: */
			static inline void USB_Host_HostMode_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_HostMode_On(void)
			{
				USBCON |=  (1 << HOST);
    56d8:	80 93 d8 00 	sts	0x00D8, r24
    56dc:	80 91 dd 00 	lds	r24, 0x00DD
    56e0:	81 60       	ori	r24, 0x01	; 1
			}

			static inline void USB_Host_VBUS_Auto_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_VBUS_Auto_Off(void)
			{
				OTGCON |=  (1 << VBUSRQC);
    56e2:	80 93 dd 00 	sts	0x00DD, r24
    56e6:	80 91 dd 00 	lds	r24, 0x00DD
    56ea:	84 60       	ori	r24, 0x04	; 4
			}

			static inline void USB_Host_VBUS_Manual_Enable(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_VBUS_Manual_Enable(void)
			{
				OTGCON |=  (1 << VBUSHWC);
    56ec:	80 93 dd 00 	sts	0x00DD, r24
    56f0:	80 91 d7 00 	lds	r24, 0x00D7
    56f4:	8f 7e       	andi	r24, 0xEF	; 239
				UHWCON &= ~(1 << UVCONE);
    56f6:	80 93 d7 00 	sts	0x00D7, r24
    56fa:	6f 9a       	sbi	0x0d, 7	; 13
    56fc:	77 9a       	sbi	0x0e, 7	; 14
    56fe:	80 91 de 00 	lds	r24, 0x00DE
			static inline void USB_Host_VBUS_Manual_On(void)
			{
				#if defined(INVERTED_VBUS_ENABLE_LINE)
				PORTE  &= ~(1 << 7);
				#else
				PORTE  |=  (1 << 7);
    5702:	81 60       	ori	r24, 0x01	; 1
						break;
					case USB_INT_VBERRI:
						OTGIEN |= (1 << VBERRE);
						break;
					case USB_INT_SRPI:
						OTGIEN |= (1 << SRPE);
    5704:	80 93 de 00 	sts	0x00DE, r24
    5708:	80 91 de 00 	lds	r24, 0x00DE
    570c:	84 60       	ori	r24, 0x04	; 4
						break;
					case USB_INT_RSTI:
						UHIEN  |= (1 << RSTE);
						break;
					case USB_INT_BCERRI:
						OTGIEN |= (1 << BCERRE);
    570e:	80 93 de 00 	sts	0x00DE, r24
    5712:	80 91 e0 00 	lds	r24, 0x00E0
    5716:	8e 7f       	andi	r24, 0xFE	; 254
			 *  register and despite the datasheet making no mention of its requirement in host mode.
			 */
			static inline void USB_Attach(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Attach(void)
			{
				UDCON  &= ~(1 << DETACH);
    5718:	80 93 e0 00 	sts	0x00E0, r24
    571c:	80 91 d8 00 	lds	r24, 0x00D8
    5720:	80 61       	ori	r24, 0x10	; 16

			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
			static inline void USB_OTGPAD_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_OTGPAD_On(void)
			{
				USBCON |=  (1 << OTGPADE);
    5722:	80 93 d8 00 	sts	0x00D8, r24
    5726:	cf 91       	pop	r28
    5728:	08 95       	ret

0000572a <USB_Init>:
    572a:	90 91 d8 00 	lds	r25, 0x00D8
	}

	#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
	USB_OTGPAD_On();
	#endif
}
    572e:	9f 7e       	andi	r25, 0xEF	; 239
			}

			static inline void USB_OTGPAD_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_OTGPAD_Off(void)
			{
				USBCON &= ~(1 << OTGPADE);
    5730:	90 93 d8 00 	sts	0x00D8, r25

			static inline void USB_REG_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_REG_On(void)
			{
			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
				UHWCON |=  (1 << UVREGE);
    5734:	90 91 d7 00 	lds	r25, 0x00D7
    5738:	91 60       	ori	r25, 0x01	; 1
    573a:	90 93 d7 00 	sts	0x00D7, r25
		PLLFRQ = (1 << PDIV2);
		#endif
	}

	#if defined(USB_CAN_BE_BOTH)
	if (Mode == USB_MODE_UID)
    573e:	83 30       	cpi	r24, 0x03	; 3
    5740:	91 f4       	brne	.+36     	; 0x5766 <USB_Init+0x3c>
	{
		UHWCON |=  (1 << UIDE);
    5742:	80 91 d7 00 	lds	r24, 0x00D7
    5746:	80 64       	ori	r24, 0x40	; 64
    5748:	80 93 d7 00 	sts	0x00D7, r24
						USBCON |= (1 << VBUSTE);
						break;
					#endif
					#if defined(USB_CAN_BE_BOTH)
					case USB_INT_IDTI:
						USBCON |= (1 << IDTE);
    574c:	80 91 d8 00 	lds	r24, 0x00D8
    5750:	82 60       	ori	r24, 0x02	; 2
    5752:	80 93 d8 00 	sts	0x00D8, r24

			#if defined(USB_CAN_BE_BOTH)
			static inline uint8_t USB_GetUSBModeFromUID(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t USB_GetUSBModeFromUID(void)
			{
				if (USBSTA & (1 << ID))
    5756:	80 91 d9 00 	lds	r24, 0x00D9
    575a:	81 ff       	sbrs	r24, 1
    575c:	02 c0       	rjmp	.+4      	; 0x5762 <USB_Init+0x38>
				  return USB_MODE_Device;
    575e:	81 e0       	ldi	r24, 0x01	; 1
    5760:	07 c0       	rjmp	.+14     	; 0x5770 <USB_Init+0x46>
				else
				  return USB_MODE_Host;
    5762:	82 e0       	ldi	r24, 0x02	; 2
    5764:	05 c0       	rjmp	.+10     	; 0x5770 <USB_Init+0x46>
		USB_INT_Enable(USB_INT_IDTI);
		USB_CurrentMode = USB_GetUSBModeFromUID();
	}
	else
	{
		UHWCON &= ~(1 << UIDE);
    5766:	90 91 d7 00 	lds	r25, 0x00D7
    576a:	9f 7b       	andi	r25, 0xBF	; 191
    576c:	90 93 d7 00 	sts	0x00D7, r25
		USB_CurrentMode = Mode;
    5770:	80 93 07 04 	sts	0x0407, r24
	}
	#endif

	USB_IsInitialized = true;
    5774:	81 e0       	ldi	r24, 0x01	; 1
    5776:	80 93 db 0d 	sts	0x0DDB, r24

	USB_ResetInterface();
    577a:	4a cf       	rjmp	.-364    	; 0x5610 <USB_ResetInterface>

0000577c <USB_INT_DisableAllInterrupts>:
    577c:	e8 ed       	ldi	r30, 0xD8	; 216
#include "../USBInterrupt.h"

void USB_INT_DisableAllInterrupts(void)
{
	#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBCON &= ~((1 << VBUSTE) | (1 << IDTE));
    577e:	f0 e0       	ldi	r31, 0x00	; 0
    5780:	80 81       	ld	r24, Z
    5782:	8c 7f       	andi	r24, 0xFC	; 252
    5784:	80 83       	st	Z, r24
	#elif defined(USB_SERIES_4_AVR)
	USBCON &= ~(1 << VBUSTE);
	#endif

	#if defined(USB_CAN_BE_BOTH)
	OTGIEN  = 0;
    5786:	10 92 de 00 	sts	0x00DE, r1
	#endif

	#if defined(USB_CAN_BE_HOST)
	UHIEN   = 0;
    578a:	10 92 a0 00 	sts	0x00A0, r1
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDIEN   = 0;
    578e:	10 92 e2 00 	sts	0x00E2, r1
    5792:	08 95       	ret

00005794 <USB_INT_ClearAllInterrupts>:
}

void USB_INT_ClearAllInterrupts(void)
{
	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBINT = 0;
    5794:	10 92 da 00 	sts	0x00DA, r1
	#endif

	#if defined(USB_CAN_BE_BOTH)
	OTGINT = 0;
    5798:	10 92 df 00 	sts	0x00DF, r1
	#endif

	#if defined(USB_CAN_BE_HOST)
	UHINT  = 0;
    579c:	10 92 9f 00 	sts	0x009F, r1
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDINT  = 0;
    57a0:	10 92 e1 00 	sts	0x00E1, r1
    57a4:	08 95       	ret

000057a6 <__vector_10>:
	#endif
}

ISR(USB_GEN_vect, ISR_BLOCK)
{
    57a6:	1f 92       	push	r1
    57a8:	0f 92       	push	r0
    57aa:	0f b6       	in	r0, 0x3f	; 63
    57ac:	0f 92       	push	r0
    57ae:	11 24       	eor	r1, r1
    57b0:	0b b6       	in	r0, 0x3b	; 59
    57b2:	0f 92       	push	r0
    57b4:	2f 93       	push	r18
    57b6:	3f 93       	push	r19
    57b8:	4f 93       	push	r20
    57ba:	5f 93       	push	r21
    57bc:	6f 93       	push	r22
    57be:	7f 93       	push	r23
    57c0:	8f 93       	push	r24
    57c2:	9f 93       	push	r25
    57c4:	af 93       	push	r26
    57c6:	bf 93       	push	r27
    57c8:	ef 93       	push	r30
    57ca:	ff 93       	push	r31
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
					case USB_INT_EORSTI:
						return (UDINT  & (1 << EORSTI));
					case USB_INT_SOFI:
						return (UDINT  & (1 << SOFI));
    57cc:	80 91 e1 00 	lds	r24, 0x00E1
	#if defined(USB_CAN_BE_DEVICE)
	#if !defined(NO_SOF_EVENTS)
	if (USB_INT_HasOccurred(USB_INT_SOFI) && USB_INT_IsEnabled(USB_INT_SOFI))
    57d0:	82 ff       	sbrs	r24, 2
    57d2:	0a c0       	rjmp	.+20     	; 0x57e8 <__vector_10+0x42>
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
					case USB_INT_EORSTI:
						return (UDIEN  & (1 << EORSTE));
					case USB_INT_SOFI:
						return (UDIEN  & (1 << SOFE));
    57d4:	80 91 e2 00 	lds	r24, 0x00E2
    57d8:	82 ff       	sbrs	r24, 2
    57da:	06 c0       	rjmp	.+12     	; 0x57e8 <__vector_10+0x42>
						break;
					case USB_INT_EORSTI:
						UDINT  &= ~(1 << EORSTI);
						break;
					case USB_INT_SOFI:
						UDINT  &= ~(1 << SOFI);
    57dc:	80 91 e1 00 	lds	r24, 0x00E1
    57e0:	8b 7f       	andi	r24, 0xFB	; 251
    57e2:	80 93 e1 00 	sts	0x00E1, r24
	{
		USB_INT_Clear(USB_INT_SOFI);

		EVENT_USB_Device_StartOfFrame();
    57e6:	7a d3       	rcall	.+1780   	; 0x5edc <USB_Event_Stub>
    57e8:	80 91 da 00 	lds	r24, 0x00DA
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						return (USBINT & (1 << VBUSTI));
    57ec:	80 ff       	sbrs	r24, 0
	}
	#endif

	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	if (USB_INT_HasOccurred(USB_INT_VBUSTI) && USB_INT_IsEnabled(USB_INT_VBUSTI))
    57ee:	1d c0       	rjmp	.+58     	; 0x582a <__vector_10+0x84>
    57f0:	80 91 d8 00 	lds	r24, 0x00D8
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						return (USBCON & (1 << VBUSTE));
    57f4:	80 ff       	sbrs	r24, 0
    57f6:	19 c0       	rjmp	.+50     	; 0x582a <__vector_10+0x84>
    57f8:	80 91 da 00 	lds	r24, 0x00DA
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						USBINT &= ~(1 << VBUSTI);
    57fc:	8e 7f       	andi	r24, 0xFE	; 254
    57fe:	80 93 da 00 	sts	0x00DA, r24
    5802:	80 91 d9 00 	lds	r24, 0x00D9
				 *  \return Boolean \c true if the VBUS line is currently detecting power from a host, \c false otherwise.
				 */
				static inline bool USB_VBUS_GetStatus(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
				static inline bool USB_VBUS_GetStatus(void)
				{
					return ((USBSTA & (1 << VBUS)) ? true : false);
    5806:	80 ff       	sbrs	r24, 0
	{
		USB_INT_Clear(USB_INT_VBUSTI);

		if (USB_VBUS_GetStatus())
    5808:	0c c0       	rjmp	.+24     	; 0x5822 <__vector_10+0x7c>
    580a:	8c e0       	ldi	r24, 0x0C	; 12

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR = USB_PLL_PSC;
    580c:	89 bd       	out	0x29, r24	; 41
    580e:	8e e0       	ldi	r24, 0x0E	; 14
				PLLCSR = (USB_PLL_PSC | (1 << PLLE));
    5810:	89 bd       	out	0x29, r24	; 41
    5812:	09 b4       	in	r0, 0x29	; 41
		{
			if (!(USB_Options & USB_OPT_MANUAL_PLL))
			{
				USB_PLL_On();
				while (!(USB_PLL_IsReady()));
    5814:	00 fe       	sbrs	r0, 0
    5816:	fd cf       	rjmp	.-6      	; 0x5812 <__vector_10+0x6c>
    5818:	81 e0       	ldi	r24, 0x01	; 1
			}

			USB_DeviceState = DEVICE_STATE_Powered;
    581a:	8e bb       	out	0x1e, r24	; 30
    581c:	0e 94 ac 02 	call	0x558	; 0x558 <EVENT_USB_Device_Connect>
			EVENT_USB_Device_Connect();
    5820:	04 c0       	rjmp	.+8      	; 0x582a <__vector_10+0x84>
    5822:	19 bc       	out	0x29, r1	; 41
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    5824:	1e ba       	out	0x1e, r1	; 30
		else
		{
			if (!(USB_Options & USB_OPT_MANUAL_PLL))
			  USB_PLL_Off();

			USB_DeviceState = DEVICE_STATE_Unattached;
    5826:	0e 94 af 02 	call	0x55e	; 0x55e <EVENT_USB_Device_Disconnect>
			EVENT_USB_Device_Disconnect();
    582a:	80 91 e1 00 	lds	r24, 0x00E1
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
    582e:	80 ff       	sbrs	r24, 0
		}
	}
	#endif

	if (USB_INT_HasOccurred(USB_INT_SUSPI) && USB_INT_IsEnabled(USB_INT_SUSPI))
    5830:	17 c0       	rjmp	.+46     	; 0x5860 <__vector_10+0xba>
    5832:	80 91 e2 00 	lds	r24, 0x00E2
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
    5836:	80 ff       	sbrs	r24, 0
    5838:	13 c0       	rjmp	.+38     	; 0x5860 <__vector_10+0xba>
    583a:	80 91 e2 00 	lds	r24, 0x00E2
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  &= ~(1 << SUSPE);
    583e:	8e 7f       	andi	r24, 0xFE	; 254
    5840:	80 93 e2 00 	sts	0x00E2, r24
    5844:	80 91 e2 00 	lds	r24, 0x00E2
						USBCON |= (1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
    5848:	80 61       	ori	r24, 0x10	; 16
    584a:	80 93 e2 00 	sts	0x00E2, r24
    584e:	80 91 d8 00 	lds	r24, 0x00D8
			#endif

			static inline void USB_CLK_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Freeze(void)
			{
				USBCON |=  (1 << FRZCLK);
    5852:	80 62       	ori	r24, 0x20	; 32
    5854:	80 93 d8 00 	sts	0x00D8, r24
    5858:	19 bc       	out	0x29, r1	; 41
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    585a:	85 e0       	ldi	r24, 0x05	; 5

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		USB_DeviceState = DEVICE_STATE_Unattached;
		EVENT_USB_Device_Disconnect();
		#else
		USB_DeviceState = DEVICE_STATE_Suspended;
    585c:	8e bb       	out	0x1e, r24	; 30
    585e:	3e d3       	rcall	.+1660   	; 0x5edc <USB_Event_Stub>
		EVENT_USB_Device_Suspend();
    5860:	80 91 e1 00 	lds	r24, 0x00E1
					case USB_INT_IDTI:
						return (USBINT & (1 << IDTI));
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
    5864:	84 ff       	sbrs	r24, 4
    5866:	2e c0       	rjmp	.+92     	; 0x58c4 <__vector_10+0x11e>
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_WAKEUPI) && USB_INT_IsEnabled(USB_INT_WAKEUPI))
    5868:	80 91 e2 00 	lds	r24, 0x00E2
					case USB_INT_IDTI:
						return (USBCON & (1 << IDTE));
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
    586c:	84 ff       	sbrs	r24, 4
    586e:	2a c0       	rjmp	.+84     	; 0x58c4 <__vector_10+0x11e>
    5870:	8c e0       	ldi	r24, 0x0C	; 12
    5872:	89 bd       	out	0x29, r24	; 41

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR = USB_PLL_PSC;
    5874:	8e e0       	ldi	r24, 0x0E	; 14
    5876:	89 bd       	out	0x29, r24	; 41
				PLLCSR = (USB_PLL_PSC | (1 << PLLE));
    5878:	09 b4       	in	r0, 0x29	; 41
    587a:	00 fe       	sbrs	r0, 0
	{
		if (!(USB_Options & USB_OPT_MANUAL_PLL))
		{
			USB_PLL_On();
			while (!(USB_PLL_IsReady()));
    587c:	fd cf       	rjmp	.-6      	; 0x5878 <__vector_10+0xd2>
    587e:	80 91 d8 00 	lds	r24, 0x00D8
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON &= ~(1 << FRZCLK);
    5882:	8f 7d       	andi	r24, 0xDF	; 223
    5884:	80 93 d8 00 	sts	0x00D8, r24
    5888:	80 91 e1 00 	lds	r24, 0x00E1
						USBINT &= ~(1 << IDTI);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
    588c:	8f 7e       	andi	r24, 0xEF	; 239
    588e:	80 93 e1 00 	sts	0x00E1, r24
    5892:	80 91 e2 00 	lds	r24, 0x00E2
						USBCON &= ~(1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
    5896:	8f 7e       	andi	r24, 0xEF	; 239
    5898:	80 93 e2 00 	sts	0x00E2, r24
    589c:	80 91 e2 00 	lds	r24, 0x00E2
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  |= (1 << SUSPE);
    58a0:	81 60       	ori	r24, 0x01	; 1
    58a2:	80 93 e2 00 	sts	0x00E2, r24
    58a6:	80 91 d7 0d 	lds	r24, 0x0DD7
		USB_INT_Clear(USB_INT_WAKEUPI);

		USB_INT_Disable(USB_INT_WAKEUPI);
		USB_INT_Enable(USB_INT_SUSPI);

		if (USB_Device_ConfigurationNumber)
    58aa:	88 23       	and	r24, r24
    58ac:	11 f0       	breq	.+4      	; 0x58b2 <__vector_10+0x10c>
    58ae:	84 e0       	ldi	r24, 0x04	; 4
    58b0:	07 c0       	rjmp	.+14     	; 0x58c0 <__vector_10+0x11a>
		  USB_DeviceState = DEVICE_STATE_Configured;
    58b2:	80 91 e3 00 	lds	r24, 0x00E3
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
    58b6:	87 ff       	sbrs	r24, 7
    58b8:	02 c0       	rjmp	.+4      	; 0x58be <__vector_10+0x118>
		else
		  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Addressed : DEVICE_STATE_Powered;
    58ba:	83 e0       	ldi	r24, 0x03	; 3
    58bc:	01 c0       	rjmp	.+2      	; 0x58c0 <__vector_10+0x11a>
    58be:	81 e0       	ldi	r24, 0x01	; 1
    58c0:	8e bb       	out	0x1e, r24	; 30
    58c2:	0c d3       	rcall	.+1560   	; 0x5edc <USB_Event_Stub>
    58c4:	80 91 e1 00 	lds	r24, 0x00E1

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		EVENT_USB_Device_Connect();
		#else
		EVENT_USB_Device_WakeUp();
    58c8:	83 ff       	sbrs	r24, 3
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
					case USB_INT_EORSTI:
						return (UDINT  & (1 << EORSTI));
    58ca:	26 c0       	rjmp	.+76     	; 0x5918 <__vector_10+0x172>
    58cc:	80 91 e2 00 	lds	r24, 0x00E2
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_EORSTI) && USB_INT_IsEnabled(USB_INT_EORSTI))
    58d0:	83 ff       	sbrs	r24, 3
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
					case USB_INT_EORSTI:
						return (UDIEN  & (1 << EORSTE));
    58d2:	22 c0       	rjmp	.+68     	; 0x5918 <__vector_10+0x172>
    58d4:	80 91 e1 00 	lds	r24, 0x00E1
    58d8:	87 7f       	andi	r24, 0xF7	; 247
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
						break;
					case USB_INT_EORSTI:
						UDINT  &= ~(1 << EORSTI);
    58da:	80 93 e1 00 	sts	0x00E1, r24
    58de:	82 e0       	ldi	r24, 0x02	; 2
    58e0:	8e bb       	out	0x1e, r24	; 30
    58e2:	10 92 d7 0d 	sts	0x0DD7, r1
	{
		USB_INT_Clear(USB_INT_EORSTI);

		USB_DeviceState                = DEVICE_STATE_Default;
    58e6:	80 91 e1 00 	lds	r24, 0x00E1
		USB_Device_ConfigurationNumber = 0;
    58ea:	8e 7f       	andi	r24, 0xFE	; 254
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
    58ec:	80 93 e1 00 	sts	0x00E1, r24
    58f0:	80 91 e2 00 	lds	r24, 0x00E2
    58f4:	8e 7f       	andi	r24, 0xFE	; 254
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  &= ~(1 << SUSPE);
    58f6:	80 93 e2 00 	sts	0x00E2, r24
    58fa:	80 91 e2 00 	lds	r24, 0x00E2
    58fe:	80 61       	ori	r24, 0x10	; 16
						USBCON |= (1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
    5900:	80 93 e2 00 	sts	0x00E2, r24
    5904:	42 e0       	ldi	r20, 0x02	; 2
    5906:	60 e0       	ldi	r22, 0x00	; 0
    5908:	80 e0       	ldi	r24, 0x00	; 0
				uint8_t Number = (Address & ENDPOINT_EPNUM_MASK);

				if (Number >= ENDPOINT_TOTAL_ENDPOINTS)
				  return false;

				return Endpoint_ConfigureEndpoint_Prv(Number,
    590a:	1d da       	rcall	.-3014   	; 0x4d46 <Endpoint_ConfigureEndpoint_Prv>
    590c:	80 91 f0 00 	lds	r24, 0x00F0
    5910:	88 60       	ori	r24, 0x08	; 8
    5912:	80 93 f0 00 	sts	0x00F0, r24
						break;
					case USB_INT_SOFI:
						UDIEN  |= (1 << SOFE);
						break;
					case USB_INT_RXSTPI:
						UEIENX |= (1 << RXSTPE);
    5916:	e2 d2       	rcall	.+1476   	; 0x5edc <USB_Event_Stub>
    5918:	80 91 9f 00 	lds	r24, 0x009F
    591c:	85 ff       	sbrs	r24, 5

		#if defined(INTERRUPT_CONTROL_ENDPOINT)
		USB_INT_Enable(USB_INT_RXSTPI);
		#endif

		EVENT_USB_Device_Reset();
    591e:	0a c0       	rjmp	.+20     	; 0x5934 <__vector_10+0x18e>
    5920:	80 91 a0 00 	lds	r24, 0x00A0
					case USB_INT_RXSTPI:
						return (UEINTX & (1 << RXSTPI));
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						return (UHINT  & (1 << HSOFI));
    5924:	85 ff       	sbrs	r24, 5
	}
	#endif

	#if defined(USB_CAN_BE_HOST)
	#if !defined(NO_SOF_EVENTS)
	if (USB_INT_HasOccurred(USB_INT_HSOFI) && USB_INT_IsEnabled(USB_INT_HSOFI))
    5926:	06 c0       	rjmp	.+12     	; 0x5934 <__vector_10+0x18e>
    5928:	80 91 9f 00 	lds	r24, 0x009F
					case USB_INT_RXSTPI:
						return (UEIENX & (1 << RXSTPE));
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						return (UHIEN  & (1 << HSOFE));
    592c:	8f 7d       	andi	r24, 0xDF	; 223
    592e:	80 93 9f 00 	sts	0x009F, r24
						UEINTX &= ~(1 << RXSTPI);
						break;
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						UHINT  &= ~(1 << HSOFI);
    5932:	d4 d2       	rcall	.+1448   	; 0x5edc <USB_Event_Stub>
    5934:	80 91 9f 00 	lds	r24, 0x009F
    5938:	81 ff       	sbrs	r24, 1
    593a:	16 c0       	rjmp	.+44     	; 0x5968 <__vector_10+0x1c2>
	{
		USB_INT_Clear(USB_INT_HSOFI);

		EVENT_USB_Host_StartOfFrame();
    593c:	80 91 a0 00 	lds	r24, 0x00A0
					case USB_INT_HSOFI:
						return (UHINT  & (1 << HSOFI));
					case USB_INT_DCONNI:
						return (UHINT  & (1 << DCONNI));
					case USB_INT_DDISCI:
						return (UHINT  & (1 << DDISCI));
    5940:	81 ff       	sbrs	r24, 1
    5942:	12 c0       	rjmp	.+36     	; 0x5968 <__vector_10+0x1c2>
	}
	#endif

	if (USB_INT_HasOccurred(USB_INT_DDISCI) && USB_INT_IsEnabled(USB_INT_DDISCI))
    5944:	80 91 9f 00 	lds	r24, 0x009F
					case USB_INT_HSOFI:
						return (UHIEN  & (1 << HSOFE));
					case USB_INT_DCONNI:
						return (UHIEN  & (1 << DCONNE));
					case USB_INT_DDISCI:
						return (UHIEN  & (1 << DDISCE));
    5948:	8d 7f       	andi	r24, 0xFD	; 253
    594a:	80 93 9f 00 	sts	0x009F, r24
    594e:	80 91 9f 00 	lds	r24, 0x009F
						break;
					case USB_INT_DCONNI:
						UHINT  &= ~(1 << DCONNI);
						break;
					case USB_INT_DDISCI:
						UHINT  &= ~(1 << DDISCI);
    5952:	8e 7f       	andi	r24, 0xFE	; 254
    5954:	80 93 9f 00 	sts	0x009F, r24
    5958:	80 91 a0 00 	lds	r24, 0x00A0
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						UHINT  &= ~(1 << HSOFI);
						break;
					case USB_INT_DCONNI:
						UHINT  &= ~(1 << DCONNI);
    595c:	8d 7f       	andi	r24, 0xFD	; 253
    595e:	80 93 a0 00 	sts	0x00A0, r24
    5962:	0e 94 e7 02 	call	0x5ce	; 0x5ce <EVENT_USB_Host_DeviceUnattached>
						break;
					case USB_INT_DCONNI:
						UHIEN  &= ~(1 << DCONNE);
						break;
					case USB_INT_DDISCI:
						UHIEN  &= ~(1 << DDISCE);
    5966:	54 de       	rcall	.-856    	; 0x5610 <USB_ResetInterface>
    5968:	80 91 df 00 	lds	r24, 0x00DF
    596c:	81 ff       	sbrs	r24, 1
	{
		USB_INT_Clear(USB_INT_DDISCI);
		USB_INT_Clear(USB_INT_DCONNI);
		USB_INT_Disable(USB_INT_DDISCI);

		EVENT_USB_Host_DeviceUnattached();
    596e:	16 c0       	rjmp	.+44     	; 0x599c <__vector_10+0x1f6>
    5970:	80 91 de 00 	lds	r24, 0x00DE

		USB_ResetInterface();
    5974:	81 ff       	sbrs	r24, 1
					case USB_INT_RSTI:
						return (UHINT  & (1 << RSTI));
					case USB_INT_BCERRI:
						return (OTGINT & (1 << BCERRI));
					case USB_INT_VBERRI:
						return (OTGINT & (1 << VBERRI));
    5976:	12 c0       	rjmp	.+36     	; 0x599c <__vector_10+0x1f6>
    5978:	80 91 df 00 	lds	r24, 0x00DF
	}

	if (USB_INT_HasOccurred(USB_INT_VBERRI) && USB_INT_IsEnabled(USB_INT_VBERRI))
    597c:	8d 7f       	andi	r24, 0xFD	; 253
					case USB_INT_RSTI:
						return (UHIEN  & (1 << RSTE));
					case USB_INT_BCERRI:
						return (OTGIEN & (1 << BCERRE));
					case USB_INT_VBERRI:
						return (OTGIEN & (1 << VBERRE));
    597e:	80 93 df 00 	sts	0x00DF, r24
    5982:	77 98       	cbi	0x0e, 7	; 14
    5984:	80 91 dd 00 	lds	r24, 0x00DD
						break;
					case USB_INT_BCERRI:
						OTGINT &= ~(1 << BCERRI);
						break;
					case USB_INT_VBERRI:
						OTGINT &= ~(1 << VBERRI);
    5988:	81 60       	ori	r24, 0x01	; 1
    598a:	80 93 dd 00 	sts	0x00DD, r24
    598e:	80 e0       	ldi	r24, 0x00	; 0
			static inline void USB_Host_VBUS_Manual_Off(void)
			{
				#if defined(INVERTED_VBUS_ENABLE_LINE)
				PORTE  |=  (1 << 7);
				#else
				PORTE  &= ~(1 << 7);
    5990:	0e 94 5f 03 	call	0x6be	; 0x6be <EVENT_USB_Host_HostError>
			}

			static inline void USB_Host_VBUS_Auto_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_VBUS_Auto_Off(void)
			{
				OTGCON |=  (1 << VBUSRQC);
    5994:	0e 94 e7 02 	call	0x5ce	; 0x5ce <EVENT_USB_Host_DeviceUnattached>
    5998:	81 e0       	ldi	r24, 0x01	; 1
    599a:	8e bb       	out	0x1e, r24	; 30
		USB_INT_Clear(USB_INT_VBERRI);

		USB_Host_VBUS_Manual_Off();
		USB_Host_VBUS_Auto_Off();

		EVENT_USB_Host_HostError(HOST_ERROR_VBusVoltageDip);
    599c:	80 91 df 00 	lds	r24, 0x00DF
    59a0:	80 ff       	sbrs	r24, 0
		EVENT_USB_Host_DeviceUnattached();
    59a2:	17 c0       	rjmp	.+46     	; 0x59d2 <__vector_10+0x22c>
    59a4:	80 91 de 00 	lds	r24, 0x00DE

		USB_HostState = HOST_STATE_Unattached;
    59a8:	80 ff       	sbrs	r24, 0
					case USB_INT_BCERRI:
						return (OTGINT & (1 << BCERRI));
					case USB_INT_VBERRI:
						return (OTGINT & (1 << VBERRI));
					case USB_INT_SRPI:
						return (OTGINT & (1 << SRPI));
    59aa:	13 c0       	rjmp	.+38     	; 0x59d2 <__vector_10+0x22c>
    59ac:	80 91 df 00 	lds	r24, 0x00DF
	}

	if (USB_INT_HasOccurred(USB_INT_SRPI) && USB_INT_IsEnabled(USB_INT_SRPI))
    59b0:	8e 7f       	andi	r24, 0xFE	; 254
					case USB_INT_BCERRI:
						return (OTGIEN & (1 << BCERRE));
					case USB_INT_VBERRI:
						return (OTGIEN & (1 << VBERRE));
					case USB_INT_SRPI:
						return (OTGIEN & (1 << SRPE));
    59b2:	80 93 df 00 	sts	0x00DF, r24
    59b6:	80 91 de 00 	lds	r24, 0x00DE
						break;
					case USB_INT_VBERRI:
						OTGINT &= ~(1 << VBERRI);
						break;
					case USB_INT_SRPI:
						OTGINT &= ~(1 << SRPI);
    59ba:	8e 7f       	andi	r24, 0xFE	; 254
    59bc:	80 93 de 00 	sts	0x00DE, r24
    59c0:	0e 94 e5 02 	call	0x5ca	; 0x5ca <EVENT_USB_Host_DeviceAttached>
						break;
					case USB_INT_VBERRI:
						OTGIEN &= ~(1 << VBERRE);
						break;
					case USB_INT_SRPI:
						OTGIEN &= ~(1 << SRPE);
    59c4:	80 91 a0 00 	lds	r24, 0x00A0
    59c8:	82 60       	ori	r24, 0x02	; 2
    59ca:	80 93 a0 00 	sts	0x00A0, r24
	{
		USB_INT_Clear(USB_INT_SRPI);
		USB_INT_Disable(USB_INT_SRPI);

		EVENT_USB_Host_DeviceAttached();
    59ce:	82 e0       	ldi	r24, 0x02	; 2
    59d0:	8e bb       	out	0x1e, r24	; 30
						break;
					case USB_INT_DCONNI:
						UHIEN  |= (1 << DCONNE);
						break;
					case USB_INT_DDISCI:
						UHIEN  |= (1 << DDISCE);
    59d2:	80 91 df 00 	lds	r24, 0x00DF
    59d6:	82 ff       	sbrs	r24, 2
    59d8:	10 c0       	rjmp	.+32     	; 0x59fa <__vector_10+0x254>
    59da:	80 91 de 00 	lds	r24, 0x00DE

		USB_INT_Enable(USB_INT_DDISCI);

		USB_HostState = HOST_STATE_Powered;
    59de:	82 ff       	sbrs	r24, 2
					case USB_INT_DDISCI:
						return (UHINT  & (1 << DDISCI));
					case USB_INT_RSTI:
						return (UHINT  & (1 << RSTI));
					case USB_INT_BCERRI:
						return (OTGINT & (1 << BCERRI));
    59e0:	0c c0       	rjmp	.+24     	; 0x59fa <__vector_10+0x254>
    59e2:	80 91 df 00 	lds	r24, 0x00DF
	}

	if (USB_INT_HasOccurred(USB_INT_BCERRI) && USB_INT_IsEnabled(USB_INT_BCERRI))
    59e6:	8b 7f       	andi	r24, 0xFB	; 251
					case USB_INT_DDISCI:
						return (UHIEN  & (1 << DDISCE));
					case USB_INT_RSTI:
						return (UHIEN  & (1 << RSTE));
					case USB_INT_BCERRI:
						return (OTGIEN & (1 << BCERRE));
    59e8:	80 93 df 00 	sts	0x00DF, r24
    59ec:	60 e0       	ldi	r22, 0x00	; 0
    59ee:	82 e0       	ldi	r24, 0x02	; 2
						break;
					case USB_INT_RSTI:
						UHINT  &= ~(1 << RSTI);
						break;
					case USB_INT_BCERRI:
						OTGINT &= ~(1 << BCERRI);
    59f0:	0e 94 64 03 	call	0x6c8	; 0x6c8 <EVENT_USB_Host_DeviceEnumerationFailed>
    59f4:	0e 94 e7 02 	call	0x5ce	; 0x5ce <EVENT_USB_Host_DeviceUnattached>
    59f8:	0b de       	rcall	.-1002   	; 0x5610 <USB_ResetInterface>
	{
		USB_INT_Clear(USB_INT_BCERRI);

		EVENT_USB_Host_DeviceEnumerationFailed(HOST_ENUMERROR_NoDeviceDetected, 0);
    59fa:	80 91 da 00 	lds	r24, 0x00DA
    59fe:	81 ff       	sbrs	r24, 1
    5a00:	1d c0       	rjmp	.+58     	; 0x5a3c <__vector_10+0x296>
		EVENT_USB_Host_DeviceUnattached();
    5a02:	80 91 d8 00 	lds	r24, 0x00D8

		USB_ResetInterface();
    5a06:	81 ff       	sbrs	r24, 1
    5a08:	19 c0       	rjmp	.+50     	; 0x5a3c <__vector_10+0x296>
					case USB_INT_VBUSTI:
						return (USBINT & (1 << VBUSTI));
					#endif
					#if defined(USB_CAN_BE_BOTH)
					case USB_INT_IDTI:
						return (USBINT & (1 << IDTI));
    5a0a:	80 91 da 00 	lds	r24, 0x00DA
	}
	#endif

	#if defined(USB_CAN_BE_BOTH)
	if (USB_INT_HasOccurred(USB_INT_IDTI) && USB_INT_IsEnabled(USB_INT_IDTI))
    5a0e:	8d 7f       	andi	r24, 0xFD	; 253
    5a10:	80 93 da 00 	sts	0x00DA, r24
					case USB_INT_VBUSTI:
						return (USBCON & (1 << VBUSTE));
					#endif
					#if defined(USB_CAN_BE_BOTH)
					case USB_INT_IDTI:
						return (USBCON & (1 << IDTE));
    5a14:	8e b3       	in	r24, 0x1e	; 30
    5a16:	81 11       	cpse	r24, r1
    5a18:	0e 94 af 02 	call	0x55e	; 0x55e <EVENT_USB_Device_Disconnect>
						USBINT &= ~(1 << VBUSTI);
						break;
					#endif
					#if defined(USB_CAN_BE_BOTH)
					case USB_INT_IDTI:
						USBINT &= ~(1 << IDTI);
    5a1c:	8e b3       	in	r24, 0x1e	; 30
    5a1e:	81 30       	cpi	r24, 0x01	; 1
    5a20:	11 f0       	breq	.+4      	; 0x5a26 <__vector_10+0x280>
    5a22:	0e 94 e7 02 	call	0x5ce	; 0x5ce <EVENT_USB_Host_DeviceUnattached>
	{
		USB_INT_Clear(USB_INT_IDTI);

		if (USB_DeviceState != DEVICE_STATE_Unattached)
    5a26:	80 91 d9 00 	lds	r24, 0x00D9
		  EVENT_USB_Device_Disconnect();
    5a2a:	81 ff       	sbrs	r24, 1

		if (USB_HostState != HOST_STATE_Unattached)
    5a2c:	02 c0       	rjmp	.+4      	; 0x5a32 <__vector_10+0x28c>
    5a2e:	81 e0       	ldi	r24, 0x01	; 1
    5a30:	01 c0       	rjmp	.+2      	; 0x5a34 <__vector_10+0x28e>
		  EVENT_USB_Host_DeviceUnattached();
    5a32:	82 e0       	ldi	r24, 0x02	; 2
    5a34:	80 93 07 04 	sts	0x0407, r24

			#if defined(USB_CAN_BE_BOTH)
			static inline uint8_t USB_GetUSBModeFromUID(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t USB_GetUSBModeFromUID(void)
			{
				if (USBSTA & (1 << ID))
    5a38:	eb dd       	rcall	.-1066   	; 0x5610 <USB_ResetInterface>
    5a3a:	50 d2       	rcall	.+1184   	; 0x5edc <USB_Event_Stub>
    5a3c:	ff 91       	pop	r31
				  return USB_MODE_Device;
    5a3e:	ef 91       	pop	r30
    5a40:	bf 91       	pop	r27
				else
				  return USB_MODE_Host;
    5a42:	af 91       	pop	r26

		USB_CurrentMode = USB_GetUSBModeFromUID();
    5a44:	9f 91       	pop	r25
    5a46:	8f 91       	pop	r24
		USB_ResetInterface();
    5a48:	7f 91       	pop	r23
    5a4a:	6f 91       	pop	r22

		EVENT_USB_UIDChange();
    5a4c:	5f 91       	pop	r21
    5a4e:	4f 91       	pop	r20
	}
	#endif
}
    5a50:	3f 91       	pop	r19
    5a52:	2f 91       	pop	r18
    5a54:	0f 90       	pop	r0
    5a56:	0b be       	out	0x3b, r0	; 59
    5a58:	0f 90       	pop	r0
    5a5a:	0f be       	out	0x3f, r0	; 63
    5a5c:	0f 90       	pop	r0
    5a5e:	1f 90       	pop	r1
    5a60:	18 95       	reti

00005a62 <__vector_11>:
    5a62:	1f 92       	push	r1
    5a64:	0f 92       	push	r0
    5a66:	0f b6       	in	r0, 0x3f	; 63
    5a68:	0f 92       	push	r0
    5a6a:	11 24       	eor	r1, r1
    5a6c:	0b b6       	in	r0, 0x3b	; 59
    5a6e:	0f 92       	push	r0
    5a70:	2f 93       	push	r18
    5a72:	3f 93       	push	r19
    5a74:	4f 93       	push	r20

#if defined(INTERRUPT_CONTROL_ENDPOINT) && defined(USB_CAN_BE_DEVICE)
ISR(USB_COM_vect, ISR_BLOCK)
{
    5a76:	5f 93       	push	r21
    5a78:	6f 93       	push	r22
    5a7a:	7f 93       	push	r23
    5a7c:	8f 93       	push	r24
    5a7e:	9f 93       	push	r25
    5a80:	af 93       	push	r26
    5a82:	bf 93       	push	r27
    5a84:	cf 93       	push	r28
    5a86:	ef 93       	push	r30
    5a88:	ff 93       	push	r31
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return ((UENUM & ENDPOINT_EPNUM_MASK) | Endpoint_GetEndpointDirection());
    5a8a:	c0 91 e9 00 	lds	r28, 0x00E9
    5a8e:	cf 70       	andi	r28, 0x0F	; 15
			 *  \return The currently selected endpoint's direction, as a \c ENDPOINT_DIR_* mask.
			 */
			static inline uint8_t Endpoint_GetEndpointDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetEndpointDirection(void)
			{
				return (UECFG0X & (1 << EPDIR)) ? ENDPOINT_DIR_IN : ENDPOINT_DIR_OUT;
    5a90:	80 91 ec 00 	lds	r24, 0x00EC
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    5a94:	10 92 e9 00 	sts	0x00E9, r1
						break;
					case USB_INT_SOFI:
						UDIEN  &= ~(1 << SOFE);
						break;
					case USB_INT_RXSTPI:
						UEIENX &= ~(1 << RXSTPE);
    5a98:	80 91 f0 00 	lds	r24, 0x00F0
    5a9c:	87 7f       	andi	r24, 0xF7	; 247
    5a9e:	80 93 f0 00 	sts	0x00F0, r24
			static inline void GlobalInterruptEnable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				sei();
    5aa2:	78 94       	sei
	Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);
	USB_INT_Disable(USB_INT_RXSTPI);

	GlobalInterruptEnable();

	USB_Device_ProcessControlRequest();
    5aa4:	c5 d0       	rcall	.+394    	; 0x5c30 <USB_Device_ProcessControlRequest>
    5aa6:	10 92 e9 00 	sts	0x00E9, r1
    5aaa:	80 91 f0 00 	lds	r24, 0x00F0
						break;
					case USB_INT_SOFI:
						UDIEN  |= (1 << SOFE);
						break;
					case USB_INT_RXSTPI:
						UEIENX |= (1 << RXSTPE);
    5aae:	88 60       	ori	r24, 0x08	; 8
    5ab0:	80 93 f0 00 	sts	0x00F0, r24
    5ab4:	c0 93 e9 00 	sts	0x00E9, r28
    5ab8:	ff 91       	pop	r31

	Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);
	USB_INT_Enable(USB_INT_RXSTPI);
	Endpoint_SelectEndpoint(PrevSelectedEndpoint);
}
    5aba:	ef 91       	pop	r30
    5abc:	cf 91       	pop	r28
    5abe:	bf 91       	pop	r27
    5ac0:	af 91       	pop	r26
    5ac2:	9f 91       	pop	r25
    5ac4:	8f 91       	pop	r24
    5ac6:	7f 91       	pop	r23
    5ac8:	6f 91       	pop	r22
    5aca:	5f 91       	pop	r21
    5acc:	4f 91       	pop	r20
    5ace:	3f 91       	pop	r19
    5ad0:	2f 91       	pop	r18
    5ad2:	0f 90       	pop	r0
    5ad4:	0b be       	out	0x3b, r0	; 59
    5ad6:	0f 90       	pop	r0
    5ad8:	0f be       	out	0x3f, r0	; 63
    5ada:	0f 90       	pop	r0
    5adc:	1f 90       	pop	r1
    5ade:	18 95       	reti

00005ae0 <USB_GetNextDescriptor>:
    5ae0:	cf 93       	push	r28
			 */
			static inline void USB_GetNextDescriptor(uint16_t* const BytesRem,
			                                         void** CurrConfigLoc) ATTR_NON_NULL_PTR_ARG(1) ATTR_NON_NULL_PTR_ARG(2);
			static inline void USB_GetNextDescriptor(uint16_t* const BytesRem,
			                                         void** CurrConfigLoc)
			{
    5ae2:	df 93       	push	r29
    5ae4:	fc 01       	movw	r30, r24
				uint16_t CurrDescriptorSize = DESCRIPTOR_CAST(*CurrConfigLoc, USB_Descriptor_Header_t).Size;
    5ae6:	eb 01       	movw	r28, r22
    5ae8:	a8 81       	ld	r26, Y
    5aea:	b9 81       	ldd	r27, Y+1	; 0x01
    5aec:	8c 91       	ld	r24, X
    5aee:	90 e0       	ldi	r25, 0x00	; 0

				if (*BytesRem < CurrDescriptorSize)
    5af0:	20 81       	ld	r18, Z
    5af2:	31 81       	ldd	r19, Z+1	; 0x01
    5af4:	82 17       	cp	r24, r18
    5af6:	93 07       	cpc	r25, r19
    5af8:	08 f4       	brcc	.+2      	; 0x5afc <USB_GetNextDescriptor+0x1c>
    5afa:	9c 01       	movw	r18, r24
				  CurrDescriptorSize = *BytesRem;

				*CurrConfigLoc  = (void*)((uintptr_t)*CurrConfigLoc + CurrDescriptorSize);
    5afc:	a2 0f       	add	r26, r18
    5afe:	b3 1f       	adc	r27, r19
    5b00:	eb 01       	movw	r28, r22
    5b02:	b9 83       	std	Y+1, r27	; 0x01
    5b04:	a8 83       	st	Y, r26
				*BytesRem      -= CurrDescriptorSize;
    5b06:	80 81       	ld	r24, Z
    5b08:	91 81       	ldd	r25, Z+1	; 0x01
    5b0a:	82 1b       	sub	r24, r18
    5b0c:	93 0b       	sbc	r25, r19
    5b0e:	91 83       	std	Z+1, r25	; 0x01
    5b10:	80 83       	st	Z, r24
			}
    5b12:	df 91       	pop	r29
    5b14:	cf 91       	pop	r28
    5b16:	08 95       	ret

00005b18 <USB_Host_GetDeviceConfigDescriptor>:
#if defined(USB_CAN_BE_HOST)
uint8_t USB_Host_GetDeviceConfigDescriptor(const uint8_t ConfigNumber,
                                           uint16_t* const ConfigSizePtr,
                                           void* const BufferPtr,
                                           const uint16_t BufferSize)
{
    5b18:	cf 92       	push	r12
    5b1a:	df 92       	push	r13
    5b1c:	ef 92       	push	r14
    5b1e:	ff 92       	push	r15
    5b20:	0f 93       	push	r16
    5b22:	1f 93       	push	r17
    5b24:	cf 93       	push	r28
    5b26:	df 93       	push	r29
    5b28:	cd b7       	in	r28, 0x3d	; 61
    5b2a:	de b7       	in	r29, 0x3e	; 62
    5b2c:	29 97       	sbiw	r28, 0x09	; 9
    5b2e:	0f b6       	in	r0, 0x3f	; 63
    5b30:	f8 94       	cli
    5b32:	de bf       	out	0x3e, r29	; 62
    5b34:	0f be       	out	0x3f, r0	; 63
    5b36:	cd bf       	out	0x3d, r28	; 61
    5b38:	7b 01       	movw	r14, r22
    5b3a:	8a 01       	movw	r16, r20
    5b3c:	69 01       	movw	r12, r18
	uint8_t ErrorCode;
	uint8_t ConfigHeader[sizeof(USB_Descriptor_Configuration_Header_t)];

	USB_ControlRequest = (USB_Request_Header_t)
    5b3e:	90 e8       	ldi	r25, 0x80	; 128
    5b40:	90 93 dc 0d 	sts	0x0DDC, r25
    5b44:	96 e0       	ldi	r25, 0x06	; 6
    5b46:	90 93 dd 0d 	sts	0x0DDD, r25
		{
			.bmRequestType = (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE),
			.bRequest      = REQ_GetDescriptor,
			.wValue        = ((DTYPE_Configuration << 8) | (ConfigNumber - 1)),
    5b4a:	e8 2f       	mov	r30, r24
    5b4c:	f0 e0       	ldi	r31, 0x00	; 0
    5b4e:	31 97       	sbiw	r30, 0x01	; 1
    5b50:	f2 60       	ori	r31, 0x02	; 2
                                           const uint16_t BufferSize)
{
	uint8_t ErrorCode;
	uint8_t ConfigHeader[sizeof(USB_Descriptor_Configuration_Header_t)];

	USB_ControlRequest = (USB_Request_Header_t)
    5b52:	f0 93 df 0d 	sts	0x0DDF, r31
    5b56:	e0 93 de 0d 	sts	0x0DDE, r30
    5b5a:	10 92 e1 0d 	sts	0x0DE1, r1
    5b5e:	10 92 e0 0d 	sts	0x0DE0, r1
    5b62:	89 e0       	ldi	r24, 0x09	; 9
    5b64:	90 e0       	ldi	r25, 0x00	; 0
    5b66:	90 93 e3 0d 	sts	0x0DE3, r25
    5b6a:	80 93 e2 0d 	sts	0x0DE2, r24
    5b6e:	10 92 a7 00 	sts	0x00A7, r1
			.wLength       = sizeof(USB_Descriptor_Configuration_Header_t),
		};

	Pipe_SelectPipe(PIPE_CONTROLPIPE);

	if ((ErrorCode = USB_Host_SendControlRequest(ConfigHeader)) != HOST_SENDCONTROL_Successful)
    5b72:	ce 01       	movw	r24, r28
    5b74:	01 96       	adiw	r24, 0x01	; 1
    5b76:	da d1       	rcall	.+948    	; 0x5f2c <USB_Host_SendControlRequest>
    5b78:	81 11       	cpse	r24, r1
    5b7a:	19 c0       	rjmp	.+50     	; 0x5bae <USB_Host_GetDeviceConfigDescriptor+0x96>
    5b7c:	eb 81       	ldd	r30, Y+3	; 0x03
	  return ErrorCode;

	*ConfigSizePtr = le16_to_cpu(DESCRIPTOR_PCAST(ConfigHeader, USB_Descriptor_Configuration_Header_t)->TotalConfigurationSize);
    5b7e:	fc 81       	ldd	r31, Y+4	; 0x04
    5b80:	d7 01       	movw	r26, r14
    5b82:	ed 93       	st	X+, r30
    5b84:	fc 93       	st	X, r31
    5b86:	ce 16       	cp	r12, r30

	if (*ConfigSizePtr > BufferSize)
    5b88:	df 06       	cpc	r13, r31
    5b8a:	70 f0       	brcs	.+28     	; 0x5ba8 <USB_Host_GetDeviceConfigDescriptor+0x90>
    5b8c:	f0 93 e3 0d 	sts	0x0DE3, r31
	  return HOST_GETCONFIG_BuffOverflow;

	USB_ControlRequest.wLength = *ConfigSizePtr;
    5b90:	e0 93 e2 0d 	sts	0x0DE2, r30
    5b94:	c8 01       	movw	r24, r16

	if ((ErrorCode = USB_Host_SendControlRequest(BufferPtr)) != HOST_SENDCONTROL_Successful)
    5b96:	ca d1       	rcall	.+916    	; 0x5f2c <USB_Host_SendControlRequest>
    5b98:	81 11       	cpse	r24, r1
    5b9a:	09 c0       	rjmp	.+18     	; 0x5bae <USB_Host_GetDeviceConfigDescriptor+0x96>
    5b9c:	f8 01       	movw	r30, r16
    5b9e:	81 81       	ldd	r24, Z+1	; 0x01
	  return ErrorCode;

	if (DESCRIPTOR_TYPE(BufferPtr) != DTYPE_Configuration)
    5ba0:	82 30       	cpi	r24, 0x02	; 2
    5ba2:	21 f0       	breq	.+8      	; 0x5bac <USB_Host_GetDeviceConfigDescriptor+0x94>
    5ba4:	86 e0       	ldi	r24, 0x06	; 6
    5ba6:	03 c0       	rjmp	.+6      	; 0x5bae <USB_Host_GetDeviceConfigDescriptor+0x96>
	  return HOST_GETCONFIG_InvalidData;
    5ba8:	85 e0       	ldi	r24, 0x05	; 5
    5baa:	01 c0       	rjmp	.+2      	; 0x5bae <USB_Host_GetDeviceConfigDescriptor+0x96>
	  return ErrorCode;

	*ConfigSizePtr = le16_to_cpu(DESCRIPTOR_PCAST(ConfigHeader, USB_Descriptor_Configuration_Header_t)->TotalConfigurationSize);

	if (*ConfigSizePtr > BufferSize)
	  return HOST_GETCONFIG_BuffOverflow;
    5bac:	80 e0       	ldi	r24, 0x00	; 0
    5bae:	29 96       	adiw	r28, 0x09	; 9
	  return ErrorCode;

	if (DESCRIPTOR_TYPE(BufferPtr) != DTYPE_Configuration)
	  return HOST_GETCONFIG_InvalidData;

	return HOST_GETCONFIG_Successful;
    5bb0:	0f b6       	in	r0, 0x3f	; 63
}
    5bb2:	f8 94       	cli
    5bb4:	de bf       	out	0x3e, r29	; 62
    5bb6:	0f be       	out	0x3f, r0	; 63
    5bb8:	cd bf       	out	0x3d, r28	; 61
    5bba:	df 91       	pop	r29
    5bbc:	cf 91       	pop	r28
    5bbe:	1f 91       	pop	r17
    5bc0:	0f 91       	pop	r16
    5bc2:	ff 90       	pop	r15
    5bc4:	ef 90       	pop	r14
    5bc6:	df 90       	pop	r13
    5bc8:	cf 90       	pop	r12
    5bca:	08 95       	ret

00005bcc <USB_GetNextDescriptorComp>:
    5bcc:	af 92       	push	r10
    5bce:	bf 92       	push	r11
}

uint8_t USB_GetNextDescriptorComp(uint16_t* const BytesRem,
                                  void** const CurrConfigLoc,
                                  ConfigComparatorPtr_t const ComparatorRoutine)
{
    5bd0:	cf 92       	push	r12
    5bd2:	df 92       	push	r13
    5bd4:	ef 92       	push	r14
    5bd6:	ff 92       	push	r15
    5bd8:	0f 93       	push	r16
    5bda:	1f 93       	push	r17
    5bdc:	cf 93       	push	r28
    5bde:	df 93       	push	r29
    5be0:	8c 01       	movw	r16, r24
    5be2:	eb 01       	movw	r28, r22
    5be4:	6a 01       	movw	r12, r20
	uint8_t ErrorCode;

	while (*BytesRem)
    5be6:	f8 01       	movw	r30, r16
    5be8:	e0 80       	ld	r14, Z
    5bea:	f1 80       	ldd	r15, Z+1	; 0x01
    5bec:	e1 14       	cp	r14, r1
    5bee:	f1 04       	cpc	r15, r1
    5bf0:	99 f0       	breq	.+38     	; 0x5c18 <USB_GetNextDescriptorComp+0x4c>
	{
		uint8_t* PrevDescLoc  = *CurrConfigLoc;
    5bf2:	a8 80       	ld	r10, Y
    5bf4:	b9 80       	ldd	r11, Y+1	; 0x01
		uint16_t PrevBytesRem = *BytesRem;

		USB_GetNextDescriptor(BytesRem, CurrConfigLoc);
    5bf6:	be 01       	movw	r22, r28
    5bf8:	c8 01       	movw	r24, r16
    5bfa:	72 df       	rcall	.-284    	; 0x5ae0 <USB_GetNextDescriptor>
    5bfc:	88 81       	ld	r24, Y

		if ((ErrorCode = ComparatorRoutine(*CurrConfigLoc)) != DESCRIPTOR_SEARCH_NotFound)
    5bfe:	99 81       	ldd	r25, Y+1	; 0x01
    5c00:	f6 01       	movw	r30, r12
    5c02:	09 95       	icall
    5c04:	82 30       	cpi	r24, 0x02	; 2
    5c06:	79 f3       	breq	.-34     	; 0x5be6 <USB_GetNextDescriptorComp+0x1a>
    5c08:	81 30       	cpi	r24, 0x01	; 1
		{
			if (ErrorCode == DESCRIPTOR_SEARCH_Fail)
    5c0a:	39 f4       	brne	.+14     	; 0x5c1a <USB_GetNextDescriptorComp+0x4e>
    5c0c:	b9 82       	std	Y+1, r11	; 0x01
			{
				*CurrConfigLoc = PrevDescLoc;
    5c0e:	a8 82       	st	Y, r10
    5c10:	f8 01       	movw	r30, r16
				*BytesRem      = PrevBytesRem;
    5c12:	f1 82       	std	Z+1, r15	; 0x01
    5c14:	e0 82       	st	Z, r14
    5c16:	01 c0       	rjmp	.+2      	; 0x5c1a <USB_GetNextDescriptorComp+0x4e>
    5c18:	82 e0       	ldi	r24, 0x02	; 2

			return ErrorCode;
		}
	}

	return DESCRIPTOR_SEARCH_COMP_EndOfDescriptor;
    5c1a:	df 91       	pop	r29
}
    5c1c:	cf 91       	pop	r28
    5c1e:	1f 91       	pop	r17
    5c20:	0f 91       	pop	r16
    5c22:	ff 90       	pop	r15
    5c24:	ef 90       	pop	r14
    5c26:	df 90       	pop	r13
    5c28:	cf 90       	pop	r12
    5c2a:	bf 90       	pop	r11
    5c2c:	af 90       	pop	r10
    5c2e:	08 95       	ret

00005c30 <USB_Device_ProcessControlRequest>:
    5c30:	1f 93       	push	r17
#if !defined(NO_DEVICE_REMOTE_WAKEUP)
bool    USB_Device_RemoteWakeupEnabled;
#endif

void USB_Device_ProcessControlRequest(void)
{
    5c32:	cf 93       	push	r28
    5c34:	df 93       	push	r29
    5c36:	cd b7       	in	r28, 0x3d	; 61
    5c38:	de b7       	in	r29, 0x3e	; 62
    5c3a:	aa 97       	sbiw	r28, 0x2a	; 42
    5c3c:	0f b6       	in	r0, 0x3f	; 63
    5c3e:	f8 94       	cli
    5c40:	de bf       	out	0x3e, r29	; 62
    5c42:	0f be       	out	0x3f, r0	; 63
    5c44:	cd bf       	out	0x3d, r28	; 61
    5c46:	ec ed       	ldi	r30, 0xDC	; 220
    5c48:	fd e0       	ldi	r31, 0x0D	; 13
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    5c4a:	80 91 f1 00 	lds	r24, 0x00F1
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
	  *(RequestHeader++) = Endpoint_Read_8();
    5c4e:	81 93       	st	Z+, r24
	USB_ControlRequest.wIndex        = Endpoint_Read_16_LE();
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
    5c50:	2d e0       	ldi	r18, 0x0D	; 13
    5c52:	e4 3e       	cpi	r30, 0xE4	; 228
    5c54:	f2 07       	cpc	r31, r18
    5c56:	c9 f7       	brne	.-14     	; 0x5c4a <USB_Device_ProcessControlRequest+0x1a>
	  *(RequestHeader++) = Endpoint_Read_8();
	#endif

	EVENT_USB_Device_ControlRequest();
    5c58:	0e 94 c4 02 	call	0x588	; 0x588 <EVENT_USB_Device_ControlRequest>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    5c5c:	80 91 e8 00 	lds	r24, 0x00E8

	if (Endpoint_IsSETUPReceived())
    5c60:	83 ff       	sbrs	r24, 3
    5c62:	24 c1       	rjmp	.+584    	; 0x5eac <USB_Device_ProcessControlRequest+0x27c>
	{
		uint8_t bmRequestType = USB_ControlRequest.bmRequestType;
    5c64:	90 91 dc 0d 	lds	r25, 0x0DDC

		switch (USB_ControlRequest.bRequest)
    5c68:	80 91 dd 0d 	lds	r24, 0x0DDD
    5c6c:	85 30       	cpi	r24, 0x05	; 5
    5c6e:	09 f4       	brne	.+2      	; 0x5c72 <USB_Device_ProcessControlRequest+0x42>
    5c70:	77 c0       	rjmp	.+238    	; 0x5d60 <USB_Device_ProcessControlRequest+0x130>
    5c72:	30 f4       	brcc	.+12     	; 0x5c80 <USB_Device_ProcessControlRequest+0x50>
    5c74:	81 30       	cpi	r24, 0x01	; 1
    5c76:	81 f1       	breq	.+96     	; 0x5cd8 <USB_Device_ProcessControlRequest+0xa8>
    5c78:	68 f0       	brcs	.+26     	; 0x5c94 <USB_Device_ProcessControlRequest+0x64>
    5c7a:	83 30       	cpi	r24, 0x03	; 3
    5c7c:	69 f1       	breq	.+90     	; 0x5cd8 <USB_Device_ProcessControlRequest+0xa8>
    5c7e:	16 c1       	rjmp	.+556    	; 0x5eac <USB_Device_ProcessControlRequest+0x27c>
    5c80:	88 30       	cpi	r24, 0x08	; 8
    5c82:	09 f4       	brne	.+2      	; 0x5c86 <USB_Device_ProcessControlRequest+0x56>
    5c84:	e3 c0       	rjmp	.+454    	; 0x5e4c <USB_Device_ProcessControlRequest+0x21c>
    5c86:	89 30       	cpi	r24, 0x09	; 9
    5c88:	09 f4       	brne	.+2      	; 0x5c8c <USB_Device_ProcessControlRequest+0x5c>
    5c8a:	f3 c0       	rjmp	.+486    	; 0x5e72 <USB_Device_ProcessControlRequest+0x242>
    5c8c:	86 30       	cpi	r24, 0x06	; 6
    5c8e:	09 f0       	breq	.+2      	; 0x5c92 <USB_Device_ProcessControlRequest+0x62>
    5c90:	0d c1       	rjmp	.+538    	; 0x5eac <USB_Device_ProcessControlRequest+0x27c>
    5c92:	87 c0       	rjmp	.+270    	; 0x5da2 <USB_Device_ProcessControlRequest+0x172>
		{
			case REQ_GetStatus:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    5c94:	90 38       	cpi	r25, 0x80	; 128
    5c96:	81 f0       	breq	.+32     	; 0x5cb8 <USB_Device_ProcessControlRequest+0x88>
    5c98:	92 38       	cpi	r25, 0x82	; 130
    5c9a:	09 f0       	breq	.+2      	; 0x5c9e <USB_Device_ProcessControlRequest+0x6e>
    5c9c:	07 c1       	rjmp	.+526    	; 0x5eac <USB_Device_ProcessControlRequest+0x27c>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    5c9e:	80 91 e0 0d 	lds	r24, 0x0DE0
    5ca2:	8f 70       	andi	r24, 0x0F	; 15
    5ca4:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    5ca8:	80 91 eb 00 	lds	r24, 0x00EB
    5cac:	85 fb       	bst	r24, 5
    5cae:	88 27       	eor	r24, r24
    5cb0:	80 f9       	bld	r24, 0
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    5cb2:	10 92 e9 00 	sts	0x00E9, r1
    5cb6:	06 c0       	rjmp	.+12     	; 0x5cc4 <USB_Device_ProcessControlRequest+0x94>
	Endpoint_ClearOUT();
}

static void USB_Device_GetStatus(void)
{
	uint8_t CurrentStatus = 0;
    5cb8:	80 91 d8 0d 	lds	r24, 0x0DD8
			if (USB_Device_CurrentlySelfPowered)
			  CurrentStatus |= FEATURE_SELFPOWERED_ENABLED;
			#endif

			#if !defined(NO_DEVICE_REMOTE_WAKEUP)
			if (USB_Device_RemoteWakeupEnabled)
    5cbc:	90 91 d9 0d 	lds	r25, 0x0DD9
    5cc0:	91 11       	cpse	r25, r1
			  CurrentStatus |= FEATURE_REMOTE_WAKEUP_ENABLED;
    5cc2:	82 60       	ori	r24, 0x02	; 2
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    5cc4:	90 91 e8 00 	lds	r25, 0x00E8
    5cc8:	97 7f       	andi	r25, 0xF7	; 247
    5cca:	90 93 e8 00 	sts	0x00E8, r25
			 *  \param[in] Data  Data to write to the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_16_LE(const uint16_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_16_LE(const uint16_t Data)
			{
				UEDATX = (Data & 0xFF);
    5cce:	80 93 f1 00 	sts	0x00F1, r24
				UEDATX = (Data >> 8);
    5cd2:	10 92 f1 00 	sts	0x00F1, r1
    5cd6:	c5 c0       	rjmp	.+394    	; 0x5e62 <USB_Device_ProcessControlRequest+0x232>
				}

				break;
			case REQ_ClearFeature:
			case REQ_SetFeature:
				if ((bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    5cd8:	29 2f       	mov	r18, r25
    5cda:	2d 7f       	andi	r18, 0xFD	; 253
    5cdc:	09 f0       	breq	.+2      	; 0x5ce0 <USB_Device_ProcessControlRequest+0xb0>
    5cde:	e6 c0       	rjmp	.+460    	; 0x5eac <USB_Device_ProcessControlRequest+0x27c>
	Endpoint_ClearStatusStage();
}

static void USB_Device_ClearSetFeature(void)
{
	switch (USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_RECIPIENT)
    5ce0:	99 23       	and	r25, r25
    5ce2:	19 f0       	breq	.+6      	; 0x5cea <USB_Device_ProcessControlRequest+0xba>
    5ce4:	92 30       	cpi	r25, 0x02	; 2
    5ce6:	61 f0       	breq	.+24     	; 0x5d00 <USB_Device_ProcessControlRequest+0xd0>
    5ce8:	e1 c0       	rjmp	.+450    	; 0x5eac <USB_Device_ProcessControlRequest+0x27c>
	{
		#if !defined(NO_DEVICE_REMOTE_WAKEUP)
		case REQREC_DEVICE:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_DeviceRemoteWakeup)
    5cea:	90 91 de 0d 	lds	r25, 0x0DDE
    5cee:	91 30       	cpi	r25, 0x01	; 1
    5cf0:	09 f0       	breq	.+2      	; 0x5cf4 <USB_Device_ProcessControlRequest+0xc4>
    5cf2:	dc c0       	rjmp	.+440    	; 0x5eac <USB_Device_ProcessControlRequest+0x27c>
			  USB_Device_RemoteWakeupEnabled = (USB_ControlRequest.bRequest == REQ_SetFeature);
    5cf4:	83 30       	cpi	r24, 0x03	; 3
    5cf6:	09 f0       	breq	.+2      	; 0x5cfa <USB_Device_ProcessControlRequest+0xca>
    5cf8:	90 e0       	ldi	r25, 0x00	; 0
    5cfa:	90 93 d9 0d 	sts	0x0DD9, r25
    5cfe:	2a c0       	rjmp	.+84     	; 0x5d54 <USB_Device_ProcessControlRequest+0x124>

			break;
		#endif
		#if !defined(CONTROL_ONLY_DEVICE)
		case REQREC_ENDPOINT:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_EndpointHalt)
    5d00:	90 91 de 0d 	lds	r25, 0x0DDE
    5d04:	91 11       	cpse	r25, r1
    5d06:	26 c0       	rjmp	.+76     	; 0x5d54 <USB_Device_ProcessControlRequest+0x124>
			{
				uint8_t EndpointIndex = ((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
    5d08:	20 91 e0 0d 	lds	r18, 0x0DE0
    5d0c:	2f 70       	andi	r18, 0x0F	; 15

				if (EndpointIndex == ENDPOINT_CONTROLEP)
    5d0e:	09 f4       	brne	.+2      	; 0x5d12 <USB_Device_ProcessControlRequest+0xe2>
    5d10:	cd c0       	rjmp	.+410    	; 0x5eac <USB_Device_ProcessControlRequest+0x27c>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    5d12:	20 93 e9 00 	sts	0x00E9, r18
			 * \return Boolean \c true if the currently selected endpoint is enabled, \c false otherwise.
			 */
			static inline bool Endpoint_IsEnabled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsEnabled(void)
			{
				return ((UECONX & (1 << EPEN)) ? true : false);
    5d16:	90 91 eb 00 	lds	r25, 0x00EB
				  return;

				Endpoint_SelectEndpoint(EndpointIndex);

				if (Endpoint_IsEnabled())
    5d1a:	90 ff       	sbrs	r25, 0
    5d1c:	1b c0       	rjmp	.+54     	; 0x5d54 <USB_Device_ProcessControlRequest+0x124>
				{
					if (USB_ControlRequest.bRequest == REQ_SetFeature)
    5d1e:	83 30       	cpi	r24, 0x03	; 3
    5d20:	21 f4       	brne	.+8      	; 0x5d2a <USB_Device_ProcessControlRequest+0xfa>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    5d22:	80 91 eb 00 	lds	r24, 0x00EB
    5d26:	80 62       	ori	r24, 0x20	; 32
    5d28:	13 c0       	rjmp	.+38     	; 0x5d50 <USB_Device_ProcessControlRequest+0x120>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearStall(void)
			{
				UECONX |= (1 << STALLRQC);
    5d2a:	80 91 eb 00 	lds	r24, 0x00EB
    5d2e:	80 61       	ori	r24, 0x10	; 16
    5d30:	80 93 eb 00 	sts	0x00EB, r24
			 *  \param[in] Address  Endpoint address whose FIFO buffers are to be reset.
			 */
			static inline void Endpoint_ResetEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetEndpoint(const uint8_t Address)
			{
				UERST = (1 << (Address & ENDPOINT_EPNUM_MASK));
    5d34:	81 e0       	ldi	r24, 0x01	; 1
    5d36:	90 e0       	ldi	r25, 0x00	; 0
    5d38:	02 2e       	mov	r0, r18
    5d3a:	01 c0       	rjmp	.+2      	; 0x5d3e <USB_Device_ProcessControlRequest+0x10e>
    5d3c:	88 0f       	add	r24, r24
    5d3e:	0a 94       	dec	r0
    5d40:	ea f7       	brpl	.-6      	; 0x5d3c <USB_Device_ProcessControlRequest+0x10c>
    5d42:	80 93 ea 00 	sts	0x00EA, r24
				UERST = 0;
    5d46:	10 92 ea 00 	sts	0x00EA, r1

			/** Resets the data toggle of the currently selected endpoint. */
			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetDataToggle(void)
			{
				UECONX |= (1 << RSTDT);
    5d4a:	80 91 eb 00 	lds	r24, 0x00EB
    5d4e:	88 60       	ori	r24, 0x08	; 8
    5d50:	80 93 eb 00 	sts	0x00EB, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    5d54:	10 92 e9 00 	sts	0x00E9, r1
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    5d58:	80 91 e8 00 	lds	r24, 0x00E8
    5d5c:	87 7f       	andi	r24, 0xF7	; 247
    5d5e:	84 c0       	rjmp	.+264    	; 0x5e68 <USB_Device_ProcessControlRequest+0x238>
					USB_Device_ClearSetFeature();
				}

				break;
			case REQ_SetAddress:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    5d60:	91 11       	cpse	r25, r1
    5d62:	a4 c0       	rjmp	.+328    	; 0x5eac <USB_Device_ProcessControlRequest+0x27c>
	}
}

static void USB_Device_SetAddress(void)
{
	uint8_t DeviceAddress = (USB_ControlRequest.wValue & 0x7F);
    5d64:	10 91 de 0d 	lds	r17, 0x0DDE
    5d68:	1f 77       	andi	r17, 0x7F	; 127
			#endif

			static inline void USB_Device_SetDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetDeviceAddress(const uint8_t Address)
			{
				UDADDR = (UDADDR & (1 << ADDEN)) | (Address & 0x7F);
    5d6a:	80 91 e3 00 	lds	r24, 0x00E3
    5d6e:	80 78       	andi	r24, 0x80	; 128
    5d70:	81 2b       	or	r24, r17
    5d72:	80 93 e3 00 	sts	0x00E3, r24
    5d76:	80 91 e8 00 	lds	r24, 0x00E8
    5d7a:	87 7f       	andi	r24, 0xF7	; 247
    5d7c:	80 93 e8 00 	sts	0x00E8, r24

	USB_Device_SetDeviceAddress(DeviceAddress);

	Endpoint_ClearSETUP();

	Endpoint_ClearStatusStage();
    5d80:	54 d8       	rcall	.-3928   	; 0x4e2a <Endpoint_ClearStatusStage>
    5d82:	80 91 e8 00 	lds	r24, 0x00E8
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    5d86:	80 ff       	sbrs	r24, 0

	while (!(Endpoint_IsINReady()));
    5d88:	fc cf       	rjmp	.-8      	; 0x5d82 <USB_Device_ProcessControlRequest+0x152>
    5d8a:	80 91 e3 00 	lds	r24, 0x00E3
			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address)
			{
				(void)Address;

				UDADDR |= (1 << ADDEN);
    5d8e:	80 68       	ori	r24, 0x80	; 128
    5d90:	80 93 e3 00 	sts	0x00E3, r24
    5d94:	11 23       	and	r17, r17

	USB_Device_EnableDeviceAddress(DeviceAddress);

	USB_DeviceState = (DeviceAddress) ? DEVICE_STATE_Addressed : DEVICE_STATE_Default;
    5d96:	11 f0       	breq	.+4      	; 0x5d9c <USB_Device_ProcessControlRequest+0x16c>
    5d98:	83 e0       	ldi	r24, 0x03	; 3
    5d9a:	01 c0       	rjmp	.+2      	; 0x5d9e <USB_Device_ProcessControlRequest+0x16e>
    5d9c:	82 e0       	ldi	r24, 0x02	; 2
    5d9e:	8e bb       	out	0x1e, r24	; 30
    5da0:	85 c0       	rjmp	.+266    	; 0x5eac <USB_Device_ProcessControlRequest+0x27c>
    5da2:	90 58       	subi	r25, 0x80	; 128
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_SetAddress();

				break;
			case REQ_GetDescriptor:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    5da4:	92 30       	cpi	r25, 0x02	; 2
    5da6:	08 f0       	brcs	.+2      	; 0x5daa <USB_Device_ProcessControlRequest+0x17a>
    5da8:	81 c0       	rjmp	.+258    	; 0x5eac <USB_Device_ProcessControlRequest+0x27c>
    5daa:	80 91 de 0d 	lds	r24, 0x0DDE
	    !(defined(USE_FLASH_DESCRIPTORS) || defined(USE_EEPROM_DESCRIPTORS) || defined(USE_RAM_DESCRIPTORS))
	uint8_t DescriptorAddressSpace;
	#endif

	#if !defined(NO_INTERNAL_SERIAL) && (USE_INTERNAL_SERIAL != NO_DESCRIPTOR)
	if (USB_ControlRequest.wValue == ((DTYPE_String << 8) | USE_INTERNAL_SERIAL))
    5dae:	90 91 df 0d 	lds	r25, 0x0DDF
    5db2:	8c 3d       	cpi	r24, 0xDC	; 220
    5db4:	23 e0       	ldi	r18, 0x03	; 3
    5db6:	92 07       	cpc	r25, r18
    5db8:	79 f5       	brne	.+94     	; 0x5e18 <USB_Device_ProcessControlRequest+0x1e8>
    5dba:	83 e0       	ldi	r24, 0x03	; 3
	{
		USB_Descriptor_Header_t Header;
		uint16_t                UnicodeString[INTERNAL_SERIAL_LENGTH_BITS / 4];
	} SignatureDescriptor;

	SignatureDescriptor.Header.Type = DTYPE_String;
    5dbc:	8a 83       	std	Y+2, r24	; 0x02
    5dbe:	8a e2       	ldi	r24, 0x2A	; 42
	SignatureDescriptor.Header.Size = USB_STRING_LEN(INTERNAL_SERIAL_LENGTH_BITS / 4);
    5dc0:	89 83       	std	Y+1, r24	; 0x01
    5dc2:	4f b7       	in	r20, 0x3f	; 63
			static inline uint_reg_t GetGlobalInterruptMask(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				return SREG;
    5dc4:	f8 94       	cli
			static inline void GlobalInterruptDisable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				cli();
    5dc6:	de 01       	movw	r26, r28
				__builtin_ssrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				cli();
				#endif

				GCC_MEMORY_BARRIER();
    5dc8:	13 96       	adiw	r26, 0x03	; 3
    5dca:	20 e0       	ldi	r18, 0x00	; 0
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
    5dcc:	3e e0       	ldi	r19, 0x0E	; 14
			static inline void USB_Device_GetSerialString(uint16_t* const UnicodeString)
			{
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;
    5dce:	51 e2       	ldi	r21, 0x21	; 33

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
				{
					uint8_t SerialByte = boot_signature_byte_get(SigReadAddress);
    5dd0:	e3 2f       	mov	r30, r19
    5dd2:	f0 e0       	ldi	r31, 0x00	; 0
    5dd4:	50 93 57 00 	sts	0x0057, r21
    5dd8:	e4 91       	lpm	r30, Z
    5dda:	20 ff       	sbrs	r18, 0

					if (SerialCharNum & 0x01)
    5ddc:	03 c0       	rjmp	.+6      	; 0x5de4 <USB_Device_ProcessControlRequest+0x1b4>
    5dde:	e2 95       	swap	r30
					{
						SerialByte >>= 4;
    5de0:	ef 70       	andi	r30, 0x0F	; 15
    5de2:	3f 5f       	subi	r19, 0xFF	; 255
						SigReadAddress++;
    5de4:	ef 70       	andi	r30, 0x0F	; 15
					}

					SerialByte &= 0x0F;
    5de6:	8e 2f       	mov	r24, r30
    5de8:	90 e0       	ldi	r25, 0x00	; 0
    5dea:	ea 30       	cpi	r30, 0x0A	; 10

					UnicodeString[SerialCharNum] = cpu_to_le16((SerialByte >= 10) ?
    5dec:	10 f0       	brcs	.+4      	; 0x5df2 <USB_Device_ProcessControlRequest+0x1c2>
    5dee:	c7 96       	adiw	r24, 0x37	; 55
    5df0:	01 c0       	rjmp	.+2      	; 0x5df4 <USB_Device_ProcessControlRequest+0x1c4>
    5df2:	c0 96       	adiw	r24, 0x30	; 48
    5df4:	8d 93       	st	X+, r24
    5df6:	9d 93       	st	X+, r25
    5df8:	2f 5f       	subi	r18, 0xFF	; 255
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
    5dfa:	24 31       	cpi	r18, 0x14	; 20
    5dfc:	49 f7       	brne	.-46     	; 0x5dd0 <USB_Device_ProcessControlRequest+0x1a0>
    5dfe:	4f bf       	out	0x3f, r20	; 63
			static inline void SetGlobalInterruptMask(const uint_reg_t GlobalIntState)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				SREG = GlobalIntState;
    5e00:	80 91 e8 00 	lds	r24, 0x00E8
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    5e04:	87 7f       	andi	r24, 0xF7	; 247
    5e06:	80 93 e8 00 	sts	0x00E8, r24
    5e0a:	6a e2       	ldi	r22, 0x2A	; 42

	USB_Device_GetSerialString(SignatureDescriptor.UnicodeString);

	Endpoint_ClearSETUP();

	Endpoint_Write_Control_Stream_LE(&SignatureDescriptor, sizeof(SignatureDescriptor));
    5e0c:	70 e0       	ldi	r23, 0x00	; 0
    5e0e:	ce 01       	movw	r24, r28
    5e10:	01 96       	adiw	r24, 0x01	; 1
    5e12:	0e 94 ae 25 	call	0x4b5c	; 0x4b5c <Endpoint_Write_Control_Stream_LE>
    5e16:	14 c0       	rjmp	.+40     	; 0x5e40 <USB_Device_ProcessControlRequest+0x210>
    5e18:	ae 01       	movw	r20, r28
		USB_Device_GetInternalSerialDescriptor();
		return;
	}
	#endif

	if ((DescriptorSize = CALLBACK_USB_GetDescriptor(USB_ControlRequest.wValue, USB_ControlRequest.wIndex,
    5e1a:	4f 5f       	subi	r20, 0xFF	; 255
    5e1c:	5f 4f       	sbci	r21, 0xFF	; 255
    5e1e:	60 91 e0 0d 	lds	r22, 0x0DE0
    5e22:	0e 94 67 02 	call	0x4ce	; 0x4ce <CALLBACK_USB_GetDescriptor>
    5e26:	00 97       	sbiw	r24, 0x00	; 0
    5e28:	09 f4       	brne	.+2      	; 0x5e2c <USB_Device_ProcessControlRequest+0x1fc>
    5e2a:	40 c0       	rjmp	.+128    	; 0x5eac <USB_Device_ProcessControlRequest+0x27c>
    5e2c:	20 91 e8 00 	lds	r18, 0x00E8
    5e30:	27 7f       	andi	r18, 0xF7	; 247
    5e32:	20 93 e8 00 	sts	0x00E8, r18
    5e36:	bc 01       	movw	r22, r24
	#if defined(USE_RAM_DESCRIPTORS) || !defined(ARCH_HAS_MULTI_ADDRESS_SPACE)
	Endpoint_Write_Control_Stream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_EEPROM_DESCRIPTORS)
	Endpoint_Write_Control_EStream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_FLASH_DESCRIPTORS)
	Endpoint_Write_Control_PStream_LE(DescriptorPointer, DescriptorSize);
    5e38:	89 81       	ldd	r24, Y+1	; 0x01
    5e3a:	9a 81       	ldd	r25, Y+2	; 0x02
    5e3c:	0e 94 45 26 	call	0x4c8a	; 0x4c8a <Endpoint_Write_Control_PStream_LE>
    5e40:	80 91 e8 00 	lds	r24, 0x00E8
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    5e44:	8b 77       	andi	r24, 0x7B	; 123
    5e46:	80 93 e8 00 	sts	0x00E8, r24
    5e4a:	30 c0       	rjmp	.+96     	; 0x5eac <USB_Device_ProcessControlRequest+0x27c>
    5e4c:	90 38       	cpi	r25, 0x80	; 128
					USB_Device_GetDescriptor();
				}

				break;
			case REQ_GetConfiguration:
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
    5e4e:	71 f5       	brne	.+92     	; 0x5eac <USB_Device_ProcessControlRequest+0x27c>
    5e50:	80 91 e8 00 	lds	r24, 0x00E8
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    5e54:	87 7f       	andi	r24, 0xF7	; 247
    5e56:	80 93 e8 00 	sts	0x00E8, r24
    5e5a:	80 91 d7 0d 	lds	r24, 0x0DD7

static void USB_Device_GetConfiguration(void)
{
	Endpoint_ClearSETUP();

	Endpoint_Write_8(USB_Device_ConfigurationNumber);
    5e5e:	80 93 f1 00 	sts	0x00F1, r24
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    5e62:	80 91 e8 00 	lds	r24, 0x00E8
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    5e66:	8e 77       	andi	r24, 0x7E	; 126
    5e68:	80 93 e8 00 	sts	0x00E8, r24
    5e6c:	0e 94 15 27 	call	0x4e2a	; 0x4e2a <Endpoint_ClearStatusStage>
	Endpoint_ClearIN();

	Endpoint_ClearStatusStage();
    5e70:	1d c0       	rjmp	.+58     	; 0x5eac <USB_Device_ProcessControlRequest+0x27c>
    5e72:	91 11       	cpse	r25, r1
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_GetConfiguration();

				break;
			case REQ_SetConfiguration:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    5e74:	1b c0       	rjmp	.+54     	; 0x5eac <USB_Device_ProcessControlRequest+0x27c>
    5e76:	90 91 de 0d 	lds	r25, 0x0DDE
}

static void USB_Device_SetConfiguration(void)
{
	#if defined(FIXED_NUM_CONFIGURATIONS)
	if ((uint8_t)USB_ControlRequest.wValue > FIXED_NUM_CONFIGURATIONS)
    5e7a:	92 30       	cpi	r25, 0x02	; 2
    5e7c:	b8 f4       	brcc	.+46     	; 0x5eac <USB_Device_ProcessControlRequest+0x27c>
    5e7e:	80 91 e8 00 	lds	r24, 0x00E8
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    5e82:	87 7f       	andi	r24, 0xF7	; 247
    5e84:	80 93 e8 00 	sts	0x00E8, r24
    5e88:	90 93 d7 0d 	sts	0x0DD7, r25
	#endif
	#endif

	Endpoint_ClearSETUP();

	USB_Device_ConfigurationNumber = (uint8_t)USB_ControlRequest.wValue;
    5e8c:	0e 94 15 27 	call	0x4e2a	; 0x4e2a <Endpoint_ClearStatusStage>

	Endpoint_ClearStatusStage();
    5e90:	80 91 d7 0d 	lds	r24, 0x0DD7

	if (USB_Device_ConfigurationNumber)
    5e94:	81 11       	cpse	r24, r1
    5e96:	04 c0       	rjmp	.+8      	; 0x5ea0 <USB_Device_ProcessControlRequest+0x270>
    5e98:	80 91 e3 00 	lds	r24, 0x00E3
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
    5e9c:	87 ff       	sbrs	r24, 7
	  USB_DeviceState = DEVICE_STATE_Configured;
	else
	  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
    5e9e:	02 c0       	rjmp	.+4      	; 0x5ea4 <USB_Device_ProcessControlRequest+0x274>
    5ea0:	84 e0       	ldi	r24, 0x04	; 4
    5ea2:	01 c0       	rjmp	.+2      	; 0x5ea6 <USB_Device_ProcessControlRequest+0x276>
    5ea4:	81 e0       	ldi	r24, 0x01	; 1
    5ea6:	8e bb       	out	0x1e, r24	; 30
    5ea8:	0e 94 b1 02 	call	0x562	; 0x562 <EVENT_USB_Device_ConfigurationChanged>

	EVENT_USB_Device_ConfigurationChanged();
    5eac:	80 91 e8 00 	lds	r24, 0x00E8
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    5eb0:	83 ff       	sbrs	r24, 3
			default:
				break;
		}
	}

	if (Endpoint_IsSETUPReceived())
    5eb2:	0a c0       	rjmp	.+20     	; 0x5ec8 <USB_Device_ProcessControlRequest+0x298>
    5eb4:	80 91 e8 00 	lds	r24, 0x00E8
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    5eb8:	87 7f       	andi	r24, 0xF7	; 247
    5eba:	80 93 e8 00 	sts	0x00E8, r24
    5ebe:	80 91 eb 00 	lds	r24, 0x00EB
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    5ec2:	80 62       	ori	r24, 0x20	; 32
    5ec4:	80 93 eb 00 	sts	0x00EB, r24
    5ec8:	aa 96       	adiw	r28, 0x2a	; 42
	{
		Endpoint_ClearSETUP();
		Endpoint_StallTransaction();
	}
}
    5eca:	0f b6       	in	r0, 0x3f	; 63
    5ecc:	f8 94       	cli
    5ece:	de bf       	out	0x3e, r29	; 62
    5ed0:	0f be       	out	0x3f, r0	; 63
    5ed2:	cd bf       	out	0x3d, r28	; 61
    5ed4:	df 91       	pop	r29
    5ed6:	cf 91       	pop	r28
    5ed8:	1f 91       	pop	r17
    5eda:	08 95       	ret

00005edc <USB_Event_Stub>:
    5edc:	08 95       	ret

00005ede <USB_Host_WaitForIOS>:

	return ReturnStatus;
}

static uint8_t USB_Host_WaitForIOS(const uint8_t WaitType)
{
    5ede:	1f 93       	push	r17
    5ee0:	cf 93       	push	r28
    5ee2:	df 93       	push	r29
    5ee4:	18 2f       	mov	r17, r24
	uint8_t  TimeoutCounter = USB_HOST_TIMEOUT_MS;
	#else
	uint16_t TimeoutCounter = USB_HOST_TIMEOUT_MS;
	#endif

	while (!(((WaitType == USB_HOST_WAITFOR_SetupSent)  && Pipe_IsSETUPSent())  ||
    5ee6:	c9 ee       	ldi	r28, 0xE9	; 233
    5ee8:	d3 e0       	ldi	r29, 0x03	; 3
    5eea:	11 11       	cpse	r17, r1
    5eec:	0d c0       	rjmp	.+26     	; 0x5f08 <USB_Host_WaitForIOS+0x2a>
			 *  \return Boolean \c true if the current pipe is ready for a SETUP packet, \c false otherwise.
			 */
			static inline bool Pipe_IsSETUPSent(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsSETUPSent(void)
			{
				return ((UPINTX & (1 << TXSTPI)) ? true : false);
    5eee:	80 91 a6 00 	lds	r24, 0x00A6
    5ef2:	83 fd       	sbrc	r24, 3
    5ef4:	16 c0       	rjmp	.+44     	; 0x5f22 <USB_Host_WaitForIOS+0x44>
	         ((WaitType == USB_HOST_WAITFOR_InReceived) && Pipe_IsINReceived()) ||
	         ((WaitType == USB_HOST_WAITFOR_OutReady)   && Pipe_IsOUTReady())))
	{
		uint8_t ErrorCode;

		if ((ErrorCode = USB_Host_WaitMS(1)) != HOST_WAITERROR_Successful)
    5ef6:	81 e0       	ldi	r24, 0x01	; 1
    5ef8:	37 d8       	rcall	.-3986   	; 0x4f68 <USB_Host_WaitMS>
    5efa:	81 11       	cpse	r24, r1
    5efc:	13 c0       	rjmp	.+38     	; 0x5f24 <USB_Host_WaitForIOS+0x46>
    5efe:	21 97       	sbiw	r28, 0x01	; 1
    5f00:	20 97       	sbiw	r28, 0x00	; 0
		  return ErrorCode;

		if (!(TimeoutCounter--))
    5f02:	99 f7       	brne	.-26     	; 0x5eea <USB_Host_WaitForIOS+0xc>
    5f04:	84 e0       	ldi	r24, 0x04	; 4
		  return HOST_SENDCONTROL_SoftwareTimeOut;
    5f06:	0e c0       	rjmp	.+28     	; 0x5f24 <USB_Host_WaitForIOS+0x46>
    5f08:	11 30       	cpi	r17, 0x01	; 1
	uint8_t  TimeoutCounter = USB_HOST_TIMEOUT_MS;
	#else
	uint16_t TimeoutCounter = USB_HOST_TIMEOUT_MS;
	#endif

	while (!(((WaitType == USB_HOST_WAITFOR_SetupSent)  && Pipe_IsSETUPSent())  ||
    5f0a:	29 f4       	brne	.+10     	; 0x5f16 <USB_Host_WaitForIOS+0x38>
    5f0c:	80 91 a6 00 	lds	r24, 0x00A6
			 *  \return Boolean \c true if the current pipe has received an IN packet, \c false otherwise.
			 */
			static inline bool Pipe_IsINReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsINReceived(void)
			{
				return ((UPINTX & (1 << RXINI)) ? true : false);
    5f10:	80 ff       	sbrs	r24, 0
	         ((WaitType == USB_HOST_WAITFOR_InReceived) && Pipe_IsINReceived()) ||
    5f12:	f1 cf       	rjmp	.-30     	; 0x5ef6 <USB_Host_WaitForIOS+0x18>
    5f14:	06 c0       	rjmp	.+12     	; 0x5f22 <USB_Host_WaitForIOS+0x44>
    5f16:	12 30       	cpi	r17, 0x02	; 2
	uint8_t  TimeoutCounter = USB_HOST_TIMEOUT_MS;
	#else
	uint16_t TimeoutCounter = USB_HOST_TIMEOUT_MS;
	#endif

	while (!(((WaitType == USB_HOST_WAITFOR_SetupSent)  && Pipe_IsSETUPSent())  ||
    5f18:	71 f7       	brne	.-36     	; 0x5ef6 <USB_Host_WaitForIOS+0x18>
    5f1a:	80 91 a6 00 	lds	r24, 0x00A6
			 *  \return Boolean \c true if the current pipe is ready for an OUT packet, \c false otherwise.
			 */
			static inline bool Pipe_IsOUTReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsOUTReady(void)
			{
				return ((UPINTX & (1 << TXOUTI)) ? true : false);
    5f1e:	82 ff       	sbrs	r24, 2
	         ((WaitType == USB_HOST_WAITFOR_InReceived) && Pipe_IsINReceived()) ||
	         ((WaitType == USB_HOST_WAITFOR_OutReady)   && Pipe_IsOUTReady())))
    5f20:	ea cf       	rjmp	.-44     	; 0x5ef6 <USB_Host_WaitForIOS+0x18>
    5f22:	80 e0       	ldi	r24, 0x00	; 0

		if (!(TimeoutCounter--))
		  return HOST_SENDCONTROL_SoftwareTimeOut;
	}

	return HOST_SENDCONTROL_Successful;
    5f24:	df 91       	pop	r29
}
    5f26:	cf 91       	pop	r28
    5f28:	1f 91       	pop	r17
    5f2a:	08 95       	ret

00005f2c <USB_Host_SendControlRequest>:
    5f2c:	ff 92       	push	r15

uint8_t USB_Host_SendControlRequest(void* const BufferPtr)
{
    5f2e:	0f 93       	push	r16
    5f30:	1f 93       	push	r17
    5f32:	cf 93       	push	r28
    5f34:	df 93       	push	r29
    5f36:	8c 01       	movw	r16, r24
			 *  \return Boolean \c true if the bus is currently suspended, \c false otherwise.
			 */
			static inline bool USB_Host_IsBusSuspended(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool USB_Host_IsBusSuspended(void)
			{
				return ((UHCON & (1 << SOFEN)) ? false : true);
    5f38:	f0 90 9e 00 	lds	r15, 0x009E
    5f3c:	8f 2d       	mov	r24, r15
    5f3e:	81 70       	andi	r24, 0x01	; 1
    5f40:	f8 2e       	mov	r15, r24

static uint8_t USB_Host_SendControlRequest_PRV(void* const BufferPtr)
{
	uint8_t* DataStream   = (uint8_t*)BufferPtr;
	uint8_t  ReturnStatus = HOST_SENDCONTROL_Successful;
	uint16_t DataLen      = USB_ControlRequest.wLength;
    5f42:	c0 91 e2 0d 	lds	r28, 0x0DE2
    5f46:	d0 91 e3 0d 	lds	r29, 0x0DE3
			 *  host and attached device may occur.
			 */
			static inline void USB_Host_ResumeBus(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_ResumeBus(void)
			{
				UHCON |=  (1 << SOFEN);
    5f4a:	80 91 9e 00 	lds	r24, 0x009E
    5f4e:	81 60       	ori	r24, 0x01	; 1
    5f50:	80 93 9e 00 	sts	0x009E, r24

	USB_Host_ResumeBus();

	if ((ReturnStatus = USB_Host_WaitMS(1)) != HOST_WAITERROR_Successful)
    5f54:	81 e0       	ldi	r24, 0x01	; 1
    5f56:	08 d8       	rcall	.-4080   	; 0x4f68 <USB_Host_WaitMS>
    5f58:	81 11       	cpse	r24, r1
    5f5a:	cd c0       	rjmp	.+410    	; 0x60f6 <USB_Host_SendControlRequest+0x1ca>
    5f5c:	80 91 aa 00 	lds	r24, 0x00AA
			 *  \param[in] Token  New pipe token to set the selected pipe to, as a \c PIPE_TOKEN_* mask.
			 */
			static inline void Pipe_SetPipeToken(const uint8_t Token) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SetPipeToken(const uint8_t Token)
			{
				UPCFG0X = ((UPCFG0X & ~(0x03 << PTOKEN0)) | Token);
    5f60:	8f 7c       	andi	r24, 0xCF	; 207
    5f62:	80 93 aa 00 	sts	0x00AA, r24
    5f66:	10 92 f5 00 	sts	0x00F5, r1

			/** Clears the error flags for the currently selected pipe. */
			static inline void Pipe_ClearError(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearError(void)
			{
				UPERRX = 0;
    5f6a:	80 91 a6 00 	lds	r24, 0x00A6
				UPINTX &= ~(1 << PERRI);
    5f6e:	8f 7e       	andi	r24, 0xEF	; 239
    5f70:	80 93 a6 00 	sts	0x00A6, r24
    5f74:	80 91 a9 00 	lds	r24, 0x00A9

			/** Unfreezes the selected pipe, allowing it to communicate with an attached device. */
			static inline void Pipe_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Unfreeze(void)
			{
				UPCONX &= ~(1 << PFREEZE);
    5f78:	8f 7b       	andi	r24, 0xBF	; 191
    5f7a:	80 93 a9 00 	sts	0x00A9, r24
    5f7e:	ec ed       	ldi	r30, 0xDC	; 220
    5f80:	fd e0       	ldi	r31, 0x0D	; 13
    5f82:	81 91       	ld	r24, Z+
	Pipe_Write_16_LE(USB_ControlRequest.wLength);
	#else
	uint8_t* HeaderStream = (uint8_t*)&USB_ControlRequest;

	for (uint8_t HeaderByte = 0; HeaderByte < sizeof(USB_Request_Header_t); HeaderByte++)
	  Pipe_Write_8(*(HeaderStream++));
    5f84:	80 93 af 00 	sts	0x00AF, r24
			 *  \param[in] Data  Data to write into the the currently selected pipe's FIFO buffer.
			 */
			static inline void Pipe_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Write_8(const uint8_t Data)
			{
				UPDATX = Data;
    5f88:	8d e0       	ldi	r24, 0x0D	; 13
	Pipe_Write_16_LE(USB_ControlRequest.wIndex);
	Pipe_Write_16_LE(USB_ControlRequest.wLength);
	#else
	uint8_t* HeaderStream = (uint8_t*)&USB_ControlRequest;

	for (uint8_t HeaderByte = 0; HeaderByte < sizeof(USB_Request_Header_t); HeaderByte++)
    5f8a:	e4 3e       	cpi	r30, 0xE4	; 228
    5f8c:	f8 07       	cpc	r31, r24
    5f8e:	c9 f7       	brne	.-14     	; 0x5f82 <USB_Host_SendControlRequest+0x56>
    5f90:	80 91 a6 00 	lds	r24, 0x00A6
			 *  \ingroup Group_PipePacketManagement_AVR8
			 */
			static inline void Pipe_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearSETUP(void)
			{
				UPINTX &= ~((1 << TXSTPI) | (1 << FIFOCON));
    5f94:	87 77       	andi	r24, 0x77	; 119
    5f96:	80 93 a6 00 	sts	0x00A6, r24
    5f9a:	80 e0       	ldi	r24, 0x00	; 0
	  Pipe_Write_8(*(HeaderStream++));
	#endif

	Pipe_ClearSETUP();

	if ((ReturnStatus = USB_Host_WaitForIOS(USB_HOST_WAITFOR_SetupSent)) != HOST_SENDCONTROL_Successful)
    5f9c:	a0 df       	rcall	.-192    	; 0x5ede <USB_Host_WaitForIOS>
    5f9e:	81 11       	cpse	r24, r1
    5fa0:	aa c0       	rjmp	.+340    	; 0x60f6 <USB_Host_SendControlRequest+0x1ca>
    5fa2:	80 91 a9 00 	lds	r24, 0x00A9

			/** Freezes the selected pipe, preventing it from communicating with an attached device. */
			static inline void Pipe_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Freeze(void)
			{
				UPCONX |= (1 << PFREEZE);
    5fa6:	80 64       	ori	r24, 0x40	; 64
    5fa8:	80 93 a9 00 	sts	0x00A9, r24
    5fac:	81 e0       	ldi	r24, 0x01	; 1
    5fae:	0e 94 b4 27 	call	0x4f68	; 0x4f68 <USB_Host_WaitMS>
	  return ReturnStatus;

	Pipe_Freeze();

	if ((ReturnStatus = USB_Host_WaitMS(1)) != HOST_WAITERROR_Successful)
    5fb2:	81 11       	cpse	r24, r1
    5fb4:	a0 c0       	rjmp	.+320    	; 0x60f6 <USB_Host_SendControlRequest+0x1ca>
    5fb6:	80 91 dc 0d 	lds	r24, 0x0DDC
	  return ReturnStatus;

	if ((USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_DIRECTION) == REQDIR_DEVICETOHOST)
    5fba:	87 ff       	sbrs	r24, 7
    5fbc:	4e c0       	rjmp	.+156    	; 0x605a <USB_Host_SendControlRequest+0x12e>
    5fbe:	80 91 aa 00 	lds	r24, 0x00AA
			 *  \param[in] Token  New pipe token to set the selected pipe to, as a \c PIPE_TOKEN_* mask.
			 */
			static inline void Pipe_SetPipeToken(const uint8_t Token) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SetPipeToken(const uint8_t Token)
			{
				UPCFG0X = ((UPCFG0X & ~(0x03 << PTOKEN0)) | Token);
    5fc2:	8f 7c       	andi	r24, 0xCF	; 207
    5fc4:	80 61       	ori	r24, 0x10	; 16
    5fc6:	80 93 aa 00 	sts	0x00AA, r24
    5fca:	01 15       	cp	r16, r1
    5fcc:	11 05       	cpc	r17, r1
	{
		Pipe_SetPipeToken(PIPE_TOKEN_IN);

		if (DataStream != NULL)
    5fce:	09 f0       	breq	.+2      	; 0x5fd2 <USB_Host_SendControlRequest+0xa6>
    5fd0:	3a c0       	rjmp	.+116    	; 0x6046 <USB_Host_SendControlRequest+0x11a>
    5fd2:	80 91 aa 00 	lds	r24, 0x00AA
    5fd6:	8f 7c       	andi	r24, 0xCF	; 207
    5fd8:	80 62       	ori	r24, 0x20	; 32
    5fda:	80 93 aa 00 	sts	0x00AA, r24
    5fde:	80 91 a9 00 	lds	r24, 0x00A9

			/** Unfreezes the selected pipe, allowing it to communicate with an attached device. */
			static inline void Pipe_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Unfreeze(void)
			{
				UPCONX &= ~(1 << PFREEZE);
    5fe2:	8f 7b       	andi	r24, 0xBF	; 191
    5fe4:	80 93 a9 00 	sts	0x00A9, r24
    5fe8:	82 e0       	ldi	r24, 0x02	; 2
    5fea:	79 df       	rcall	.-270    	; 0x5ede <USB_Host_WaitForIOS>
		}

		Pipe_SetPipeToken(PIPE_TOKEN_OUT);
		Pipe_Unfreeze();

		if ((ReturnStatus = USB_Host_WaitForIOS(USB_HOST_WAITFOR_OutReady)) != HOST_SENDCONTROL_Successful)
    5fec:	81 11       	cpse	r24, r1
    5fee:	83 c0       	rjmp	.+262    	; 0x60f6 <USB_Host_SendControlRequest+0x1ca>
    5ff0:	80 91 a6 00 	lds	r24, 0x00A6
    5ff4:	8b 77       	andi	r24, 0x7B	; 123
			 *  \ingroup Group_PipePacketManagement_AVR8
			 */
			static inline void Pipe_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearOUT(void)
			{
				UPINTX &= ~((1 << TXOUTI) | (1 << FIFOCON));
    5ff6:	80 93 a6 00 	sts	0x00A6, r24
    5ffa:	82 e0       	ldi	r24, 0x02	; 2
    5ffc:	70 df       	rcall	.-288    	; 0x5ede <USB_Host_WaitForIOS>
    5ffe:	7b c0       	rjmp	.+246    	; 0x60f6 <USB_Host_SendControlRequest+0x1ca>
		  return ReturnStatus;

		Pipe_ClearOUT();

		if ((ReturnStatus = USB_Host_WaitForIOS(USB_HOST_WAITFOR_OutReady)) != HOST_SENDCONTROL_Successful)
    6000:	80 91 a9 00 	lds	r24, 0x00A9
    6004:	8f 7b       	andi	r24, 0xBF	; 191
    6006:	80 93 a9 00 	sts	0x00A9, r24

			/** Unfreezes the selected pipe, allowing it to communicate with an attached device. */
			static inline void Pipe_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Unfreeze(void)
			{
				UPCONX &= ~(1 << PFREEZE);
    600a:	81 e0       	ldi	r24, 0x01	; 1
    600c:	68 df       	rcall	.-304    	; 0x5ede <USB_Host_WaitForIOS>
    600e:	81 11       	cpse	r24, r1
    6010:	72 c0       	rjmp	.+228    	; 0x60f6 <USB_Host_SendControlRequest+0x1ca>
		{
			while (DataLen)
			{
				Pipe_Unfreeze();

				if ((ReturnStatus = USB_Host_WaitForIOS(USB_HOST_WAITFOR_InReceived)) != HOST_SENDCONTROL_Successful)
    6012:	80 91 f6 00 	lds	r24, 0x00F6
    6016:	90 91 f7 00 	lds	r25, 0x00F7
    601a:	89 2b       	or	r24, r25
			 *  \return Total number of bytes in the currently selected pipe's FIFO buffer.
			 */
			static inline uint16_t Pipe_BytesInPipe(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Pipe_BytesInPipe(void)
			{
				return UPBCX;
    601c:	11 f4       	brne	.+4      	; 0x6022 <USB_Host_SendControlRequest+0xf6>
    601e:	c0 e0       	ldi	r28, 0x00	; 0
    6020:	d0 e0       	ldi	r29, 0x00	; 0
    6022:	f8 01       	movw	r30, r16
				  return ReturnStatus;

				if (!(Pipe_BytesInPipe()))
    6024:	8f 01       	movw	r16, r30
    6026:	80 91 f6 00 	lds	r24, 0x00F6
				  DataLen = 0;
    602a:	90 91 f7 00 	lds	r25, 0x00F7
    602e:	89 2b       	or	r24, r25
    6030:	69 f4       	brne	.+26     	; 0x604c <USB_Host_SendControlRequest+0x120>
    6032:	80 91 a9 00 	lds	r24, 0x00A9
    6036:	80 64       	ori	r24, 0x40	; 64

				while (Pipe_BytesInPipe() && DataLen)
    6038:	80 93 a9 00 	sts	0x00A9, r24

			/** Freezes the selected pipe, preventing it from communicating with an attached device. */
			static inline void Pipe_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Freeze(void)
			{
				UPCONX |= (1 << PFREEZE);
    603c:	80 91 a6 00 	lds	r24, 0x00A6
    6040:	8e 77       	andi	r24, 0x7E	; 126
    6042:	80 93 a6 00 	sts	0x00A6, r24
			 *  \ingroup Group_PipePacketManagement_AVR8
			 */
			static inline void Pipe_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearIN(void)
			{
				UPINTX &= ~((1 << RXINI) | (1 << FIFOCON));
    6046:	20 97       	sbiw	r28, 0x00	; 0
    6048:	d9 f6       	brne	.-74     	; 0x6000 <USB_Host_SendControlRequest+0xd4>
    604a:	c3 cf       	rjmp	.-122    	; 0x5fd2 <USB_Host_SendControlRequest+0xa6>
    604c:	20 97       	sbiw	r28, 0x00	; 0
    604e:	89 f3       	breq	.-30     	; 0x6032 <USB_Host_SendControlRequest+0x106>
	{
		Pipe_SetPipeToken(PIPE_TOKEN_IN);

		if (DataStream != NULL)
		{
			while (DataLen)
    6050:	80 91 af 00 	lds	r24, 0x00AF
    6054:	81 93       	st	Z+, r24
				  return ReturnStatus;

				if (!(Pipe_BytesInPipe()))
				  DataLen = 0;

				while (Pipe_BytesInPipe() && DataLen)
    6056:	21 97       	sbiw	r28, 0x01	; 1
    6058:	e5 cf       	rjmp	.-54     	; 0x6024 <USB_Host_SendControlRequest+0xf8>
			 *  \return Next byte in the currently selected pipe's FIFO buffer.
			 */
			static inline uint8_t Pipe_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Pipe_Read_8(void)
			{
				return UPDATX;
    605a:	01 15       	cp	r16, r1
    605c:	11 05       	cpc	r17, r1
				{
					*(DataStream++) = Pipe_Read_8();
    605e:	b1 f1       	breq	.+108    	; 0x60cc <USB_Host_SendControlRequest+0x1a0>
					DataLen--;
    6060:	80 91 aa 00 	lds	r24, 0x00AA
		if ((ReturnStatus = USB_Host_WaitForIOS(USB_HOST_WAITFOR_OutReady)) != HOST_SENDCONTROL_Successful)
		  return ReturnStatus;
	}
	else
	{
		if (DataStream != NULL)
    6064:	8f 7c       	andi	r24, 0xCF	; 207
    6066:	80 62       	ori	r24, 0x20	; 32
    6068:	80 93 aa 00 	sts	0x00AA, r24
			 *  \param[in] Token  New pipe token to set the selected pipe to, as a \c PIPE_TOKEN_* mask.
			 */
			static inline void Pipe_SetPipeToken(const uint8_t Token) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SetPipeToken(const uint8_t Token)
			{
				UPCFG0X = ((UPCFG0X & ~(0x03 << PTOKEN0)) | Token);
    606c:	80 91 a9 00 	lds	r24, 0x00A9
    6070:	8f 7b       	andi	r24, 0xBF	; 191
    6072:	80 93 a9 00 	sts	0x00A9, r24

			/** Unfreezes the selected pipe, allowing it to communicate with an attached device. */
			static inline void Pipe_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Unfreeze(void)
			{
				UPCONX &= ~(1 << PFREEZE);
    6076:	82 e0       	ldi	r24, 0x02	; 2
    6078:	20 97       	sbiw	r28, 0x00	; 0
    607a:	01 f1       	breq	.+64     	; 0x60bc <USB_Host_SendControlRequest+0x190>
    607c:	30 df       	rcall	.-416    	; 0x5ede <USB_Host_WaitForIOS>
    607e:	81 11       	cpse	r24, r1
			Pipe_SetPipeToken(PIPE_TOKEN_OUT);
			Pipe_Unfreeze();

			while (DataLen)
			{
				if ((ReturnStatus = USB_Host_WaitForIOS(USB_HOST_WAITFOR_OutReady)) != HOST_SENDCONTROL_Successful)
    6080:	3a c0       	rjmp	.+116    	; 0x60f6 <USB_Host_SendControlRequest+0x1ca>
		if (DataStream != NULL)
		{
			Pipe_SetPipeToken(PIPE_TOKEN_OUT);
			Pipe_Unfreeze();

			while (DataLen)
    6082:	f8 01       	movw	r30, r16
    6084:	20 91 f6 00 	lds	r18, 0x00F6
			{
				if ((ReturnStatus = USB_Host_WaitForIOS(USB_HOST_WAITFOR_OutReady)) != HOST_SENDCONTROL_Successful)
    6088:	30 91 f7 00 	lds	r19, 0x00F7
    608c:	80 91 8d 01 	lds	r24, 0x018D
			 *  \return Total number of bytes in the currently selected pipe's FIFO buffer.
			 */
			static inline uint16_t Pipe_BytesInPipe(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Pipe_BytesInPipe(void)
			{
				return UPBCX;
    6090:	90 e0       	ldi	r25, 0x00	; 0
    6092:	28 17       	cp	r18, r24
    6094:	39 07       	cpc	r19, r25
    6096:	58 f4       	brcc	.+22     	; 0x60ae <USB_Host_SendControlRequest+0x182>
				  return ReturnStatus;

				while (DataLen && (Pipe_BytesInPipe() < USB_Host_ControlPipeSize))
    6098:	cf 01       	movw	r24, r30
    609a:	01 96       	adiw	r24, 0x01	; 1
    609c:	8c 01       	movw	r16, r24
    609e:	20 81       	ld	r18, Z
    60a0:	20 93 af 00 	sts	0x00AF, r18
    60a4:	21 97       	sbiw	r28, 0x01	; 1
    60a6:	20 97       	sbiw	r28, 0x00	; 0
    60a8:	19 f0       	breq	.+6      	; 0x60b0 <USB_Host_SendControlRequest+0x184>
				{
					Pipe_Write_8(*(DataStream++));
    60aa:	fc 01       	movw	r30, r24
			 *  \param[in] Data  Data to write into the the currently selected pipe's FIFO buffer.
			 */
			static inline void Pipe_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Write_8(const uint8_t Data)
			{
				UPDATX = Data;
    60ac:	eb cf       	rjmp	.-42     	; 0x6084 <USB_Host_SendControlRequest+0x158>
    60ae:	8f 01       	movw	r16, r30
					DataLen--;
    60b0:	80 91 a6 00 	lds	r24, 0x00A6
			while (DataLen)
			{
				if ((ReturnStatus = USB_Host_WaitForIOS(USB_HOST_WAITFOR_OutReady)) != HOST_SENDCONTROL_Successful)
				  return ReturnStatus;

				while (DataLen && (Pipe_BytesInPipe() < USB_Host_ControlPipeSize))
    60b4:	8b 77       	andi	r24, 0x7B	; 123
    60b6:	80 93 a6 00 	sts	0x00A6, r24
    60ba:	dd cf       	rjmp	.-70     	; 0x6076 <USB_Host_SendControlRequest+0x14a>
			 *  \ingroup Group_PipePacketManagement_AVR8
			 */
			static inline void Pipe_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearOUT(void)
			{
				UPINTX &= ~((1 << TXOUTI) | (1 << FIFOCON));
    60bc:	10 df       	rcall	.-480    	; 0x5ede <USB_Host_WaitForIOS>
    60be:	81 11       	cpse	r24, r1
    60c0:	1a c0       	rjmp	.+52     	; 0x60f6 <USB_Host_SendControlRequest+0x1ca>
    60c2:	80 91 a9 00 	lds	r24, 0x00A9
    60c6:	80 64       	ori	r24, 0x40	; 64
				}

				Pipe_ClearOUT();
			}

			if ((ReturnStatus = USB_Host_WaitForIOS(USB_HOST_WAITFOR_OutReady)) != HOST_SENDCONTROL_Successful)
    60c8:	80 93 a9 00 	sts	0x00A9, r24
    60cc:	80 91 aa 00 	lds	r24, 0x00AA

			/** Freezes the selected pipe, preventing it from communicating with an attached device. */
			static inline void Pipe_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Freeze(void)
			{
				UPCONX |= (1 << PFREEZE);
    60d0:	8f 7c       	andi	r24, 0xCF	; 207
    60d2:	80 61       	ori	r24, 0x10	; 16
    60d4:	80 93 aa 00 	sts	0x00AA, r24
    60d8:	80 91 a9 00 	lds	r24, 0x00A9
			 *  \param[in] Token  New pipe token to set the selected pipe to, as a \c PIPE_TOKEN_* mask.
			 */
			static inline void Pipe_SetPipeToken(const uint8_t Token) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SetPipeToken(const uint8_t Token)
			{
				UPCFG0X = ((UPCFG0X & ~(0x03 << PTOKEN0)) | Token);
    60dc:	8f 7b       	andi	r24, 0xBF	; 191
    60de:	80 93 a9 00 	sts	0x00A9, r24
    60e2:	81 e0       	ldi	r24, 0x01	; 1
    60e4:	fc de       	rcall	.-520    	; 0x5ede <USB_Host_WaitForIOS>

			/** Unfreezes the selected pipe, allowing it to communicate with an attached device. */
			static inline void Pipe_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Unfreeze(void)
			{
				UPCONX &= ~(1 << PFREEZE);
    60e6:	81 11       	cpse	r24, r1
    60e8:	06 c0       	rjmp	.+12     	; 0x60f6 <USB_Host_SendControlRequest+0x1ca>
    60ea:	80 91 a6 00 	lds	r24, 0x00A6
    60ee:	8e 77       	andi	r24, 0x7E	; 126
		}

		Pipe_SetPipeToken(PIPE_TOKEN_IN);
		Pipe_Unfreeze();

		if ((ReturnStatus = USB_Host_WaitForIOS(USB_HOST_WAITFOR_InReceived)) != HOST_SENDCONTROL_Successful)
    60f0:	80 93 a6 00 	sts	0x00A6, r24
    60f4:	80 e0       	ldi	r24, 0x00	; 0
    60f6:	90 91 a9 00 	lds	r25, 0x00A9
			 *  \ingroup Group_PipePacketManagement_AVR8
			 */
			static inline void Pipe_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearIN(void)
			{
				UPINTX &= ~((1 << RXINI) | (1 << FIFOCON));
    60fa:	90 64       	ori	r25, 0x40	; 64
    60fc:	90 93 a9 00 	sts	0x00A9, r25
    6100:	f1 10       	cpse	r15, r1
    6102:	05 c0       	rjmp	.+10     	; 0x610e <USB_Host_SendControlRequest+0x1e2>
    6104:	90 91 9e 00 	lds	r25, 0x009E

			/** Freezes the selected pipe, preventing it from communicating with an attached device. */
			static inline void Pipe_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Freeze(void)
			{
				UPCONX |= (1 << PFREEZE);
    6108:	9e 7f       	andi	r25, 0xFE	; 254
    610a:	90 93 9e 00 	sts	0x009E, r25
    610e:	91 e0       	ldi	r25, 0x01	; 1
	bool BusSuspended    = USB_Host_IsBusSuspended();
	uint8_t ReturnStatus = USB_Host_SendControlRequest_PRV(BufferPtr);

	Pipe_Freeze();

	if (BusSuspended)
    6110:	90 93 a8 00 	sts	0x00A8, r25
			 *             some events (such as device disconnections) will not fire until the bus is resumed.
			 */
			static inline void USB_Host_SuspendBus(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_SuspendBus(void)
			{
				UHCON &= ~(1 << SOFEN);
    6114:	10 92 a8 00 	sts	0x00A8, r1
    6118:	df 91       	pop	r29
    611a:	cf 91       	pop	r28
    611c:	1f 91       	pop	r17
			 *  \param[in] Address  Address of the pipe to reset.
			 */
			static inline void Pipe_ResetPipe(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ResetPipe(const uint8_t Address)
			{
				UPRST = (1 << (Address & PIPE_PIPENUM_MASK));
    611e:	0f 91       	pop	r16
    6120:	ff 90       	pop	r15
    6122:	08 95       	ret

00006124 <USB_Host_SetDeviceConfiguration>:
				UPRST = 0;
    6124:	cf 93       	push	r28
    6126:	c8 2f       	mov	r28, r24
	  USB_Host_SuspendBus();

	Pipe_ResetPipe(PIPE_CONTROLPIPE);

	return ReturnStatus;
}
    6128:	10 92 dc 0d 	sts	0x0DDC, r1
    612c:	89 e0       	ldi	r24, 0x09	; 9
    612e:	80 93 dd 0d 	sts	0x0DDD, r24
    6132:	2c 2f       	mov	r18, r28

uint8_t USB_Host_SetDeviceConfiguration(const uint8_t ConfigNumber)
{
	uint8_t ErrorCode;

	USB_ControlRequest = (USB_Request_Header_t)
    6134:	30 e0       	ldi	r19, 0x00	; 0
    6136:	30 93 df 0d 	sts	0x0DDF, r19
    613a:	20 93 de 0d 	sts	0x0DDE, r18
    613e:	10 92 e1 0d 	sts	0x0DE1, r1
    6142:	10 92 e0 0d 	sts	0x0DE0, r1
    6146:	10 92 e3 0d 	sts	0x0DE3, r1
    614a:	10 92 e2 0d 	sts	0x0DE2, r1
			 *  \param[in] Address  Address of the pipe to select.
			 */
			static inline void Pipe_SelectPipe(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SelectPipe(const uint8_t Address)
			{
				UPNUM = (Address & PIPE_PIPENUM_MASK);
    614e:	10 92 a7 00 	sts	0x00A7, r1
			.wLength       = 0,
		};

	Pipe_SelectPipe(PIPE_CONTROLPIPE);

	if ((ErrorCode = USB_Host_SendControlRequest(NULL)) == HOST_SENDCONTROL_Successful)
    6152:	80 e0       	ldi	r24, 0x00	; 0
    6154:	90 e0       	ldi	r25, 0x00	; 0
    6156:	ea de       	rcall	.-556    	; 0x5f2c <USB_Host_SendControlRequest>
    6158:	81 11       	cpse	r24, r1
    615a:	08 c0       	rjmp	.+16     	; 0x616c <USB_Host_SetDeviceConfiguration+0x48>
    615c:	c0 93 da 0d 	sts	0x0DDA, r28
	{
		USB_Host_ConfigurationNumber = ConfigNumber;
    6160:	cc 23       	and	r28, r28
		USB_HostState                = (ConfigNumber) ? HOST_STATE_Configured : HOST_STATE_Addressed;
    6162:	11 f0       	breq	.+4      	; 0x6168 <USB_Host_SetDeviceConfiguration+0x44>
    6164:	9b e0       	ldi	r25, 0x0B	; 11
    6166:	01 c0       	rjmp	.+2      	; 0x616a <USB_Host_SetDeviceConfiguration+0x46>
    6168:	9a e0       	ldi	r25, 0x0A	; 10
    616a:	9e bb       	out	0x1e, r25	; 30
    616c:	cf 91       	pop	r28
	}

	return ErrorCode;
}
    616e:	08 95       	ret

00006170 <USB_USBTask>:
    6170:	cf 93       	push	r28
#endif

void USB_USBTask(void)
{
	#if defined(USB_CAN_BE_BOTH)
		if (USB_CurrentMode == USB_MODE_Device)
    6172:	80 91 07 04 	lds	r24, 0x0407
    6176:	81 30       	cpi	r24, 0x01	; 1
    6178:	c9 f4       	brne	.+50     	; 0x61ac <USB_USBTask+0x3c>
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_DeviceTask(void)
{
	if (USB_DeviceState == DEVICE_STATE_Unattached)
    617a:	8e b3       	in	r24, 0x1e	; 30
    617c:	88 23       	and	r24, r24
    617e:	29 f1       	breq	.+74     	; 0x61ca <USB_USBTask+0x5a>
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return ((UENUM & ENDPOINT_EPNUM_MASK) | Endpoint_GetEndpointDirection());
    6180:	80 91 e9 00 	lds	r24, 0x00E9
    6184:	8f 70       	andi	r24, 0x0F	; 15
			 *  \return The currently selected endpoint's direction, as a \c ENDPOINT_DIR_* mask.
			 */
			static inline uint8_t Endpoint_GetEndpointDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetEndpointDirection(void)
			{
				return (UECFG0X & (1 << EPDIR)) ? ENDPOINT_DIR_IN : ENDPOINT_DIR_OUT;
    6186:	90 91 ec 00 	lds	r25, 0x00EC
    618a:	90 ff       	sbrs	r25, 0
    618c:	02 c0       	rjmp	.+4      	; 0x6192 <USB_USBTask+0x22>
    618e:	90 e8       	ldi	r25, 0x80	; 128
    6190:	01 c0       	rjmp	.+2      	; 0x6194 <USB_USBTask+0x24>
    6192:	90 e0       	ldi	r25, 0x00	; 0
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return ((UENUM & ENDPOINT_EPNUM_MASK) | Endpoint_GetEndpointDirection());
    6194:	c9 2f       	mov	r28, r25
    6196:	c8 2b       	or	r28, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    6198:	10 92 e9 00 	sts	0x00E9, r1
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    619c:	80 91 e8 00 	lds	r24, 0x00E8

	uint8_t PrevEndpoint = Endpoint_GetCurrentEndpoint();

	Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);

	if (Endpoint_IsSETUPReceived())
    61a0:	83 fd       	sbrc	r24, 3
	  USB_Device_ProcessControlRequest();
    61a2:	46 dd       	rcall	.-1396   	; 0x5c30 <USB_Device_ProcessControlRequest>
    61a4:	cf 70       	andi	r28, 0x0F	; 15
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    61a6:	c0 93 e9 00 	sts	0x00E9, r28
    61aa:	0f c0       	rjmp	.+30     	; 0x61ca <USB_USBTask+0x5a>
    61ac:	80 91 07 04 	lds	r24, 0x0407
void USB_USBTask(void)
{
	#if defined(USB_CAN_BE_BOTH)
		if (USB_CurrentMode == USB_MODE_Device)
		  USB_DeviceTask();
		else if (USB_CurrentMode == USB_MODE_Host)
    61b0:	82 30       	cpi	r24, 0x02	; 2
    61b2:	59 f4       	brne	.+22     	; 0x61ca <USB_USBTask+0x5a>
    61b4:	c0 91 a7 00 	lds	r28, 0x00A7
			 *  \return Index of the currently selected pipe.
			 */
			static inline uint8_t Pipe_GetCurrentPipe(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Pipe_GetCurrentPipe(void)
			{
				return ((UPNUM & PIPE_PIPENUM_MASK) | Pipe_GetPipeDirection());
    61b8:	cf 70       	andi	r28, 0x0F	; 15
    61ba:	80 91 aa 00 	lds	r24, 0x00AA
			 *  \return The currently selected pipe's direction, as a \c PIPE_DIR_* mask.
			 */
			static inline uint8_t Pipe_GetPipeDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Pipe_GetPipeDirection(void)
			{
				return (UPCFG0X & (1 << EPDIR)) ? PIPE_DIR_IN : PIPE_DIR_OUT;
    61be:	10 92 a7 00 	sts	0x00A7, r1
			 *  \param[in] Address  Address of the pipe to select.
			 */
			static inline void Pipe_SelectPipe(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SelectPipe(const uint8_t Address)
			{
				UPNUM = (Address & PIPE_PIPENUM_MASK);
    61c2:	0e 94 04 28 	call	0x5008	; 0x5008 <USB_Host_ProcessNextHostState>
{
	uint8_t PrevPipe = Pipe_GetCurrentPipe();

	Pipe_SelectPipe(PIPE_CONTROLPIPE);

	USB_Host_ProcessNextHostState();
    61c6:	c0 93 a7 00 	sts	0x00A7, r28
    61ca:	cf 91       	pop	r28
	#elif defined(USB_CAN_BE_HOST)
		USB_HostTask();
	#elif defined(USB_CAN_BE_DEVICE)
		USB_DeviceTask();
	#endif
}
    61cc:	08 95       	ret

000061ce <MS_Device_ProcessControlRequest>:
    61ce:	cf 93       	push	r28
#define  __INCLUDE_FROM_MS_DRIVER
#define  __INCLUDE_FROM_MASSSTORAGE_DEVICE_C
#include "MassStorageClassDevice.h"

void MS_Device_ProcessControlRequest(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
    61d0:	df 93       	push	r29
    61d2:	ec 01       	movw	r28, r24
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    61d4:	80 91 e8 00 	lds	r24, 0x00E8
	if (!(Endpoint_IsSETUPReceived()))
    61d8:	83 ff       	sbrs	r24, 3
    61da:	37 c0       	rjmp	.+110    	; 0x624a <MS_Device_ProcessControlRequest+0x7c>
	  return;

	if (USB_ControlRequest.wIndex != MSInterfaceInfo->Config.InterfaceNumber)
    61dc:	88 81       	ld	r24, Y
    61de:	90 e0       	ldi	r25, 0x00	; 0
    61e0:	20 91 e0 0d 	lds	r18, 0x0DE0
    61e4:	30 91 e1 0d 	lds	r19, 0x0DE1
    61e8:	28 17       	cp	r18, r24
    61ea:	39 07       	cpc	r19, r25
    61ec:	71 f5       	brne	.+92     	; 0x624a <MS_Device_ProcessControlRequest+0x7c>
	  return;

	switch (USB_ControlRequest.bRequest)
    61ee:	80 91 dd 0d 	lds	r24, 0x0DDD
    61f2:	8e 3f       	cpi	r24, 0xFE	; 254
    61f4:	81 f0       	breq	.+32     	; 0x6216 <MS_Device_ProcessControlRequest+0x48>
    61f6:	8f 3f       	cpi	r24, 0xFF	; 255
    61f8:	41 f5       	brne	.+80     	; 0x624a <MS_Device_ProcessControlRequest+0x7c>
	{
		case MS_REQ_MassStorageReset:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
    61fa:	80 91 dc 0d 	lds	r24, 0x0DDC
    61fe:	81 32       	cpi	r24, 0x21	; 33
    6200:	21 f5       	brne	.+72     	; 0x624a <MS_Device_ProcessControlRequest+0x7c>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    6202:	80 91 e8 00 	lds	r24, 0x00E8
    6206:	87 7f       	andi	r24, 0xF7	; 247
    6208:	80 93 e8 00 	sts	0x00E8, r24
			{
				Endpoint_ClearSETUP();
				Endpoint_ClearStatusStage();
    620c:	0e 94 15 27 	call	0x4e2a	; 0x4e2a <Endpoint_ClearStatusStage>

				MSInterfaceInfo->State.IsMassStoreReset = true;
    6210:	81 e0       	ldi	r24, 0x01	; 1
    6212:	88 af       	std	Y+56, r24	; 0x38
    6214:	1a c0       	rjmp	.+52     	; 0x624a <MS_Device_ProcessControlRequest+0x7c>
			}

			break;
		case MS_REQ_GetMaxLUN:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
    6216:	80 91 dc 0d 	lds	r24, 0x0DDC
    621a:	81 3a       	cpi	r24, 0xA1	; 161
    621c:	b1 f4       	brne	.+44     	; 0x624a <MS_Device_ProcessControlRequest+0x7c>
    621e:	80 91 e8 00 	lds	r24, 0x00E8
    6222:	87 7f       	andi	r24, 0xF7	; 247
    6224:	80 93 e8 00 	sts	0x00E8, r24
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    6228:	80 91 e8 00 	lds	r24, 0x00E8
			{
				Endpoint_ClearSETUP();
				while (!(Endpoint_IsINReady()));
    622c:	80 ff       	sbrs	r24, 0
    622e:	fc cf       	rjmp	.-8      	; 0x6228 <MS_Device_ProcessControlRequest+0x5a>
				Endpoint_Write_8(MSInterfaceInfo->Config.TotalLUNs - 1);
    6230:	8b 85       	ldd	r24, Y+11	; 0x0b
    6232:	81 50       	subi	r24, 0x01	; 1
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    6234:	80 93 f1 00 	sts	0x00F1, r24
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    6238:	80 91 e8 00 	lds	r24, 0x00E8
    623c:	8e 77       	andi	r24, 0x7E	; 126
    623e:	80 93 e8 00 	sts	0x00E8, r24
				Endpoint_ClearStatusStage();
			}

			break;
	}
}
    6242:	df 91       	pop	r29
    6244:	cf 91       	pop	r28
			{
				Endpoint_ClearSETUP();
				while (!(Endpoint_IsINReady()));
				Endpoint_Write_8(MSInterfaceInfo->Config.TotalLUNs - 1);
				Endpoint_ClearIN();
				Endpoint_ClearStatusStage();
    6246:	0c 94 15 27 	jmp	0x4e2a	; 0x4e2a <Endpoint_ClearStatusStage>
			}

			break;
	}
}
    624a:	df 91       	pop	r29
    624c:	cf 91       	pop	r28
    624e:	08 95       	ret

00006250 <MS_Device_ConfigureEndpoints>:

bool MS_Device_ConfigureEndpoints(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
    6250:	cf 93       	push	r28
    6252:	df 93       	push	r29
    6254:	ec 01       	movw	r28, r24
	memset(&MSInterfaceInfo->State, 0x00, sizeof(MSInterfaceInfo->State));
    6256:	fc 01       	movw	r30, r24
    6258:	3c 96       	adiw	r30, 0x0c	; 12
    625a:	8d e2       	ldi	r24, 0x2D	; 45
    625c:	df 01       	movw	r26, r30
    625e:	1d 92       	st	X+, r1
    6260:	8a 95       	dec	r24
    6262:	e9 f7       	brne	.-6      	; 0x625e <MS_Device_ConfigureEndpoints+0xe>

	MSInterfaceInfo->Config.DataINEndpoint.Type  = EP_TYPE_BULK;
    6264:	82 e0       	ldi	r24, 0x02	; 2
    6266:	8c 83       	std	Y+4, r24	; 0x04
	MSInterfaceInfo->Config.DataOUTEndpoint.Type = EP_TYPE_BULK;
    6268:	89 87       	std	Y+9, r24	; 0x09

	if (!(Endpoint_ConfigureEndpointTable(&MSInterfaceInfo->Config.DataINEndpoint, 1)))
    626a:	61 e0       	ldi	r22, 0x01	; 1
    626c:	ce 01       	movw	r24, r28
    626e:	01 96       	adiw	r24, 0x01	; 1
    6270:	0e 94 d8 26 	call	0x4db0	; 0x4db0 <Endpoint_ConfigureEndpointTable>
    6274:	88 23       	and	r24, r24
    6276:	39 f0       	breq	.+14     	; 0x6286 <MS_Device_ConfigureEndpoints+0x36>
	  return false;

	if (!(Endpoint_ConfigureEndpointTable(&MSInterfaceInfo->Config.DataOUTEndpoint, 1)))
    6278:	61 e0       	ldi	r22, 0x01	; 1
    627a:	ce 01       	movw	r24, r28
    627c:	06 96       	adiw	r24, 0x06	; 6
	  return false;

	return true;
}
    627e:	df 91       	pop	r29
    6280:	cf 91       	pop	r28
	MSInterfaceInfo->Config.DataOUTEndpoint.Type = EP_TYPE_BULK;

	if (!(Endpoint_ConfigureEndpointTable(&MSInterfaceInfo->Config.DataINEndpoint, 1)))
	  return false;

	if (!(Endpoint_ConfigureEndpointTable(&MSInterfaceInfo->Config.DataOUTEndpoint, 1)))
    6282:	0c 94 d8 26 	jmp	0x4db0	; 0x4db0 <Endpoint_ConfigureEndpointTable>
	  return false;

	return true;
}
    6286:	80 e0       	ldi	r24, 0x00	; 0
    6288:	df 91       	pop	r29
    628a:	cf 91       	pop	r28
    628c:	08 95       	ret

0000628e <MS_Device_USBTask>:

void MS_Device_USBTask(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
    628e:	ef 92       	push	r14
    6290:	ff 92       	push	r15
    6292:	0f 93       	push	r16
    6294:	1f 93       	push	r17
    6296:	cf 93       	push	r28
    6298:	df 93       	push	r29
    629a:	00 d0       	rcall	.+0      	; 0x629c <MS_Device_USBTask+0xe>
    629c:	cd b7       	in	r28, 0x3d	; 61
    629e:	de b7       	in	r29, 0x3e	; 62
    62a0:	8c 01       	movw	r16, r24
	if (USB_DeviceState != DEVICE_STATE_Configured)
    62a2:	8e b3       	in	r24, 0x1e	; 30
    62a4:	84 30       	cpi	r24, 0x04	; 4
    62a6:	09 f0       	breq	.+2      	; 0x62aa <MS_Device_USBTask+0x1c>
    62a8:	03 c1       	rjmp	.+518    	; 0x64b0 <MS_Device_USBTask+0x222>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    62aa:	f8 01       	movw	r30, r16
    62ac:	86 81       	ldd	r24, Z+6	; 0x06
    62ae:	8f 70       	andi	r24, 0x0F	; 15
    62b0:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    62b4:	80 91 e8 00 	lds	r24, 0x00E8
	  return;

	Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataOUTEndpoint.Address);

	if (Endpoint_IsOUTReceived())
    62b8:	82 ff       	sbrs	r24, 2
    62ba:	c0 c0       	rjmp	.+384    	; 0x643c <MS_Device_USBTask+0x1ae>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    62bc:	86 81       	ldd	r24, Z+6	; 0x06
    62be:	8f 70       	andi	r24, 0x0F	; 15
    62c0:	80 93 e9 00 	sts	0x00E9, r24
{
	uint16_t BytesProcessed;

	Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataOUTEndpoint.Address);

	BytesProcessed = 0;
    62c4:	1a 82       	std	Y+2, r1	; 0x02
    62c6:	19 82       	std	Y+1, r1	; 0x01
	while (Endpoint_Read_Stream_LE(&MSInterfaceInfo->State.CommandBlock,
    62c8:	78 01       	movw	r14, r16
    62ca:	fc e0       	ldi	r31, 0x0C	; 12
    62cc:	ef 0e       	add	r14, r31
    62ce:	f1 1c       	adc	r15, r1
    62d0:	ae 01       	movw	r20, r28
    62d2:	4f 5f       	subi	r20, 0xFF	; 255
    62d4:	5f 4f       	sbci	r21, 0xFF	; 255
    62d6:	6f e0       	ldi	r22, 0x0F	; 15
    62d8:	70 e0       	ldi	r23, 0x00	; 0
    62da:	c7 01       	movw	r24, r14
    62dc:	0e 94 67 25 	call	0x4ace	; 0x4ace <Endpoint_Read_Stream_LE>
	                               (sizeof(MS_CommandBlockWrapper_t) - 16), &BytesProcessed) ==
	                               ENDPOINT_RWSTREAM_IncompleteTransfer)
	{
		if (MSInterfaceInfo->State.IsMassStoreReset)
    62e0:	f8 01       	movw	r30, r16
	uint16_t BytesProcessed;

	Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataOUTEndpoint.Address);

	BytesProcessed = 0;
	while (Endpoint_Read_Stream_LE(&MSInterfaceInfo->State.CommandBlock,
    62e2:	85 30       	cpi	r24, 0x05	; 5
    62e4:	21 f4       	brne	.+8      	; 0x62ee <MS_Device_USBTask+0x60>
	                               (sizeof(MS_CommandBlockWrapper_t) - 16), &BytesProcessed) ==
	                               ENDPOINT_RWSTREAM_IncompleteTransfer)
	{
		if (MSInterfaceInfo->State.IsMassStoreReset)
    62e6:	80 ad       	ldd	r24, Z+56	; 0x38
    62e8:	88 23       	and	r24, r24
    62ea:	91 f3       	breq	.-28     	; 0x62d0 <MS_Device_USBTask+0x42>
    62ec:	a7 c0       	rjmp	.+334    	; 0x643c <MS_Device_USBTask+0x1ae>
		  return false;
	}

	if ((MSInterfaceInfo->State.CommandBlock.Signature         != CPU_TO_LE32(MS_CBW_SIGNATURE))     ||
    62ee:	84 85       	ldd	r24, Z+12	; 0x0c
    62f0:	95 85       	ldd	r25, Z+13	; 0x0d
    62f2:	a6 85       	ldd	r26, Z+14	; 0x0e
    62f4:	b7 85       	ldd	r27, Z+15	; 0x0f
    62f6:	85 35       	cpi	r24, 0x55	; 85
    62f8:	93 45       	sbci	r25, 0x53	; 83
    62fa:	a2 44       	sbci	r26, 0x42	; 66
    62fc:	b3 44       	sbci	r27, 0x43	; 67
    62fe:	61 f4       	brne	.+24     	; 0x6318 <MS_Device_USBTask+0x8a>
    6300:	f8 01       	movw	r30, r16
    6302:	91 8d       	ldd	r25, Z+25	; 0x19
    6304:	83 85       	ldd	r24, Z+11	; 0x0b
    6306:	98 17       	cp	r25, r24
    6308:	38 f4       	brcc	.+14     	; 0x6318 <MS_Device_USBTask+0x8a>
	    (MSInterfaceInfo->State.CommandBlock.LUN               >= MSInterfaceInfo->Config.TotalLUNs) ||
		(MSInterfaceInfo->State.CommandBlock.Flags              & 0x1F)                              ||
    630a:	80 8d       	ldd	r24, Z+24	; 0x18
    630c:	8f 71       	andi	r24, 0x1F	; 31
		if (MSInterfaceInfo->State.IsMassStoreReset)
		  return false;
	}

	if ((MSInterfaceInfo->State.CommandBlock.Signature         != CPU_TO_LE32(MS_CBW_SIGNATURE))     ||
	    (MSInterfaceInfo->State.CommandBlock.LUN               >= MSInterfaceInfo->Config.TotalLUNs) ||
    630e:	21 f4       	brne	.+8      	; 0x6318 <MS_Device_USBTask+0x8a>
		(MSInterfaceInfo->State.CommandBlock.Flags              & 0x1F)                              ||
    6310:	82 8d       	ldd	r24, Z+26	; 0x1a
    6312:	81 50       	subi	r24, 0x01	; 1
    6314:	80 31       	cpi	r24, 0x10	; 16
    6316:	80 f0       	brcs	.+32     	; 0x6338 <MS_Device_USBTask+0xaa>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    6318:	80 91 eb 00 	lds	r24, 0x00EB
    631c:	80 62       	ori	r24, 0x20	; 32
    631e:	80 93 eb 00 	sts	0x00EB, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    6322:	f8 01       	movw	r30, r16
    6324:	81 81       	ldd	r24, Z+1	; 0x01
    6326:	8f 70       	andi	r24, 0x0F	; 15
    6328:	80 93 e9 00 	sts	0x00E9, r24
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    632c:	80 91 eb 00 	lds	r24, 0x00EB
    6330:	80 62       	ori	r24, 0x20	; 32
    6332:	80 93 eb 00 	sts	0x00EB, r24
    6336:	82 c0       	rjmp	.+260    	; 0x643c <MS_Device_USBTask+0x1ae>
		Endpoint_StallTransaction();

		return false;
	}

	BytesProcessed = 0;
    6338:	1a 82       	std	Y+2, r1	; 0x02
    633a:	19 82       	std	Y+1, r1	; 0x01
	while (Endpoint_Read_Stream_LE(&MSInterfaceInfo->State.CommandBlock.SCSICommandData,
    633c:	78 01       	movw	r14, r16
    633e:	fb e1       	ldi	r31, 0x1B	; 27
    6340:	ef 0e       	add	r14, r31
    6342:	f1 1c       	adc	r15, r1
    6344:	f8 01       	movw	r30, r16
    6346:	62 8d       	ldd	r22, Z+26	; 0x1a
    6348:	70 e0       	ldi	r23, 0x00	; 0
    634a:	ae 01       	movw	r20, r28
    634c:	4f 5f       	subi	r20, 0xFF	; 255
    634e:	5f 4f       	sbci	r21, 0xFF	; 255
    6350:	c7 01       	movw	r24, r14
    6352:	0e 94 67 25 	call	0x4ace	; 0x4ace <Endpoint_Read_Stream_LE>
    6356:	85 30       	cpi	r24, 0x05	; 5
    6358:	29 f4       	brne	.+10     	; 0x6364 <MS_Device_USBTask+0xd6>
	                                MSInterfaceInfo->State.CommandBlock.SCSICommandLength, &BytesProcessed) ==
	                                ENDPOINT_RWSTREAM_IncompleteTransfer)
	{
		if (MSInterfaceInfo->State.IsMassStoreReset)
    635a:	f8 01       	movw	r30, r16
    635c:	80 ad       	ldd	r24, Z+56	; 0x38
    635e:	88 23       	and	r24, r24
    6360:	89 f3       	breq	.-30     	; 0x6344 <MS_Device_USBTask+0xb6>
    6362:	6c c0       	rjmp	.+216    	; 0x643c <MS_Device_USBTask+0x1ae>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    6364:	80 91 e8 00 	lds	r24, 0x00E8
    6368:	8b 77       	andi	r24, 0x7B	; 123
    636a:	80 93 e8 00 	sts	0x00E8, r24

	if (Endpoint_IsOUTReceived())
	{
		if (MS_Device_ReadInCommandBlock(MSInterfaceInfo))
		{
			if (MSInterfaceInfo->State.CommandBlock.Flags & MS_COMMAND_DIR_DATA_IN)
    636e:	f8 01       	movw	r30, r16
    6370:	80 8d       	ldd	r24, Z+24	; 0x18
    6372:	87 ff       	sbrs	r24, 7
    6374:	04 c0       	rjmp	.+8      	; 0x637e <MS_Device_USBTask+0xf0>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    6376:	81 81       	ldd	r24, Z+1	; 0x01
    6378:	8f 70       	andi	r24, 0x0F	; 15
    637a:	80 93 e9 00 	sts	0x00E9, r24
			  Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataINEndpoint.Address);

			bool SCSICommandResult = CALLBACK_MS_Device_SCSICommandReceived(MSInterfaceInfo);
    637e:	c8 01       	movw	r24, r16
    6380:	0e 94 cc 02 	call	0x598	; 0x598 <CALLBACK_MS_Device_SCSICommandReceived>

			MSInterfaceInfo->State.CommandStatus.Status              = (SCSICommandResult) ? MS_SCSI_COMMAND_Pass : MS_SCSI_COMMAND_Fail;
    6384:	91 e0       	ldi	r25, 0x01	; 1
    6386:	98 27       	eor	r25, r24
    6388:	f8 01       	movw	r30, r16
    638a:	97 ab       	std	Z+55, r25	; 0x37
			MSInterfaceInfo->State.CommandStatus.Signature           = CPU_TO_LE32(MS_CSW_SIGNATURE);
    638c:	45 e5       	ldi	r20, 0x55	; 85
    638e:	53 e5       	ldi	r21, 0x53	; 83
    6390:	62 e4       	ldi	r22, 0x42	; 66
    6392:	73 e5       	ldi	r23, 0x53	; 83
    6394:	43 a7       	std	Z+43, r20	; 0x2b
    6396:	54 a7       	std	Z+44, r21	; 0x2c
    6398:	65 a7       	std	Z+45, r22	; 0x2d
    639a:	76 a7       	std	Z+46, r23	; 0x2e
			MSInterfaceInfo->State.CommandStatus.Tag                 = MSInterfaceInfo->State.CommandBlock.Tag;
    639c:	40 89       	ldd	r20, Z+16	; 0x10
    639e:	51 89       	ldd	r21, Z+17	; 0x11
    63a0:	62 89       	ldd	r22, Z+18	; 0x12
    63a2:	73 89       	ldd	r23, Z+19	; 0x13
    63a4:	47 a7       	std	Z+47, r20	; 0x2f
    63a6:	50 ab       	std	Z+48, r21	; 0x30
    63a8:	61 ab       	std	Z+49, r22	; 0x31
    63aa:	72 ab       	std	Z+50, r23	; 0x32
			MSInterfaceInfo->State.CommandStatus.DataTransferResidue = MSInterfaceInfo->State.CommandBlock.DataTransferLength;
    63ac:	44 89       	ldd	r20, Z+20	; 0x14
    63ae:	55 89       	ldd	r21, Z+21	; 0x15
    63b0:	66 89       	ldd	r22, Z+22	; 0x16
    63b2:	77 89       	ldd	r23, Z+23	; 0x17
    63b4:	43 ab       	std	Z+51, r20	; 0x33
    63b6:	54 ab       	std	Z+52, r21	; 0x34
    63b8:	65 ab       	std	Z+53, r22	; 0x35
    63ba:	76 ab       	std	Z+54, r23	; 0x36

			if (!(SCSICommandResult) && (le32_to_cpu(MSInterfaceInfo->State.CommandStatus.DataTransferResidue)))
    63bc:	81 11       	cpse	r24, r1
    63be:	09 c0       	rjmp	.+18     	; 0x63d2 <MS_Device_USBTask+0x144>
    63c0:	45 2b       	or	r20, r21
    63c2:	46 2b       	or	r20, r22
    63c4:	47 2b       	or	r20, r23
    63c6:	29 f0       	breq	.+10     	; 0x63d2 <MS_Device_USBTask+0x144>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    63c8:	80 91 eb 00 	lds	r24, 0x00EB
    63cc:	80 62       	ori	r24, 0x20	; 32
    63ce:	80 93 eb 00 	sts	0x00EB, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    63d2:	f8 01       	movw	r30, r16
    63d4:	86 81       	ldd	r24, Z+6	; 0x06
    63d6:	8f 70       	andi	r24, 0x0F	; 15
    63d8:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    63dc:	80 91 eb 00 	lds	r24, 0x00EB
	{
		#if !defined(INTERRUPT_CONTROL_ENDPOINT)
		USB_USBTask();
		#endif

		if (MSInterfaceInfo->State.IsMassStoreReset)
    63e0:	f8 01       	movw	r30, r16

static void MS_Device_ReturnCommandStatus(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataOUTEndpoint.Address);

	while (Endpoint_IsStalled())
    63e2:	85 ff       	sbrs	r24, 5
    63e4:	04 c0       	rjmp	.+8      	; 0x63ee <MS_Device_USBTask+0x160>
	{
		#if !defined(INTERRUPT_CONTROL_ENDPOINT)
		USB_USBTask();
		#endif

		if (MSInterfaceInfo->State.IsMassStoreReset)
    63e6:	80 ad       	ldd	r24, Z+56	; 0x38
    63e8:	88 23       	and	r24, r24
    63ea:	c1 f3       	breq	.-16     	; 0x63dc <MS_Device_USBTask+0x14e>
    63ec:	27 c0       	rjmp	.+78     	; 0x643c <MS_Device_USBTask+0x1ae>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    63ee:	81 81       	ldd	r24, Z+1	; 0x01
    63f0:	8f 70       	andi	r24, 0x0F	; 15
    63f2:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    63f6:	80 91 eb 00 	lds	r24, 0x00EB
		  return;
	}

	Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataINEndpoint.Address);

	while (Endpoint_IsStalled())
    63fa:	85 ff       	sbrs	r24, 5
    63fc:	05 c0       	rjmp	.+10     	; 0x6408 <MS_Device_USBTask+0x17a>
	{
		#if !defined(INTERRUPT_CONTROL_ENDPOINT)
		USB_USBTask();
		#endif

		if (MSInterfaceInfo->State.IsMassStoreReset)
    63fe:	f8 01       	movw	r30, r16
    6400:	80 ad       	ldd	r24, Z+56	; 0x38
    6402:	88 23       	and	r24, r24
    6404:	c1 f3       	breq	.-16     	; 0x63f6 <MS_Device_USBTask+0x168>
    6406:	1a c0       	rjmp	.+52     	; 0x643c <MS_Device_USBTask+0x1ae>
		  return;
	}

	uint16_t BytesProcessed = 0;
    6408:	1a 82       	std	Y+2, r1	; 0x02
    640a:	19 82       	std	Y+1, r1	; 0x01
	while (Endpoint_Write_Stream_LE(&MSInterfaceInfo->State.CommandStatus,
    640c:	78 01       	movw	r14, r16
    640e:	fb e2       	ldi	r31, 0x2B	; 43
    6410:	ef 0e       	add	r14, r31
    6412:	f1 1c       	adc	r15, r1
    6414:	ae 01       	movw	r20, r28
    6416:	4f 5f       	subi	r20, 0xFF	; 255
    6418:	5f 4f       	sbci	r21, 0xFF	; 255
    641a:	6d e0       	ldi	r22, 0x0D	; 13
    641c:	70 e0       	ldi	r23, 0x00	; 0
    641e:	c7 01       	movw	r24, r14
    6420:	0e 94 d2 24 	call	0x49a4	; 0x49a4 <Endpoint_Write_Stream_LE>
    6424:	85 30       	cpi	r24, 0x05	; 5
    6426:	29 f4       	brne	.+10     	; 0x6432 <MS_Device_USBTask+0x1a4>
	                                sizeof(MS_CommandStatusWrapper_t), &BytesProcessed) ==
	                                ENDPOINT_RWSTREAM_IncompleteTransfer)
	{
		if (MSInterfaceInfo->State.IsMassStoreReset)
    6428:	f8 01       	movw	r30, r16
    642a:	80 ad       	ldd	r24, Z+56	; 0x38
    642c:	88 23       	and	r24, r24
    642e:	91 f3       	breq	.-28     	; 0x6414 <MS_Device_USBTask+0x186>
    6430:	05 c0       	rjmp	.+10     	; 0x643c <MS_Device_USBTask+0x1ae>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    6432:	80 91 e8 00 	lds	r24, 0x00E8
    6436:	8e 77       	andi	r24, 0x7E	; 126
    6438:	80 93 e8 00 	sts	0x00E8, r24

			MS_Device_ReturnCommandStatus(MSInterfaceInfo);
		}
	}

	if (MSInterfaceInfo->State.IsMassStoreReset)
    643c:	f8 01       	movw	r30, r16
    643e:	80 ad       	ldd	r24, Z+56	; 0x38
    6440:	88 23       	and	r24, r24
    6442:	b1 f1       	breq	.+108    	; 0x64b0 <MS_Device_USBTask+0x222>
			 *  \param[in] Address  Endpoint address whose FIFO buffers are to be reset.
			 */
			static inline void Endpoint_ResetEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetEndpoint(const uint8_t Address)
			{
				UERST = (1 << (Address & ENDPOINT_EPNUM_MASK));
    6444:	26 81       	ldd	r18, Z+6	; 0x06
    6446:	2f 70       	andi	r18, 0x0F	; 15
    6448:	81 e0       	ldi	r24, 0x01	; 1
    644a:	90 e0       	ldi	r25, 0x00	; 0
    644c:	ac 01       	movw	r20, r24
    644e:	02 c0       	rjmp	.+4      	; 0x6454 <MS_Device_USBTask+0x1c6>
    6450:	44 0f       	add	r20, r20
    6452:	55 1f       	adc	r21, r21
    6454:	2a 95       	dec	r18
    6456:	e2 f7       	brpl	.-8      	; 0x6450 <MS_Device_USBTask+0x1c2>
    6458:	40 93 ea 00 	sts	0x00EA, r20
				UERST = 0;
    645c:	10 92 ea 00 	sts	0x00EA, r1
			 *  \param[in] Address  Endpoint address whose FIFO buffers are to be reset.
			 */
			static inline void Endpoint_ResetEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetEndpoint(const uint8_t Address)
			{
				UERST = (1 << (Address & ENDPOINT_EPNUM_MASK));
    6460:	21 81       	ldd	r18, Z+1	; 0x01
    6462:	2f 70       	andi	r18, 0x0F	; 15
    6464:	02 2e       	mov	r0, r18
    6466:	01 c0       	rjmp	.+2      	; 0x646a <MS_Device_USBTask+0x1dc>
    6468:	88 0f       	add	r24, r24
    646a:	0a 94       	dec	r0
    646c:	ea f7       	brpl	.-6      	; 0x6468 <MS_Device_USBTask+0x1da>
    646e:	80 93 ea 00 	sts	0x00EA, r24
				UERST = 0;
    6472:	10 92 ea 00 	sts	0x00EA, r1
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    6476:	86 81       	ldd	r24, Z+6	; 0x06
    6478:	8f 70       	andi	r24, 0x0F	; 15
    647a:	80 93 e9 00 	sts	0x00E9, r24
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearStall(void)
			{
				UECONX |= (1 << STALLRQC);
    647e:	80 91 eb 00 	lds	r24, 0x00EB
    6482:	80 61       	ori	r24, 0x10	; 16
    6484:	80 93 eb 00 	sts	0x00EB, r24

			/** Resets the data toggle of the currently selected endpoint. */
			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetDataToggle(void)
			{
				UECONX |= (1 << RSTDT);
    6488:	80 91 eb 00 	lds	r24, 0x00EB
    648c:	88 60       	ori	r24, 0x08	; 8
    648e:	80 93 eb 00 	sts	0x00EB, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    6492:	81 81       	ldd	r24, Z+1	; 0x01
    6494:	8f 70       	andi	r24, 0x0F	; 15
    6496:	80 93 e9 00 	sts	0x00E9, r24
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearStall(void)
			{
				UECONX |= (1 << STALLRQC);
    649a:	80 91 eb 00 	lds	r24, 0x00EB
    649e:	80 61       	ori	r24, 0x10	; 16
    64a0:	80 93 eb 00 	sts	0x00EB, r24

			/** Resets the data toggle of the currently selected endpoint. */
			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetDataToggle(void)
			{
				UECONX |= (1 << RSTDT);
    64a4:	80 91 eb 00 	lds	r24, 0x00EB
    64a8:	88 60       	ori	r24, 0x08	; 8
    64aa:	80 93 eb 00 	sts	0x00EB, r24
		Endpoint_ResetDataToggle();
		Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataINEndpoint.Address);
		Endpoint_ClearStall();
		Endpoint_ResetDataToggle();

		MSInterfaceInfo->State.IsMassStoreReset = false;
    64ae:	10 ae       	std	Z+56, r1	; 0x38
	}
}
    64b0:	0f 90       	pop	r0
    64b2:	0f 90       	pop	r0
    64b4:	df 91       	pop	r29
    64b6:	cf 91       	pop	r28
    64b8:	1f 91       	pop	r17
    64ba:	0f 91       	pop	r16
    64bc:	ff 90       	pop	r15
    64be:	ef 90       	pop	r14
    64c0:	08 95       	ret

000064c2 <RNDIS_Device_ProcessControlRequest>:
		CPU_TO_LE32(OID_802_3_XMIT_ONE_COLLISION),
		CPU_TO_LE32(OID_802_3_XMIT_MORE_COLLISIONS),
	};

void RNDIS_Device_ProcessControlRequest(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
    64c2:	cf 92       	push	r12
    64c4:	df 92       	push	r13
    64c6:	ef 92       	push	r14
    64c8:	ff 92       	push	r15
    64ca:	0f 93       	push	r16
    64cc:	1f 93       	push	r17
    64ce:	cf 93       	push	r28
    64d0:	df 93       	push	r29
    64d2:	8c 01       	movw	r16, r24
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    64d4:	80 91 e8 00 	lds	r24, 0x00E8
	if (!(Endpoint_IsSETUPReceived()))
    64d8:	83 ff       	sbrs	r24, 3
    64da:	62 c2       	rjmp	.+1220   	; 0x69a0 <RNDIS_Device_ProcessControlRequest+0x4de>
	  return;

	if (USB_ControlRequest.wIndex != RNDISInterfaceInfo->Config.ControlInterfaceNumber)
    64dc:	f8 01       	movw	r30, r16
    64de:	80 81       	ld	r24, Z
    64e0:	90 e0       	ldi	r25, 0x00	; 0
    64e2:	20 91 e0 0d 	lds	r18, 0x0DE0
    64e6:	30 91 e1 0d 	lds	r19, 0x0DE1
    64ea:	28 17       	cp	r18, r24
    64ec:	39 07       	cpc	r19, r25
    64ee:	09 f0       	breq	.+2      	; 0x64f2 <RNDIS_Device_ProcessControlRequest+0x30>
    64f0:	57 c2       	rjmp	.+1198   	; 0x69a0 <RNDIS_Device_ProcessControlRequest+0x4de>
	  return;

	switch (USB_ControlRequest.bRequest)
    64f2:	80 91 dd 0d 	lds	r24, 0x0DDD
    64f6:	88 23       	and	r24, r24
    64f8:	21 f0       	breq	.+8      	; 0x6502 <RNDIS_Device_ProcessControlRequest+0x40>
    64fa:	81 30       	cpi	r24, 0x01	; 1
    64fc:	09 f4       	brne	.+2      	; 0x6500 <RNDIS_Device_ProcessControlRequest+0x3e>
    64fe:	ed c1       	rjmp	.+986    	; 0x68da <RNDIS_Device_ProcessControlRequest+0x418>
    6500:	4f c2       	rjmp	.+1182   	; 0x69a0 <RNDIS_Device_ProcessControlRequest+0x4de>
	{
		case RNDIS_REQ_SendEncapsulatedCommand:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
    6502:	80 91 dc 0d 	lds	r24, 0x0DDC
    6506:	81 32       	cpi	r24, 0x21	; 33
    6508:	09 f0       	breq	.+2      	; 0x650c <RNDIS_Device_ProcessControlRequest+0x4a>
    650a:	4a c2       	rjmp	.+1172   	; 0x69a0 <RNDIS_Device_ProcessControlRequest+0x4de>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    650c:	80 91 e8 00 	lds	r24, 0x00E8
    6510:	87 7f       	andi	r24, 0xF7	; 247
    6512:	80 93 e8 00 	sts	0x00E8, r24
			{
				Endpoint_ClearSETUP();
				Endpoint_Read_Control_Stream_LE(RNDISInterfaceInfo->Config.MessageBuffer, USB_ControlRequest.wLength);
    6516:	60 91 e2 0d 	lds	r22, 0x0DE2
    651a:	70 91 e3 0d 	lds	r23, 0x0DE3
    651e:	f8 01       	movw	r30, r16
    6520:	80 8d       	ldd	r24, Z+24	; 0x18
    6522:	91 8d       	ldd	r25, Z+25	; 0x19
    6524:	0e 94 09 26 	call	0x4c12	; 0x4c12 <Endpoint_Read_Control_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    6528:	80 91 e8 00 	lds	r24, 0x00E8
    652c:	8e 77       	andi	r24, 0x7E	; 126
    652e:	80 93 e8 00 	sts	0x00E8, r24
void RNDIS_Device_ProcessRNDISControlMessage(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
	/* Note: Only a single buffer is used for both the received message and its response to save SRAM. Because of
	         this, response bytes should be filled in order so that they do not clobber unread data in the buffer. */

	RNDIS_Message_Header_t* MessageHeader = (RNDIS_Message_Header_t*)RNDISInterfaceInfo->Config.MessageBuffer;
    6532:	f8 01       	movw	r30, r16
    6534:	c0 8d       	ldd	r28, Z+24	; 0x18
    6536:	d1 8d       	ldd	r29, Z+25	; 0x19

	switch (le32_to_cpu(MessageHeader->MessageType))
    6538:	48 81       	ld	r20, Y
    653a:	59 81       	ldd	r21, Y+1	; 0x01
    653c:	6a 81       	ldd	r22, Y+2	; 0x02
    653e:	7b 81       	ldd	r23, Y+3	; 0x03
    6540:	44 30       	cpi	r20, 0x04	; 4
    6542:	51 05       	cpc	r21, r1
    6544:	61 05       	cpc	r22, r1
    6546:	71 05       	cpc	r23, r1
    6548:	09 f4       	brne	.+2      	; 0x654c <RNDIS_Device_ProcessControlRequest+0x8a>
    654a:	7b c0       	rjmp	.+246    	; 0x6642 <RNDIS_Device_ProcessControlRequest+0x180>
    654c:	98 f4       	brcc	.+38     	; 0x6574 <RNDIS_Device_ProcessControlRequest+0xb2>
    654e:	42 30       	cpi	r20, 0x02	; 2
    6550:	51 05       	cpc	r21, r1
    6552:	61 05       	cpc	r22, r1
    6554:	71 05       	cpc	r23, r1
    6556:	81 f1       	breq	.+96     	; 0x65b8 <RNDIS_Device_ProcessControlRequest+0xf6>
    6558:	43 30       	cpi	r20, 0x03	; 3
    655a:	51 05       	cpc	r21, r1
    655c:	61 05       	cpc	r22, r1
    655e:	71 05       	cpc	r23, r1
    6560:	09 f0       	breq	.+2      	; 0x6564 <RNDIS_Device_ProcessControlRequest+0xa2>
    6562:	1e c2       	rjmp	.+1084   	; 0x69a0 <RNDIS_Device_ProcessControlRequest+0x4de>
			INITIALIZE_Response->AFListSize             = CPU_TO_LE32(0);

			RNDISInterfaceInfo->State.CurrRNDISState    = RNDIS_Initialized;
			break;
		case REMOTE_NDIS_HALT_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = false;
    6564:	f8 01       	movw	r30, r16
    6566:	14 8e       	std	Z+28, r1	; 0x1c

			MessageHeader->MessageLength                = CPU_TO_LE32(0);
    6568:	1c 82       	std	Y+4, r1	; 0x04
    656a:	1d 82       	std	Y+5, r1	; 0x05
    656c:	1e 82       	std	Y+6, r1	; 0x06
    656e:	1f 82       	std	Y+7, r1	; 0x07

			RNDISInterfaceInfo->State.CurrRNDISState    = RNDIS_Uninitialized;
    6570:	15 8e       	std	Z+29, r1	; 0x1d
    6572:	16 c2       	rjmp	.+1068   	; 0x69a0 <RNDIS_Device_ProcessControlRequest+0x4de>
	/* Note: Only a single buffer is used for both the received message and its response to save SRAM. Because of
	         this, response bytes should be filled in order so that they do not clobber unread data in the buffer. */

	RNDIS_Message_Header_t* MessageHeader = (RNDIS_Message_Header_t*)RNDISInterfaceInfo->Config.MessageBuffer;

	switch (le32_to_cpu(MessageHeader->MessageType))
    6574:	46 30       	cpi	r20, 0x06	; 6
    6576:	51 05       	cpc	r21, r1
    6578:	61 05       	cpc	r22, r1
    657a:	71 05       	cpc	r23, r1
    657c:	09 f4       	brne	.+2      	; 0x6580 <RNDIS_Device_ProcessControlRequest+0xbe>
    657e:	91 c1       	rjmp	.+802    	; 0x68a2 <RNDIS_Device_ProcessControlRequest+0x3e0>
    6580:	08 f4       	brcc	.+2      	; 0x6584 <RNDIS_Device_ProcessControlRequest+0xc2>
    6582:	45 c1       	rjmp	.+650    	; 0x680e <RNDIS_Device_ProcessControlRequest+0x34c>
    6584:	48 30       	cpi	r20, 0x08	; 8
    6586:	51 05       	cpc	r21, r1
    6588:	61 05       	cpc	r22, r1
    658a:	71 05       	cpc	r23, r1
    658c:	09 f0       	breq	.+2      	; 0x6590 <RNDIS_Device_ProcessControlRequest+0xce>
    658e:	08 c2       	rjmp	.+1040   	; 0x69a0 <RNDIS_Device_ProcessControlRequest+0x4de>
			RESET_Response->Status                      = CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS);
			RESET_Response->AddressingReset             = CPU_TO_LE32(0);

			break;
		case REMOTE_NDIS_KEEPALIVE_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = true;
    6590:	81 e0       	ldi	r24, 0x01	; 1
    6592:	f8 01       	movw	r30, r16
    6594:	84 8f       	std	Z+28, r24	; 0x1c
			RNDIS_KeepAlive_Message_t*  KEEPALIVE_Message  =
			                (RNDIS_KeepAlive_Message_t*)RNDISInterfaceInfo->Config.MessageBuffer;
			RNDIS_KeepAlive_Complete_t* KEEPALIVE_Response =
			                (RNDIS_KeepAlive_Complete_t*)RNDISInterfaceInfo->Config.MessageBuffer;

			KEEPALIVE_Response->MessageType             = CPU_TO_LE32(REMOTE_NDIS_KEEPALIVE_CMPLT);
    6596:	88 e0       	ldi	r24, 0x08	; 8
    6598:	90 e0       	ldi	r25, 0x00	; 0
    659a:	a0 e0       	ldi	r26, 0x00	; 0
    659c:	b0 e8       	ldi	r27, 0x80	; 128
    659e:	88 83       	st	Y, r24
    65a0:	99 83       	std	Y+1, r25	; 0x01
    65a2:	aa 83       	std	Y+2, r26	; 0x02
    65a4:	bb 83       	std	Y+3, r27	; 0x03
			KEEPALIVE_Response->MessageLength           = CPU_TO_LE32(sizeof(RNDIS_KeepAlive_Complete_t));
    65a6:	80 e1       	ldi	r24, 0x10	; 16
    65a8:	90 e0       	ldi	r25, 0x00	; 0
    65aa:	a0 e0       	ldi	r26, 0x00	; 0
    65ac:	b0 e0       	ldi	r27, 0x00	; 0
    65ae:	8c 83       	std	Y+4, r24	; 0x04
    65b0:	9d 83       	std	Y+5, r25	; 0x05
    65b2:	ae 83       	std	Y+6, r26	; 0x06
    65b4:	bf 83       	std	Y+7, r27	; 0x07
    65b6:	8c c1       	rjmp	.+792    	; 0x68d0 <RNDIS_Device_ProcessControlRequest+0x40e>
	RNDIS_Message_Header_t* MessageHeader = (RNDIS_Message_Header_t*)RNDISInterfaceInfo->Config.MessageBuffer;

	switch (le32_to_cpu(MessageHeader->MessageType))
	{
		case REMOTE_NDIS_INITIALIZE_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = true;
    65b8:	21 e0       	ldi	r18, 0x01	; 1
    65ba:	f8 01       	movw	r30, r16
    65bc:	24 8f       	std	Z+28, r18	; 0x1c
			RNDIS_Initialize_Message_t*  INITIALIZE_Message  =
			               (RNDIS_Initialize_Message_t*)RNDISInterfaceInfo->Config.MessageBuffer;
			RNDIS_Initialize_Complete_t* INITIALIZE_Response =
			               (RNDIS_Initialize_Complete_t*)RNDISInterfaceInfo->Config.MessageBuffer;

			INITIALIZE_Response->MessageType            = CPU_TO_LE32(REMOTE_NDIS_INITIALIZE_CMPLT);
    65be:	82 e0       	ldi	r24, 0x02	; 2
    65c0:	90 e0       	ldi	r25, 0x00	; 0
    65c2:	a0 e0       	ldi	r26, 0x00	; 0
    65c4:	b0 e8       	ldi	r27, 0x80	; 128
    65c6:	88 83       	st	Y, r24
    65c8:	99 83       	std	Y+1, r25	; 0x01
    65ca:	aa 83       	std	Y+2, r26	; 0x02
    65cc:	bb 83       	std	Y+3, r27	; 0x03
			INITIALIZE_Response->MessageLength          = CPU_TO_LE32(sizeof(RNDIS_Initialize_Complete_t));
    65ce:	84 e3       	ldi	r24, 0x34	; 52
    65d0:	90 e0       	ldi	r25, 0x00	; 0
    65d2:	a0 e0       	ldi	r26, 0x00	; 0
    65d4:	b0 e0       	ldi	r27, 0x00	; 0
    65d6:	8c 83       	std	Y+4, r24	; 0x04
    65d8:	9d 83       	std	Y+5, r25	; 0x05
    65da:	ae 83       	std	Y+6, r26	; 0x06
    65dc:	bf 83       	std	Y+7, r27	; 0x07
			INITIALIZE_Response->RequestId              = INITIALIZE_Message->RequestId;
			INITIALIZE_Response->Status                 = CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS);
    65de:	1c 86       	std	Y+12, r1	; 0x0c
    65e0:	1d 86       	std	Y+13, r1	; 0x0d
    65e2:	1e 86       	std	Y+14, r1	; 0x0e
    65e4:	1f 86       	std	Y+15, r1	; 0x0f

			INITIALIZE_Response->MajorVersion           = CPU_TO_LE32(REMOTE_NDIS_VERSION_MAJOR);
    65e6:	81 e0       	ldi	r24, 0x01	; 1
    65e8:	90 e0       	ldi	r25, 0x00	; 0
    65ea:	a0 e0       	ldi	r26, 0x00	; 0
    65ec:	b0 e0       	ldi	r27, 0x00	; 0
    65ee:	88 8b       	std	Y+16, r24	; 0x10
    65f0:	99 8b       	std	Y+17, r25	; 0x11
    65f2:	aa 8b       	std	Y+18, r26	; 0x12
    65f4:	bb 8b       	std	Y+19, r27	; 0x13
			INITIALIZE_Response->MinorVersion           = CPU_TO_LE32(REMOTE_NDIS_VERSION_MINOR);
    65f6:	1c 8a       	std	Y+20, r1	; 0x14
    65f8:	1d 8a       	std	Y+21, r1	; 0x15
    65fa:	1e 8a       	std	Y+22, r1	; 0x16
    65fc:	1f 8a       	std	Y+23, r1	; 0x17
			INITIALIZE_Response->DeviceFlags            = CPU_TO_LE32(REMOTE_NDIS_DF_CONNECTIONLESS);
    65fe:	88 8f       	std	Y+24, r24	; 0x18
    6600:	99 8f       	std	Y+25, r25	; 0x19
    6602:	aa 8f       	std	Y+26, r26	; 0x1a
    6604:	bb 8f       	std	Y+27, r27	; 0x1b
			INITIALIZE_Response->Medium                 = CPU_TO_LE32(REMOTE_NDIS_MEDIUM_802_3);
    6606:	1c 8e       	std	Y+28, r1	; 0x1c
    6608:	1d 8e       	std	Y+29, r1	; 0x1d
    660a:	1e 8e       	std	Y+30, r1	; 0x1e
    660c:	1f 8e       	std	Y+31, r1	; 0x1f
			INITIALIZE_Response->MaxPacketsPerTransfer  = CPU_TO_LE32(1);
    660e:	88 a3       	std	Y+32, r24	; 0x20
    6610:	99 a3       	std	Y+33, r25	; 0x21
    6612:	aa a3       	std	Y+34, r26	; 0x22
    6614:	bb a3       	std	Y+35, r27	; 0x23
			INITIALIZE_Response->MaxTransferSize        = CPU_TO_LE32(sizeof(RNDIS_Packet_Message_t) + ETHERNET_FRAME_SIZE_MAX);
    6616:	88 e0       	ldi	r24, 0x08	; 8
    6618:	96 e0       	ldi	r25, 0x06	; 6
    661a:	a0 e0       	ldi	r26, 0x00	; 0
    661c:	b0 e0       	ldi	r27, 0x00	; 0
    661e:	8c a3       	std	Y+36, r24	; 0x24
    6620:	9d a3       	std	Y+37, r25	; 0x25
    6622:	ae a3       	std	Y+38, r26	; 0x26
    6624:	bf a3       	std	Y+39, r27	; 0x27
			INITIALIZE_Response->PacketAlignmentFactor  = CPU_TO_LE32(0);
    6626:	18 a6       	std	Y+40, r1	; 0x28
    6628:	19 a6       	std	Y+41, r1	; 0x29
    662a:	1a a6       	std	Y+42, r1	; 0x2a
    662c:	1b a6       	std	Y+43, r1	; 0x2b
			INITIALIZE_Response->AFListOffset           = CPU_TO_LE32(0);
    662e:	1c a6       	std	Y+44, r1	; 0x2c
    6630:	1d a6       	std	Y+45, r1	; 0x2d
    6632:	1e a6       	std	Y+46, r1	; 0x2e
    6634:	1f a6       	std	Y+47, r1	; 0x2f
			INITIALIZE_Response->AFListSize             = CPU_TO_LE32(0);
    6636:	18 aa       	std	Y+48, r1	; 0x30
    6638:	19 aa       	std	Y+49, r1	; 0x31
    663a:	1a aa       	std	Y+50, r1	; 0x32
    663c:	1b aa       	std	Y+51, r1	; 0x33

			RNDISInterfaceInfo->State.CurrRNDISState    = RNDIS_Initialized;
    663e:	25 8f       	std	Z+29, r18	; 0x1d
    6640:	af c1       	rjmp	.+862    	; 0x69a0 <RNDIS_Device_ProcessControlRequest+0x4de>
			MessageHeader->MessageLength                = CPU_TO_LE32(0);

			RNDISInterfaceInfo->State.CurrRNDISState    = RNDIS_Uninitialized;
			break;
		case REMOTE_NDIS_QUERY_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = true;
    6642:	81 e0       	ldi	r24, 0x01	; 1
    6644:	f8 01       	movw	r30, r16
    6646:	84 8f       	std	Z+28, r24	; 0x1c

			RNDIS_Query_Message_t*  QUERY_Message       = (RNDIS_Query_Message_t*)RNDISInterfaceInfo->Config.MessageBuffer;
			RNDIS_Query_Complete_t* QUERY_Response      = (RNDIS_Query_Complete_t*)RNDISInterfaceInfo->Config.MessageBuffer;
			uint32_t                Query_Oid           = CPU_TO_LE32(QUERY_Message->Oid);
    6648:	4c 85       	ldd	r20, Y+12	; 0x0c
    664a:	5d 85       	ldd	r21, Y+13	; 0x0d
    664c:	6e 85       	ldd	r22, Y+14	; 0x0e
    664e:	7f 85       	ldd	r23, Y+15	; 0x0f

			void*    QueryData    = &RNDISInterfaceInfo->Config.MessageBuffer[sizeof(RNDIS_Message_Header_t) +
			                                                                  le32_to_cpu(QUERY_Message->InformationBufferOffset)];
			void*    ResponseData = &RNDISInterfaceInfo->Config.MessageBuffer[sizeof(RNDIS_Query_Complete_t)];
    6650:	ce 01       	movw	r24, r28
    6652:	48 96       	adiw	r24, 0x18	; 24
			uint16_t ResponseSize;

			QUERY_Response->MessageType                 = CPU_TO_LE32(REMOTE_NDIS_QUERY_CMPLT);
    6654:	24 e0       	ldi	r18, 0x04	; 4
    6656:	c2 2e       	mov	r12, r18
    6658:	d1 2c       	mov	r13, r1
    665a:	e1 2c       	mov	r14, r1
    665c:	20 e8       	ldi	r18, 0x80	; 128
    665e:	f2 2e       	mov	r15, r18
    6660:	c8 82       	st	Y, r12
    6662:	d9 82       	std	Y+1, r13	; 0x01
    6664:	ea 82       	std	Y+2, r14	; 0x02
    6666:	fb 82       	std	Y+3, r15	; 0x03
                                          uint16_t* const ResponseSize)
{
	(void)QueryData;
	(void)QuerySize;

	switch (OId)
    6668:	4e 30       	cpi	r20, 0x0E	; 14
    666a:	f1 e0       	ldi	r31, 0x01	; 1
    666c:	5f 07       	cpc	r21, r31
    666e:	6f 07       	cpc	r22, r31
    6670:	71 05       	cpc	r23, r1
    6672:	09 f4       	brne	.+2      	; 0x6676 <RNDIS_Device_ProcessControlRequest+0x1b4>
    6674:	ba c0       	rjmp	.+372    	; 0x67ea <RNDIS_Device_ProcessControlRequest+0x328>
    6676:	08 f0       	brcs	.+2      	; 0x667a <RNDIS_Device_ProcessControlRequest+0x1b8>
    6678:	57 c0       	rjmp	.+174    	; 0x6728 <RNDIS_Device_ProcessControlRequest+0x266>
    667a:	46 30       	cpi	r20, 0x06	; 6
    667c:	e1 e0       	ldi	r30, 0x01	; 1
    667e:	5e 07       	cpc	r21, r30
    6680:	6e 07       	cpc	r22, r30
    6682:	71 05       	cpc	r23, r1
    6684:	09 f4       	brne	.+2      	; 0x6688 <RNDIS_Device_ProcessControlRequest+0x1c6>
    6686:	a7 c0       	rjmp	.+334    	; 0x67d6 <RNDIS_Device_ProcessControlRequest+0x314>
    6688:	e8 f4       	brcc	.+58     	; 0x66c4 <RNDIS_Device_ProcessControlRequest+0x202>
    668a:	42 30       	cpi	r20, 0x02	; 2
    668c:	21 e0       	ldi	r18, 0x01	; 1
    668e:	52 07       	cpc	r21, r18
    6690:	62 07       	cpc	r22, r18
    6692:	71 05       	cpc	r23, r1
    6694:	09 f4       	brne	.+2      	; 0x6698 <RNDIS_Device_ProcessControlRequest+0x1d6>
    6696:	af c0       	rjmp	.+350    	; 0x67f6 <RNDIS_Device_ProcessControlRequest+0x334>
    6698:	70 f4       	brcc	.+28     	; 0x66b6 <RNDIS_Device_ProcessControlRequest+0x1f4>
    669a:	41 30       	cpi	r20, 0x01	; 1
    669c:	51 40       	sbci	r21, 0x01	; 1
    669e:	61 40       	sbci	r22, 0x01	; 1
    66a0:	71 05       	cpc	r23, r1
    66a2:	09 f0       	breq	.+2      	; 0x66a6 <RNDIS_Device_ProcessControlRequest+0x1e4>
    66a4:	65 c1       	rjmp	.+714    	; 0x6970 <RNDIS_Device_ProcessControlRequest+0x4ae>
	{
		case OID_GEN_SUPPORTED_LIST:
			*ResponseSize = sizeof(AdapterSupportedOIDList);

			memcpy_P(ResponseData, AdapterSupportedOIDList, sizeof(AdapterSupportedOIDList));
    66a6:	4c e6       	ldi	r20, 0x6C	; 108
    66a8:	50 e0       	ldi	r21, 0x00	; 0
    66aa:	63 ea       	ldi	r22, 0xA3	; 163
    66ac:	73 e0       	ldi	r23, 0x03	; 3
    66ae:	09 d7       	rcall	.+3602   	; 0x74c2 <memcpy_P>
    66b0:	0c e6       	ldi	r16, 0x6C	; 108
	(void)QuerySize;

	switch (OId)
	{
		case OID_GEN_SUPPORTED_LIST:
			*ResponseSize = sizeof(AdapterSupportedOIDList);
    66b2:	10 e0       	ldi	r17, 0x00	; 0
    66b4:	41 c1       	rjmp	.+642    	; 0x6938 <RNDIS_Device_ProcessControlRequest+0x476>
    66b6:	45 30       	cpi	r20, 0x05	; 5
                                          uint16_t* const ResponseSize)
{
	(void)QueryData;
	(void)QuerySize;

	switch (OId)
    66b8:	51 40       	sbci	r21, 0x01	; 1
    66ba:	61 40       	sbci	r22, 0x01	; 1
    66bc:	71 05       	cpc	r23, r1
    66be:	08 f4       	brcc	.+2      	; 0x66c2 <RNDIS_Device_ProcessControlRequest+0x200>
    66c0:	9a c0       	rjmp	.+308    	; 0x67f6 <RNDIS_Device_ProcessControlRequest+0x334>
    66c2:	56 c1       	rjmp	.+684    	; 0x6970 <RNDIS_Device_ProcessControlRequest+0x4ae>
    66c4:	4c 30       	cpi	r20, 0x0C	; 12
    66c6:	e1 e0       	ldi	r30, 0x01	; 1
    66c8:	5e 07       	cpc	r21, r30
    66ca:	6e 07       	cpc	r22, r30
    66cc:	71 05       	cpc	r23, r1
    66ce:	90 f4       	brcc	.+36     	; 0x66f4 <RNDIS_Device_ProcessControlRequest+0x232>
    66d0:	4a 30       	cpi	r20, 0x0A	; 10
    66d2:	f1 e0       	ldi	r31, 0x01	; 1
    66d4:	5f 07       	cpc	r21, r31
    66d6:	6f 07       	cpc	r22, r31
    66d8:	71 05       	cpc	r23, r1
    66da:	08 f0       	brcs	.+2      	; 0x66de <RNDIS_Device_ProcessControlRequest+0x21c>
    66dc:	7c c0       	rjmp	.+248    	; 0x67d6 <RNDIS_Device_ProcessControlRequest+0x314>
    66de:	47 30       	cpi	r20, 0x07	; 7
    66e0:	51 40       	sbci	r21, 0x01	; 1
    66e2:	61 40       	sbci	r22, 0x01	; 1
    66e4:	71 05       	cpc	r23, r1
    66e6:	09 f0       	breq	.+2      	; 0x66ea <RNDIS_Device_ProcessControlRequest+0x228>
    66e8:	43 c1       	rjmp	.+646    	; 0x6970 <RNDIS_Device_ProcessControlRequest+0x4ae>
    66ea:	80 ea       	ldi	r24, 0xA0	; 160
			return true;
		case OID_GEN_LINK_SPEED:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate 10Mb/s link speed */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(100000);
    66ec:	96 e8       	ldi	r25, 0x86	; 134
    66ee:	a1 e0       	ldi	r26, 0x01	; 1
    66f0:	b0 e0       	ldi	r27, 0x00	; 0
    66f2:	86 c0       	rjmp	.+268    	; 0x6800 <RNDIS_Device_ProcessControlRequest+0x33e>
    66f4:	4c 30       	cpi	r20, 0x0C	; 12
                                          uint16_t* const ResponseSize)
{
	(void)QueryData;
	(void)QuerySize;

	switch (OId)
    66f6:	e1 e0       	ldi	r30, 0x01	; 1
    66f8:	5e 07       	cpc	r21, r30
    66fa:	6e 07       	cpc	r22, r30
    66fc:	71 05       	cpc	r23, r1
    66fe:	09 f4       	brne	.+2      	; 0x6702 <RNDIS_Device_ProcessControlRequest+0x240>
    6700:	65 c0       	rjmp	.+202    	; 0x67cc <RNDIS_Device_ProcessControlRequest+0x30a>
    6702:	4d 30       	cpi	r20, 0x0D	; 13
    6704:	51 40       	sbci	r21, 0x01	; 1
    6706:	61 40       	sbci	r22, 0x01	; 1
    6708:	71 05       	cpc	r23, r1
    670a:	09 f0       	breq	.+2      	; 0x670e <RNDIS_Device_ProcessControlRequest+0x24c>
    670c:	31 c1       	rjmp	.+610    	; 0x6970 <RNDIS_Device_ProcessControlRequest+0x4ae>
    670e:	f8 01       	movw	r30, r16

			*((uint32_t*)ResponseData) = CPU_TO_LE32(ETHERNET_FRAME_SIZE_MAX);

			return true;
		case OID_GEN_VENDOR_DESCRIPTION:
			*ResponseSize = (strlen(RNDISInterfaceInfo->Config.AdapterVendorDescription) + 1);
    6710:	60 89       	ldd	r22, Z+16	; 0x10
    6712:	71 89       	ldd	r23, Z+17	; 0x11
    6714:	fb 01       	movw	r30, r22
    6716:	01 90       	ld	r0, Z+
    6718:	00 20       	and	r0, r0
    671a:	e9 f7       	brne	.-6      	; 0x6716 <RNDIS_Device_ProcessControlRequest+0x254>
    671c:	8f 01       	movw	r16, r30
    671e:	06 1b       	sub	r16, r22
    6720:	17 0b       	sbc	r17, r23
    6722:	a8 01       	movw	r20, r16

			memcpy(ResponseData, RNDISInterfaceInfo->Config.AdapterVendorDescription, *ResponseSize);
    6724:	09 d7       	rcall	.+3602   	; 0x7538 <memcpy>
    6726:	08 c1       	rjmp	.+528    	; 0x6938 <RNDIS_Device_ProcessControlRequest+0x476>
    6728:	46 30       	cpi	r20, 0x06	; 6
    672a:	21 e0       	ldi	r18, 0x01	; 1
                                          uint16_t* const ResponseSize)
{
	(void)QueryData;
	(void)QuerySize;

	switch (OId)
    672c:	52 07       	cpc	r21, r18
    672e:	22 e0       	ldi	r18, 0x02	; 2
    6730:	62 07       	cpc	r22, r18
    6732:	71 05       	cpc	r23, r1
    6734:	28 f5       	brcc	.+74     	; 0x6780 <RNDIS_Device_ProcessControlRequest+0x2be>
    6736:	41 30       	cpi	r20, 0x01	; 1
    6738:	81 e0       	ldi	r24, 0x01	; 1
    673a:	58 07       	cpc	r21, r24
    673c:	82 e0       	ldi	r24, 0x02	; 2
    673e:	68 07       	cpc	r22, r24
    6740:	71 05       	cpc	r23, r1
    6742:	08 f0       	brcs	.+2      	; 0x6746 <RNDIS_Device_ProcessControlRequest+0x284>
    6744:	58 c0       	rjmp	.+176    	; 0x67f6 <RNDIS_Device_ProcessControlRequest+0x334>
    6746:	44 31       	cpi	r20, 0x14	; 20
    6748:	e1 e0       	ldi	r30, 0x01	; 1
    674a:	5e 07       	cpc	r21, r30
    674c:	6e 07       	cpc	r22, r30
    674e:	71 05       	cpc	r23, r1
    6750:	09 f4       	brne	.+2      	; 0x6754 <RNDIS_Device_ProcessControlRequest+0x292>
    6752:	51 c0       	rjmp	.+162    	; 0x67f6 <RNDIS_Device_ProcessControlRequest+0x334>
    6754:	42 30       	cpi	r20, 0x02	; 2
    6756:	f2 e0       	ldi	r31, 0x02	; 2
    6758:	5f 07       	cpc	r21, r31
    675a:	f1 e0       	ldi	r31, 0x01	; 1
    675c:	6f 07       	cpc	r22, r31
    675e:	71 05       	cpc	r23, r1
    6760:	09 f4       	brne	.+2      	; 0x6764 <RNDIS_Device_ProcessControlRequest+0x2a2>
    6762:	49 c0       	rjmp	.+146    	; 0x67f6 <RNDIS_Device_ProcessControlRequest+0x334>
    6764:	41 31       	cpi	r20, 0x11	; 17
    6766:	51 40       	sbci	r21, 0x01	; 1
    6768:	61 40       	sbci	r22, 0x01	; 1
    676a:	71 05       	cpc	r23, r1
    676c:	09 f0       	breq	.+2      	; 0x6770 <RNDIS_Device_ProcessControlRequest+0x2ae>
    676e:	00 c1       	rjmp	.+512    	; 0x6970 <RNDIS_Device_ProcessControlRequest+0x4ae>
    6770:	f8 01       	movw	r30, r16
    6772:	82 8d       	ldd	r24, Z+26	; 0x1a
			return true;
		case OID_GEN_MAXIMUM_TOTAL_SIZE:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate maximum overall buffer (Ethernet frame and RNDIS header) the adapter can handle */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(RNDISInterfaceInfo->Config.MessageBufferLength + ETHERNET_FRAME_SIZE_MAX);
    6774:	93 8d       	ldd	r25, Z+27	; 0x1b
    6776:	84 52       	subi	r24, 0x24	; 36
    6778:	9a 4f       	sbci	r25, 0xFA	; 250
    677a:	a0 e0       	ldi	r26, 0x00	; 0
    677c:	b0 e0       	ldi	r27, 0x00	; 0
    677e:	40 c0       	rjmp	.+128    	; 0x6800 <RNDIS_Device_ProcessControlRequest+0x33e>
    6780:	44 30       	cpi	r20, 0x04	; 4
    6782:	e1 e0       	ldi	r30, 0x01	; 1
                                          uint16_t* const ResponseSize)
{
	(void)QueryData;
	(void)QuerySize;

	switch (OId)
    6784:	5e 07       	cpc	r21, r30
    6786:	6e 07       	cpc	r22, r30
    6788:	7e 07       	cpc	r23, r30
    678a:	51 f1       	breq	.+84     	; 0x67e0 <RNDIS_Device_ProcessControlRequest+0x31e>
    678c:	a8 f4       	brcc	.+42     	; 0x67b8 <RNDIS_Device_ProcessControlRequest+0x2f6>
    678e:	41 50       	subi	r20, 0x01	; 1
    6790:	51 40       	sbci	r21, 0x01	; 1
    6792:	61 40       	sbci	r22, 0x01	; 1
    6794:	71 40       	sbci	r23, 0x01	; 1
    6796:	42 30       	cpi	r20, 0x02	; 2
    6798:	51 05       	cpc	r21, r1
    679a:	61 05       	cpc	r22, r1
    679c:	71 05       	cpc	r23, r1
    679e:	08 f0       	brcs	.+2      	; 0x67a2 <RNDIS_Device_ProcessControlRequest+0x2e0>
    67a0:	e7 c0       	rjmp	.+462    	; 0x6970 <RNDIS_Device_ProcessControlRequest+0x4ae>
    67a2:	f8 01       	movw	r30, r16
    67a4:	72 96       	adiw	r30, 0x12	; 18
			return true;
		case OID_802_3_PERMANENT_ADDRESS:
		case OID_802_3_CURRENT_ADDRESS:
			*ResponseSize = sizeof(MAC_Address_t);

			memcpy(ResponseData, &RNDISInterfaceInfo->Config.AdapterMACAddress, sizeof(MAC_Address_t));
    67a6:	26 e0       	ldi	r18, 0x06	; 6
    67a8:	dc 01       	movw	r26, r24
    67aa:	01 90       	ld	r0, Z+
    67ac:	0d 92       	st	X+, r0
    67ae:	2a 95       	dec	r18
    67b0:	e1 f7       	brne	.-8      	; 0x67aa <RNDIS_Device_ProcessControlRequest+0x2e8>
    67b2:	06 e0       	ldi	r16, 0x06	; 6
    67b4:	10 e0       	ldi	r17, 0x00	; 0
			*((uint32_t*)ResponseData) = CPU_TO_LE32(100000);

			return true;
		case OID_802_3_PERMANENT_ADDRESS:
		case OID_802_3_CURRENT_ADDRESS:
			*ResponseSize = sizeof(MAC_Address_t);
    67b6:	c0 c0       	rjmp	.+384    	; 0x6938 <RNDIS_Device_ProcessControlRequest+0x476>
    67b8:	41 50       	subi	r20, 0x01	; 1
    67ba:	51 40       	sbci	r21, 0x01	; 1
                                          uint16_t* const ResponseSize)
{
	(void)QueryData;
	(void)QuerySize;

	switch (OId)
    67bc:	62 40       	sbci	r22, 0x02	; 2
    67be:	71 40       	sbci	r23, 0x01	; 1
    67c0:	43 30       	cpi	r20, 0x03	; 3
    67c2:	51 05       	cpc	r21, r1
    67c4:	61 05       	cpc	r22, r1
    67c6:	71 05       	cpc	r23, r1
    67c8:	b0 f0       	brcs	.+44     	; 0x67f6 <RNDIS_Device_ProcessControlRequest+0x334>
    67ca:	d2 c0       	rjmp	.+420    	; 0x6970 <RNDIS_Device_ProcessControlRequest+0x4ae>
    67cc:	8f ef       	ldi	r24, 0xFF	; 255
    67ce:	9f ef       	ldi	r25, 0xFF	; 255
			return true;
		case OID_GEN_VENDOR_ID:
			*ResponseSize = sizeof(uint32_t);

			/* Vendor ID 0x0xFFFFFF is reserved for vendors who have not purchased a NDIS VID */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(0x00FFFFFF);
    67d0:	af ef       	ldi	r26, 0xFF	; 255
    67d2:	b0 e0       	ldi	r27, 0x00	; 0
    67d4:	15 c0       	rjmp	.+42     	; 0x6800 <RNDIS_Device_ProcessControlRequest+0x33e>
    67d6:	8c ed       	ldi	r24, 0xDC	; 220
    67d8:	95 e0       	ldi	r25, 0x05	; 5
		case OID_GEN_MAXIMUM_FRAME_SIZE:
		case OID_GEN_TRANSMIT_BLOCK_SIZE:
		case OID_GEN_RECEIVE_BLOCK_SIZE:
			*ResponseSize = sizeof(uint32_t);

			*((uint32_t*)ResponseData) = CPU_TO_LE32(ETHERNET_FRAME_SIZE_MAX);
    67da:	a0 e0       	ldi	r26, 0x00	; 0
    67dc:	b0 e0       	ldi	r27, 0x00	; 0
    67de:	10 c0       	rjmp	.+32     	; 0x6800 <RNDIS_Device_ProcessControlRequest+0x33e>
    67e0:	81 e0       	ldi	r24, 0x01	; 1
    67e2:	90 e0       	ldi	r25, 0x00	; 0
			return true;
		case OID_802_3_MAXIMUM_LIST_SIZE:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate only one multicast address supported */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(1);
    67e4:	a0 e0       	ldi	r26, 0x00	; 0
    67e6:	b0 e0       	ldi	r27, 0x00	; 0
    67e8:	0b c0       	rjmp	.+22     	; 0x6800 <RNDIS_Device_ProcessControlRequest+0x33e>
    67ea:	f8 01       	movw	r30, r16
    67ec:	86 8d       	ldd	r24, Z+30	; 0x1e

			return true;
		case OID_GEN_CURRENT_PACKET_FILTER:
			*ResponseSize = sizeof(uint32_t);

			*((uint32_t*)ResponseData) = cpu_to_le32(RNDISInterfaceInfo->State.CurrPacketFilter);
    67ee:	97 8d       	ldd	r25, Z+31	; 0x1f
    67f0:	a0 a1       	ldd	r26, Z+32	; 0x20
    67f2:	b1 a1       	ldd	r27, Z+33	; 0x21
    67f4:	05 c0       	rjmp	.+10     	; 0x6800 <RNDIS_Device_ProcessControlRequest+0x33e>
    67f6:	18 8e       	std	Y+24, r1	; 0x18
    67f8:	19 8e       	std	Y+25, r1	; 0x19
		case OID_802_3_XMIT_ONE_COLLISION:
		case OID_802_3_XMIT_MORE_COLLISIONS:
			*ResponseSize = sizeof(uint32_t);

			/* Unused statistic OIDs - always return 0 for each */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(0);
    67fa:	1a 8e       	std	Y+26, r1	; 0x1a
    67fc:	1b 8e       	std	Y+27, r1	; 0x1b
    67fe:	04 c0       	rjmp	.+8      	; 0x6808 <RNDIS_Device_ProcessControlRequest+0x346>
    6800:	88 8f       	std	Y+24, r24	; 0x18
    6802:	99 8f       	std	Y+25, r25	; 0x19
			return true;
		case OID_GEN_MAXIMUM_TOTAL_SIZE:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate maximum overall buffer (Ethernet frame and RNDIS header) the adapter can handle */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(RNDISInterfaceInfo->Config.MessageBufferLength + ETHERNET_FRAME_SIZE_MAX);
    6804:	aa 8f       	std	Y+26, r26	; 0x1a
    6806:	bb 8f       	std	Y+27, r27	; 0x1b
    6808:	04 e0       	ldi	r16, 0x04	; 4
    680a:	10 e0       	ldi	r17, 0x00	; 0
			/* Unused statistic OIDs - always return 0 for each */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(0);

			return true;
		case OID_GEN_MAXIMUM_TOTAL_SIZE:
			*ResponseSize = sizeof(uint32_t);
    680c:	95 c0       	rjmp	.+298    	; 0x6938 <RNDIS_Device_ProcessControlRequest+0x476>
    680e:	81 e0       	ldi	r24, 0x01	; 1
    6810:	f8 01       	movw	r30, r16
				QUERY_Response->InformationBufferOffset = CPU_TO_LE32(0);
			}

			break;
		case REMOTE_NDIS_SET_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = true;
    6812:	84 8f       	std	Z+28, r24	; 0x1c
    6814:	8c 85       	ldd	r24, Y+12	; 0x0c
    6816:	9d 85       	ldd	r25, Y+13	; 0x0d

			RNDIS_Set_Message_t*  SET_Message           = (RNDIS_Set_Message_t*)RNDISInterfaceInfo->Config.MessageBuffer;
			RNDIS_Set_Complete_t* SET_Response          = (RNDIS_Set_Complete_t*)RNDISInterfaceInfo->Config.MessageBuffer;
			uint32_t              SET_Oid               = le32_to_cpu(SET_Message->Oid);
    6818:	ae 85       	ldd	r26, Y+14	; 0x0e
    681a:	bf 85       	ldd	r27, Y+15	; 0x0f
    681c:	45 e0       	ldi	r20, 0x05	; 5
    681e:	50 e0       	ldi	r21, 0x00	; 0

			SET_Response->MessageType                   = CPU_TO_LE32(REMOTE_NDIS_SET_CMPLT);
    6820:	60 e0       	ldi	r22, 0x00	; 0
    6822:	70 e8       	ldi	r23, 0x80	; 128
    6824:	48 83       	st	Y, r20
    6826:	59 83       	std	Y+1, r21	; 0x01
    6828:	6a 83       	std	Y+2, r22	; 0x02
    682a:	7b 83       	std	Y+3, r23	; 0x03
    682c:	40 e1       	ldi	r20, 0x10	; 16
    682e:	50 e0       	ldi	r21, 0x00	; 0
			SET_Response->MessageLength                 = CPU_TO_LE32(sizeof(RNDIS_Set_Complete_t));
    6830:	60 e0       	ldi	r22, 0x00	; 0
    6832:	70 e0       	ldi	r23, 0x00	; 0
    6834:	4c 83       	std	Y+4, r20	; 0x04
    6836:	5d 83       	std	Y+5, r21	; 0x05
    6838:	6e 83       	std	Y+6, r22	; 0x06
    683a:	7f 83       	std	Y+7, r23	; 0x07
    683c:	20 8d       	ldd	r18, Z+24	; 0x18
    683e:	31 8d       	ldd	r19, Z+25	; 0x19
			SET_Response->RequestId                     = SET_Message->RequestId;

			void* SetData = &RNDISInterfaceInfo->Config.MessageBuffer[sizeof(RNDIS_Message_Header_t) +
    6840:	4c 89       	ldd	r20, Y+20	; 0x14
    6842:	5d 89       	ldd	r21, Y+21	; 0x15
			                                                              le32_to_cpu(SET_Message->InformationBufferOffset)];
    6844:	6e 89       	ldd	r22, Y+22	; 0x16
    6846:	7f 89       	ldd	r23, Y+23	; 0x17
    6848:	8e 30       	cpi	r24, 0x0E	; 14
    684a:	f1 e0       	ldi	r31, 0x01	; 1
                                        const void* SetData,
                                        const uint16_t SetSize)
{
	(void)SetSize;

	switch (OId)
    684c:	9f 07       	cpc	r25, r31
    684e:	af 07       	cpc	r26, r31
    6850:	b1 05       	cpc	r27, r1
    6852:	51 f0       	breq	.+20     	; 0x6868 <RNDIS_Device_ProcessControlRequest+0x3a6>
    6854:	83 30       	cpi	r24, 0x03	; 3
    6856:	91 40       	sbci	r25, 0x01	; 1
    6858:	a1 40       	sbci	r26, 0x01	; 1
    685a:	b1 40       	sbci	r27, 0x01	; 1
    685c:	d1 f0       	breq	.+52     	; 0x6892 <RNDIS_Device_ProcessControlRequest+0x3d0>
    685e:	8b eb       	ldi	r24, 0xBB	; 187
    6860:	90 e0       	ldi	r25, 0x00	; 0
			void* SetData = &RNDISInterfaceInfo->Config.MessageBuffer[sizeof(RNDIS_Message_Header_t) +
			                                                              le32_to_cpu(SET_Message->InformationBufferOffset)];

			SET_Response->Status = RNDIS_Device_ProcessNDISSet(RNDISInterfaceInfo, SET_Oid, SetData,
			                                                   le32_to_cpu(SET_Message->InformationBufferLength)) ?
			                                                   REMOTE_NDIS_STATUS_SUCCESS : REMOTE_NDIS_STATUS_NOT_SUPPORTED;
    6862:	a0 e0       	ldi	r26, 0x00	; 0
    6864:	b0 ec       	ldi	r27, 0xC0	; 192
    6866:	18 c0       	rjmp	.+48     	; 0x6898 <RNDIS_Device_ProcessControlRequest+0x3d6>
    6868:	f9 01       	movw	r30, r18
    686a:	e4 0f       	add	r30, r20
	(void)SetSize;

	switch (OId)
	{
		case OID_GEN_CURRENT_PACKET_FILTER:
			RNDISInterfaceInfo->State.CurrPacketFilter = le32_to_cpu(*((uint32_t*)SetData));
    686c:	f5 1f       	adc	r31, r21
    686e:	80 85       	ldd	r24, Z+8	; 0x08
    6870:	91 85       	ldd	r25, Z+9	; 0x09
    6872:	a2 85       	ldd	r26, Z+10	; 0x0a
    6874:	b3 85       	ldd	r27, Z+11	; 0x0b
    6876:	f8 01       	movw	r30, r16
    6878:	86 8f       	std	Z+30, r24	; 0x1e
    687a:	97 8f       	std	Z+31, r25	; 0x1f
    687c:	a0 a3       	std	Z+32, r26	; 0x20
    687e:	b1 a3       	std	Z+33, r27	; 0x21
    6880:	89 2b       	or	r24, r25
    6882:	8a 2b       	or	r24, r26
			RNDISInterfaceInfo->State.CurrRNDISState   = (RNDISInterfaceInfo->State.CurrPacketFilter) ? RNDIS_Data_Initialized : RNDIS_Initialized;
    6884:	8b 2b       	or	r24, r27
    6886:	11 f0       	breq	.+4      	; 0x688c <RNDIS_Device_ProcessControlRequest+0x3ca>
    6888:	82 e0       	ldi	r24, 0x02	; 2
    688a:	01 c0       	rjmp	.+2      	; 0x688e <RNDIS_Device_ProcessControlRequest+0x3cc>
    688c:	81 e0       	ldi	r24, 0x01	; 1
    688e:	f8 01       	movw	r30, r16
    6890:	85 8f       	std	Z+29, r24	; 0x1d
    6892:	80 e0       	ldi	r24, 0x00	; 0
    6894:	90 e0       	ldi	r25, 0x00	; 0
			void* SetData = &RNDISInterfaceInfo->Config.MessageBuffer[sizeof(RNDIS_Message_Header_t) +
			                                                              le32_to_cpu(SET_Message->InformationBufferOffset)];

			SET_Response->Status = RNDIS_Device_ProcessNDISSet(RNDISInterfaceInfo, SET_Oid, SetData,
			                                                   le32_to_cpu(SET_Message->InformationBufferLength)) ?
			                                                   REMOTE_NDIS_STATUS_SUCCESS : REMOTE_NDIS_STATUS_NOT_SUPPORTED;
    6896:	dc 01       	movw	r26, r24
    6898:	8c 87       	std	Y+12, r24	; 0x0c
    689a:	9d 87       	std	Y+13, r25	; 0x0d
			SET_Response->RequestId                     = SET_Message->RequestId;

			void* SetData = &RNDISInterfaceInfo->Config.MessageBuffer[sizeof(RNDIS_Message_Header_t) +
			                                                              le32_to_cpu(SET_Message->InformationBufferOffset)];

			SET_Response->Status = RNDIS_Device_ProcessNDISSet(RNDISInterfaceInfo, SET_Oid, SetData,
    689c:	ae 87       	std	Y+14, r26	; 0x0e
    689e:	bf 87       	std	Y+15, r27	; 0x0f
    68a0:	7f c0       	rjmp	.+254    	; 0x69a0 <RNDIS_Device_ProcessControlRequest+0x4de>
    68a2:	81 e0       	ldi	r24, 0x01	; 1
    68a4:	f8 01       	movw	r30, r16
			                                                   le32_to_cpu(SET_Message->InformationBufferLength)) ?
			                                                   REMOTE_NDIS_STATUS_SUCCESS : REMOTE_NDIS_STATUS_NOT_SUPPORTED;
			break;
		case REMOTE_NDIS_RESET_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = true;
    68a6:	84 8f       	std	Z+28, r24	; 0x1c
    68a8:	86 e0       	ldi	r24, 0x06	; 6
    68aa:	90 e0       	ldi	r25, 0x00	; 0

			RNDIS_Reset_Complete_t* RESET_Response      = (RNDIS_Reset_Complete_t*)RNDISInterfaceInfo->Config.MessageBuffer;

			RESET_Response->MessageType                 = CPU_TO_LE32(REMOTE_NDIS_RESET_CMPLT);
    68ac:	a0 e0       	ldi	r26, 0x00	; 0
    68ae:	b0 e8       	ldi	r27, 0x80	; 128
    68b0:	88 83       	st	Y, r24
    68b2:	99 83       	std	Y+1, r25	; 0x01
    68b4:	aa 83       	std	Y+2, r26	; 0x02
    68b6:	bb 83       	std	Y+3, r27	; 0x03
    68b8:	80 e1       	ldi	r24, 0x10	; 16
    68ba:	90 e0       	ldi	r25, 0x00	; 0
			RESET_Response->MessageLength               = CPU_TO_LE32(sizeof(RNDIS_Reset_Complete_t));
    68bc:	a0 e0       	ldi	r26, 0x00	; 0
    68be:	b0 e0       	ldi	r27, 0x00	; 0
    68c0:	8c 83       	std	Y+4, r24	; 0x04
    68c2:	9d 83       	std	Y+5, r25	; 0x05
    68c4:	ae 83       	std	Y+6, r26	; 0x06
    68c6:	bf 83       	std	Y+7, r27	; 0x07
    68c8:	18 86       	std	Y+8, r1	; 0x08
    68ca:	19 86       	std	Y+9, r1	; 0x09
			RESET_Response->Status                      = CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS);
    68cc:	1a 86       	std	Y+10, r1	; 0x0a
    68ce:	1b 86       	std	Y+11, r1	; 0x0b
    68d0:	1c 86       	std	Y+12, r1	; 0x0c
    68d2:	1d 86       	std	Y+13, r1	; 0x0d
			                (RNDIS_KeepAlive_Complete_t*)RNDISInterfaceInfo->Config.MessageBuffer;

			KEEPALIVE_Response->MessageType             = CPU_TO_LE32(REMOTE_NDIS_KEEPALIVE_CMPLT);
			KEEPALIVE_Response->MessageLength           = CPU_TO_LE32(sizeof(RNDIS_KeepAlive_Complete_t));
			KEEPALIVE_Response->RequestId               = KEEPALIVE_Message->RequestId;
			KEEPALIVE_Response->Status                  = CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS);
    68d4:	1e 86       	std	Y+14, r1	; 0x0e
    68d6:	1f 86       	std	Y+15, r1	; 0x0f
    68d8:	63 c0       	rjmp	.+198    	; 0x69a0 <RNDIS_Device_ProcessControlRequest+0x4de>
    68da:	80 91 dc 0d 	lds	r24, 0x0DDC
				RNDIS_Device_ProcessRNDISControlMessage(RNDISInterfaceInfo);
			}

			break;
		case RNDIS_REQ_GetEncapsulatedResponse:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
    68de:	81 3a       	cpi	r24, 0xA1	; 161
    68e0:	09 f0       	breq	.+2      	; 0x68e4 <RNDIS_Device_ProcessControlRequest+0x422>
    68e2:	5e c0       	rjmp	.+188    	; 0x69a0 <RNDIS_Device_ProcessControlRequest+0x4de>
    68e4:	f8 01       	movw	r30, r16
    68e6:	c0 8d       	ldd	r28, Z+24	; 0x18
			{
				RNDIS_Message_Header_t* MessageHeader = (RNDIS_Message_Header_t*)RNDISInterfaceInfo->Config.MessageBuffer;
    68e8:	d1 8d       	ldd	r29, Z+25	; 0x19
    68ea:	8c 81       	ldd	r24, Y+4	; 0x04
    68ec:	9d 81       	ldd	r25, Y+5	; 0x05

				if (!(MessageHeader->MessageLength))
    68ee:	ae 81       	ldd	r26, Y+6	; 0x06
    68f0:	bf 81       	ldd	r27, Y+7	; 0x07
    68f2:	89 2b       	or	r24, r25
    68f4:	8a 2b       	or	r24, r26
    68f6:	8b 2b       	or	r24, r27
    68f8:	49 f4       	brne	.+18     	; 0x690c <RNDIS_Device_ProcessControlRequest+0x44a>
    68fa:	18 82       	st	Y, r1
    68fc:	81 e0       	ldi	r24, 0x01	; 1
				{
					RNDISInterfaceInfo->Config.MessageBuffer[0] = 0;
    68fe:	90 e0       	ldi	r25, 0x00	; 0
					MessageHeader->MessageLength                = CPU_TO_LE32(1);
    6900:	a0 e0       	ldi	r26, 0x00	; 0
    6902:	b0 e0       	ldi	r27, 0x00	; 0
    6904:	8c 83       	std	Y+4, r24	; 0x04
    6906:	9d 83       	std	Y+5, r25	; 0x05
    6908:	ae 83       	std	Y+6, r26	; 0x06
    690a:	bf 83       	std	Y+7, r27	; 0x07
    690c:	80 91 e8 00 	lds	r24, 0x00E8
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    6910:	87 7f       	andi	r24, 0xF7	; 247
    6912:	80 93 e8 00 	sts	0x00E8, r24
    6916:	6c 81       	ldd	r22, Y+4	; 0x04
    6918:	7d 81       	ldd	r23, Y+5	; 0x05
				}

				Endpoint_ClearSETUP();
				Endpoint_Write_Control_Stream_LE(RNDISInterfaceInfo->Config.MessageBuffer, le32_to_cpu(MessageHeader->MessageLength));
    691a:	f8 01       	movw	r30, r16
    691c:	80 8d       	ldd	r24, Z+24	; 0x18
    691e:	91 8d       	ldd	r25, Z+25	; 0x19
    6920:	0e 94 ae 25 	call	0x4b5c	; 0x4b5c <Endpoint_Write_Control_Stream_LE>
    6924:	80 91 e8 00 	lds	r24, 0x00E8
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    6928:	8b 77       	andi	r24, 0x7B	; 123
    692a:	80 93 e8 00 	sts	0x00E8, r24
    692e:	1c 82       	std	Y+4, r1	; 0x04
    6930:	1d 82       	std	Y+5, r1	; 0x05
				Endpoint_ClearOUT();

				MessageHeader->MessageLength = CPU_TO_LE32(0);
    6932:	1e 82       	std	Y+6, r1	; 0x06
    6934:	1f 82       	std	Y+7, r1	; 0x07
    6936:	34 c0       	rjmp	.+104    	; 0x69a0 <RNDIS_Device_ProcessControlRequest+0x4de>
    6938:	1c 86       	std	Y+12, r1	; 0x0c
    693a:	1d 86       	std	Y+13, r1	; 0x0d
			QUERY_Response->MessageType                 = CPU_TO_LE32(REMOTE_NDIS_QUERY_CMPLT);

			if (RNDIS_Device_ProcessNDISQuery(RNDISInterfaceInfo, Query_Oid, QueryData, le32_to_cpu(QUERY_Message->InformationBufferLength),
			                                  ResponseData, &ResponseSize))
			{
				QUERY_Response->Status                  = CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS);
    693c:	1e 86       	std	Y+14, r1	; 0x0e
    693e:	1f 86       	std	Y+15, r1	; 0x0f
    6940:	c8 01       	movw	r24, r16
    6942:	48 96       	adiw	r24, 0x18	; 24
				QUERY_Response->MessageLength           = cpu_to_le32(sizeof(RNDIS_Query_Complete_t) + ResponseSize);
    6944:	a0 e0       	ldi	r26, 0x00	; 0
    6946:	b0 e0       	ldi	r27, 0x00	; 0
    6948:	8c 83       	std	Y+4, r24	; 0x04
    694a:	9d 83       	std	Y+5, r25	; 0x05
    694c:	ae 83       	std	Y+6, r26	; 0x06
    694e:	bf 83       	std	Y+7, r27	; 0x07
    6950:	a8 01       	movw	r20, r16
    6952:	60 e0       	ldi	r22, 0x00	; 0

				QUERY_Response->InformationBufferLength = CPU_TO_LE32(ResponseSize);
    6954:	70 e0       	ldi	r23, 0x00	; 0
    6956:	48 8b       	std	Y+16, r20	; 0x10
    6958:	59 8b       	std	Y+17, r21	; 0x11
    695a:	6a 8b       	std	Y+18, r22	; 0x12
    695c:	7b 8b       	std	Y+19, r23	; 0x13
    695e:	80 e1       	ldi	r24, 0x10	; 16
    6960:	90 e0       	ldi	r25, 0x00	; 0
				QUERY_Response->InformationBufferOffset = CPU_TO_LE32(sizeof(RNDIS_Query_Complete_t) - sizeof(RNDIS_Message_Header_t));
    6962:	a0 e0       	ldi	r26, 0x00	; 0
    6964:	b0 e0       	ldi	r27, 0x00	; 0
    6966:	8c 8b       	std	Y+20, r24	; 0x14
    6968:	9d 8b       	std	Y+21, r25	; 0x15
    696a:	ae 8b       	std	Y+22, r26	; 0x16
    696c:	bf 8b       	std	Y+23, r27	; 0x17
    696e:	18 c0       	rjmp	.+48     	; 0x69a0 <RNDIS_Device_ProcessControlRequest+0x4de>
    6970:	8b eb       	ldi	r24, 0xBB	; 187
    6972:	90 e0       	ldi	r25, 0x00	; 0
			}
			else
			{
				QUERY_Response->Status                  = CPU_TO_LE32(REMOTE_NDIS_STATUS_NOT_SUPPORTED);
    6974:	a0 e0       	ldi	r26, 0x00	; 0
    6976:	b0 ec       	ldi	r27, 0xC0	; 192
    6978:	8c 87       	std	Y+12, r24	; 0x0c
    697a:	9d 87       	std	Y+13, r25	; 0x0d
    697c:	ae 87       	std	Y+14, r26	; 0x0e
    697e:	bf 87       	std	Y+15, r27	; 0x0f
    6980:	88 e1       	ldi	r24, 0x18	; 24
    6982:	90 e0       	ldi	r25, 0x00	; 0
				QUERY_Response->MessageLength           = CPU_TO_LE32(sizeof(RNDIS_Query_Complete_t));
    6984:	a0 e0       	ldi	r26, 0x00	; 0
    6986:	b0 e0       	ldi	r27, 0x00	; 0
    6988:	8c 83       	std	Y+4, r24	; 0x04
    698a:	9d 83       	std	Y+5, r25	; 0x05
    698c:	ae 83       	std	Y+6, r26	; 0x06
    698e:	bf 83       	std	Y+7, r27	; 0x07
    6990:	18 8a       	std	Y+16, r1	; 0x10
    6992:	19 8a       	std	Y+17, r1	; 0x11

				QUERY_Response->InformationBufferLength = CPU_TO_LE32(0);
    6994:	1a 8a       	std	Y+18, r1	; 0x12
    6996:	1b 8a       	std	Y+19, r1	; 0x13
    6998:	1c 8a       	std	Y+20, r1	; 0x14
    699a:	1d 8a       	std	Y+21, r1	; 0x15
				QUERY_Response->InformationBufferOffset = CPU_TO_LE32(0);
    699c:	1e 8a       	std	Y+22, r1	; 0x16
    699e:	1f 8a       	std	Y+23, r1	; 0x17
    69a0:	df 91       	pop	r29
    69a2:	cf 91       	pop	r28
				MessageHeader->MessageLength = CPU_TO_LE32(0);
			}

			break;
	}
}
    69a4:	1f 91       	pop	r17
    69a6:	0f 91       	pop	r16
    69a8:	ff 90       	pop	r15
    69aa:	ef 90       	pop	r14
    69ac:	df 90       	pop	r13
    69ae:	cf 90       	pop	r12
    69b0:	08 95       	ret

000069b2 <RNDIS_Device_ConfigureEndpoints>:
    69b2:	cf 93       	push	r28
    69b4:	df 93       	push	r29

bool RNDIS_Device_ConfigureEndpoints(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
    69b6:	ec 01       	movw	r28, r24
	memset(&RNDISInterfaceInfo->State, 0x00, sizeof(RNDISInterfaceInfo->State));
    69b8:	fc 01       	movw	r30, r24
    69ba:	7c 96       	adiw	r30, 0x1c	; 28
    69bc:	86 e0       	ldi	r24, 0x06	; 6
    69be:	df 01       	movw	r26, r30
    69c0:	1d 92       	st	X+, r1
    69c2:	8a 95       	dec	r24
    69c4:	e9 f7       	brne	.-6      	; 0x69c0 <RNDIS_Device_ConfigureEndpoints+0xe>

	RNDISInterfaceInfo->Config.DataINEndpoint.Type       = EP_TYPE_BULK;
    69c6:	82 e0       	ldi	r24, 0x02	; 2
    69c8:	8c 83       	std	Y+4, r24	; 0x04
	RNDISInterfaceInfo->Config.DataOUTEndpoint.Type      = EP_TYPE_BULK;
    69ca:	89 87       	std	Y+9, r24	; 0x09
	RNDISInterfaceInfo->Config.NotificationEndpoint.Type = EP_TYPE_INTERRUPT;
    69cc:	83 e0       	ldi	r24, 0x03	; 3
    69ce:	8e 87       	std	Y+14, r24	; 0x0e

	if (RNDISInterfaceInfo->Config.MessageBuffer == NULL)
    69d0:	88 8d       	ldd	r24, Y+24	; 0x18
    69d2:	99 8d       	ldd	r25, Y+25	; 0x19
    69d4:	89 2b       	or	r24, r25
    69d6:	d1 f0       	breq	.+52     	; 0x6a0c <RNDIS_Device_ConfigureEndpoints+0x5a>
	  return false;

	if (RNDISInterfaceInfo->Config.MessageBufferLength < RNDIS_DEVICE_MIN_MESSAGE_BUFFER_LENGTH)
    69d8:	8a 8d       	ldd	r24, Y+26	; 0x1a
    69da:	9b 8d       	ldd	r25, Y+27	; 0x1b
    69dc:	84 38       	cpi	r24, 0x84	; 132
    69de:	91 05       	cpc	r25, r1
    69e0:	a8 f0       	brcs	.+42     	; 0x6a0c <RNDIS_Device_ConfigureEndpoints+0x5a>
	  return false;

	if (!(Endpoint_ConfigureEndpointTable(&RNDISInterfaceInfo->Config.DataINEndpoint, 1)))
    69e2:	61 e0       	ldi	r22, 0x01	; 1
    69e4:	ce 01       	movw	r24, r28
    69e6:	01 96       	adiw	r24, 0x01	; 1
    69e8:	0e 94 d8 26 	call	0x4db0	; 0x4db0 <Endpoint_ConfigureEndpointTable>
    69ec:	88 23       	and	r24, r24
    69ee:	71 f0       	breq	.+28     	; 0x6a0c <RNDIS_Device_ConfigureEndpoints+0x5a>
	  return false;

	if (!(Endpoint_ConfigureEndpointTable(&RNDISInterfaceInfo->Config.DataOUTEndpoint, 1)))
    69f0:	61 e0       	ldi	r22, 0x01	; 1
    69f2:	ce 01       	movw	r24, r28
    69f4:	06 96       	adiw	r24, 0x06	; 6
    69f6:	0e 94 d8 26 	call	0x4db0	; 0x4db0 <Endpoint_ConfigureEndpointTable>
    69fa:	88 23       	and	r24, r24
    69fc:	39 f0       	breq	.+14     	; 0x6a0c <RNDIS_Device_ConfigureEndpoints+0x5a>
	  return false;

	if (!(Endpoint_ConfigureEndpointTable(&RNDISInterfaceInfo->Config.NotificationEndpoint, 1)))
    69fe:	61 e0       	ldi	r22, 0x01	; 1
    6a00:	ce 01       	movw	r24, r28
    6a02:	0b 96       	adiw	r24, 0x0b	; 11
	  return false;

	return true;
}
    6a04:	df 91       	pop	r29
    6a06:	cf 91       	pop	r28
	  return false;

	if (!(Endpoint_ConfigureEndpointTable(&RNDISInterfaceInfo->Config.DataOUTEndpoint, 1)))
	  return false;

	if (!(Endpoint_ConfigureEndpointTable(&RNDISInterfaceInfo->Config.NotificationEndpoint, 1)))
    6a08:	0c 94 d8 26 	jmp	0x4db0	; 0x4db0 <Endpoint_ConfigureEndpointTable>
	  return false;

	return true;
}
    6a0c:	80 e0       	ldi	r24, 0x00	; 0
    6a0e:	df 91       	pop	r29
    6a10:	cf 91       	pop	r28
    6a12:	08 95       	ret

00006a14 <RNDIS_Device_USBTask>:

void RNDIS_Device_USBTask(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
    6a14:	0f 93       	push	r16
    6a16:	1f 93       	push	r17
    6a18:	cf 93       	push	r28
    6a1a:	df 93       	push	r29
    6a1c:	cd b7       	in	r28, 0x3d	; 61
    6a1e:	de b7       	in	r29, 0x3e	; 62
    6a20:	28 97       	sbiw	r28, 0x08	; 8
    6a22:	0f b6       	in	r0, 0x3f	; 63
    6a24:	f8 94       	cli
    6a26:	de bf       	out	0x3e, r29	; 62
    6a28:	0f be       	out	0x3f, r0	; 63
    6a2a:	cd bf       	out	0x3d, r28	; 61
    6a2c:	8c 01       	movw	r16, r24
	if (USB_DeviceState != DEVICE_STATE_Configured)
    6a2e:	8e b3       	in	r24, 0x1e	; 30
    6a30:	84 30       	cpi	r24, 0x04	; 4
    6a32:	21 f5       	brne	.+72     	; 0x6a7c <RNDIS_Device_USBTask+0x68>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    6a34:	f8 01       	movw	r30, r16
    6a36:	83 85       	ldd	r24, Z+11	; 0x0b
    6a38:	8f 70       	andi	r24, 0x0F	; 15
    6a3a:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    6a3e:	80 91 e8 00 	lds	r24, 0x00E8
	  return;

	Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.NotificationEndpoint.Address);

	if (Endpoint_IsINReady() && RNDISInterfaceInfo->State.ResponseReady)
    6a42:	80 ff       	sbrs	r24, 0
    6a44:	1b c0       	rjmp	.+54     	; 0x6a7c <RNDIS_Device_USBTask+0x68>
    6a46:	84 8d       	ldd	r24, Z+28	; 0x1c
    6a48:	88 23       	and	r24, r24
    6a4a:	c1 f0       	breq	.+48     	; 0x6a7c <RNDIS_Device_USBTask+0x68>
	{
		USB_Request_Header_t Notification = (USB_Request_Header_t)
    6a4c:	88 e0       	ldi	r24, 0x08	; 8
    6a4e:	e8 ef       	ldi	r30, 0xF8	; 248
    6a50:	f1 e0       	ldi	r31, 0x01	; 1
    6a52:	de 01       	movw	r26, r28
    6a54:	11 96       	adiw	r26, 0x01	; 1
    6a56:	01 90       	ld	r0, Z+
    6a58:	0d 92       	st	X+, r0
    6a5a:	8a 95       	dec	r24
    6a5c:	e1 f7       	brne	.-8      	; 0x6a56 <RNDIS_Device_USBTask+0x42>
				.wValue        = CPU_TO_LE16(0),
				.wIndex        = CPU_TO_LE16(0),
				.wLength       = CPU_TO_LE16(0),
			};

		Endpoint_Write_Stream_LE(&Notification, sizeof(USB_Request_Header_t), NULL);
    6a5e:	40 e0       	ldi	r20, 0x00	; 0
    6a60:	50 e0       	ldi	r21, 0x00	; 0
    6a62:	68 e0       	ldi	r22, 0x08	; 8
    6a64:	70 e0       	ldi	r23, 0x00	; 0
    6a66:	ce 01       	movw	r24, r28
    6a68:	01 96       	adiw	r24, 0x01	; 1
    6a6a:	0e 94 d2 24 	call	0x49a4	; 0x49a4 <Endpoint_Write_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    6a6e:	80 91 e8 00 	lds	r24, 0x00E8
    6a72:	8e 77       	andi	r24, 0x7E	; 126
    6a74:	80 93 e8 00 	sts	0x00E8, r24

		Endpoint_ClearIN();

		RNDISInterfaceInfo->State.ResponseReady = false;
    6a78:	f8 01       	movw	r30, r16
    6a7a:	14 8e       	std	Z+28, r1	; 0x1c
	}
}
    6a7c:	28 96       	adiw	r28, 0x08	; 8
    6a7e:	0f b6       	in	r0, 0x3f	; 63
    6a80:	f8 94       	cli
    6a82:	de bf       	out	0x3e, r29	; 62
    6a84:	0f be       	out	0x3f, r0	; 63
    6a86:	cd bf       	out	0x3d, r28	; 61
    6a88:	df 91       	pop	r29
    6a8a:	cf 91       	pop	r28
    6a8c:	1f 91       	pop	r17
    6a8e:	0f 91       	pop	r16
    6a90:	08 95       	ret

00006a92 <RNDIS_Device_IsPacketReceived>:
	}
}

bool RNDIS_Device_IsPacketReceived(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
    6a92:	2e b3       	in	r18, 0x1e	; 30
    6a94:	24 30       	cpi	r18, 0x04	; 4
    6a96:	71 f4       	brne	.+28     	; 0x6ab4 <RNDIS_Device_IsPacketReceived+0x22>
    6a98:	fc 01       	movw	r30, r24
    6a9a:	25 8d       	ldd	r18, Z+29	; 0x1d
    6a9c:	22 30       	cpi	r18, 0x02	; 2
    6a9e:	51 f4       	brne	.+20     	; 0x6ab4 <RNDIS_Device_IsPacketReceived+0x22>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    6aa0:	86 81       	ldd	r24, Z+6	; 0x06
    6aa2:	8f 70       	andi	r24, 0x0F	; 15
    6aa4:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    6aa8:	80 91 e8 00 	lds	r24, 0x00E8
    6aac:	82 fb       	bst	r24, 2
    6aae:	88 27       	eor	r24, r24
    6ab0:	80 f9       	bld	r24, 0
	{
		return false;
	}

	Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.DataOUTEndpoint.Address);
	return Endpoint_IsOUTReceived();
    6ab2:	08 95       	ret
bool RNDIS_Device_IsPacketReceived(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
	{
		return false;
    6ab4:	80 e0       	ldi	r24, 0x00	; 0
	}

	Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.DataOUTEndpoint.Address);
	return Endpoint_IsOUTReceived();
}
    6ab6:	08 95       	ret

00006ab8 <RNDIS_Device_ReadPacket>:

uint8_t RNDIS_Device_ReadPacket(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo,
                                void* Buffer,
                                uint16_t* const PacketLength)
{
    6ab8:	ef 92       	push	r14
    6aba:	ff 92       	push	r15
    6abc:	0f 93       	push	r16
    6abe:	1f 93       	push	r17
    6ac0:	cf 93       	push	r28
    6ac2:	df 93       	push	r29
    6ac4:	cd b7       	in	r28, 0x3d	; 61
    6ac6:	de b7       	in	r29, 0x3e	; 62
    6ac8:	ac 97       	sbiw	r28, 0x2c	; 44
    6aca:	0f b6       	in	r0, 0x3f	; 63
    6acc:	f8 94       	cli
    6ace:	de bf       	out	0x3e, r29	; 62
    6ad0:	0f be       	out	0x3f, r0	; 63
    6ad2:	cd bf       	out	0x3d, r28	; 61
    6ad4:	fc 01       	movw	r30, r24
    6ad6:	7b 01       	movw	r14, r22
    6ad8:	8a 01       	movw	r16, r20
	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
    6ada:	8e b3       	in	r24, 0x1e	; 30
    6adc:	84 30       	cpi	r24, 0x04	; 4
    6ade:	a9 f5       	brne	.+106    	; 0x6b4a <RNDIS_Device_ReadPacket+0x92>
    6ae0:	85 8d       	ldd	r24, Z+29	; 0x1d
    6ae2:	82 30       	cpi	r24, 0x02	; 2
    6ae4:	91 f5       	brne	.+100    	; 0x6b4a <RNDIS_Device_ReadPacket+0x92>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    6ae6:	86 81       	ldd	r24, Z+6	; 0x06
    6ae8:	8f 70       	andi	r24, 0x0F	; 15
    6aea:	80 93 e9 00 	sts	0x00E9, r24
		return ENDPOINT_RWSTREAM_DeviceDisconnected;
	}

	Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.DataOUTEndpoint.Address);

	*PacketLength = 0;
    6aee:	fa 01       	movw	r30, r20
    6af0:	11 82       	std	Z+1, r1	; 0x01
    6af2:	10 82       	st	Z, r1
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    6af4:	80 91 e8 00 	lds	r24, 0x00E8

	if (!(Endpoint_IsOUTReceived()))
    6af8:	82 ff       	sbrs	r24, 2
    6afa:	29 c0       	rjmp	.+82     	; 0x6b4e <RNDIS_Device_ReadPacket+0x96>
		return ENDPOINT_RWSTREAM_NoError;

	RNDIS_Packet_Message_t RNDISPacketHeader;
	Endpoint_Read_Stream_LE(&RNDISPacketHeader, sizeof(RNDIS_Packet_Message_t), NULL);
    6afc:	40 e0       	ldi	r20, 0x00	; 0
    6afe:	50 e0       	ldi	r21, 0x00	; 0
    6b00:	6c e2       	ldi	r22, 0x2C	; 44
    6b02:	70 e0       	ldi	r23, 0x00	; 0
    6b04:	ce 01       	movw	r24, r28
    6b06:	01 96       	adiw	r24, 0x01	; 1
    6b08:	0e 94 67 25 	call	0x4ace	; 0x4ace <Endpoint_Read_Stream_LE>

	if (le32_to_cpu(RNDISPacketHeader.DataLength) > ETHERNET_FRAME_SIZE_MAX)
    6b0c:	6d 85       	ldd	r22, Y+13	; 0x0d
    6b0e:	7e 85       	ldd	r23, Y+14	; 0x0e
    6b10:	8f 85       	ldd	r24, Y+15	; 0x0f
    6b12:	98 89       	ldd	r25, Y+16	; 0x10
    6b14:	6d 3d       	cpi	r22, 0xDD	; 221
    6b16:	f5 e0       	ldi	r31, 0x05	; 5
    6b18:	7f 07       	cpc	r23, r31
    6b1a:	81 05       	cpc	r24, r1
    6b1c:	91 05       	cpc	r25, r1
    6b1e:	38 f0       	brcs	.+14     	; 0x6b2e <RNDIS_Device_ReadPacket+0x76>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    6b20:	80 91 eb 00 	lds	r24, 0x00EB
    6b24:	80 62       	ori	r24, 0x20	; 32
    6b26:	80 93 eb 00 	sts	0x00EB, r24
	{
		Endpoint_StallTransaction();

		return RNDIS_ERROR_LOGICAL_CMD_FAILED;
    6b2a:	80 e8       	ldi	r24, 0x80	; 128
    6b2c:	11 c0       	rjmp	.+34     	; 0x6b50 <RNDIS_Device_ReadPacket+0x98>
	}

	*PacketLength = (uint16_t)le32_to_cpu(RNDISPacketHeader.DataLength);
    6b2e:	f8 01       	movw	r30, r16
    6b30:	71 83       	std	Z+1, r23	; 0x01
    6b32:	60 83       	st	Z, r22

	Endpoint_Read_Stream_LE(Buffer, *PacketLength, NULL);
    6b34:	40 e0       	ldi	r20, 0x00	; 0
    6b36:	50 e0       	ldi	r21, 0x00	; 0
    6b38:	c7 01       	movw	r24, r14
    6b3a:	0e 94 67 25 	call	0x4ace	; 0x4ace <Endpoint_Read_Stream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    6b3e:	80 91 e8 00 	lds	r24, 0x00E8
    6b42:	8b 77       	andi	r24, 0x7B	; 123
    6b44:	80 93 e8 00 	sts	0x00E8, r24
    6b48:	02 c0       	rjmp	.+4      	; 0x6b4e <RNDIS_Device_ReadPacket+0x96>
                                uint16_t* const PacketLength)
{
	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
	{
		return ENDPOINT_RWSTREAM_DeviceDisconnected;
    6b4a:	82 e0       	ldi	r24, 0x02	; 2
    6b4c:	01 c0       	rjmp	.+2      	; 0x6b50 <RNDIS_Device_ReadPacket+0x98>
	Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.DataOUTEndpoint.Address);

	*PacketLength = 0;

	if (!(Endpoint_IsOUTReceived()))
		return ENDPOINT_RWSTREAM_NoError;
    6b4e:	80 e0       	ldi	r24, 0x00	; 0

	Endpoint_Read_Stream_LE(Buffer, *PacketLength, NULL);
	Endpoint_ClearOUT();

	return ENDPOINT_RWSTREAM_NoError;
}
    6b50:	ac 96       	adiw	r28, 0x2c	; 44
    6b52:	0f b6       	in	r0, 0x3f	; 63
    6b54:	f8 94       	cli
    6b56:	de bf       	out	0x3e, r29	; 62
    6b58:	0f be       	out	0x3f, r0	; 63
    6b5a:	cd bf       	out	0x3d, r28	; 61
    6b5c:	df 91       	pop	r29
    6b5e:	cf 91       	pop	r28
    6b60:	1f 91       	pop	r17
    6b62:	0f 91       	pop	r16
    6b64:	ff 90       	pop	r15
    6b66:	ef 90       	pop	r14
    6b68:	08 95       	ret

00006b6a <RNDIS_Device_SendPacket>:

uint8_t RNDIS_Device_SendPacket(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo,
                                void* Buffer,
                                const uint16_t PacketLength)
{
    6b6a:	cf 92       	push	r12
    6b6c:	df 92       	push	r13
    6b6e:	ef 92       	push	r14
    6b70:	ff 92       	push	r15
    6b72:	0f 93       	push	r16
    6b74:	1f 93       	push	r17
    6b76:	cf 93       	push	r28
    6b78:	df 93       	push	r29
    6b7a:	cd b7       	in	r28, 0x3d	; 61
    6b7c:	de b7       	in	r29, 0x3e	; 62
    6b7e:	ac 97       	sbiw	r28, 0x2c	; 44
    6b80:	0f b6       	in	r0, 0x3f	; 63
    6b82:	f8 94       	cli
    6b84:	de bf       	out	0x3e, r29	; 62
    6b86:	0f be       	out	0x3f, r0	; 63
    6b88:	cd bf       	out	0x3d, r28	; 61
    6b8a:	6b 01       	movw	r12, r22
    6b8c:	7a 01       	movw	r14, r20
	uint8_t ErrorCode;

	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
    6b8e:	2e b3       	in	r18, 0x1e	; 30
    6b90:	24 30       	cpi	r18, 0x04	; 4
    6b92:	09 f0       	breq	.+2      	; 0x6b96 <RNDIS_Device_SendPacket+0x2c>
    6b94:	47 c0       	rjmp	.+142    	; 0x6c24 <RNDIS_Device_SendPacket+0xba>
    6b96:	fc 01       	movw	r30, r24
    6b98:	25 8d       	ldd	r18, Z+29	; 0x1d
    6b9a:	22 30       	cpi	r18, 0x02	; 2
    6b9c:	09 f0       	breq	.+2      	; 0x6ba0 <RNDIS_Device_SendPacket+0x36>
    6b9e:	42 c0       	rjmp	.+132    	; 0x6c24 <RNDIS_Device_SendPacket+0xba>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    6ba0:	81 81       	ldd	r24, Z+1	; 0x01
    6ba2:	8f 70       	andi	r24, 0x0F	; 15
    6ba4:	80 93 e9 00 	sts	0x00E9, r24
		return ENDPOINT_RWSTREAM_DeviceDisconnected;
	}

	Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.DataINEndpoint.Address);

	if ((ErrorCode = Endpoint_WaitUntilReady()) != ENDPOINT_READYWAIT_NoError)
    6ba8:	0e 94 34 27 	call	0x4e68	; 0x4e68 <Endpoint_WaitUntilReady>
    6bac:	81 11       	cpse	r24, r1
    6bae:	3b c0       	rjmp	.+118    	; 0x6c26 <RNDIS_Device_SendPacket+0xbc>
	  return ErrorCode;

	RNDIS_Packet_Message_t RNDISPacketHeader;

	memset(&RNDISPacketHeader, 0, sizeof(RNDIS_Packet_Message_t));
    6bb0:	ce 01       	movw	r24, r28
    6bb2:	01 96       	adiw	r24, 0x01	; 1
    6bb4:	2c e2       	ldi	r18, 0x2C	; 44
    6bb6:	fc 01       	movw	r30, r24
    6bb8:	11 92       	st	Z+, r1
    6bba:	2a 95       	dec	r18
    6bbc:	e9 f7       	brne	.-6      	; 0x6bb8 <RNDIS_Device_SendPacket+0x4e>

	RNDISPacketHeader.MessageType   = CPU_TO_LE32(REMOTE_NDIS_PACKET_MSG);
    6bbe:	41 e0       	ldi	r20, 0x01	; 1
    6bc0:	50 e0       	ldi	r21, 0x00	; 0
    6bc2:	60 e0       	ldi	r22, 0x00	; 0
    6bc4:	70 e0       	ldi	r23, 0x00	; 0
    6bc6:	49 83       	std	Y+1, r20	; 0x01
    6bc8:	5a 83       	std	Y+2, r21	; 0x02
    6bca:	6b 83       	std	Y+3, r22	; 0x03
    6bcc:	7c 83       	std	Y+4, r23	; 0x04
	RNDISPacketHeader.MessageLength = cpu_to_le32(sizeof(RNDIS_Packet_Message_t) + PacketLength);
    6bce:	a7 01       	movw	r20, r14
    6bd0:	44 5d       	subi	r20, 0xD4	; 212
    6bd2:	5f 4f       	sbci	r21, 0xFF	; 255
    6bd4:	60 e0       	ldi	r22, 0x00	; 0
    6bd6:	70 e0       	ldi	r23, 0x00	; 0
    6bd8:	4d 83       	std	Y+5, r20	; 0x05
    6bda:	5e 83       	std	Y+6, r21	; 0x06
    6bdc:	6f 83       	std	Y+7, r22	; 0x07
    6bde:	78 87       	std	Y+8, r23	; 0x08
	RNDISPacketHeader.DataOffset    = CPU_TO_LE32(sizeof(RNDIS_Packet_Message_t) - sizeof(RNDIS_Message_Header_t));
    6be0:	44 e2       	ldi	r20, 0x24	; 36
    6be2:	50 e0       	ldi	r21, 0x00	; 0
    6be4:	60 e0       	ldi	r22, 0x00	; 0
    6be6:	70 e0       	ldi	r23, 0x00	; 0
    6be8:	49 87       	std	Y+9, r20	; 0x09
    6bea:	5a 87       	std	Y+10, r21	; 0x0a
    6bec:	6b 87       	std	Y+11, r22	; 0x0b
    6bee:	7c 87       	std	Y+12, r23	; 0x0c
	RNDISPacketHeader.DataLength    = cpu_to_le32(PacketLength);
    6bf0:	87 01       	movw	r16, r14
    6bf2:	20 e0       	ldi	r18, 0x00	; 0
    6bf4:	30 e0       	ldi	r19, 0x00	; 0
    6bf6:	0d 87       	std	Y+13, r16	; 0x0d
    6bf8:	1e 87       	std	Y+14, r17	; 0x0e
    6bfa:	2f 87       	std	Y+15, r18	; 0x0f
    6bfc:	38 8b       	std	Y+16, r19	; 0x10

	Endpoint_Write_Stream_LE(&RNDISPacketHeader, sizeof(RNDIS_Packet_Message_t), NULL);
    6bfe:	40 e0       	ldi	r20, 0x00	; 0
    6c00:	50 e0       	ldi	r21, 0x00	; 0
    6c02:	6c e2       	ldi	r22, 0x2C	; 44
    6c04:	70 e0       	ldi	r23, 0x00	; 0
    6c06:	0e 94 d2 24 	call	0x49a4	; 0x49a4 <Endpoint_Write_Stream_LE>
	Endpoint_Write_Stream_LE(Buffer, PacketLength, NULL);
    6c0a:	40 e0       	ldi	r20, 0x00	; 0
    6c0c:	50 e0       	ldi	r21, 0x00	; 0
    6c0e:	b7 01       	movw	r22, r14
    6c10:	c6 01       	movw	r24, r12
    6c12:	0e 94 d2 24 	call	0x49a4	; 0x49a4 <Endpoint_Write_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    6c16:	80 91 e8 00 	lds	r24, 0x00E8
    6c1a:	8e 77       	andi	r24, 0x7E	; 126
    6c1c:	80 93 e8 00 	sts	0x00E8, r24
	Endpoint_ClearIN();

	return ENDPOINT_RWSTREAM_NoError;
    6c20:	80 e0       	ldi	r24, 0x00	; 0
    6c22:	01 c0       	rjmp	.+2      	; 0x6c26 <RNDIS_Device_SendPacket+0xbc>
	uint8_t ErrorCode;

	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
	{
		return ENDPOINT_RWSTREAM_DeviceDisconnected;
    6c24:	82 e0       	ldi	r24, 0x02	; 2
	Endpoint_Write_Stream_LE(&RNDISPacketHeader, sizeof(RNDIS_Packet_Message_t), NULL);
	Endpoint_Write_Stream_LE(Buffer, PacketLength, NULL);
	Endpoint_ClearIN();

	return ENDPOINT_RWSTREAM_NoError;
}
    6c26:	ac 96       	adiw	r28, 0x2c	; 44
    6c28:	0f b6       	in	r0, 0x3f	; 63
    6c2a:	f8 94       	cli
    6c2c:	de bf       	out	0x3e, r29	; 62
    6c2e:	0f be       	out	0x3f, r0	; 63
    6c30:	cd bf       	out	0x3d, r28	; 61
    6c32:	df 91       	pop	r29
    6c34:	cf 91       	pop	r28
    6c36:	1f 91       	pop	r17
    6c38:	0f 91       	pop	r16
    6c3a:	ff 90       	pop	r15
    6c3c:	ef 90       	pop	r14
    6c3e:	df 90       	pop	r13
    6c40:	cf 90       	pop	r12
    6c42:	08 95       	ret

00006c44 <DCOMP_RNDIS_Host_NextRNDISControlInterface>:

	return RNDIS_ENUMERROR_NoError;
}

static uint8_t DCOMP_RNDIS_Host_NextRNDISControlInterface(void* const CurrentDescriptor)
{
    6c44:	fc 01       	movw	r30, r24
	USB_Descriptor_Header_t* Header = DESCRIPTOR_PCAST(CurrentDescriptor, USB_Descriptor_Header_t);

	if (Header->Type == DTYPE_Interface)
    6c46:	81 81       	ldd	r24, Z+1	; 0x01
    6c48:	84 30       	cpi	r24, 0x04	; 4
    6c4a:	59 f4       	brne	.+22     	; 0x6c62 <DCOMP_RNDIS_Host_NextRNDISControlInterface+0x1e>
	{
		USB_Descriptor_Interface_t* Interface = DESCRIPTOR_PCAST(CurrentDescriptor, USB_Descriptor_Interface_t);

		if ((Interface->Class    == CDC_CSCP_CDCClass)    &&
    6c4c:	85 81       	ldd	r24, Z+5	; 0x05
    6c4e:	82 30       	cpi	r24, 0x02	; 2
    6c50:	41 f4       	brne	.+16     	; 0x6c62 <DCOMP_RNDIS_Host_NextRNDISControlInterface+0x1e>
    6c52:	86 81       	ldd	r24, Z+6	; 0x06
    6c54:	82 30       	cpi	r24, 0x02	; 2
    6c56:	29 f4       	brne	.+10     	; 0x6c62 <DCOMP_RNDIS_Host_NextRNDISControlInterface+0x1e>
		    (Interface->SubClass == CDC_CSCP_ACMSubclass) &&
    6c58:	87 81       	ldd	r24, Z+7	; 0x07
    6c5a:	8f 3f       	cpi	r24, 0xFF	; 255
    6c5c:	11 f4       	brne	.+4      	; 0x6c62 <DCOMP_RNDIS_Host_NextRNDISControlInterface+0x1e>
		    (Interface->Protocol == CDC_CSCP_VendorSpecificProtocol))
		{
			return DESCRIPTOR_SEARCH_Found;
    6c5e:	80 e0       	ldi	r24, 0x00	; 0
    6c60:	08 95       	ret
		}
	}

	return DESCRIPTOR_SEARCH_NotFound;
    6c62:	82 e0       	ldi	r24, 0x02	; 2
}
    6c64:	08 95       	ret

00006c66 <DCOMP_RNDIS_Host_NextRNDISDataInterface>:

static uint8_t DCOMP_RNDIS_Host_NextRNDISDataInterface(void* const CurrentDescriptor)
{
    6c66:	fc 01       	movw	r30, r24
	USB_Descriptor_Header_t* Header = DESCRIPTOR_PCAST(CurrentDescriptor, USB_Descriptor_Header_t);

	if (Header->Type == DTYPE_Interface)
    6c68:	81 81       	ldd	r24, Z+1	; 0x01
    6c6a:	84 30       	cpi	r24, 0x04	; 4
    6c6c:	51 f4       	brne	.+20     	; 0x6c82 <DCOMP_RNDIS_Host_NextRNDISDataInterface+0x1c>
	{
		USB_Descriptor_Interface_t* Interface = DESCRIPTOR_PCAST(CurrentDescriptor,
		                                                         USB_Descriptor_Interface_t);

		if ((Interface->Class    == CDC_CSCP_CDCDataClass)   &&
    6c6e:	85 81       	ldd	r24, Z+5	; 0x05
    6c70:	8a 30       	cpi	r24, 0x0A	; 10
    6c72:	39 f4       	brne	.+14     	; 0x6c82 <DCOMP_RNDIS_Host_NextRNDISDataInterface+0x1c>
    6c74:	86 81       	ldd	r24, Z+6	; 0x06
    6c76:	81 11       	cpse	r24, r1
    6c78:	04 c0       	rjmp	.+8      	; 0x6c82 <DCOMP_RNDIS_Host_NextRNDISDataInterface+0x1c>
		    (Interface->SubClass == CDC_CSCP_NoDataSubclass) &&
    6c7a:	87 81       	ldd	r24, Z+7	; 0x07
    6c7c:	81 11       	cpse	r24, r1
    6c7e:	01 c0       	rjmp	.+2      	; 0x6c82 <DCOMP_RNDIS_Host_NextRNDISDataInterface+0x1c>
    6c80:	08 95       	ret
		{
			return DESCRIPTOR_SEARCH_Found;
		}
	}

	return DESCRIPTOR_SEARCH_NotFound;
    6c82:	82 e0       	ldi	r24, 0x02	; 2
}
    6c84:	08 95       	ret

00006c86 <DCOMP_RNDIS_Host_NextRNDISInterfaceEndpoint>:

static uint8_t DCOMP_RNDIS_Host_NextRNDISInterfaceEndpoint(void* const CurrentDescriptor)
{
    6c86:	fc 01       	movw	r30, r24
	USB_Descriptor_Header_t* Header = DESCRIPTOR_PCAST(CurrentDescriptor, USB_Descriptor_Header_t);

	if (Header->Type == DTYPE_Endpoint)
    6c88:	81 81       	ldd	r24, Z+1	; 0x01
    6c8a:	85 30       	cpi	r24, 0x05	; 5
    6c8c:	59 f4       	brne	.+22     	; 0x6ca4 <DCOMP_RNDIS_Host_NextRNDISInterfaceEndpoint+0x1e>
	{
		USB_Descriptor_Endpoint_t* Endpoint = DESCRIPTOR_PCAST(CurrentDescriptor, USB_Descriptor_Endpoint_t);

		uint8_t EndpointType = (Endpoint->Attributes & EP_TYPE_MASK);
    6c8e:	83 81       	ldd	r24, Z+3	; 0x03
    6c90:	83 70       	andi	r24, 0x03	; 3

		if (((EndpointType == EP_TYPE_BULK) || (EndpointType == EP_TYPE_INTERRUPT)) &&
    6c92:	82 50       	subi	r24, 0x02	; 2
    6c94:	82 30       	cpi	r24, 0x02	; 2
    6c96:	50 f4       	brcc	.+20     	; 0x6cac <DCOMP_RNDIS_Host_NextRNDISInterfaceEndpoint+0x26>
		    !(Pipe_IsEndpointBound(Endpoint->EndpointAddress)))
    6c98:	82 81       	ldd	r24, Z+2	; 0x02
    6c9a:	0e 94 97 2a 	call	0x552e	; 0x552e <Pipe_IsEndpointBound>
	{
		USB_Descriptor_Endpoint_t* Endpoint = DESCRIPTOR_PCAST(CurrentDescriptor, USB_Descriptor_Endpoint_t);

		uint8_t EndpointType = (Endpoint->Attributes & EP_TYPE_MASK);

		if (((EndpointType == EP_TYPE_BULK) || (EndpointType == EP_TYPE_INTERRUPT)) &&
    6c9e:	81 11       	cpse	r24, r1
    6ca0:	05 c0       	rjmp	.+10     	; 0x6cac <DCOMP_RNDIS_Host_NextRNDISInterfaceEndpoint+0x26>
    6ca2:	06 c0       	rjmp	.+12     	; 0x6cb0 <DCOMP_RNDIS_Host_NextRNDISInterfaceEndpoint+0x2a>
		    !(Pipe_IsEndpointBound(Endpoint->EndpointAddress)))
		{
			return DESCRIPTOR_SEARCH_Found;
		}
	}
	else if (Header->Type == DTYPE_Interface)
    6ca4:	84 30       	cpi	r24, 0x04	; 4
    6ca6:	11 f4       	brne	.+4      	; 0x6cac <DCOMP_RNDIS_Host_NextRNDISInterfaceEndpoint+0x26>
	{
		return DESCRIPTOR_SEARCH_Fail;
    6ca8:	81 e0       	ldi	r24, 0x01	; 1
    6caa:	08 95       	ret
	}

	return DESCRIPTOR_SEARCH_NotFound;
    6cac:	82 e0       	ldi	r24, 0x02	; 2
    6cae:	08 95       	ret
		uint8_t EndpointType = (Endpoint->Attributes & EP_TYPE_MASK);

		if (((EndpointType == EP_TYPE_BULK) || (EndpointType == EP_TYPE_INTERRUPT)) &&
		    !(Pipe_IsEndpointBound(Endpoint->EndpointAddress)))
		{
			return DESCRIPTOR_SEARCH_Found;
    6cb0:	80 e0       	ldi	r24, 0x00	; 0
	{
		return DESCRIPTOR_SEARCH_Fail;
	}

	return DESCRIPTOR_SEARCH_NotFound;
}
    6cb2:	08 95       	ret

00006cb4 <RNDIS_SendEncapsulatedCommand>:

static uint8_t RNDIS_SendEncapsulatedCommand(USB_ClassInfo_RNDIS_Host_t* const RNDISInterfaceInfo,
                                             void* Buffer,
                                             const uint16_t Length)
{
	USB_ControlRequest = (USB_Request_Header_t)
    6cb4:	fc 01       	movw	r30, r24
    6cb6:	87 89       	ldd	r24, Z+23	; 0x17
    6cb8:	90 e0       	ldi	r25, 0x00	; 0
    6cba:	21 e2       	ldi	r18, 0x21	; 33
    6cbc:	20 93 dc 0d 	sts	0x0DDC, r18
    6cc0:	10 92 dd 0d 	sts	0x0DDD, r1
    6cc4:	10 92 df 0d 	sts	0x0DDF, r1
    6cc8:	10 92 de 0d 	sts	0x0DDE, r1
    6ccc:	90 93 e1 0d 	sts	0x0DE1, r25
    6cd0:	80 93 e0 0d 	sts	0x0DE0, r24
    6cd4:	50 93 e3 0d 	sts	0x0DE3, r21
    6cd8:	40 93 e2 0d 	sts	0x0DE2, r20
			 *  \param[in] Address  Address of the pipe to select.
			 */
			static inline void Pipe_SelectPipe(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SelectPipe(const uint8_t Address)
			{
				UPNUM = (Address & PIPE_PIPENUM_MASK);
    6cdc:	10 92 a7 00 	sts	0x00A7, r1
			.wLength       = Length,
		};

	Pipe_SelectPipe(PIPE_CONTROLPIPE);

	return USB_Host_SendControlRequest(Buffer);
    6ce0:	cb 01       	movw	r24, r22
    6ce2:	24 c9       	rjmp	.-3512   	; 0x5f2c <USB_Host_SendControlRequest>

00006ce4 <RNDIS_GetEncapsulatedResponse>:
    6ce4:	fc 01       	movw	r30, r24

static uint8_t RNDIS_GetEncapsulatedResponse(USB_ClassInfo_RNDIS_Host_t* const RNDISInterfaceInfo,
                                             void* Buffer,
                                             const uint16_t Length)
{
	USB_ControlRequest = (USB_Request_Header_t)
    6ce6:	87 89       	ldd	r24, Z+23	; 0x17
    6ce8:	90 e0       	ldi	r25, 0x00	; 0
    6cea:	21 ea       	ldi	r18, 0xA1	; 161
    6cec:	20 93 dc 0d 	sts	0x0DDC, r18
    6cf0:	21 e0       	ldi	r18, 0x01	; 1
    6cf2:	20 93 dd 0d 	sts	0x0DDD, r18
    6cf6:	10 92 df 0d 	sts	0x0DDF, r1
    6cfa:	10 92 de 0d 	sts	0x0DDE, r1
    6cfe:	90 93 e1 0d 	sts	0x0DE1, r25
    6d02:	80 93 e0 0d 	sts	0x0DE0, r24
    6d06:	50 93 e3 0d 	sts	0x0DE3, r21
    6d0a:	40 93 e2 0d 	sts	0x0DE2, r20
    6d0e:	10 92 a7 00 	sts	0x00A7, r1
			.wLength       = Length,
		};

	Pipe_SelectPipe(PIPE_CONTROLPIPE);

	return USB_Host_SendControlRequest(Buffer);
    6d12:	cb 01       	movw	r24, r22
    6d14:	0b c9       	rjmp	.-3562   	; 0x5f2c <USB_Host_SendControlRequest>

00006d16 <RNDIS_Host_ConfigurePipes>:
    6d16:	8f 92       	push	r8
#include "RNDISClassHost.h"

uint8_t RNDIS_Host_ConfigurePipes(USB_ClassInfo_RNDIS_Host_t* const RNDISInterfaceInfo,
                                  uint16_t ConfigDescriptorSize,
                                  void* ConfigDescriptorData)
{
    6d18:	9f 92       	push	r9
    6d1a:	af 92       	push	r10
    6d1c:	bf 92       	push	r11
    6d1e:	cf 92       	push	r12
    6d20:	df 92       	push	r13
    6d22:	ef 92       	push	r14
    6d24:	ff 92       	push	r15
    6d26:	0f 93       	push	r16
    6d28:	1f 93       	push	r17
    6d2a:	cf 93       	push	r28
    6d2c:	df 93       	push	r29
    6d2e:	00 d0       	rcall	.+0      	; 0x6d30 <RNDIS_Host_ConfigurePipes+0x1a>
    6d30:	00 d0       	rcall	.+0      	; 0x6d32 <RNDIS_Host_ConfigurePipes+0x1c>
    6d32:	cd b7       	in	r28, 0x3d	; 61
    6d34:	de b7       	in	r29, 0x3e	; 62
    6d36:	8c 01       	movw	r16, r24
    6d38:	7a 83       	std	Y+2, r23	; 0x02
    6d3a:	69 83       	std	Y+1, r22	; 0x01
    6d3c:	5c 83       	std	Y+4, r21	; 0x04
    6d3e:	4b 83       	std	Y+3, r20	; 0x03
	USB_Descriptor_Endpoint_t*  DataINEndpoint        = NULL;
	USB_Descriptor_Endpoint_t*  DataOUTEndpoint       = NULL;
	USB_Descriptor_Endpoint_t*  NotificationEndpoint  = NULL;
	USB_Descriptor_Interface_t* RNDISControlInterface = NULL;

	memset(&RNDISInterfaceInfo->State, 0x00, sizeof(RNDISInterfaceInfo->State));
    6d40:	fc 01       	movw	r30, r24
    6d42:	76 96       	adiw	r30, 0x16	; 22
    6d44:	8a e0       	ldi	r24, 0x0A	; 10
    6d46:	df 01       	movw	r26, r30
    6d48:	1d 92       	st	X+, r1
    6d4a:	8a 95       	dec	r24
    6d4c:	e9 f7       	brne	.-6      	; 0x6d48 <RNDIS_Host_ConfigurePipes+0x32>

	if (DESCRIPTOR_TYPE(ConfigDescriptorData) != DTYPE_Configuration)
    6d4e:	8b 80       	ldd	r8, Y+3	; 0x03
    6d50:	9c 80       	ldd	r9, Y+4	; 0x04
    6d52:	f4 01       	movw	r30, r8
    6d54:	81 81       	ldd	r24, Z+1	; 0x01
    6d56:	82 30       	cpi	r24, 0x02	; 2
    6d58:	09 f0       	breq	.+2      	; 0x6d5c <RNDIS_Host_ConfigurePipes+0x46>
    6d5a:	9b c0       	rjmp	.+310    	; 0x6e92 <RNDIS_Host_ConfigurePipes+0x17c>
    6d5c:	e1 2c       	mov	r14, r1
    6d5e:	f1 2c       	mov	r15, r1
    6d60:	c1 2c       	mov	r12, r1
    6d62:	d1 2c       	mov	r13, r1
    6d64:	a1 2c       	mov	r10, r1
    6d66:	b1 2c       	mov	r11, r1

	RNDISControlInterface = DESCRIPTOR_PCAST(ConfigDescriptorData, USB_Descriptor_Interface_t);

	while (!(DataINEndpoint) || !(DataOUTEndpoint) || !(NotificationEndpoint))
	{
		if (!(RNDISControlInterface) ||
    6d68:	81 14       	cp	r8, r1
    6d6a:	91 04       	cpc	r9, r1
    6d6c:	21 f4       	brne	.+8      	; 0x6d76 <RNDIS_Host_ConfigurePipes+0x60>
		    USB_GetNextDescriptorComp(&ConfigDescriptorSize, &ConfigDescriptorData,
		                              DCOMP_RNDIS_Host_NextRNDISInterfaceEndpoint) != DESCRIPTOR_SEARCH_COMP_Found)
		{
			if (NotificationEndpoint)
    6d6e:	e1 14       	cp	r14, r1
    6d70:	f1 04       	cpc	r15, r1
    6d72:	69 f4       	brne	.+26     	; 0x6d8e <RNDIS_Host_ConfigurePipes+0x78>
    6d74:	1e c0       	rjmp	.+60     	; 0x6db2 <RNDIS_Host_ConfigurePipes+0x9c>
	RNDISControlInterface = DESCRIPTOR_PCAST(ConfigDescriptorData, USB_Descriptor_Interface_t);

	while (!(DataINEndpoint) || !(DataOUTEndpoint) || !(NotificationEndpoint))
	{
		if (!(RNDISControlInterface) ||
		    USB_GetNextDescriptorComp(&ConfigDescriptorSize, &ConfigDescriptorData,
    6d76:	43 e4       	ldi	r20, 0x43	; 67
    6d78:	56 e3       	ldi	r21, 0x36	; 54
    6d7a:	be 01       	movw	r22, r28
    6d7c:	6d 5f       	subi	r22, 0xFD	; 253
    6d7e:	7f 4f       	sbci	r23, 0xFF	; 255
    6d80:	ce 01       	movw	r24, r28
    6d82:	01 96       	adiw	r24, 0x01	; 1
    6d84:	0e 94 e6 2d 	call	0x5bcc	; 0x5bcc <USB_GetNextDescriptorComp>

	RNDISControlInterface = DESCRIPTOR_PCAST(ConfigDescriptorData, USB_Descriptor_Interface_t);

	while (!(DataINEndpoint) || !(DataOUTEndpoint) || !(NotificationEndpoint))
	{
		if (!(RNDISControlInterface) ||
    6d88:	81 11       	cpse	r24, r1
    6d8a:	f1 cf       	rjmp	.-30     	; 0x6d6e <RNDIS_Host_ConfigurePipes+0x58>
    6d8c:	20 c0       	rjmp	.+64     	; 0x6dce <RNDIS_Host_ConfigurePipes+0xb8>
		    USB_GetNextDescriptorComp(&ConfigDescriptorSize, &ConfigDescriptorData,
		                              DCOMP_RNDIS_Host_NextRNDISInterfaceEndpoint) != DESCRIPTOR_SEARCH_COMP_Found)
		{
			if (NotificationEndpoint)
			{
				if (USB_GetNextDescriptorComp(&ConfigDescriptorSize, &ConfigDescriptorData,
    6d8e:	43 e3       	ldi	r20, 0x33	; 51
    6d90:	56 e3       	ldi	r21, 0x36	; 54
    6d92:	be 01       	movw	r22, r28
    6d94:	6d 5f       	subi	r22, 0xFD	; 253
    6d96:	7f 4f       	sbci	r23, 0xFF	; 255
    6d98:	ce 01       	movw	r24, r28
    6d9a:	01 96       	adiw	r24, 0x01	; 1
    6d9c:	0e 94 e6 2d 	call	0x5bcc	; 0x5bcc <USB_GetNextDescriptorComp>
    6da0:	81 11       	cpse	r24, r1
    6da2:	05 c0       	rjmp	.+10     	; 0x6dae <RNDIS_Host_ConfigurePipes+0x98>
											  DCOMP_RNDIS_Host_NextRNDISDataInterface) != DESCRIPTOR_SEARCH_COMP_Found)
				{
					return RNDIS_ENUMERROR_NoCompatibleInterfaceFound;
				}

				DataINEndpoint  = NULL;
    6da4:	a1 2c       	mov	r10, r1
    6da6:	b1 2c       	mov	r11, r1
				DataOUTEndpoint = NULL;
    6da8:	c1 2c       	mov	r12, r1
    6daa:	d1 2c       	mov	r13, r1
    6dac:	dd cf       	rjmp	.-70     	; 0x6d68 <RNDIS_Host_ConfigurePipes+0x52>
			if (NotificationEndpoint)
			{
				if (USB_GetNextDescriptorComp(&ConfigDescriptorSize, &ConfigDescriptorData,
											  DCOMP_RNDIS_Host_NextRNDISDataInterface) != DESCRIPTOR_SEARCH_COMP_Found)
				{
					return RNDIS_ENUMERROR_NoCompatibleInterfaceFound;
    6dae:	82 e0       	ldi	r24, 0x02	; 2
    6db0:	71 c0       	rjmp	.+226    	; 0x6e94 <RNDIS_Host_ConfigurePipes+0x17e>
				DataINEndpoint  = NULL;
				DataOUTEndpoint = NULL;
			}
			else
			{
				if (USB_GetNextDescriptorComp(&ConfigDescriptorSize, &ConfigDescriptorData,
    6db2:	42 e2       	ldi	r20, 0x22	; 34
    6db4:	56 e3       	ldi	r21, 0x36	; 54
    6db6:	be 01       	movw	r22, r28
    6db8:	6d 5f       	subi	r22, 0xFD	; 253
    6dba:	7f 4f       	sbci	r23, 0xFF	; 255
    6dbc:	ce 01       	movw	r24, r28
    6dbe:	01 96       	adiw	r24, 0x01	; 1
    6dc0:	0e 94 e6 2d 	call	0x5bcc	; 0x5bcc <USB_GetNextDescriptorComp>
    6dc4:	81 11       	cpse	r24, r1
    6dc6:	f3 cf       	rjmp	.-26     	; 0x6dae <RNDIS_Host_ConfigurePipes+0x98>
											  DCOMP_RNDIS_Host_NextRNDISControlInterface) != DESCRIPTOR_SEARCH_COMP_Found)
				{
					return RNDIS_ENUMERROR_NoCompatibleInterfaceFound;
				}

				RNDISControlInterface = DESCRIPTOR_PCAST(ConfigDescriptorData, USB_Descriptor_Interface_t);
    6dc8:	8b 80       	ldd	r8, Y+3	; 0x03
    6dca:	9c 80       	ldd	r9, Y+4	; 0x04
    6dcc:	0e c0       	rjmp	.+28     	; 0x6dea <RNDIS_Host_ConfigurePipes+0xd4>
			}

			continue;
		}

		USB_Descriptor_Endpoint_t* EndpointData = DESCRIPTOR_PCAST(ConfigDescriptorData, USB_Descriptor_Endpoint_t);
    6dce:	eb 81       	ldd	r30, Y+3	; 0x03
    6dd0:	fc 81       	ldd	r31, Y+4	; 0x04

		if ((EndpointData->EndpointAddress & ENDPOINT_DIR_MASK) == ENDPOINT_DIR_IN)
    6dd2:	82 81       	ldd	r24, Z+2	; 0x02
    6dd4:	87 ff       	sbrs	r24, 7
    6dd6:	06 c0       	rjmp	.+12     	; 0x6de4 <RNDIS_Host_ConfigurePipes+0xce>
		{
			if ((EndpointData->Attributes & EP_TYPE_MASK) == EP_TYPE_INTERRUPT)
    6dd8:	83 81       	ldd	r24, Z+3	; 0x03
    6dda:	83 70       	andi	r24, 0x03	; 3
    6ddc:	83 30       	cpi	r24, 0x03	; 3
    6dde:	21 f4       	brne	.+8      	; 0x6de8 <RNDIS_Host_ConfigurePipes+0xd2>
			  NotificationEndpoint = EndpointData;
    6de0:	7f 01       	movw	r14, r30
    6de2:	03 c0       	rjmp	.+6      	; 0x6dea <RNDIS_Host_ConfigurePipes+0xd4>
			else
			  DataINEndpoint = EndpointData;
		}
		else
		{
			DataOUTEndpoint = EndpointData;
    6de4:	6f 01       	movw	r12, r30
    6de6:	01 c0       	rjmp	.+2      	; 0x6dea <RNDIS_Host_ConfigurePipes+0xd4>
		if ((EndpointData->EndpointAddress & ENDPOINT_DIR_MASK) == ENDPOINT_DIR_IN)
		{
			if ((EndpointData->Attributes & EP_TYPE_MASK) == EP_TYPE_INTERRUPT)
			  NotificationEndpoint = EndpointData;
			else
			  DataINEndpoint = EndpointData;
    6de8:	5f 01       	movw	r10, r30
	if (DESCRIPTOR_TYPE(ConfigDescriptorData) != DTYPE_Configuration)
	  return RNDIS_ENUMERROR_InvalidConfigDescriptor;

	RNDISControlInterface = DESCRIPTOR_PCAST(ConfigDescriptorData, USB_Descriptor_Interface_t);

	while (!(DataINEndpoint) || !(DataOUTEndpoint) || !(NotificationEndpoint))
    6dea:	a1 14       	cp	r10, r1
    6dec:	b1 04       	cpc	r11, r1
    6dee:	09 f4       	brne	.+2      	; 0x6df2 <RNDIS_Host_ConfigurePipes+0xdc>
    6df0:	bb cf       	rjmp	.-138    	; 0x6d68 <RNDIS_Host_ConfigurePipes+0x52>
    6df2:	c1 14       	cp	r12, r1
    6df4:	d1 04       	cpc	r13, r1
    6df6:	09 f4       	brne	.+2      	; 0x6dfa <RNDIS_Host_ConfigurePipes+0xe4>
    6df8:	b7 cf       	rjmp	.-146    	; 0x6d68 <RNDIS_Host_ConfigurePipes+0x52>
    6dfa:	e1 14       	cp	r14, r1
    6dfc:	f1 04       	cpc	r15, r1
    6dfe:	09 f4       	brne	.+2      	; 0x6e02 <RNDIS_Host_ConfigurePipes+0xec>
    6e00:	b3 cf       	rjmp	.-154    	; 0x6d68 <RNDIS_Host_ConfigurePipes+0x52>
		{
			DataOUTEndpoint = EndpointData;
		}
	}

	RNDISInterfaceInfo->Config.DataINPipe.Size  = le16_to_cpu(DataINEndpoint->EndpointSize);
    6e02:	d5 01       	movw	r26, r10
    6e04:	14 96       	adiw	r26, 0x04	; 4
    6e06:	8d 91       	ld	r24, X+
    6e08:	9c 91       	ld	r25, X
    6e0a:	15 97       	sbiw	r26, 0x05	; 5
    6e0c:	f8 01       	movw	r30, r16
    6e0e:	92 83       	std	Z+2, r25	; 0x02
    6e10:	81 83       	std	Z+1, r24	; 0x01
	RNDISInterfaceInfo->Config.DataINPipe.EndpointAddress = DataINEndpoint->EndpointAddress;
    6e12:	12 96       	adiw	r26, 0x02	; 2
    6e14:	8c 91       	ld	r24, X
    6e16:	83 83       	std	Z+3, r24	; 0x03
	RNDISInterfaceInfo->Config.DataINPipe.Type  = EP_TYPE_BULK;
    6e18:	22 e0       	ldi	r18, 0x02	; 2
    6e1a:	24 83       	std	Z+4, r18	; 0x04

	RNDISInterfaceInfo->Config.DataOUTPipe.Size = le16_to_cpu(DataOUTEndpoint->EndpointSize);
    6e1c:	d6 01       	movw	r26, r12
    6e1e:	14 96       	adiw	r26, 0x04	; 4
    6e20:	8d 91       	ld	r24, X+
    6e22:	9c 91       	ld	r25, X
    6e24:	15 97       	sbiw	r26, 0x05	; 5
    6e26:	90 87       	std	Z+8, r25	; 0x08
    6e28:	87 83       	std	Z+7, r24	; 0x07
	RNDISInterfaceInfo->Config.DataOUTPipe.EndpointAddress = DataOUTEndpoint->EndpointAddress;
    6e2a:	12 96       	adiw	r26, 0x02	; 2
    6e2c:	8c 91       	ld	r24, X
    6e2e:	81 87       	std	Z+9, r24	; 0x09
	RNDISInterfaceInfo->Config.DataOUTPipe.Type = EP_TYPE_BULK;
    6e30:	22 87       	std	Z+10, r18	; 0x0a

	RNDISInterfaceInfo->Config.NotificationPipe.Size = le16_to_cpu(NotificationEndpoint->EndpointSize);
    6e32:	f7 01       	movw	r30, r14
    6e34:	84 81       	ldd	r24, Z+4	; 0x04
    6e36:	95 81       	ldd	r25, Z+5	; 0x05
    6e38:	d8 01       	movw	r26, r16
    6e3a:	1e 96       	adiw	r26, 0x0e	; 14
    6e3c:	9c 93       	st	X, r25
    6e3e:	8e 93       	st	-X, r24
    6e40:	1d 97       	sbiw	r26, 0x0d	; 13
	RNDISInterfaceInfo->Config.NotificationPipe.EndpointAddress = NotificationEndpoint->EndpointAddress;
    6e42:	82 81       	ldd	r24, Z+2	; 0x02
    6e44:	1f 96       	adiw	r26, 0x0f	; 15
    6e46:	8c 93       	st	X, r24
    6e48:	1f 97       	sbiw	r26, 0x0f	; 15
	RNDISInterfaceInfo->Config.NotificationPipe.Type = EP_TYPE_INTERRUPT;
    6e4a:	83 e0       	ldi	r24, 0x03	; 3
    6e4c:	50 96       	adiw	r26, 0x10	; 16
    6e4e:	8c 93       	st	X, r24

	if (!(Pipe_ConfigurePipeTable(&RNDISInterfaceInfo->Config.DataINPipe, 1)))
    6e50:	61 e0       	ldi	r22, 0x01	; 1
    6e52:	c8 01       	movw	r24, r16
    6e54:	0e 94 64 2a 	call	0x54c8	; 0x54c8 <Pipe_ConfigurePipeTable>
    6e58:	81 11       	cpse	r24, r1
    6e5a:	02 c0       	rjmp	.+4      	; 0x6e60 <RNDIS_Host_ConfigurePipes+0x14a>
	  return RNDIS_ENUMERROR_PipeConfigurationFailed;
    6e5c:	83 e0       	ldi	r24, 0x03	; 3
    6e5e:	1a c0       	rjmp	.+52     	; 0x6e94 <RNDIS_Host_ConfigurePipes+0x17e>

	if (!(Pipe_ConfigurePipeTable(&RNDISInterfaceInfo->Config.DataOUTPipe, 1)))
    6e60:	61 e0       	ldi	r22, 0x01	; 1
    6e62:	c8 01       	movw	r24, r16
    6e64:	06 96       	adiw	r24, 0x06	; 6
    6e66:	0e 94 64 2a 	call	0x54c8	; 0x54c8 <Pipe_ConfigurePipeTable>
    6e6a:	88 23       	and	r24, r24
    6e6c:	b9 f3       	breq	.-18     	; 0x6e5c <RNDIS_Host_ConfigurePipes+0x146>
	  return RNDIS_ENUMERROR_PipeConfigurationFailed;

	if (!(Pipe_ConfigurePipeTable(&RNDISInterfaceInfo->Config.NotificationPipe, 1)))
    6e6e:	61 e0       	ldi	r22, 0x01	; 1
    6e70:	c8 01       	movw	r24, r16
    6e72:	0c 96       	adiw	r24, 0x0c	; 12
    6e74:	0e 94 64 2a 	call	0x54c8	; 0x54c8 <Pipe_ConfigurePipeTable>
    6e78:	88 23       	and	r24, r24
    6e7a:	81 f3       	breq	.-32     	; 0x6e5c <RNDIS_Host_ConfigurePipes+0x146>
	  return RNDIS_ENUMERROR_PipeConfigurationFailed;

	RNDISInterfaceInfo->State.ControlInterfaceNumber = RNDISControlInterface->InterfaceNumber;
    6e7c:	f4 01       	movw	r30, r8
    6e7e:	82 81       	ldd	r24, Z+2	; 0x02
    6e80:	d8 01       	movw	r26, r16
    6e82:	57 96       	adiw	r26, 0x17	; 23
    6e84:	8c 93       	st	X, r24
    6e86:	57 97       	sbiw	r26, 0x17	; 23
	RNDISInterfaceInfo->State.IsActive = true;
    6e88:	81 e0       	ldi	r24, 0x01	; 1
    6e8a:	56 96       	adiw	r26, 0x16	; 22
    6e8c:	8c 93       	st	X, r24

	return RNDIS_ENUMERROR_NoError;
    6e8e:	80 e0       	ldi	r24, 0x00	; 0
    6e90:	01 c0       	rjmp	.+2      	; 0x6e94 <RNDIS_Host_ConfigurePipes+0x17e>
	USB_Descriptor_Interface_t* RNDISControlInterface = NULL;

	memset(&RNDISInterfaceInfo->State, 0x00, sizeof(RNDISInterfaceInfo->State));

	if (DESCRIPTOR_TYPE(ConfigDescriptorData) != DTYPE_Configuration)
	  return RNDIS_ENUMERROR_InvalidConfigDescriptor;
    6e92:	81 e0       	ldi	r24, 0x01	; 1

	RNDISInterfaceInfo->State.ControlInterfaceNumber = RNDISControlInterface->InterfaceNumber;
	RNDISInterfaceInfo->State.IsActive = true;

	return RNDIS_ENUMERROR_NoError;
}
    6e94:	0f 90       	pop	r0
    6e96:	0f 90       	pop	r0
    6e98:	0f 90       	pop	r0
    6e9a:	0f 90       	pop	r0
    6e9c:	df 91       	pop	r29
    6e9e:	cf 91       	pop	r28
    6ea0:	1f 91       	pop	r17
    6ea2:	0f 91       	pop	r16
    6ea4:	ff 90       	pop	r15
    6ea6:	ef 90       	pop	r14
    6ea8:	df 90       	pop	r13
    6eaa:	cf 90       	pop	r12
    6eac:	bf 90       	pop	r11
    6eae:	af 90       	pop	r10
    6eb0:	9f 90       	pop	r9
    6eb2:	8f 90       	pop	r8
    6eb4:	08 95       	ret

00006eb6 <RNDIS_Host_InitializeDevice>:

	return HOST_SENDCONTROL_Successful;
}

uint8_t RNDIS_Host_InitializeDevice(USB_ClassInfo_RNDIS_Host_t* const RNDISInterfaceInfo)
{
    6eb6:	0f 93       	push	r16
    6eb8:	1f 93       	push	r17
    6eba:	cf 93       	push	r28
    6ebc:	df 93       	push	r29
    6ebe:	cd b7       	in	r28, 0x3d	; 61
    6ec0:	de b7       	in	r29, 0x3e	; 62
    6ec2:	cc 54       	subi	r28, 0x4C	; 76
    6ec4:	d1 09       	sbc	r29, r1
    6ec6:	0f b6       	in	r0, 0x3f	; 63
    6ec8:	f8 94       	cli
    6eca:	de bf       	out	0x3e, r29	; 62
    6ecc:	0f be       	out	0x3f, r0	; 63
    6ece:	cd bf       	out	0x3d, r28	; 61
    6ed0:	8c 01       	movw	r16, r24
	uint8_t ErrorCode;

	RNDIS_Initialize_Message_t  InitMessage;
	RNDIS_Initialize_Complete_t InitMessageResponse;

	InitMessage.MessageType     = CPU_TO_LE32(REMOTE_NDIS_INITIALIZE_MSG);
    6ed2:	82 e0       	ldi	r24, 0x02	; 2
    6ed4:	90 e0       	ldi	r25, 0x00	; 0
    6ed6:	a0 e0       	ldi	r26, 0x00	; 0
    6ed8:	b0 e0       	ldi	r27, 0x00	; 0
    6eda:	8d ab       	std	Y+53, r24	; 0x35
    6edc:	9e ab       	std	Y+54, r25	; 0x36
    6ede:	af ab       	std	Y+55, r26	; 0x37
    6ee0:	b8 af       	std	Y+56, r27	; 0x38
	InitMessage.MessageLength   = CPU_TO_LE32(sizeof(RNDIS_Initialize_Message_t));
    6ee2:	88 e1       	ldi	r24, 0x18	; 24
    6ee4:	90 e0       	ldi	r25, 0x00	; 0
    6ee6:	a0 e0       	ldi	r26, 0x00	; 0
    6ee8:	b0 e0       	ldi	r27, 0x00	; 0
    6eea:	89 af       	std	Y+57, r24	; 0x39
    6eec:	9a af       	std	Y+58, r25	; 0x3a
    6eee:	ab af       	std	Y+59, r26	; 0x3b
    6ef0:	bc af       	std	Y+60, r27	; 0x3c
	InitMessage.RequestId       = cpu_to_le32(RNDISInterfaceInfo->State.RequestID++);
    6ef2:	f8 01       	movw	r30, r16
    6ef4:	44 8d       	ldd	r20, Z+28	; 0x1c
    6ef6:	55 8d       	ldd	r21, Z+29	; 0x1d
    6ef8:	66 8d       	ldd	r22, Z+30	; 0x1e
    6efa:	77 8d       	ldd	r23, Z+31	; 0x1f
    6efc:	db 01       	movw	r26, r22
    6efe:	ca 01       	movw	r24, r20
    6f00:	01 96       	adiw	r24, 0x01	; 1
    6f02:	a1 1d       	adc	r26, r1
    6f04:	b1 1d       	adc	r27, r1
    6f06:	84 8f       	std	Z+28, r24	; 0x1c
    6f08:	95 8f       	std	Z+29, r25	; 0x1d
    6f0a:	a6 8f       	std	Z+30, r26	; 0x1e
    6f0c:	b7 8f       	std	Z+31, r27	; 0x1f
    6f0e:	21 96       	adiw	r28, 0x01	; 1
    6f10:	4c af       	std	Y+60, r20	; 0x3c
    6f12:	5d af       	std	Y+61, r21	; 0x3d
    6f14:	6e af       	std	Y+62, r22	; 0x3e
    6f16:	7f af       	std	Y+63, r23	; 0x3f
    6f18:	21 97       	sbiw	r28, 0x01	; 1

	InitMessage.MajorVersion    = CPU_TO_LE32(REMOTE_NDIS_VERSION_MAJOR);
    6f1a:	81 e0       	ldi	r24, 0x01	; 1
    6f1c:	90 e0       	ldi	r25, 0x00	; 0
    6f1e:	a0 e0       	ldi	r26, 0x00	; 0
    6f20:	b0 e0       	ldi	r27, 0x00	; 0
    6f22:	25 96       	adiw	r28, 0x05	; 5
    6f24:	8c af       	std	Y+60, r24	; 0x3c
    6f26:	9d af       	std	Y+61, r25	; 0x3d
    6f28:	ae af       	std	Y+62, r26	; 0x3e
    6f2a:	bf af       	std	Y+63, r27	; 0x3f
    6f2c:	25 97       	sbiw	r28, 0x05	; 5
	InitMessage.MinorVersion    = CPU_TO_LE32(REMOTE_NDIS_VERSION_MINOR);
    6f2e:	29 96       	adiw	r28, 0x09	; 9
    6f30:	1c ae       	std	Y+60, r1	; 0x3c
    6f32:	1d ae       	std	Y+61, r1	; 0x3d
    6f34:	1e ae       	std	Y+62, r1	; 0x3e
    6f36:	1f ae       	std	Y+63, r1	; 0x3f
    6f38:	29 97       	sbiw	r28, 0x09	; 9
	InitMessage.MaxTransferSize = cpu_to_le32(RNDISInterfaceInfo->Config.HostMaxPacketSize);
    6f3a:	82 89       	ldd	r24, Z+18	; 0x12
    6f3c:	93 89       	ldd	r25, Z+19	; 0x13
    6f3e:	a4 89       	ldd	r26, Z+20	; 0x14
    6f40:	b5 89       	ldd	r27, Z+21	; 0x15
    6f42:	2d 96       	adiw	r28, 0x0d	; 13
    6f44:	8c af       	std	Y+60, r24	; 0x3c
    6f46:	9d af       	std	Y+61, r25	; 0x3d
    6f48:	ae af       	std	Y+62, r26	; 0x3e
    6f4a:	bf af       	std	Y+63, r27	; 0x3f
    6f4c:	2d 97       	sbiw	r28, 0x0d	; 13

	if ((ErrorCode = RNDIS_SendEncapsulatedCommand(RNDISInterfaceInfo, &InitMessage,
    6f4e:	48 e1       	ldi	r20, 0x18	; 24
    6f50:	50 e0       	ldi	r21, 0x00	; 0
    6f52:	be 01       	movw	r22, r28
    6f54:	6b 5c       	subi	r22, 0xCB	; 203
    6f56:	7f 4f       	sbci	r23, 0xFF	; 255
    6f58:	c8 01       	movw	r24, r16
    6f5a:	ac de       	rcall	.-680    	; 0x6cb4 <RNDIS_SendEncapsulatedCommand>
    6f5c:	81 11       	cpse	r24, r1
    6f5e:	1d c0       	rjmp	.+58     	; 0x6f9a <RNDIS_Host_InitializeDevice+0xe4>
    6f60:	44 e3       	ldi	r20, 0x34	; 52
	                                               sizeof(RNDIS_Initialize_Message_t))) != HOST_SENDCONTROL_Successful)
	{
		return ErrorCode;
	}

	if ((ErrorCode = RNDIS_GetEncapsulatedResponse(RNDISInterfaceInfo, &InitMessageResponse,
    6f62:	50 e0       	ldi	r21, 0x00	; 0
    6f64:	be 01       	movw	r22, r28
    6f66:	6f 5f       	subi	r22, 0xFF	; 255
    6f68:	7f 4f       	sbci	r23, 0xFF	; 255
    6f6a:	c8 01       	movw	r24, r16
    6f6c:	bb de       	rcall	.-650    	; 0x6ce4 <RNDIS_GetEncapsulatedResponse>
    6f6e:	81 11       	cpse	r24, r1
    6f70:	14 c0       	rjmp	.+40     	; 0x6f9a <RNDIS_Host_InitializeDevice+0xe4>
    6f72:	8d 85       	ldd	r24, Y+13	; 0x0d
    6f74:	9e 85       	ldd	r25, Y+14	; 0x0e
	                                               sizeof(RNDIS_Initialize_Complete_t))) != HOST_SENDCONTROL_Successful)
	{
		return ErrorCode;
	}

	if (InitMessageResponse.Status != CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS))
    6f76:	af 85       	ldd	r26, Y+15	; 0x0f
    6f78:	b8 89       	ldd	r27, Y+16	; 0x10
    6f7a:	89 2b       	or	r24, r25
    6f7c:	8a 2b       	or	r24, r26
    6f7e:	8b 2b       	or	r24, r27
    6f80:	59 f4       	brne	.+22     	; 0x6f98 <RNDIS_Host_InitializeDevice+0xe2>
    6f82:	8d a1       	ldd	r24, Y+37	; 0x25
    6f84:	9e a1       	ldd	r25, Y+38	; 0x26
	  return RNDIS_ERROR_LOGICAL_CMD_FAILED;

	RNDISInterfaceInfo->State.DeviceMaxPacketSize = le32_to_cpu(InitMessageResponse.MaxTransferSize);
    6f86:	af a1       	ldd	r26, Y+39	; 0x27
    6f88:	b8 a5       	ldd	r27, Y+40	; 0x28
    6f8a:	f8 01       	movw	r30, r16
    6f8c:	80 8f       	std	Z+24, r24	; 0x18
    6f8e:	91 8f       	std	Z+25, r25	; 0x19
    6f90:	a2 8f       	std	Z+26, r26	; 0x1a
    6f92:	b3 8f       	std	Z+27, r27	; 0x1b
    6f94:	80 e0       	ldi	r24, 0x00	; 0
    6f96:	01 c0       	rjmp	.+2      	; 0x6f9a <RNDIS_Host_InitializeDevice+0xe4>

	return HOST_SENDCONTROL_Successful;
    6f98:	80 e8       	ldi	r24, 0x80	; 128
    6f9a:	c4 5b       	subi	r28, 0xB4	; 180
	{
		return ErrorCode;
	}

	if (InitMessageResponse.Status != CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS))
	  return RNDIS_ERROR_LOGICAL_CMD_FAILED;
    6f9c:	df 4f       	sbci	r29, 0xFF	; 255

	RNDISInterfaceInfo->State.DeviceMaxPacketSize = le32_to_cpu(InitMessageResponse.MaxTransferSize);

	return HOST_SENDCONTROL_Successful;
}
    6f9e:	0f b6       	in	r0, 0x3f	; 63
    6fa0:	f8 94       	cli
    6fa2:	de bf       	out	0x3e, r29	; 62
    6fa4:	0f be       	out	0x3f, r0	; 63
    6fa6:	cd bf       	out	0x3d, r28	; 61
    6fa8:	df 91       	pop	r29
    6faa:	cf 91       	pop	r28
    6fac:	1f 91       	pop	r17
    6fae:	0f 91       	pop	r16
    6fb0:	08 95       	ret

00006fb2 <RNDIS_Host_SetRNDISProperty>:
    6fb2:	4f 92       	push	r4
    6fb4:	5f 92       	push	r5

uint8_t RNDIS_Host_SetRNDISProperty(USB_ClassInfo_RNDIS_Host_t* const RNDISInterfaceInfo,
                                    const uint32_t Oid,
                                    void* Buffer,
                                    const uint16_t Length)
{
    6fb6:	6f 92       	push	r6
    6fb8:	7f 92       	push	r7
    6fba:	8f 92       	push	r8
    6fbc:	9f 92       	push	r9
    6fbe:	af 92       	push	r10
    6fc0:	bf 92       	push	r11
    6fc2:	cf 92       	push	r12
    6fc4:	df 92       	push	r13
    6fc6:	ef 92       	push	r14
    6fc8:	ff 92       	push	r15
    6fca:	0f 93       	push	r16
    6fcc:	1f 93       	push	r17
    6fce:	cf 93       	push	r28
    6fd0:	df 93       	push	r29
    6fd2:	cd b7       	in	r28, 0x3d	; 61
    6fd4:	de b7       	in	r29, 0x3e	; 62
    6fd6:	60 97       	sbiw	r28, 0x10	; 16
    6fd8:	0f b6       	in	r0, 0x3f	; 63
    6fda:	f8 94       	cli
    6fdc:	de bf       	out	0x3e, r29	; 62
    6fde:	0f be       	out	0x3f, r0	; 63
    6fe0:	cd bf       	out	0x3d, r28	; 61
    6fe2:	6c 01       	movw	r12, r24

	if (SetMessageResponse.Status != CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS))
	  return RNDIS_ERROR_LOGICAL_CMD_FAILED;

	return HOST_SENDCONTROL_Successful;
}
    6fe4:	8d b6       	in	r8, 0x3d	; 61
    6fe6:	9e b6       	in	r9, 0x3e	; 62

	struct
	{
		RNDIS_Set_Message_t SetMessage;
		uint8_t             ContiguousBuffer[Length];
	} SetMessageData;
    6fe8:	58 01       	movw	r10, r16
    6fea:	8c e1       	ldi	r24, 0x1C	; 28
    6fec:	a8 0e       	add	r10, r24
    6fee:	b1 1c       	adc	r11, r1
    6ff0:	ed b7       	in	r30, 0x3d	; 61
    6ff2:	fe b7       	in	r31, 0x3e	; 62
    6ff4:	ea 19       	sub	r30, r10
    6ff6:	fb 09       	sbc	r31, r11
    6ff8:	0f b6       	in	r0, 0x3f	; 63
    6ffa:	f8 94       	cli
    6ffc:	fe bf       	out	0x3e, r31	; 62
    6ffe:	0f be       	out	0x3f, r0	; 63
    7000:	ed bf       	out	0x3d, r30	; 61
    7002:	8d b7       	in	r24, 0x3d	; 61
    7004:	9e b7       	in	r25, 0x3e	; 62
    7006:	01 96       	adiw	r24, 0x01	; 1
    7008:	7c 01       	movw	r14, r24

	RNDIS_Set_Complete_t SetMessageResponse;

	SetMessageData.SetMessage.MessageType    = CPU_TO_LE32(REMOTE_NDIS_SET_MSG);
    700a:	85 e0       	ldi	r24, 0x05	; 5
    700c:	90 e0       	ldi	r25, 0x00	; 0
    700e:	a0 e0       	ldi	r26, 0x00	; 0
    7010:	b0 e0       	ldi	r27, 0x00	; 0
    7012:	81 83       	std	Z+1, r24	; 0x01
    7014:	92 83       	std	Z+2, r25	; 0x02
    7016:	a3 83       	std	Z+3, r26	; 0x03
    7018:	b4 83       	std	Z+4, r27	; 0x04
	SetMessageData.SetMessage.MessageLength  = cpu_to_le32(sizeof(RNDIS_Set_Message_t) + Length);
    701a:	c5 01       	movw	r24, r10
    701c:	a0 e0       	ldi	r26, 0x00	; 0
    701e:	b0 e0       	ldi	r27, 0x00	; 0
    7020:	f7 01       	movw	r30, r14
    7022:	84 83       	std	Z+4, r24	; 0x04
    7024:	95 83       	std	Z+5, r25	; 0x05
    7026:	a6 83       	std	Z+6, r26	; 0x06
    7028:	b7 83       	std	Z+7, r27	; 0x07
	SetMessageData.SetMessage.RequestId      = cpu_to_le32(RNDISInterfaceInfo->State.RequestID++);
    702a:	f6 01       	movw	r30, r12
    702c:	84 8d       	ldd	r24, Z+28	; 0x1c
    702e:	95 8d       	ldd	r25, Z+29	; 0x1d
    7030:	a6 8d       	ldd	r26, Z+30	; 0x1e
    7032:	b7 8d       	ldd	r27, Z+31	; 0x1f
    7034:	2c 01       	movw	r4, r24
    7036:	3d 01       	movw	r6, r26
    7038:	ff ef       	ldi	r31, 0xFF	; 255
    703a:	4f 1a       	sub	r4, r31
    703c:	5f 0a       	sbc	r5, r31
    703e:	6f 0a       	sbc	r6, r31
    7040:	7f 0a       	sbc	r7, r31
    7042:	f6 01       	movw	r30, r12
    7044:	44 8e       	std	Z+28, r4	; 0x1c
    7046:	55 8e       	std	Z+29, r5	; 0x1d
    7048:	66 8e       	std	Z+30, r6	; 0x1e
    704a:	77 8e       	std	Z+31, r7	; 0x1f
    704c:	f7 01       	movw	r30, r14
    704e:	80 87       	std	Z+8, r24	; 0x08
    7050:	91 87       	std	Z+9, r25	; 0x09
    7052:	a2 87       	std	Z+10, r26	; 0x0a
    7054:	b3 87       	std	Z+11, r27	; 0x0b

	SetMessageData.SetMessage.Oid            = cpu_to_le32(Oid);
    7056:	44 87       	std	Z+12, r20	; 0x0c
    7058:	55 87       	std	Z+13, r21	; 0x0d
    705a:	66 87       	std	Z+14, r22	; 0x0e
    705c:	77 87       	std	Z+15, r23	; 0x0f
	SetMessageData.SetMessage.InformationBufferLength = cpu_to_le32(Length);
    705e:	c8 01       	movw	r24, r16
    7060:	a0 e0       	ldi	r26, 0x00	; 0
    7062:	b0 e0       	ldi	r27, 0x00	; 0
    7064:	80 8b       	std	Z+16, r24	; 0x10
    7066:	91 8b       	std	Z+17, r25	; 0x11
    7068:	a2 8b       	std	Z+18, r26	; 0x12
    706a:	b3 8b       	std	Z+19, r27	; 0x13
	SetMessageData.SetMessage.InformationBufferOffset = CPU_TO_LE32(sizeof(RNDIS_Set_Message_t) - sizeof(RNDIS_Message_Header_t));
    706c:	84 e1       	ldi	r24, 0x14	; 20
    706e:	90 e0       	ldi	r25, 0x00	; 0
    7070:	a0 e0       	ldi	r26, 0x00	; 0
    7072:	b0 e0       	ldi	r27, 0x00	; 0
    7074:	84 8b       	std	Z+20, r24	; 0x14
    7076:	95 8b       	std	Z+21, r25	; 0x15
    7078:	a6 8b       	std	Z+22, r26	; 0x16
    707a:	b7 8b       	std	Z+23, r27	; 0x17
	SetMessageData.SetMessage.DeviceVcHandle = CPU_TO_LE32(0);
    707c:	10 8e       	std	Z+24, r1	; 0x18
    707e:	11 8e       	std	Z+25, r1	; 0x19
    7080:	12 8e       	std	Z+26, r1	; 0x1a
    7082:	13 8e       	std	Z+27, r1	; 0x1b

	memcpy(&SetMessageData.ContiguousBuffer, Buffer, Length);
    7084:	8d b7       	in	r24, 0x3d	; 61
    7086:	9e b7       	in	r25, 0x3e	; 62
    7088:	4d 96       	adiw	r24, 0x1d	; 29
    708a:	a8 01       	movw	r20, r16
    708c:	b9 01       	movw	r22, r18
    708e:	54 d2       	rcall	.+1192   	; 0x7538 <memcpy>
    7090:	a5 01       	movw	r20, r10

	if ((ErrorCode = RNDIS_SendEncapsulatedCommand(RNDISInterfaceInfo, &SetMessageData,
    7092:	b7 01       	movw	r22, r14
    7094:	c6 01       	movw	r24, r12
    7096:	0e de       	rcall	.-996    	; 0x6cb4 <RNDIS_SendEncapsulatedCommand>
    7098:	81 11       	cpse	r24, r1
    709a:	14 c0       	rjmp	.+40     	; 0x70c4 <RNDIS_Host_SetRNDISProperty+0x112>
    709c:	40 e1       	ldi	r20, 0x10	; 16
    709e:	50 e0       	ldi	r21, 0x00	; 0
	                                               (sizeof(RNDIS_Set_Message_t) + Length))) != HOST_SENDCONTROL_Successful)
	{
		return ErrorCode;
	}

	if ((ErrorCode = RNDIS_GetEncapsulatedResponse(RNDISInterfaceInfo, &SetMessageResponse,
    70a0:	be 01       	movw	r22, r28
    70a2:	6f 5f       	subi	r22, 0xFF	; 255
    70a4:	7f 4f       	sbci	r23, 0xFF	; 255
    70a6:	c6 01       	movw	r24, r12
    70a8:	1d de       	rcall	.-966    	; 0x6ce4 <RNDIS_GetEncapsulatedResponse>
    70aa:	81 11       	cpse	r24, r1
    70ac:	0b c0       	rjmp	.+22     	; 0x70c4 <RNDIS_Host_SetRNDISProperty+0x112>
    70ae:	8d 85       	ldd	r24, Y+13	; 0x0d
    70b0:	9e 85       	ldd	r25, Y+14	; 0x0e
    70b2:	af 85       	ldd	r26, Y+15	; 0x0f
	                                               sizeof(RNDIS_Set_Complete_t))) != HOST_SENDCONTROL_Successful)
	{
		return ErrorCode;
	}

	if (SetMessageResponse.Status != CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS))
    70b4:	b8 89       	ldd	r27, Y+16	; 0x10
    70b6:	89 2b       	or	r24, r25
    70b8:	8a 2b       	or	r24, r26
    70ba:	8b 2b       	or	r24, r27
    70bc:	11 f0       	breq	.+4      	; 0x70c2 <RNDIS_Host_SetRNDISProperty+0x110>
    70be:	80 e8       	ldi	r24, 0x80	; 128
    70c0:	01 c0       	rjmp	.+2      	; 0x70c4 <RNDIS_Host_SetRNDISProperty+0x112>
    70c2:	80 e0       	ldi	r24, 0x00	; 0
	  return RNDIS_ERROR_LOGICAL_CMD_FAILED;
    70c4:	0f b6       	in	r0, 0x3f	; 63
    70c6:	f8 94       	cli

	return HOST_SENDCONTROL_Successful;
    70c8:	9e be       	out	0x3e, r9	; 62
}
    70ca:	0f be       	out	0x3f, r0	; 63
    70cc:	8d be       	out	0x3d, r8	; 61
    70ce:	60 96       	adiw	r28, 0x10	; 16
    70d0:	0f b6       	in	r0, 0x3f	; 63
    70d2:	f8 94       	cli
    70d4:	de bf       	out	0x3e, r29	; 62
    70d6:	0f be       	out	0x3f, r0	; 63
    70d8:	cd bf       	out	0x3d, r28	; 61
    70da:	df 91       	pop	r29
    70dc:	cf 91       	pop	r28
    70de:	1f 91       	pop	r17
    70e0:	0f 91       	pop	r16
    70e2:	ff 90       	pop	r15
    70e4:	ef 90       	pop	r14
    70e6:	df 90       	pop	r13
    70e8:	cf 90       	pop	r12
    70ea:	bf 90       	pop	r11
    70ec:	af 90       	pop	r10
    70ee:	9f 90       	pop	r9
    70f0:	8f 90       	pop	r8
    70f2:	7f 90       	pop	r7
    70f4:	6f 90       	pop	r6
    70f6:	5f 90       	pop	r5
    70f8:	4f 90       	pop	r4
    70fa:	08 95       	ret

000070fc <RNDIS_Host_QueryRNDISProperty>:
    70fc:	2f 92       	push	r2
    70fe:	3f 92       	push	r3
    7100:	4f 92       	push	r4

uint8_t RNDIS_Host_QueryRNDISProperty(USB_ClassInfo_RNDIS_Host_t* const RNDISInterfaceInfo,
                                      const uint32_t Oid,
                                      void* Buffer,
                                      const uint16_t MaxLength)
{
    7102:	5f 92       	push	r5
    7104:	6f 92       	push	r6
    7106:	7f 92       	push	r7
    7108:	8f 92       	push	r8
    710a:	9f 92       	push	r9
    710c:	af 92       	push	r10
    710e:	bf 92       	push	r11
    7110:	cf 92       	push	r12
    7112:	df 92       	push	r13
    7114:	ef 92       	push	r14
    7116:	ff 92       	push	r15
    7118:	0f 93       	push	r16
    711a:	1f 93       	push	r17
    711c:	cf 93       	push	r28
    711e:	df 93       	push	r29
    7120:	cd b7       	in	r28, 0x3d	; 61
    7122:	de b7       	in	r29, 0x3e	; 62
    7124:	6c 97       	sbiw	r28, 0x1c	; 28
    7126:	0f b6       	in	r0, 0x3f	; 63
    7128:	f8 94       	cli
    712a:	de bf       	out	0x3e, r29	; 62
    712c:	0f be       	out	0x3f, r0	; 63
    712e:	cd bf       	out	0x3d, r28	; 61
    7130:	7c 01       	movw	r14, r24
    7132:	59 01       	movw	r10, r18
	  return RNDIS_ERROR_LOGICAL_CMD_FAILED;

	memcpy(Buffer, &QueryMessageResponseData.ContiguousBuffer, MaxLength);

	return HOST_SENDCONTROL_Successful;
}
    7134:	8d b6       	in	r8, 0x3d	; 61
    7136:	9e b6       	in	r9, 0x3e	; 62

	struct
	{
		RNDIS_Query_Complete_t QueryMessageResponse;
		uint8_t                ContiguousBuffer[MaxLength];
	} QueryMessageResponseData;
    7138:	38 01       	movw	r6, r16
    713a:	28 e1       	ldi	r18, 0x18	; 24
    713c:	62 0e       	add	r6, r18
    713e:	71 1c       	adc	r7, r1
    7140:	8d b7       	in	r24, 0x3d	; 61
    7142:	9e b7       	in	r25, 0x3e	; 62
    7144:	86 19       	sub	r24, r6
    7146:	97 09       	sbc	r25, r7
    7148:	0f b6       	in	r0, 0x3f	; 63
    714a:	f8 94       	cli
    714c:	9e bf       	out	0x3e, r25	; 62
    714e:	0f be       	out	0x3f, r0	; 63
    7150:	8d bf       	out	0x3d, r24	; 61
    7152:	ed b7       	in	r30, 0x3d	; 61
    7154:	fe b7       	in	r31, 0x3e	; 62
    7156:	31 96       	adiw	r30, 0x01	; 1
    7158:	6f 01       	movw	r12, r30

	QueryMessage.MessageType    = CPU_TO_LE32(REMOTE_NDIS_QUERY_MSG);
    715a:	84 e0       	ldi	r24, 0x04	; 4
    715c:	90 e0       	ldi	r25, 0x00	; 0
    715e:	a0 e0       	ldi	r26, 0x00	; 0
    7160:	b0 e0       	ldi	r27, 0x00	; 0
    7162:	89 83       	std	Y+1, r24	; 0x01
    7164:	9a 83       	std	Y+2, r25	; 0x02
    7166:	ab 83       	std	Y+3, r26	; 0x03
    7168:	bc 83       	std	Y+4, r27	; 0x04
	QueryMessage.MessageLength  = CPU_TO_LE32(sizeof(RNDIS_Query_Message_t));
    716a:	8c e1       	ldi	r24, 0x1C	; 28
    716c:	90 e0       	ldi	r25, 0x00	; 0
    716e:	a0 e0       	ldi	r26, 0x00	; 0
    7170:	b0 e0       	ldi	r27, 0x00	; 0
    7172:	8d 83       	std	Y+5, r24	; 0x05
    7174:	9e 83       	std	Y+6, r25	; 0x06
    7176:	af 83       	std	Y+7, r26	; 0x07
    7178:	b8 87       	std	Y+8, r27	; 0x08
	QueryMessage.RequestId      = cpu_to_le32(RNDISInterfaceInfo->State.RequestID++);
    717a:	f7 01       	movw	r30, r14
    717c:	84 8d       	ldd	r24, Z+28	; 0x1c
    717e:	95 8d       	ldd	r25, Z+29	; 0x1d
    7180:	a6 8d       	ldd	r26, Z+30	; 0x1e
    7182:	b7 8d       	ldd	r27, Z+31	; 0x1f
    7184:	1c 01       	movw	r2, r24
    7186:	2d 01       	movw	r4, r26
    7188:	ff ef       	ldi	r31, 0xFF	; 255
    718a:	2f 1a       	sub	r2, r31
    718c:	3f 0a       	sbc	r3, r31
    718e:	4f 0a       	sbc	r4, r31
    7190:	5f 0a       	sbc	r5, r31
    7192:	f7 01       	movw	r30, r14
    7194:	24 8e       	std	Z+28, r2	; 0x1c
    7196:	35 8e       	std	Z+29, r3	; 0x1d
    7198:	46 8e       	std	Z+30, r4	; 0x1e
    719a:	57 8e       	std	Z+31, r5	; 0x1f
    719c:	89 87       	std	Y+9, r24	; 0x09
    719e:	9a 87       	std	Y+10, r25	; 0x0a
    71a0:	ab 87       	std	Y+11, r26	; 0x0b
    71a2:	bc 87       	std	Y+12, r27	; 0x0c

	QueryMessage.Oid            = cpu_to_le32(Oid);
    71a4:	4d 87       	std	Y+13, r20	; 0x0d
    71a6:	5e 87       	std	Y+14, r21	; 0x0e
    71a8:	6f 87       	std	Y+15, r22	; 0x0f
    71aa:	78 8b       	std	Y+16, r23	; 0x10
	QueryMessage.InformationBufferLength = CPU_TO_LE32(0);
    71ac:	19 8a       	std	Y+17, r1	; 0x11
    71ae:	1a 8a       	std	Y+18, r1	; 0x12
    71b0:	1b 8a       	std	Y+19, r1	; 0x13
    71b2:	1c 8a       	std	Y+20, r1	; 0x14
	QueryMessage.InformationBufferOffset = CPU_TO_LE32(0);
    71b4:	1d 8a       	std	Y+21, r1	; 0x15
    71b6:	1e 8a       	std	Y+22, r1	; 0x16
    71b8:	1f 8a       	std	Y+23, r1	; 0x17
    71ba:	18 8e       	std	Y+24, r1	; 0x18
	QueryMessage.DeviceVcHandle = CPU_TO_LE32(0);
    71bc:	19 8e       	std	Y+25, r1	; 0x19
    71be:	1a 8e       	std	Y+26, r1	; 0x1a
    71c0:	1b 8e       	std	Y+27, r1	; 0x1b
    71c2:	1c 8e       	std	Y+28, r1	; 0x1c

	if ((ErrorCode = RNDIS_SendEncapsulatedCommand(RNDISInterfaceInfo, &QueryMessage,
    71c4:	4c e1       	ldi	r20, 0x1C	; 28
    71c6:	50 e0       	ldi	r21, 0x00	; 0
    71c8:	be 01       	movw	r22, r28
    71ca:	6f 5f       	subi	r22, 0xFF	; 255
    71cc:	7f 4f       	sbci	r23, 0xFF	; 255
    71ce:	c7 01       	movw	r24, r14
    71d0:	71 dd       	rcall	.-1310   	; 0x6cb4 <RNDIS_SendEncapsulatedCommand>
    71d2:	81 11       	cpse	r24, r1
    71d4:	18 c0       	rjmp	.+48     	; 0x7206 <RNDIS_Host_QueryRNDISProperty+0x10a>
    71d6:	a3 01       	movw	r20, r6
	                                               sizeof(RNDIS_Query_Message_t))) != HOST_SENDCONTROL_Successful)
	{
		return ErrorCode;
	}

	if ((ErrorCode = RNDIS_GetEncapsulatedResponse(RNDISInterfaceInfo, &QueryMessageResponseData,
    71d8:	b6 01       	movw	r22, r12
    71da:	c7 01       	movw	r24, r14
    71dc:	83 dd       	rcall	.-1274   	; 0x6ce4 <RNDIS_GetEncapsulatedResponse>
    71de:	81 11       	cpse	r24, r1
    71e0:	12 c0       	rjmp	.+36     	; 0x7206 <RNDIS_Host_QueryRNDISProperty+0x10a>
    71e2:	f6 01       	movw	r30, r12
    71e4:	84 85       	ldd	r24, Z+12	; 0x0c
	                                               sizeof(QueryMessageResponseData))) != HOST_SENDCONTROL_Successful)
	{
		return ErrorCode;
	}

	if (QueryMessageResponseData.QueryMessageResponse.Status != CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS))
    71e6:	95 85       	ldd	r25, Z+13	; 0x0d
    71e8:	a6 85       	ldd	r26, Z+14	; 0x0e
    71ea:	b7 85       	ldd	r27, Z+15	; 0x0f
    71ec:	89 2b       	or	r24, r25
    71ee:	8a 2b       	or	r24, r26
    71f0:	8b 2b       	or	r24, r27
    71f2:	41 f4       	brne	.+16     	; 0x7204 <RNDIS_Host_QueryRNDISProperty+0x108>
    71f4:	b6 01       	movw	r22, r12
    71f6:	68 5e       	subi	r22, 0xE8	; 232
	  return RNDIS_ERROR_LOGICAL_CMD_FAILED;

	memcpy(Buffer, &QueryMessageResponseData.ContiguousBuffer, MaxLength);
    71f8:	7f 4f       	sbci	r23, 0xFF	; 255
    71fa:	a8 01       	movw	r20, r16
    71fc:	c5 01       	movw	r24, r10
    71fe:	9c d1       	rcall	.+824    	; 0x7538 <memcpy>
    7200:	80 e0       	ldi	r24, 0x00	; 0
    7202:	01 c0       	rjmp	.+2      	; 0x7206 <RNDIS_Host_QueryRNDISProperty+0x10a>
    7204:	80 e8       	ldi	r24, 0x80	; 128

	return HOST_SENDCONTROL_Successful;
    7206:	0f b6       	in	r0, 0x3f	; 63
    7208:	f8 94       	cli
	{
		return ErrorCode;
	}

	if (QueryMessageResponseData.QueryMessageResponse.Status != CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS))
	  return RNDIS_ERROR_LOGICAL_CMD_FAILED;
    720a:	9e be       	out	0x3e, r9	; 62

	memcpy(Buffer, &QueryMessageResponseData.ContiguousBuffer, MaxLength);

	return HOST_SENDCONTROL_Successful;
}
    720c:	0f be       	out	0x3f, r0	; 63
    720e:	8d be       	out	0x3d, r8	; 61
    7210:	6c 96       	adiw	r28, 0x1c	; 28
    7212:	0f b6       	in	r0, 0x3f	; 63
    7214:	f8 94       	cli
    7216:	de bf       	out	0x3e, r29	; 62
    7218:	0f be       	out	0x3f, r0	; 63
    721a:	cd bf       	out	0x3d, r28	; 61
    721c:	df 91       	pop	r29
    721e:	cf 91       	pop	r28
    7220:	1f 91       	pop	r17
    7222:	0f 91       	pop	r16
    7224:	ff 90       	pop	r15
    7226:	ef 90       	pop	r14
    7228:	df 90       	pop	r13
    722a:	cf 90       	pop	r12
    722c:	bf 90       	pop	r11
    722e:	af 90       	pop	r10
    7230:	9f 90       	pop	r9
    7232:	8f 90       	pop	r8
    7234:	7f 90       	pop	r7
    7236:	6f 90       	pop	r6
    7238:	5f 90       	pop	r5
    723a:	4f 90       	pop	r4
    723c:	3f 90       	pop	r3
    723e:	2f 90       	pop	r2
    7240:	08 95       	ret

00007242 <RNDIS_Host_IsPacketReceived>:
    7242:	fc 01       	movw	r30, r24
    7244:	8e b3       	in	r24, 0x1e	; 30
    7246:	8b 30       	cpi	r24, 0x0B	; 11

bool RNDIS_Host_IsPacketReceived(USB_ClassInfo_RNDIS_Host_t* const RNDISInterfaceInfo)
{
	bool PacketWaiting;

	if ((USB_HostState != HOST_STATE_Configured) || !(RNDISInterfaceInfo->State.IsActive))
    7248:	a9 f4       	brne	.+42     	; 0x7274 <RNDIS_Host_IsPacketReceived+0x32>
    724a:	86 89       	ldd	r24, Z+22	; 0x16
    724c:	88 23       	and	r24, r24
    724e:	99 f0       	breq	.+38     	; 0x7276 <RNDIS_Host_IsPacketReceived+0x34>
    7250:	80 81       	ld	r24, Z
    7252:	8f 70       	andi	r24, 0x0F	; 15
    7254:	80 93 a7 00 	sts	0x00A7, r24

			/** Unfreezes the selected pipe, allowing it to communicate with an attached device. */
			static inline void Pipe_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Unfreeze(void)
			{
				UPCONX &= ~(1 << PFREEZE);
    7258:	80 91 a9 00 	lds	r24, 0x00A9
    725c:	8f 7b       	andi	r24, 0xBF	; 191
    725e:	80 93 a9 00 	sts	0x00A9, r24
			 *  \return Boolean \c true if the current pipe has received an IN packet, \c false otherwise.
			 */
			static inline bool Pipe_IsINReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsINReceived(void)
			{
				return ((UPINTX & (1 << RXINI)) ? true : false);
    7262:	80 91 a6 00 	lds	r24, 0x00A6
    7266:	81 70       	andi	r24, 0x01	; 1

			/** Freezes the selected pipe, preventing it from communicating with an attached device. */
			static inline void Pipe_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Freeze(void)
			{
				UPCONX |= (1 << PFREEZE);
    7268:	90 91 a9 00 	lds	r25, 0x00A9
    726c:	90 64       	ori	r25, 0x40	; 64
    726e:	90 93 a9 00 	sts	0x00A9, r25

	Pipe_Unfreeze();
	PacketWaiting = Pipe_IsINReceived();
	Pipe_Freeze();

	return PacketWaiting;
    7272:	08 95       	ret
bool RNDIS_Host_IsPacketReceived(USB_ClassInfo_RNDIS_Host_t* const RNDISInterfaceInfo)
{
	bool PacketWaiting;

	if ((USB_HostState != HOST_STATE_Configured) || !(RNDISInterfaceInfo->State.IsActive))
	  return false;
    7274:	80 e0       	ldi	r24, 0x00	; 0
	Pipe_Unfreeze();
	PacketWaiting = Pipe_IsINReceived();
	Pipe_Freeze();

	return PacketWaiting;
}
    7276:	08 95       	ret

00007278 <RNDIS_Host_ReadPacket>:

uint8_t RNDIS_Host_ReadPacket(USB_ClassInfo_RNDIS_Host_t* const RNDISInterfaceInfo,
                              void* Buffer,
                              uint16_t* const PacketLength)
{
    7278:	ef 92       	push	r14
    727a:	ff 92       	push	r15
    727c:	0f 93       	push	r16
    727e:	1f 93       	push	r17
    7280:	cf 93       	push	r28
    7282:	df 93       	push	r29
    7284:	cd b7       	in	r28, 0x3d	; 61
    7286:	de b7       	in	r29, 0x3e	; 62
    7288:	ac 97       	sbiw	r28, 0x2c	; 44
    728a:	0f b6       	in	r0, 0x3f	; 63
    728c:	f8 94       	cli
    728e:	de bf       	out	0x3e, r29	; 62
    7290:	0f be       	out	0x3f, r0	; 63
    7292:	cd bf       	out	0x3d, r28	; 61
    7294:	fc 01       	movw	r30, r24
    7296:	7b 01       	movw	r14, r22
    7298:	8a 01       	movw	r16, r20
	uint8_t ErrorCode;

	if ((USB_HostState != HOST_STATE_Configured) || !(RNDISInterfaceInfo->State.IsActive))
    729a:	8e b3       	in	r24, 0x1e	; 30
    729c:	8b 30       	cpi	r24, 0x0B	; 11
    729e:	09 f0       	breq	.+2      	; 0x72a2 <RNDIS_Host_ReadPacket+0x2a>
    72a0:	4e c0       	rjmp	.+156    	; 0x733e <RNDIS_Host_ReadPacket+0xc6>
    72a2:	86 89       	ldd	r24, Z+22	; 0x16
    72a4:	88 23       	and	r24, r24
    72a6:	09 f4       	brne	.+2      	; 0x72aa <RNDIS_Host_ReadPacket+0x32>
    72a8:	4a c0       	rjmp	.+148    	; 0x733e <RNDIS_Host_ReadPacket+0xc6>
			 *  \param[in] Address  Address of the pipe to select.
			 */
			static inline void Pipe_SelectPipe(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SelectPipe(const uint8_t Address)
			{
				UPNUM = (Address & PIPE_PIPENUM_MASK);
    72aa:	80 81       	ld	r24, Z
    72ac:	8f 70       	andi	r24, 0x0F	; 15
    72ae:	80 93 a7 00 	sts	0x00A7, r24

			/** Unfreezes the selected pipe, allowing it to communicate with an attached device. */
			static inline void Pipe_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Unfreeze(void)
			{
				UPCONX &= ~(1 << PFREEZE);
    72b2:	80 91 a9 00 	lds	r24, 0x00A9
    72b6:	8f 7b       	andi	r24, 0xBF	; 191
    72b8:	80 93 a9 00 	sts	0x00A9, r24
			 *          on its direction.
			 */
			static inline bool Pipe_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsReadWriteAllowed(void)
			{
				return ((UPINTX & (1 << RWAL)) ? true : false);
    72bc:	80 91 a6 00 	lds	r24, 0x00A6
	  return PIPE_READYWAIT_DeviceDisconnected;

	Pipe_SelectPipe(RNDISInterfaceInfo->Config.DataINPipe.Address);
	Pipe_Unfreeze();

	if (!(Pipe_IsReadWriteAllowed()))
    72c0:	85 fd       	sbrc	r24, 5
    72c2:	0d c0       	rjmp	.+26     	; 0x72de <RNDIS_Host_ReadPacket+0x66>
			 *  \return Boolean \c true if the current pipe has received an IN packet, \c false otherwise.
			 */
			static inline bool Pipe_IsINReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsINReceived(void)
			{
				return ((UPINTX & (1 << RXINI)) ? true : false);
    72c4:	80 91 a6 00 	lds	r24, 0x00A6
	{
		if (Pipe_IsINReceived())
    72c8:	80 ff       	sbrs	r24, 0
    72ca:	05 c0       	rjmp	.+10     	; 0x72d6 <RNDIS_Host_ReadPacket+0x5e>
			 *  \ingroup Group_PipePacketManagement_AVR8
			 */
			static inline void Pipe_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearIN(void)
			{
				UPINTX &= ~((1 << RXINI) | (1 << FIFOCON));
    72cc:	80 91 a6 00 	lds	r24, 0x00A6
    72d0:	8e 77       	andi	r24, 0x7E	; 126
    72d2:	80 93 a6 00 	sts	0x00A6, r24
		  Pipe_ClearIN();

		*PacketLength = 0;
    72d6:	f8 01       	movw	r30, r16
    72d8:	11 82       	std	Z+1, r1	; 0x01
    72da:	10 82       	st	Z, r1
    72dc:	29 c0       	rjmp	.+82     	; 0x7330 <RNDIS_Host_ReadPacket+0xb8>
		return PIPE_RWSTREAM_NoError;
	}

	RNDIS_Packet_Message_t DeviceMessage;

	if ((ErrorCode = Pipe_Read_Stream_LE(&DeviceMessage, sizeof(RNDIS_Packet_Message_t),
    72de:	40 e0       	ldi	r20, 0x00	; 0
    72e0:	50 e0       	ldi	r21, 0x00	; 0
    72e2:	6c e2       	ldi	r22, 0x2C	; 44
    72e4:	70 e0       	ldi	r23, 0x00	; 0
    72e6:	ce 01       	movw	r24, r28
    72e8:	01 96       	adiw	r24, 0x01	; 1
    72ea:	0e 94 af 29 	call	0x535e	; 0x535e <Pipe_Read_Stream_LE>
    72ee:	81 11       	cpse	r24, r1
    72f0:	27 c0       	rjmp	.+78     	; 0x7340 <RNDIS_Host_ReadPacket+0xc8>
	                                     NULL)) != PIPE_RWSTREAM_NoError)
	{
		return ErrorCode;
	}

	*PacketLength = (uint16_t)le32_to_cpu(DeviceMessage.DataLength);
    72f2:	8d 85       	ldd	r24, Y+13	; 0x0d
    72f4:	9e 85       	ldd	r25, Y+14	; 0x0e
    72f6:	f8 01       	movw	r30, r16
    72f8:	91 83       	std	Z+1, r25	; 0x01
    72fa:	80 83       	st	Z, r24

	Pipe_Discard_Stream(le32_to_cpu(DeviceMessage.DataOffset) -
    72fc:	89 85       	ldd	r24, Y+9	; 0x09
    72fe:	9a 85       	ldd	r25, Y+10	; 0x0a
    7300:	60 e0       	ldi	r22, 0x00	; 0
    7302:	70 e0       	ldi	r23, 0x00	; 0
    7304:	84 97       	sbiw	r24, 0x24	; 36
    7306:	0e 94 1f 29 	call	0x523e	; 0x523e <Pipe_Discard_Stream>
	                    (sizeof(RNDIS_Packet_Message_t) - sizeof(RNDIS_Message_Header_t)),
	                    NULL);

	Pipe_Read_Stream_LE(Buffer, *PacketLength, NULL);
    730a:	f8 01       	movw	r30, r16
    730c:	60 81       	ld	r22, Z
    730e:	71 81       	ldd	r23, Z+1	; 0x01
    7310:	40 e0       	ldi	r20, 0x00	; 0
    7312:	50 e0       	ldi	r21, 0x00	; 0
    7314:	c7 01       	movw	r24, r14
    7316:	0e 94 af 29 	call	0x535e	; 0x535e <Pipe_Read_Stream_LE>
			 *  \return Total number of bytes in the currently selected pipe's FIFO buffer.
			 */
			static inline uint16_t Pipe_BytesInPipe(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Pipe_BytesInPipe(void)
			{
				return UPBCX;
    731a:	80 91 f6 00 	lds	r24, 0x00F6
    731e:	90 91 f7 00 	lds	r25, 0x00F7

	if (!(Pipe_BytesInPipe()))
    7322:	89 2b       	or	r24, r25
    7324:	29 f4       	brne	.+10     	; 0x7330 <RNDIS_Host_ReadPacket+0xb8>
			 *  \ingroup Group_PipePacketManagement_AVR8
			 */
			static inline void Pipe_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearIN(void)
			{
				UPINTX &= ~((1 << RXINI) | (1 << FIFOCON));
    7326:	80 91 a6 00 	lds	r24, 0x00A6
    732a:	8e 77       	andi	r24, 0x7E	; 126
    732c:	80 93 a6 00 	sts	0x00A6, r24

			/** Freezes the selected pipe, preventing it from communicating with an attached device. */
			static inline void Pipe_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Freeze(void)
			{
				UPCONX |= (1 << PFREEZE);
    7330:	80 91 a9 00 	lds	r24, 0x00A9
    7334:	80 64       	ori	r24, 0x40	; 64
    7336:	80 93 a9 00 	sts	0x00A9, r24
	  Pipe_ClearIN();

	Pipe_Freeze();

	return PIPE_RWSTREAM_NoError;
    733a:	80 e0       	ldi	r24, 0x00	; 0
    733c:	01 c0       	rjmp	.+2      	; 0x7340 <RNDIS_Host_ReadPacket+0xc8>
                              uint16_t* const PacketLength)
{
	uint8_t ErrorCode;

	if ((USB_HostState != HOST_STATE_Configured) || !(RNDISInterfaceInfo->State.IsActive))
	  return PIPE_READYWAIT_DeviceDisconnected;
    733e:	82 e0       	ldi	r24, 0x02	; 2
	  Pipe_ClearIN();

	Pipe_Freeze();

	return PIPE_RWSTREAM_NoError;
}
    7340:	ac 96       	adiw	r28, 0x2c	; 44
    7342:	0f b6       	in	r0, 0x3f	; 63
    7344:	f8 94       	cli
    7346:	de bf       	out	0x3e, r29	; 62
    7348:	0f be       	out	0x3f, r0	; 63
    734a:	cd bf       	out	0x3d, r28	; 61
    734c:	df 91       	pop	r29
    734e:	cf 91       	pop	r28
    7350:	1f 91       	pop	r17
    7352:	0f 91       	pop	r16
    7354:	ff 90       	pop	r15
    7356:	ef 90       	pop	r14
    7358:	08 95       	ret

0000735a <RNDIS_Host_SendPacket>:

uint8_t RNDIS_Host_SendPacket(USB_ClassInfo_RNDIS_Host_t* const RNDISInterfaceInfo,
                              void* Buffer,
                              const uint16_t PacketLength)
{
    735a:	cf 92       	push	r12
    735c:	df 92       	push	r13
    735e:	ef 92       	push	r14
    7360:	ff 92       	push	r15
    7362:	0f 93       	push	r16
    7364:	1f 93       	push	r17
    7366:	cf 93       	push	r28
    7368:	df 93       	push	r29
    736a:	cd b7       	in	r28, 0x3d	; 61
    736c:	de b7       	in	r29, 0x3e	; 62
    736e:	ac 97       	sbiw	r28, 0x2c	; 44
    7370:	0f b6       	in	r0, 0x3f	; 63
    7372:	f8 94       	cli
    7374:	de bf       	out	0x3e, r29	; 62
    7376:	0f be       	out	0x3f, r0	; 63
    7378:	cd bf       	out	0x3d, r28	; 61
    737a:	6b 01       	movw	r12, r22
    737c:	7a 01       	movw	r14, r20
	uint8_t ErrorCode;

	if ((USB_HostState != HOST_STATE_Configured) || !(RNDISInterfaceInfo->State.IsActive))
    737e:	2e b3       	in	r18, 0x1e	; 30
    7380:	2b 30       	cpi	r18, 0x0B	; 11
    7382:	09 f0       	breq	.+2      	; 0x7386 <RNDIS_Host_SendPacket+0x2c>
    7384:	53 c0       	rjmp	.+166    	; 0x742c <RNDIS_Host_SendPacket+0xd2>
    7386:	dc 01       	movw	r26, r24
    7388:	56 96       	adiw	r26, 0x16	; 22
    738a:	2c 91       	ld	r18, X
    738c:	22 23       	and	r18, r18
    738e:	09 f4       	brne	.+2      	; 0x7392 <RNDIS_Host_SendPacket+0x38>
    7390:	4d c0       	rjmp	.+154    	; 0x742c <RNDIS_Host_SendPacket+0xd2>
	  return PIPE_READYWAIT_DeviceDisconnected;

	RNDIS_Packet_Message_t DeviceMessage;

	memset(&DeviceMessage, 0, sizeof(RNDIS_Packet_Message_t));
    7392:	fe 01       	movw	r30, r28
    7394:	31 96       	adiw	r30, 0x01	; 1
    7396:	2c e2       	ldi	r18, 0x2C	; 44
    7398:	df 01       	movw	r26, r30
    739a:	1d 92       	st	X+, r1
    739c:	2a 95       	dec	r18
    739e:	e9 f7       	brne	.-6      	; 0x739a <RNDIS_Host_SendPacket+0x40>
	DeviceMessage.MessageType   = CPU_TO_LE32(REMOTE_NDIS_PACKET_MSG);
    73a0:	41 e0       	ldi	r20, 0x01	; 1
    73a2:	50 e0       	ldi	r21, 0x00	; 0
    73a4:	60 e0       	ldi	r22, 0x00	; 0
    73a6:	70 e0       	ldi	r23, 0x00	; 0
    73a8:	49 83       	std	Y+1, r20	; 0x01
    73aa:	5a 83       	std	Y+2, r21	; 0x02
    73ac:	6b 83       	std	Y+3, r22	; 0x03
    73ae:	7c 83       	std	Y+4, r23	; 0x04
	DeviceMessage.MessageLength = CPU_TO_LE32(sizeof(RNDIS_Packet_Message_t) + PacketLength);
    73b0:	a7 01       	movw	r20, r14
    73b2:	44 5d       	subi	r20, 0xD4	; 212
    73b4:	5f 4f       	sbci	r21, 0xFF	; 255
    73b6:	60 e0       	ldi	r22, 0x00	; 0
    73b8:	70 e0       	ldi	r23, 0x00	; 0
    73ba:	4d 83       	std	Y+5, r20	; 0x05
    73bc:	5e 83       	std	Y+6, r21	; 0x06
    73be:	6f 83       	std	Y+7, r22	; 0x07
    73c0:	78 87       	std	Y+8, r23	; 0x08
	DeviceMessage.DataOffset    = CPU_TO_LE32(sizeof(RNDIS_Packet_Message_t) - sizeof(RNDIS_Message_Header_t));
    73c2:	44 e2       	ldi	r20, 0x24	; 36
    73c4:	50 e0       	ldi	r21, 0x00	; 0
    73c6:	60 e0       	ldi	r22, 0x00	; 0
    73c8:	70 e0       	ldi	r23, 0x00	; 0
    73ca:	49 87       	std	Y+9, r20	; 0x09
    73cc:	5a 87       	std	Y+10, r21	; 0x0a
    73ce:	6b 87       	std	Y+11, r22	; 0x0b
    73d0:	7c 87       	std	Y+12, r23	; 0x0c
	DeviceMessage.DataLength    = cpu_to_le32(PacketLength);
    73d2:	87 01       	movw	r16, r14
    73d4:	20 e0       	ldi	r18, 0x00	; 0
    73d6:	30 e0       	ldi	r19, 0x00	; 0
    73d8:	0d 87       	std	Y+13, r16	; 0x0d
    73da:	1e 87       	std	Y+14, r17	; 0x0e
    73dc:	2f 87       	std	Y+15, r18	; 0x0f
    73de:	38 8b       	std	Y+16, r19	; 0x10
			 *  \param[in] Address  Address of the pipe to select.
			 */
			static inline void Pipe_SelectPipe(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SelectPipe(const uint8_t Address)
			{
				UPNUM = (Address & PIPE_PIPENUM_MASK);
    73e0:	dc 01       	movw	r26, r24
    73e2:	16 96       	adiw	r26, 0x06	; 6
    73e4:	8c 91       	ld	r24, X
    73e6:	8f 70       	andi	r24, 0x0F	; 15
    73e8:	80 93 a7 00 	sts	0x00A7, r24

			/** Unfreezes the selected pipe, allowing it to communicate with an attached device. */
			static inline void Pipe_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Unfreeze(void)
			{
				UPCONX &= ~(1 << PFREEZE);
    73ec:	80 91 a9 00 	lds	r24, 0x00A9
    73f0:	8f 7b       	andi	r24, 0xBF	; 191
    73f2:	80 93 a9 00 	sts	0x00A9, r24

	Pipe_SelectPipe(RNDISInterfaceInfo->Config.DataOUTPipe.Address);
	Pipe_Unfreeze();

	if ((ErrorCode = Pipe_Write_Stream_LE(&DeviceMessage, sizeof(RNDIS_Packet_Message_t),
    73f6:	40 e0       	ldi	r20, 0x00	; 0
    73f8:	50 e0       	ldi	r21, 0x00	; 0
    73fa:	6c e2       	ldi	r22, 0x2C	; 44
    73fc:	70 e0       	ldi	r23, 0x00	; 0
    73fe:	cf 01       	movw	r24, r30
    7400:	0e 94 62 29 	call	0x52c4	; 0x52c4 <Pipe_Write_Stream_LE>
    7404:	81 11       	cpse	r24, r1
    7406:	13 c0       	rjmp	.+38     	; 0x742e <RNDIS_Host_SendPacket+0xd4>
	                                      NULL)) != PIPE_RWSTREAM_NoError)
	{
		return ErrorCode;
	}

	Pipe_Write_Stream_LE(Buffer, PacketLength, NULL);
    7408:	40 e0       	ldi	r20, 0x00	; 0
    740a:	50 e0       	ldi	r21, 0x00	; 0
    740c:	b7 01       	movw	r22, r14
    740e:	c6 01       	movw	r24, r12
    7410:	0e 94 62 29 	call	0x52c4	; 0x52c4 <Pipe_Write_Stream_LE>
			 *  \ingroup Group_PipePacketManagement_AVR8
			 */
			static inline void Pipe_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearOUT(void)
			{
				UPINTX &= ~((1 << TXOUTI) | (1 << FIFOCON));
    7414:	80 91 a6 00 	lds	r24, 0x00A6
    7418:	8b 77       	andi	r24, 0x7B	; 123
    741a:	80 93 a6 00 	sts	0x00A6, r24

			/** Freezes the selected pipe, preventing it from communicating with an attached device. */
			static inline void Pipe_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Freeze(void)
			{
				UPCONX |= (1 << PFREEZE);
    741e:	80 91 a9 00 	lds	r24, 0x00A9
    7422:	80 64       	ori	r24, 0x40	; 64
    7424:	80 93 a9 00 	sts	0x00A9, r24
	Pipe_ClearOUT();

	Pipe_Freeze();

	return PIPE_RWSTREAM_NoError;
    7428:	80 e0       	ldi	r24, 0x00	; 0
    742a:	01 c0       	rjmp	.+2      	; 0x742e <RNDIS_Host_SendPacket+0xd4>
                              const uint16_t PacketLength)
{
	uint8_t ErrorCode;

	if ((USB_HostState != HOST_STATE_Configured) || !(RNDISInterfaceInfo->State.IsActive))
	  return PIPE_READYWAIT_DeviceDisconnected;
    742c:	82 e0       	ldi	r24, 0x02	; 2
	Pipe_ClearOUT();

	Pipe_Freeze();

	return PIPE_RWSTREAM_NoError;
}
    742e:	ac 96       	adiw	r28, 0x2c	; 44
    7430:	0f b6       	in	r0, 0x3f	; 63
    7432:	f8 94       	cli
    7434:	de bf       	out	0x3e, r29	; 62
    7436:	0f be       	out	0x3f, r0	; 63
    7438:	cd bf       	out	0x3d, r28	; 61
    743a:	df 91       	pop	r29
    743c:	cf 91       	pop	r28
    743e:	1f 91       	pop	r17
    7440:	0f 91       	pop	r16
    7442:	ff 90       	pop	r15
    7444:	ef 90       	pop	r14
    7446:	df 90       	pop	r13
    7448:	cf 90       	pop	r12
    744a:	08 95       	ret

0000744c <__umulhisi3>:
    744c:	a2 9f       	mul	r26, r18
    744e:	b0 01       	movw	r22, r0
    7450:	b3 9f       	mul	r27, r19
    7452:	c0 01       	movw	r24, r0
    7454:	a3 9f       	mul	r26, r19
    7456:	70 0d       	add	r23, r0
    7458:	81 1d       	adc	r24, r1
    745a:	11 24       	eor	r1, r1
    745c:	91 1d       	adc	r25, r1
    745e:	b2 9f       	mul	r27, r18
    7460:	70 0d       	add	r23, r0
    7462:	81 1d       	adc	r24, r1
    7464:	11 24       	eor	r1, r1
    7466:	91 1d       	adc	r25, r1
    7468:	08 95       	ret

0000746a <__muluhisi3>:
    746a:	f0 df       	rcall	.-32     	; 0x744c <__umulhisi3>
    746c:	a5 9f       	mul	r26, r21
    746e:	90 0d       	add	r25, r0
    7470:	b4 9f       	mul	r27, r20
    7472:	90 0d       	add	r25, r0
    7474:	a4 9f       	mul	r26, r20
    7476:	80 0d       	add	r24, r0
    7478:	91 1d       	adc	r25, r1
    747a:	11 24       	eor	r1, r1
    747c:	08 95       	ret

0000747e <__udivmodsi4>:
    747e:	a1 e2       	ldi	r26, 0x21	; 33
    7480:	1a 2e       	mov	r1, r26
    7482:	aa 1b       	sub	r26, r26
    7484:	bb 1b       	sub	r27, r27
    7486:	fd 01       	movw	r30, r26
    7488:	0d c0       	rjmp	.+26     	; 0x74a4 <__udivmodsi4_ep>

0000748a <__udivmodsi4_loop>:
    748a:	aa 1f       	adc	r26, r26
    748c:	bb 1f       	adc	r27, r27
    748e:	ee 1f       	adc	r30, r30
    7490:	ff 1f       	adc	r31, r31
    7492:	a2 17       	cp	r26, r18
    7494:	b3 07       	cpc	r27, r19
    7496:	e4 07       	cpc	r30, r20
    7498:	f5 07       	cpc	r31, r21
    749a:	20 f0       	brcs	.+8      	; 0x74a4 <__udivmodsi4_ep>
    749c:	a2 1b       	sub	r26, r18
    749e:	b3 0b       	sbc	r27, r19
    74a0:	e4 0b       	sbc	r30, r20
    74a2:	f5 0b       	sbc	r31, r21

000074a4 <__udivmodsi4_ep>:
    74a4:	66 1f       	adc	r22, r22
    74a6:	77 1f       	adc	r23, r23
    74a8:	88 1f       	adc	r24, r24
    74aa:	99 1f       	adc	r25, r25
    74ac:	1a 94       	dec	r1
    74ae:	69 f7       	brne	.-38     	; 0x748a <__udivmodsi4_loop>
    74b0:	60 95       	com	r22
    74b2:	70 95       	com	r23
    74b4:	80 95       	com	r24
    74b6:	90 95       	com	r25
    74b8:	9b 01       	movw	r18, r22
    74ba:	ac 01       	movw	r20, r24
    74bc:	bd 01       	movw	r22, r26
    74be:	cf 01       	movw	r24, r30
    74c0:	08 95       	ret

000074c2 <memcpy_P>:
    74c2:	fb 01       	movw	r30, r22
    74c4:	dc 01       	movw	r26, r24
    74c6:	02 c0       	rjmp	.+4      	; 0x74cc <memcpy_P+0xa>
    74c8:	05 90       	lpm	r0, Z+
    74ca:	0d 92       	st	X+, r0
    74cc:	41 50       	subi	r20, 0x01	; 1
    74ce:	50 40       	sbci	r21, 0x00	; 0
    74d0:	d8 f7       	brcc	.-10     	; 0x74c8 <memcpy_P+0x6>
    74d2:	08 95       	ret

000074d4 <strcat_P>:
    74d4:	fb 01       	movw	r30, r22
    74d6:	dc 01       	movw	r26, r24
    74d8:	0d 90       	ld	r0, X+
    74da:	00 20       	and	r0, r0
    74dc:	e9 f7       	brne	.-6      	; 0x74d8 <strcat_P+0x4>
    74de:	11 97       	sbiw	r26, 0x01	; 1
    74e0:	05 90       	lpm	r0, Z+
    74e2:	0d 92       	st	X+, r0
    74e4:	00 20       	and	r0, r0
    74e6:	e1 f7       	brne	.-8      	; 0x74e0 <strcat_P+0xc>
    74e8:	08 95       	ret

000074ea <strcmp_P>:
    74ea:	fb 01       	movw	r30, r22
    74ec:	dc 01       	movw	r26, r24
    74ee:	8d 91       	ld	r24, X+
    74f0:	05 90       	lpm	r0, Z+
    74f2:	80 19       	sub	r24, r0
    74f4:	01 10       	cpse	r0, r1
    74f6:	d9 f3       	breq	.-10     	; 0x74ee <strcmp_P+0x4>
    74f8:	99 0b       	sbc	r25, r25
    74fa:	08 95       	ret

000074fc <strcpy_P>:
    74fc:	fb 01       	movw	r30, r22
    74fe:	dc 01       	movw	r26, r24
    7500:	05 90       	lpm	r0, Z+
    7502:	0d 92       	st	X+, r0
    7504:	00 20       	and	r0, r0
    7506:	e1 f7       	brne	.-8      	; 0x7500 <strcpy_P+0x4>
    7508:	08 95       	ret

0000750a <strlcpy_P>:
    750a:	dc 01       	movw	r26, r24
    750c:	fb 01       	movw	r30, r22
    750e:	41 50       	subi	r20, 0x01	; 1
    7510:	50 40       	sbci	r21, 0x00	; 0
    7512:	58 f0       	brcs	.+22     	; 0x752a <strlcpy_P+0x20>
    7514:	49 f0       	breq	.+18     	; 0x7528 <strlcpy_P+0x1e>
    7516:	05 90       	lpm	r0, Z+
    7518:	0d 92       	st	X+, r0
    751a:	00 20       	and	r0, r0
    751c:	c1 f7       	brne	.-16     	; 0x750e <strlcpy_P+0x4>
    751e:	e6 1b       	sub	r30, r22
    7520:	f7 0b       	sbc	r31, r23
    7522:	31 97       	sbiw	r30, 0x01	; 1
    7524:	cf 01       	movw	r24, r30
    7526:	08 95       	ret
    7528:	1c 92       	st	X, r1
    752a:	05 90       	lpm	r0, Z+
    752c:	00 20       	and	r0, r0
    752e:	e9 f7       	brne	.-6      	; 0x752a <strlcpy_P+0x20>
    7530:	f6 cf       	rjmp	.-20     	; 0x751e <strlcpy_P+0x14>

00007532 <strtok>:
    7532:	48 e0       	ldi	r20, 0x08	; 8
    7534:	54 e0       	ldi	r21, 0x04	; 4
    7536:	43 c0       	rjmp	.+134    	; 0x75be <strtok_r>

00007538 <memcpy>:
    7538:	fb 01       	movw	r30, r22
    753a:	dc 01       	movw	r26, r24
    753c:	02 c0       	rjmp	.+4      	; 0x7542 <memcpy+0xa>
    753e:	01 90       	ld	r0, Z+
    7540:	0d 92       	st	X+, r0
    7542:	41 50       	subi	r20, 0x01	; 1
    7544:	50 40       	sbci	r21, 0x00	; 0
    7546:	d8 f7       	brcc	.-10     	; 0x753e <memcpy+0x6>
    7548:	08 95       	ret

0000754a <memset>:
    754a:	dc 01       	movw	r26, r24
    754c:	01 c0       	rjmp	.+2      	; 0x7550 <memset+0x6>
    754e:	6d 93       	st	X+, r22
    7550:	41 50       	subi	r20, 0x01	; 1
    7552:	50 40       	sbci	r21, 0x00	; 0
    7554:	e0 f7       	brcc	.-8      	; 0x754e <memset+0x4>
    7556:	08 95       	ret

00007558 <strcat>:
    7558:	fb 01       	movw	r30, r22
    755a:	dc 01       	movw	r26, r24
    755c:	0d 90       	ld	r0, X+
    755e:	00 20       	and	r0, r0
    7560:	e9 f7       	brne	.-6      	; 0x755c <strcat+0x4>
    7562:	11 97       	sbiw	r26, 0x01	; 1
    7564:	01 90       	ld	r0, Z+
    7566:	0d 92       	st	X+, r0
    7568:	00 20       	and	r0, r0
    756a:	e1 f7       	brne	.-8      	; 0x7564 <strcat+0xc>
    756c:	08 95       	ret

0000756e <strchr>:
    756e:	fc 01       	movw	r30, r24
    7570:	81 91       	ld	r24, Z+
    7572:	86 17       	cp	r24, r22
    7574:	21 f0       	breq	.+8      	; 0x757e <strchr+0x10>
    7576:	88 23       	and	r24, r24
    7578:	d9 f7       	brne	.-10     	; 0x7570 <strchr+0x2>
    757a:	99 27       	eor	r25, r25
    757c:	08 95       	ret
    757e:	31 97       	sbiw	r30, 0x01	; 1
    7580:	cf 01       	movw	r24, r30
    7582:	08 95       	ret

00007584 <strcmp>:
    7584:	fb 01       	movw	r30, r22
    7586:	dc 01       	movw	r26, r24
    7588:	8d 91       	ld	r24, X+
    758a:	01 90       	ld	r0, Z+
    758c:	80 19       	sub	r24, r0
    758e:	01 10       	cpse	r0, r1
    7590:	d9 f3       	breq	.-10     	; 0x7588 <strcmp+0x4>
    7592:	99 0b       	sbc	r25, r25
    7594:	08 95       	ret

00007596 <strlcpy>:
    7596:	dc 01       	movw	r26, r24
    7598:	fb 01       	movw	r30, r22
    759a:	41 50       	subi	r20, 0x01	; 1
    759c:	50 40       	sbci	r21, 0x00	; 0
    759e:	58 f0       	brcs	.+22     	; 0x75b6 <strlcpy+0x20>
    75a0:	49 f0       	breq	.+18     	; 0x75b4 <strlcpy+0x1e>
    75a2:	01 90       	ld	r0, Z+
    75a4:	0d 92       	st	X+, r0
    75a6:	00 20       	and	r0, r0
    75a8:	c1 f7       	brne	.-16     	; 0x759a <strlcpy+0x4>
    75aa:	e6 1b       	sub	r30, r22
    75ac:	f7 0b       	sbc	r31, r23
    75ae:	31 97       	sbiw	r30, 0x01	; 1
    75b0:	cf 01       	movw	r24, r30
    75b2:	08 95       	ret
    75b4:	1c 92       	st	X, r1
    75b6:	01 90       	ld	r0, Z+
    75b8:	00 20       	and	r0, r0
    75ba:	e9 f7       	brne	.-6      	; 0x75b6 <strlcpy+0x20>
    75bc:	f6 cf       	rjmp	.-20     	; 0x75aa <strlcpy+0x14>

000075be <strtok_r>:
    75be:	fa 01       	movw	r30, r20
    75c0:	a1 91       	ld	r26, Z+
    75c2:	b0 81       	ld	r27, Z
    75c4:	00 97       	sbiw	r24, 0x00	; 0
    75c6:	19 f4       	brne	.+6      	; 0x75ce <strtok_r+0x10>
    75c8:	10 97       	sbiw	r26, 0x00	; 0
    75ca:	e1 f0       	breq	.+56     	; 0x7604 <strtok_r+0x46>
    75cc:	cd 01       	movw	r24, r26
    75ce:	dc 01       	movw	r26, r24
    75d0:	cd 01       	movw	r24, r26
    75d2:	0d 90       	ld	r0, X+
    75d4:	00 20       	and	r0, r0
    75d6:	11 f4       	brne	.+4      	; 0x75dc <strtok_r+0x1e>
    75d8:	c0 01       	movw	r24, r0
    75da:	13 c0       	rjmp	.+38     	; 0x7602 <strtok_r+0x44>
    75dc:	fb 01       	movw	r30, r22
    75de:	21 91       	ld	r18, Z+
    75e0:	22 23       	and	r18, r18
    75e2:	19 f0       	breq	.+6      	; 0x75ea <strtok_r+0x2c>
    75e4:	20 15       	cp	r18, r0
    75e6:	d9 f7       	brne	.-10     	; 0x75de <strtok_r+0x20>
    75e8:	f3 cf       	rjmp	.-26     	; 0x75d0 <strtok_r+0x12>
    75ea:	fb 01       	movw	r30, r22
    75ec:	21 91       	ld	r18, Z+
    75ee:	20 15       	cp	r18, r0
    75f0:	19 f4       	brne	.+6      	; 0x75f8 <strtok_r+0x3a>
    75f2:	1e 92       	st	-X, r1
    75f4:	11 96       	adiw	r26, 0x01	; 1
    75f6:	06 c0       	rjmp	.+12     	; 0x7604 <strtok_r+0x46>
    75f8:	22 23       	and	r18, r18
    75fa:	c1 f7       	brne	.-16     	; 0x75ec <strtok_r+0x2e>
    75fc:	0d 90       	ld	r0, X+
    75fe:	00 20       	and	r0, r0
    7600:	a1 f7       	brne	.-24     	; 0x75ea <strtok_r+0x2c>
    7602:	d0 01       	movw	r26, r0
    7604:	fa 01       	movw	r30, r20
    7606:	a1 93       	st	Z+, r26
    7608:	b0 83       	st	Z, r27
    760a:	08 95       	ret

0000760c <sprintf_P>:
    760c:	0f 93       	push	r16
    760e:	1f 93       	push	r17
    7610:	cf 93       	push	r28
    7612:	df 93       	push	r29
    7614:	cd b7       	in	r28, 0x3d	; 61
    7616:	de b7       	in	r29, 0x3e	; 62
    7618:	2e 97       	sbiw	r28, 0x0e	; 14
    761a:	0f b6       	in	r0, 0x3f	; 63
    761c:	f8 94       	cli
    761e:	de bf       	out	0x3e, r29	; 62
    7620:	0f be       	out	0x3f, r0	; 63
    7622:	cd bf       	out	0x3d, r28	; 61
    7624:	0d 89       	ldd	r16, Y+21	; 0x15
    7626:	1e 89       	ldd	r17, Y+22	; 0x16
    7628:	8e e0       	ldi	r24, 0x0E	; 14
    762a:	8c 83       	std	Y+4, r24	; 0x04
    762c:	1a 83       	std	Y+2, r17	; 0x02
    762e:	09 83       	std	Y+1, r16	; 0x01
    7630:	8f ef       	ldi	r24, 0xFF	; 255
    7632:	9f e7       	ldi	r25, 0x7F	; 127
    7634:	9e 83       	std	Y+6, r25	; 0x06
    7636:	8d 83       	std	Y+5, r24	; 0x05
    7638:	ae 01       	movw	r20, r28
    763a:	47 5e       	subi	r20, 0xE7	; 231
    763c:	5f 4f       	sbci	r21, 0xFF	; 255
    763e:	6f 89       	ldd	r22, Y+23	; 0x17
    7640:	78 8d       	ldd	r23, Y+24	; 0x18
    7642:	ce 01       	movw	r24, r28
    7644:	01 96       	adiw	r24, 0x01	; 1
    7646:	10 d0       	rcall	.+32     	; 0x7668 <vfprintf>
    7648:	ef 81       	ldd	r30, Y+7	; 0x07
    764a:	f8 85       	ldd	r31, Y+8	; 0x08
    764c:	e0 0f       	add	r30, r16
    764e:	f1 1f       	adc	r31, r17
    7650:	10 82       	st	Z, r1
    7652:	2e 96       	adiw	r28, 0x0e	; 14
    7654:	0f b6       	in	r0, 0x3f	; 63
    7656:	f8 94       	cli
    7658:	de bf       	out	0x3e, r29	; 62
    765a:	0f be       	out	0x3f, r0	; 63
    765c:	cd bf       	out	0x3d, r28	; 61
    765e:	df 91       	pop	r29
    7660:	cf 91       	pop	r28
    7662:	1f 91       	pop	r17
    7664:	0f 91       	pop	r16
    7666:	08 95       	ret

00007668 <vfprintf>:
    7668:	2f 92       	push	r2
    766a:	3f 92       	push	r3
    766c:	4f 92       	push	r4
    766e:	5f 92       	push	r5
    7670:	6f 92       	push	r6
    7672:	7f 92       	push	r7
    7674:	8f 92       	push	r8
    7676:	9f 92       	push	r9
    7678:	af 92       	push	r10
    767a:	bf 92       	push	r11
    767c:	cf 92       	push	r12
    767e:	df 92       	push	r13
    7680:	ef 92       	push	r14
    7682:	ff 92       	push	r15
    7684:	0f 93       	push	r16
    7686:	1f 93       	push	r17
    7688:	cf 93       	push	r28
    768a:	df 93       	push	r29
    768c:	cd b7       	in	r28, 0x3d	; 61
    768e:	de b7       	in	r29, 0x3e	; 62
    7690:	2c 97       	sbiw	r28, 0x0c	; 12
    7692:	0f b6       	in	r0, 0x3f	; 63
    7694:	f8 94       	cli
    7696:	de bf       	out	0x3e, r29	; 62
    7698:	0f be       	out	0x3f, r0	; 63
    769a:	cd bf       	out	0x3d, r28	; 61
    769c:	7c 01       	movw	r14, r24
    769e:	6b 01       	movw	r12, r22
    76a0:	8a 01       	movw	r16, r20
    76a2:	fc 01       	movw	r30, r24
    76a4:	17 82       	std	Z+7, r1	; 0x07
    76a6:	16 82       	std	Z+6, r1	; 0x06
    76a8:	83 81       	ldd	r24, Z+3	; 0x03
    76aa:	81 ff       	sbrs	r24, 1
    76ac:	b0 c1       	rjmp	.+864    	; 0x7a0e <vfprintf+0x3a6>
    76ae:	ce 01       	movw	r24, r28
    76b0:	01 96       	adiw	r24, 0x01	; 1
    76b2:	4c 01       	movw	r8, r24
    76b4:	f7 01       	movw	r30, r14
    76b6:	93 81       	ldd	r25, Z+3	; 0x03
    76b8:	f6 01       	movw	r30, r12
    76ba:	93 fd       	sbrc	r25, 3
    76bc:	85 91       	lpm	r24, Z+
    76be:	93 ff       	sbrs	r25, 3
    76c0:	81 91       	ld	r24, Z+
    76c2:	6f 01       	movw	r12, r30
    76c4:	88 23       	and	r24, r24
    76c6:	09 f4       	brne	.+2      	; 0x76ca <vfprintf+0x62>
    76c8:	9e c1       	rjmp	.+828    	; 0x7a06 <vfprintf+0x39e>
    76ca:	85 32       	cpi	r24, 0x25	; 37
    76cc:	39 f4       	brne	.+14     	; 0x76dc <vfprintf+0x74>
    76ce:	93 fd       	sbrc	r25, 3
    76d0:	85 91       	lpm	r24, Z+
    76d2:	93 ff       	sbrs	r25, 3
    76d4:	81 91       	ld	r24, Z+
    76d6:	6f 01       	movw	r12, r30
    76d8:	85 32       	cpi	r24, 0x25	; 37
    76da:	21 f4       	brne	.+8      	; 0x76e4 <vfprintf+0x7c>
    76dc:	b7 01       	movw	r22, r14
    76de:	90 e0       	ldi	r25, 0x00	; 0
    76e0:	c7 d1       	rcall	.+910    	; 0x7a70 <fputc>
    76e2:	e8 cf       	rjmp	.-48     	; 0x76b4 <vfprintf+0x4c>
    76e4:	51 2c       	mov	r5, r1
    76e6:	31 2c       	mov	r3, r1
    76e8:	20 e0       	ldi	r18, 0x00	; 0
    76ea:	20 32       	cpi	r18, 0x20	; 32
    76ec:	a0 f4       	brcc	.+40     	; 0x7716 <vfprintf+0xae>
    76ee:	8b 32       	cpi	r24, 0x2B	; 43
    76f0:	69 f0       	breq	.+26     	; 0x770c <vfprintf+0xa4>
    76f2:	30 f4       	brcc	.+12     	; 0x7700 <vfprintf+0x98>
    76f4:	80 32       	cpi	r24, 0x20	; 32
    76f6:	59 f0       	breq	.+22     	; 0x770e <vfprintf+0xa6>
    76f8:	83 32       	cpi	r24, 0x23	; 35
    76fa:	69 f4       	brne	.+26     	; 0x7716 <vfprintf+0xae>
    76fc:	20 61       	ori	r18, 0x10	; 16
    76fe:	2c c0       	rjmp	.+88     	; 0x7758 <vfprintf+0xf0>
    7700:	8d 32       	cpi	r24, 0x2D	; 45
    7702:	39 f0       	breq	.+14     	; 0x7712 <vfprintf+0xaa>
    7704:	80 33       	cpi	r24, 0x30	; 48
    7706:	39 f4       	brne	.+14     	; 0x7716 <vfprintf+0xae>
    7708:	21 60       	ori	r18, 0x01	; 1
    770a:	26 c0       	rjmp	.+76     	; 0x7758 <vfprintf+0xf0>
    770c:	22 60       	ori	r18, 0x02	; 2
    770e:	24 60       	ori	r18, 0x04	; 4
    7710:	23 c0       	rjmp	.+70     	; 0x7758 <vfprintf+0xf0>
    7712:	28 60       	ori	r18, 0x08	; 8
    7714:	21 c0       	rjmp	.+66     	; 0x7758 <vfprintf+0xf0>
    7716:	27 fd       	sbrc	r18, 7
    7718:	27 c0       	rjmp	.+78     	; 0x7768 <vfprintf+0x100>
    771a:	30 ed       	ldi	r19, 0xD0	; 208
    771c:	38 0f       	add	r19, r24
    771e:	3a 30       	cpi	r19, 0x0A	; 10
    7720:	78 f4       	brcc	.+30     	; 0x7740 <vfprintf+0xd8>
    7722:	26 ff       	sbrs	r18, 6
    7724:	06 c0       	rjmp	.+12     	; 0x7732 <vfprintf+0xca>
    7726:	fa e0       	ldi	r31, 0x0A	; 10
    7728:	5f 9e       	mul	r5, r31
    772a:	30 0d       	add	r19, r0
    772c:	11 24       	eor	r1, r1
    772e:	53 2e       	mov	r5, r19
    7730:	13 c0       	rjmp	.+38     	; 0x7758 <vfprintf+0xf0>
    7732:	8a e0       	ldi	r24, 0x0A	; 10
    7734:	38 9e       	mul	r3, r24
    7736:	30 0d       	add	r19, r0
    7738:	11 24       	eor	r1, r1
    773a:	33 2e       	mov	r3, r19
    773c:	20 62       	ori	r18, 0x20	; 32
    773e:	0c c0       	rjmp	.+24     	; 0x7758 <vfprintf+0xf0>
    7740:	8e 32       	cpi	r24, 0x2E	; 46
    7742:	21 f4       	brne	.+8      	; 0x774c <vfprintf+0xe4>
    7744:	26 fd       	sbrc	r18, 6
    7746:	5f c1       	rjmp	.+702    	; 0x7a06 <vfprintf+0x39e>
    7748:	20 64       	ori	r18, 0x40	; 64
    774a:	06 c0       	rjmp	.+12     	; 0x7758 <vfprintf+0xf0>
    774c:	8c 36       	cpi	r24, 0x6C	; 108
    774e:	11 f4       	brne	.+4      	; 0x7754 <vfprintf+0xec>
    7750:	20 68       	ori	r18, 0x80	; 128
    7752:	02 c0       	rjmp	.+4      	; 0x7758 <vfprintf+0xf0>
    7754:	88 36       	cpi	r24, 0x68	; 104
    7756:	41 f4       	brne	.+16     	; 0x7768 <vfprintf+0x100>
    7758:	f6 01       	movw	r30, r12
    775a:	93 fd       	sbrc	r25, 3
    775c:	85 91       	lpm	r24, Z+
    775e:	93 ff       	sbrs	r25, 3
    7760:	81 91       	ld	r24, Z+
    7762:	6f 01       	movw	r12, r30
    7764:	81 11       	cpse	r24, r1
    7766:	c1 cf       	rjmp	.-126    	; 0x76ea <vfprintf+0x82>
    7768:	98 2f       	mov	r25, r24
    776a:	9f 7d       	andi	r25, 0xDF	; 223
    776c:	95 54       	subi	r25, 0x45	; 69
    776e:	93 30       	cpi	r25, 0x03	; 3
    7770:	28 f4       	brcc	.+10     	; 0x777c <vfprintf+0x114>
    7772:	0c 5f       	subi	r16, 0xFC	; 252
    7774:	1f 4f       	sbci	r17, 0xFF	; 255
    7776:	ff e3       	ldi	r31, 0x3F	; 63
    7778:	f9 83       	std	Y+1, r31	; 0x01
    777a:	0d c0       	rjmp	.+26     	; 0x7796 <vfprintf+0x12e>
    777c:	83 36       	cpi	r24, 0x63	; 99
    777e:	31 f0       	breq	.+12     	; 0x778c <vfprintf+0x124>
    7780:	83 37       	cpi	r24, 0x73	; 115
    7782:	71 f0       	breq	.+28     	; 0x77a0 <vfprintf+0x138>
    7784:	83 35       	cpi	r24, 0x53	; 83
    7786:	09 f0       	breq	.+2      	; 0x778a <vfprintf+0x122>
    7788:	57 c0       	rjmp	.+174    	; 0x7838 <vfprintf+0x1d0>
    778a:	21 c0       	rjmp	.+66     	; 0x77ce <vfprintf+0x166>
    778c:	f8 01       	movw	r30, r16
    778e:	80 81       	ld	r24, Z
    7790:	89 83       	std	Y+1, r24	; 0x01
    7792:	0e 5f       	subi	r16, 0xFE	; 254
    7794:	1f 4f       	sbci	r17, 0xFF	; 255
    7796:	44 24       	eor	r4, r4
    7798:	43 94       	inc	r4
    779a:	51 2c       	mov	r5, r1
    779c:	54 01       	movw	r10, r8
    779e:	14 c0       	rjmp	.+40     	; 0x77c8 <vfprintf+0x160>
    77a0:	38 01       	movw	r6, r16
    77a2:	f2 e0       	ldi	r31, 0x02	; 2
    77a4:	6f 0e       	add	r6, r31
    77a6:	71 1c       	adc	r7, r1
    77a8:	f8 01       	movw	r30, r16
    77aa:	a0 80       	ld	r10, Z
    77ac:	b1 80       	ldd	r11, Z+1	; 0x01
    77ae:	26 ff       	sbrs	r18, 6
    77b0:	03 c0       	rjmp	.+6      	; 0x77b8 <vfprintf+0x150>
    77b2:	65 2d       	mov	r22, r5
    77b4:	70 e0       	ldi	r23, 0x00	; 0
    77b6:	02 c0       	rjmp	.+4      	; 0x77bc <vfprintf+0x154>
    77b8:	6f ef       	ldi	r22, 0xFF	; 255
    77ba:	7f ef       	ldi	r23, 0xFF	; 255
    77bc:	c5 01       	movw	r24, r10
    77be:	2c 87       	std	Y+12, r18	; 0x0c
    77c0:	4c d1       	rcall	.+664    	; 0x7a5a <strnlen>
    77c2:	2c 01       	movw	r4, r24
    77c4:	83 01       	movw	r16, r6
    77c6:	2c 85       	ldd	r18, Y+12	; 0x0c
    77c8:	2f 77       	andi	r18, 0x7F	; 127
    77ca:	22 2e       	mov	r2, r18
    77cc:	16 c0       	rjmp	.+44     	; 0x77fa <vfprintf+0x192>
    77ce:	38 01       	movw	r6, r16
    77d0:	f2 e0       	ldi	r31, 0x02	; 2
    77d2:	6f 0e       	add	r6, r31
    77d4:	71 1c       	adc	r7, r1
    77d6:	f8 01       	movw	r30, r16
    77d8:	a0 80       	ld	r10, Z
    77da:	b1 80       	ldd	r11, Z+1	; 0x01
    77dc:	26 ff       	sbrs	r18, 6
    77de:	03 c0       	rjmp	.+6      	; 0x77e6 <vfprintf+0x17e>
    77e0:	65 2d       	mov	r22, r5
    77e2:	70 e0       	ldi	r23, 0x00	; 0
    77e4:	02 c0       	rjmp	.+4      	; 0x77ea <vfprintf+0x182>
    77e6:	6f ef       	ldi	r22, 0xFF	; 255
    77e8:	7f ef       	ldi	r23, 0xFF	; 255
    77ea:	c5 01       	movw	r24, r10
    77ec:	2c 87       	std	Y+12, r18	; 0x0c
    77ee:	2a d1       	rcall	.+596    	; 0x7a44 <strnlen_P>
    77f0:	2c 01       	movw	r4, r24
    77f2:	2c 85       	ldd	r18, Y+12	; 0x0c
    77f4:	20 68       	ori	r18, 0x80	; 128
    77f6:	22 2e       	mov	r2, r18
    77f8:	83 01       	movw	r16, r6
    77fa:	23 fc       	sbrc	r2, 3
    77fc:	19 c0       	rjmp	.+50     	; 0x7830 <vfprintf+0x1c8>
    77fe:	83 2d       	mov	r24, r3
    7800:	90 e0       	ldi	r25, 0x00	; 0
    7802:	48 16       	cp	r4, r24
    7804:	59 06       	cpc	r5, r25
    7806:	a0 f4       	brcc	.+40     	; 0x7830 <vfprintf+0x1c8>
    7808:	b7 01       	movw	r22, r14
    780a:	80 e2       	ldi	r24, 0x20	; 32
    780c:	90 e0       	ldi	r25, 0x00	; 0
    780e:	30 d1       	rcall	.+608    	; 0x7a70 <fputc>
    7810:	3a 94       	dec	r3
    7812:	f5 cf       	rjmp	.-22     	; 0x77fe <vfprintf+0x196>
    7814:	f5 01       	movw	r30, r10
    7816:	27 fc       	sbrc	r2, 7
    7818:	85 91       	lpm	r24, Z+
    781a:	27 fe       	sbrs	r2, 7
    781c:	81 91       	ld	r24, Z+
    781e:	5f 01       	movw	r10, r30
    7820:	b7 01       	movw	r22, r14
    7822:	90 e0       	ldi	r25, 0x00	; 0
    7824:	25 d1       	rcall	.+586    	; 0x7a70 <fputc>
    7826:	31 10       	cpse	r3, r1
    7828:	3a 94       	dec	r3
    782a:	f1 e0       	ldi	r31, 0x01	; 1
    782c:	4f 1a       	sub	r4, r31
    782e:	51 08       	sbc	r5, r1
    7830:	41 14       	cp	r4, r1
    7832:	51 04       	cpc	r5, r1
    7834:	79 f7       	brne	.-34     	; 0x7814 <vfprintf+0x1ac>
    7836:	de c0       	rjmp	.+444    	; 0x79f4 <vfprintf+0x38c>
    7838:	84 36       	cpi	r24, 0x64	; 100
    783a:	11 f0       	breq	.+4      	; 0x7840 <vfprintf+0x1d8>
    783c:	89 36       	cpi	r24, 0x69	; 105
    783e:	31 f5       	brne	.+76     	; 0x788c <vfprintf+0x224>
    7840:	f8 01       	movw	r30, r16
    7842:	27 ff       	sbrs	r18, 7
    7844:	07 c0       	rjmp	.+14     	; 0x7854 <vfprintf+0x1ec>
    7846:	60 81       	ld	r22, Z
    7848:	71 81       	ldd	r23, Z+1	; 0x01
    784a:	82 81       	ldd	r24, Z+2	; 0x02
    784c:	93 81       	ldd	r25, Z+3	; 0x03
    784e:	0c 5f       	subi	r16, 0xFC	; 252
    7850:	1f 4f       	sbci	r17, 0xFF	; 255
    7852:	08 c0       	rjmp	.+16     	; 0x7864 <vfprintf+0x1fc>
    7854:	60 81       	ld	r22, Z
    7856:	71 81       	ldd	r23, Z+1	; 0x01
    7858:	88 27       	eor	r24, r24
    785a:	77 fd       	sbrc	r23, 7
    785c:	80 95       	com	r24
    785e:	98 2f       	mov	r25, r24
    7860:	0e 5f       	subi	r16, 0xFE	; 254
    7862:	1f 4f       	sbci	r17, 0xFF	; 255
    7864:	2f 76       	andi	r18, 0x6F	; 111
    7866:	b2 2e       	mov	r11, r18
    7868:	97 ff       	sbrs	r25, 7
    786a:	09 c0       	rjmp	.+18     	; 0x787e <vfprintf+0x216>
    786c:	90 95       	com	r25
    786e:	80 95       	com	r24
    7870:	70 95       	com	r23
    7872:	61 95       	neg	r22
    7874:	7f 4f       	sbci	r23, 0xFF	; 255
    7876:	8f 4f       	sbci	r24, 0xFF	; 255
    7878:	9f 4f       	sbci	r25, 0xFF	; 255
    787a:	20 68       	ori	r18, 0x80	; 128
    787c:	b2 2e       	mov	r11, r18
    787e:	2a e0       	ldi	r18, 0x0A	; 10
    7880:	30 e0       	ldi	r19, 0x00	; 0
    7882:	a4 01       	movw	r20, r8
    7884:	27 d1       	rcall	.+590    	; 0x7ad4 <__ultoa_invert>
    7886:	a8 2e       	mov	r10, r24
    7888:	a8 18       	sub	r10, r8
    788a:	43 c0       	rjmp	.+134    	; 0x7912 <vfprintf+0x2aa>
    788c:	85 37       	cpi	r24, 0x75	; 117
    788e:	29 f4       	brne	.+10     	; 0x789a <vfprintf+0x232>
    7890:	2f 7e       	andi	r18, 0xEF	; 239
    7892:	b2 2e       	mov	r11, r18
    7894:	2a e0       	ldi	r18, 0x0A	; 10
    7896:	30 e0       	ldi	r19, 0x00	; 0
    7898:	25 c0       	rjmp	.+74     	; 0x78e4 <vfprintf+0x27c>
    789a:	f2 2f       	mov	r31, r18
    789c:	f9 7f       	andi	r31, 0xF9	; 249
    789e:	bf 2e       	mov	r11, r31
    78a0:	8f 36       	cpi	r24, 0x6F	; 111
    78a2:	c1 f0       	breq	.+48     	; 0x78d4 <vfprintf+0x26c>
    78a4:	18 f4       	brcc	.+6      	; 0x78ac <vfprintf+0x244>
    78a6:	88 35       	cpi	r24, 0x58	; 88
    78a8:	79 f0       	breq	.+30     	; 0x78c8 <vfprintf+0x260>
    78aa:	ad c0       	rjmp	.+346    	; 0x7a06 <vfprintf+0x39e>
    78ac:	80 37       	cpi	r24, 0x70	; 112
    78ae:	19 f0       	breq	.+6      	; 0x78b6 <vfprintf+0x24e>
    78b0:	88 37       	cpi	r24, 0x78	; 120
    78b2:	21 f0       	breq	.+8      	; 0x78bc <vfprintf+0x254>
    78b4:	a8 c0       	rjmp	.+336    	; 0x7a06 <vfprintf+0x39e>
    78b6:	2f 2f       	mov	r18, r31
    78b8:	20 61       	ori	r18, 0x10	; 16
    78ba:	b2 2e       	mov	r11, r18
    78bc:	b4 fe       	sbrs	r11, 4
    78be:	0d c0       	rjmp	.+26     	; 0x78da <vfprintf+0x272>
    78c0:	8b 2d       	mov	r24, r11
    78c2:	84 60       	ori	r24, 0x04	; 4
    78c4:	b8 2e       	mov	r11, r24
    78c6:	09 c0       	rjmp	.+18     	; 0x78da <vfprintf+0x272>
    78c8:	24 ff       	sbrs	r18, 4
    78ca:	0a c0       	rjmp	.+20     	; 0x78e0 <vfprintf+0x278>
    78cc:	9f 2f       	mov	r25, r31
    78ce:	96 60       	ori	r25, 0x06	; 6
    78d0:	b9 2e       	mov	r11, r25
    78d2:	06 c0       	rjmp	.+12     	; 0x78e0 <vfprintf+0x278>
    78d4:	28 e0       	ldi	r18, 0x08	; 8
    78d6:	30 e0       	ldi	r19, 0x00	; 0
    78d8:	05 c0       	rjmp	.+10     	; 0x78e4 <vfprintf+0x27c>
    78da:	20 e1       	ldi	r18, 0x10	; 16
    78dc:	30 e0       	ldi	r19, 0x00	; 0
    78de:	02 c0       	rjmp	.+4      	; 0x78e4 <vfprintf+0x27c>
    78e0:	20 e1       	ldi	r18, 0x10	; 16
    78e2:	32 e0       	ldi	r19, 0x02	; 2
    78e4:	f8 01       	movw	r30, r16
    78e6:	b7 fe       	sbrs	r11, 7
    78e8:	07 c0       	rjmp	.+14     	; 0x78f8 <vfprintf+0x290>
    78ea:	60 81       	ld	r22, Z
    78ec:	71 81       	ldd	r23, Z+1	; 0x01
    78ee:	82 81       	ldd	r24, Z+2	; 0x02
    78f0:	93 81       	ldd	r25, Z+3	; 0x03
    78f2:	0c 5f       	subi	r16, 0xFC	; 252
    78f4:	1f 4f       	sbci	r17, 0xFF	; 255
    78f6:	06 c0       	rjmp	.+12     	; 0x7904 <vfprintf+0x29c>
    78f8:	60 81       	ld	r22, Z
    78fa:	71 81       	ldd	r23, Z+1	; 0x01
    78fc:	80 e0       	ldi	r24, 0x00	; 0
    78fe:	90 e0       	ldi	r25, 0x00	; 0
    7900:	0e 5f       	subi	r16, 0xFE	; 254
    7902:	1f 4f       	sbci	r17, 0xFF	; 255
    7904:	a4 01       	movw	r20, r8
    7906:	e6 d0       	rcall	.+460    	; 0x7ad4 <__ultoa_invert>
    7908:	a8 2e       	mov	r10, r24
    790a:	a8 18       	sub	r10, r8
    790c:	fb 2d       	mov	r31, r11
    790e:	ff 77       	andi	r31, 0x7F	; 127
    7910:	bf 2e       	mov	r11, r31
    7912:	b6 fe       	sbrs	r11, 6
    7914:	0b c0       	rjmp	.+22     	; 0x792c <vfprintf+0x2c4>
    7916:	2b 2d       	mov	r18, r11
    7918:	2e 7f       	andi	r18, 0xFE	; 254
    791a:	a5 14       	cp	r10, r5
    791c:	50 f4       	brcc	.+20     	; 0x7932 <vfprintf+0x2ca>
    791e:	b4 fe       	sbrs	r11, 4
    7920:	0a c0       	rjmp	.+20     	; 0x7936 <vfprintf+0x2ce>
    7922:	b2 fc       	sbrc	r11, 2
    7924:	08 c0       	rjmp	.+16     	; 0x7936 <vfprintf+0x2ce>
    7926:	2b 2d       	mov	r18, r11
    7928:	2e 7e       	andi	r18, 0xEE	; 238
    792a:	05 c0       	rjmp	.+10     	; 0x7936 <vfprintf+0x2ce>
    792c:	7a 2c       	mov	r7, r10
    792e:	2b 2d       	mov	r18, r11
    7930:	03 c0       	rjmp	.+6      	; 0x7938 <vfprintf+0x2d0>
    7932:	7a 2c       	mov	r7, r10
    7934:	01 c0       	rjmp	.+2      	; 0x7938 <vfprintf+0x2d0>
    7936:	75 2c       	mov	r7, r5
    7938:	24 ff       	sbrs	r18, 4
    793a:	0d c0       	rjmp	.+26     	; 0x7956 <vfprintf+0x2ee>
    793c:	fe 01       	movw	r30, r28
    793e:	ea 0d       	add	r30, r10
    7940:	f1 1d       	adc	r31, r1
    7942:	80 81       	ld	r24, Z
    7944:	80 33       	cpi	r24, 0x30	; 48
    7946:	11 f4       	brne	.+4      	; 0x794c <vfprintf+0x2e4>
    7948:	29 7e       	andi	r18, 0xE9	; 233
    794a:	09 c0       	rjmp	.+18     	; 0x795e <vfprintf+0x2f6>
    794c:	22 ff       	sbrs	r18, 2
    794e:	06 c0       	rjmp	.+12     	; 0x795c <vfprintf+0x2f4>
    7950:	73 94       	inc	r7
    7952:	73 94       	inc	r7
    7954:	04 c0       	rjmp	.+8      	; 0x795e <vfprintf+0x2f6>
    7956:	82 2f       	mov	r24, r18
    7958:	86 78       	andi	r24, 0x86	; 134
    795a:	09 f0       	breq	.+2      	; 0x795e <vfprintf+0x2f6>
    795c:	73 94       	inc	r7
    795e:	23 fd       	sbrc	r18, 3
    7960:	12 c0       	rjmp	.+36     	; 0x7986 <vfprintf+0x31e>
    7962:	20 ff       	sbrs	r18, 0
    7964:	06 c0       	rjmp	.+12     	; 0x7972 <vfprintf+0x30a>
    7966:	5a 2c       	mov	r5, r10
    7968:	73 14       	cp	r7, r3
    796a:	18 f4       	brcc	.+6      	; 0x7972 <vfprintf+0x30a>
    796c:	53 0c       	add	r5, r3
    796e:	57 18       	sub	r5, r7
    7970:	73 2c       	mov	r7, r3
    7972:	73 14       	cp	r7, r3
    7974:	60 f4       	brcc	.+24     	; 0x798e <vfprintf+0x326>
    7976:	b7 01       	movw	r22, r14
    7978:	80 e2       	ldi	r24, 0x20	; 32
    797a:	90 e0       	ldi	r25, 0x00	; 0
    797c:	2c 87       	std	Y+12, r18	; 0x0c
    797e:	78 d0       	rcall	.+240    	; 0x7a70 <fputc>
    7980:	73 94       	inc	r7
    7982:	2c 85       	ldd	r18, Y+12	; 0x0c
    7984:	f6 cf       	rjmp	.-20     	; 0x7972 <vfprintf+0x30a>
    7986:	73 14       	cp	r7, r3
    7988:	10 f4       	brcc	.+4      	; 0x798e <vfprintf+0x326>
    798a:	37 18       	sub	r3, r7
    798c:	01 c0       	rjmp	.+2      	; 0x7990 <vfprintf+0x328>
    798e:	31 2c       	mov	r3, r1
    7990:	24 ff       	sbrs	r18, 4
    7992:	11 c0       	rjmp	.+34     	; 0x79b6 <vfprintf+0x34e>
    7994:	b7 01       	movw	r22, r14
    7996:	80 e3       	ldi	r24, 0x30	; 48
    7998:	90 e0       	ldi	r25, 0x00	; 0
    799a:	2c 87       	std	Y+12, r18	; 0x0c
    799c:	69 d0       	rcall	.+210    	; 0x7a70 <fputc>
    799e:	2c 85       	ldd	r18, Y+12	; 0x0c
    79a0:	22 ff       	sbrs	r18, 2
    79a2:	16 c0       	rjmp	.+44     	; 0x79d0 <vfprintf+0x368>
    79a4:	21 ff       	sbrs	r18, 1
    79a6:	03 c0       	rjmp	.+6      	; 0x79ae <vfprintf+0x346>
    79a8:	88 e5       	ldi	r24, 0x58	; 88
    79aa:	90 e0       	ldi	r25, 0x00	; 0
    79ac:	02 c0       	rjmp	.+4      	; 0x79b2 <vfprintf+0x34a>
    79ae:	88 e7       	ldi	r24, 0x78	; 120
    79b0:	90 e0       	ldi	r25, 0x00	; 0
    79b2:	b7 01       	movw	r22, r14
    79b4:	0c c0       	rjmp	.+24     	; 0x79ce <vfprintf+0x366>
    79b6:	82 2f       	mov	r24, r18
    79b8:	86 78       	andi	r24, 0x86	; 134
    79ba:	51 f0       	breq	.+20     	; 0x79d0 <vfprintf+0x368>
    79bc:	21 fd       	sbrc	r18, 1
    79be:	02 c0       	rjmp	.+4      	; 0x79c4 <vfprintf+0x35c>
    79c0:	80 e2       	ldi	r24, 0x20	; 32
    79c2:	01 c0       	rjmp	.+2      	; 0x79c6 <vfprintf+0x35e>
    79c4:	8b e2       	ldi	r24, 0x2B	; 43
    79c6:	27 fd       	sbrc	r18, 7
    79c8:	8d e2       	ldi	r24, 0x2D	; 45
    79ca:	b7 01       	movw	r22, r14
    79cc:	90 e0       	ldi	r25, 0x00	; 0
    79ce:	50 d0       	rcall	.+160    	; 0x7a70 <fputc>
    79d0:	a5 14       	cp	r10, r5
    79d2:	30 f4       	brcc	.+12     	; 0x79e0 <vfprintf+0x378>
    79d4:	b7 01       	movw	r22, r14
    79d6:	80 e3       	ldi	r24, 0x30	; 48
    79d8:	90 e0       	ldi	r25, 0x00	; 0
    79da:	4a d0       	rcall	.+148    	; 0x7a70 <fputc>
    79dc:	5a 94       	dec	r5
    79de:	f8 cf       	rjmp	.-16     	; 0x79d0 <vfprintf+0x368>
    79e0:	aa 94       	dec	r10
    79e2:	f4 01       	movw	r30, r8
    79e4:	ea 0d       	add	r30, r10
    79e6:	f1 1d       	adc	r31, r1
    79e8:	80 81       	ld	r24, Z
    79ea:	b7 01       	movw	r22, r14
    79ec:	90 e0       	ldi	r25, 0x00	; 0
    79ee:	40 d0       	rcall	.+128    	; 0x7a70 <fputc>
    79f0:	a1 10       	cpse	r10, r1
    79f2:	f6 cf       	rjmp	.-20     	; 0x79e0 <vfprintf+0x378>
    79f4:	33 20       	and	r3, r3
    79f6:	09 f4       	brne	.+2      	; 0x79fa <vfprintf+0x392>
    79f8:	5d ce       	rjmp	.-838    	; 0x76b4 <vfprintf+0x4c>
    79fa:	b7 01       	movw	r22, r14
    79fc:	80 e2       	ldi	r24, 0x20	; 32
    79fe:	90 e0       	ldi	r25, 0x00	; 0
    7a00:	37 d0       	rcall	.+110    	; 0x7a70 <fputc>
    7a02:	3a 94       	dec	r3
    7a04:	f7 cf       	rjmp	.-18     	; 0x79f4 <vfprintf+0x38c>
    7a06:	f7 01       	movw	r30, r14
    7a08:	86 81       	ldd	r24, Z+6	; 0x06
    7a0a:	97 81       	ldd	r25, Z+7	; 0x07
    7a0c:	02 c0       	rjmp	.+4      	; 0x7a12 <vfprintf+0x3aa>
    7a0e:	8f ef       	ldi	r24, 0xFF	; 255
    7a10:	9f ef       	ldi	r25, 0xFF	; 255
    7a12:	2c 96       	adiw	r28, 0x0c	; 12
    7a14:	0f b6       	in	r0, 0x3f	; 63
    7a16:	f8 94       	cli
    7a18:	de bf       	out	0x3e, r29	; 62
    7a1a:	0f be       	out	0x3f, r0	; 63
    7a1c:	cd bf       	out	0x3d, r28	; 61
    7a1e:	df 91       	pop	r29
    7a20:	cf 91       	pop	r28
    7a22:	1f 91       	pop	r17
    7a24:	0f 91       	pop	r16
    7a26:	ff 90       	pop	r15
    7a28:	ef 90       	pop	r14
    7a2a:	df 90       	pop	r13
    7a2c:	cf 90       	pop	r12
    7a2e:	bf 90       	pop	r11
    7a30:	af 90       	pop	r10
    7a32:	9f 90       	pop	r9
    7a34:	8f 90       	pop	r8
    7a36:	7f 90       	pop	r7
    7a38:	6f 90       	pop	r6
    7a3a:	5f 90       	pop	r5
    7a3c:	4f 90       	pop	r4
    7a3e:	3f 90       	pop	r3
    7a40:	2f 90       	pop	r2
    7a42:	08 95       	ret

00007a44 <strnlen_P>:
    7a44:	fc 01       	movw	r30, r24
    7a46:	05 90       	lpm	r0, Z+
    7a48:	61 50       	subi	r22, 0x01	; 1
    7a4a:	70 40       	sbci	r23, 0x00	; 0
    7a4c:	01 10       	cpse	r0, r1
    7a4e:	d8 f7       	brcc	.-10     	; 0x7a46 <strnlen_P+0x2>
    7a50:	80 95       	com	r24
    7a52:	90 95       	com	r25
    7a54:	8e 0f       	add	r24, r30
    7a56:	9f 1f       	adc	r25, r31
    7a58:	08 95       	ret

00007a5a <strnlen>:
    7a5a:	fc 01       	movw	r30, r24
    7a5c:	61 50       	subi	r22, 0x01	; 1
    7a5e:	70 40       	sbci	r23, 0x00	; 0
    7a60:	01 90       	ld	r0, Z+
    7a62:	01 10       	cpse	r0, r1
    7a64:	d8 f7       	brcc	.-10     	; 0x7a5c <strnlen+0x2>
    7a66:	80 95       	com	r24
    7a68:	90 95       	com	r25
    7a6a:	8e 0f       	add	r24, r30
    7a6c:	9f 1f       	adc	r25, r31
    7a6e:	08 95       	ret

00007a70 <fputc>:
    7a70:	0f 93       	push	r16
    7a72:	1f 93       	push	r17
    7a74:	cf 93       	push	r28
    7a76:	df 93       	push	r29
    7a78:	18 2f       	mov	r17, r24
    7a7a:	09 2f       	mov	r16, r25
    7a7c:	eb 01       	movw	r28, r22
    7a7e:	8b 81       	ldd	r24, Y+3	; 0x03
    7a80:	81 fd       	sbrc	r24, 1
    7a82:	03 c0       	rjmp	.+6      	; 0x7a8a <fputc+0x1a>
    7a84:	8f ef       	ldi	r24, 0xFF	; 255
    7a86:	9f ef       	ldi	r25, 0xFF	; 255
    7a88:	20 c0       	rjmp	.+64     	; 0x7aca <fputc+0x5a>
    7a8a:	82 ff       	sbrs	r24, 2
    7a8c:	10 c0       	rjmp	.+32     	; 0x7aae <fputc+0x3e>
    7a8e:	4e 81       	ldd	r20, Y+6	; 0x06
    7a90:	5f 81       	ldd	r21, Y+7	; 0x07
    7a92:	2c 81       	ldd	r18, Y+4	; 0x04
    7a94:	3d 81       	ldd	r19, Y+5	; 0x05
    7a96:	42 17       	cp	r20, r18
    7a98:	53 07       	cpc	r21, r19
    7a9a:	7c f4       	brge	.+30     	; 0x7aba <fputc+0x4a>
    7a9c:	e8 81       	ld	r30, Y
    7a9e:	f9 81       	ldd	r31, Y+1	; 0x01
    7aa0:	9f 01       	movw	r18, r30
    7aa2:	2f 5f       	subi	r18, 0xFF	; 255
    7aa4:	3f 4f       	sbci	r19, 0xFF	; 255
    7aa6:	39 83       	std	Y+1, r19	; 0x01
    7aa8:	28 83       	st	Y, r18
    7aaa:	10 83       	st	Z, r17
    7aac:	06 c0       	rjmp	.+12     	; 0x7aba <fputc+0x4a>
    7aae:	e8 85       	ldd	r30, Y+8	; 0x08
    7ab0:	f9 85       	ldd	r31, Y+9	; 0x09
    7ab2:	81 2f       	mov	r24, r17
    7ab4:	09 95       	icall
    7ab6:	89 2b       	or	r24, r25
    7ab8:	29 f7       	brne	.-54     	; 0x7a84 <fputc+0x14>
    7aba:	2e 81       	ldd	r18, Y+6	; 0x06
    7abc:	3f 81       	ldd	r19, Y+7	; 0x07
    7abe:	2f 5f       	subi	r18, 0xFF	; 255
    7ac0:	3f 4f       	sbci	r19, 0xFF	; 255
    7ac2:	3f 83       	std	Y+7, r19	; 0x07
    7ac4:	2e 83       	std	Y+6, r18	; 0x06
    7ac6:	81 2f       	mov	r24, r17
    7ac8:	90 2f       	mov	r25, r16
    7aca:	df 91       	pop	r29
    7acc:	cf 91       	pop	r28
    7ace:	1f 91       	pop	r17
    7ad0:	0f 91       	pop	r16
    7ad2:	08 95       	ret

00007ad4 <__ultoa_invert>:
    7ad4:	fa 01       	movw	r30, r20
    7ad6:	aa 27       	eor	r26, r26
    7ad8:	28 30       	cpi	r18, 0x08	; 8
    7ada:	51 f1       	breq	.+84     	; 0x7b30 <__ultoa_invert+0x5c>
    7adc:	20 31       	cpi	r18, 0x10	; 16
    7ade:	81 f1       	breq	.+96     	; 0x7b40 <__ultoa_invert+0x6c>
    7ae0:	e8 94       	clt
    7ae2:	6f 93       	push	r22
    7ae4:	6e 7f       	andi	r22, 0xFE	; 254
    7ae6:	6e 5f       	subi	r22, 0xFE	; 254
    7ae8:	7f 4f       	sbci	r23, 0xFF	; 255
    7aea:	8f 4f       	sbci	r24, 0xFF	; 255
    7aec:	9f 4f       	sbci	r25, 0xFF	; 255
    7aee:	af 4f       	sbci	r26, 0xFF	; 255
    7af0:	b1 e0       	ldi	r27, 0x01	; 1
    7af2:	3e d0       	rcall	.+124    	; 0x7b70 <__ultoa_invert+0x9c>
    7af4:	b4 e0       	ldi	r27, 0x04	; 4
    7af6:	3c d0       	rcall	.+120    	; 0x7b70 <__ultoa_invert+0x9c>
    7af8:	67 0f       	add	r22, r23
    7afa:	78 1f       	adc	r23, r24
    7afc:	89 1f       	adc	r24, r25
    7afe:	9a 1f       	adc	r25, r26
    7b00:	a1 1d       	adc	r26, r1
    7b02:	68 0f       	add	r22, r24
    7b04:	79 1f       	adc	r23, r25
    7b06:	8a 1f       	adc	r24, r26
    7b08:	91 1d       	adc	r25, r1
    7b0a:	a1 1d       	adc	r26, r1
    7b0c:	6a 0f       	add	r22, r26
    7b0e:	71 1d       	adc	r23, r1
    7b10:	81 1d       	adc	r24, r1
    7b12:	91 1d       	adc	r25, r1
    7b14:	a1 1d       	adc	r26, r1
    7b16:	20 d0       	rcall	.+64     	; 0x7b58 <__ultoa_invert+0x84>
    7b18:	09 f4       	brne	.+2      	; 0x7b1c <__ultoa_invert+0x48>
    7b1a:	68 94       	set
    7b1c:	3f 91       	pop	r19
    7b1e:	2a e0       	ldi	r18, 0x0A	; 10
    7b20:	26 9f       	mul	r18, r22
    7b22:	11 24       	eor	r1, r1
    7b24:	30 19       	sub	r19, r0
    7b26:	30 5d       	subi	r19, 0xD0	; 208
    7b28:	31 93       	st	Z+, r19
    7b2a:	de f6       	brtc	.-74     	; 0x7ae2 <__ultoa_invert+0xe>
    7b2c:	cf 01       	movw	r24, r30
    7b2e:	08 95       	ret
    7b30:	46 2f       	mov	r20, r22
    7b32:	47 70       	andi	r20, 0x07	; 7
    7b34:	40 5d       	subi	r20, 0xD0	; 208
    7b36:	41 93       	st	Z+, r20
    7b38:	b3 e0       	ldi	r27, 0x03	; 3
    7b3a:	0f d0       	rcall	.+30     	; 0x7b5a <__ultoa_invert+0x86>
    7b3c:	c9 f7       	brne	.-14     	; 0x7b30 <__ultoa_invert+0x5c>
    7b3e:	f6 cf       	rjmp	.-20     	; 0x7b2c <__ultoa_invert+0x58>
    7b40:	46 2f       	mov	r20, r22
    7b42:	4f 70       	andi	r20, 0x0F	; 15
    7b44:	40 5d       	subi	r20, 0xD0	; 208
    7b46:	4a 33       	cpi	r20, 0x3A	; 58
    7b48:	18 f0       	brcs	.+6      	; 0x7b50 <__ultoa_invert+0x7c>
    7b4a:	49 5d       	subi	r20, 0xD9	; 217
    7b4c:	31 fd       	sbrc	r19, 1
    7b4e:	40 52       	subi	r20, 0x20	; 32
    7b50:	41 93       	st	Z+, r20
    7b52:	02 d0       	rcall	.+4      	; 0x7b58 <__ultoa_invert+0x84>
    7b54:	a9 f7       	brne	.-22     	; 0x7b40 <__ultoa_invert+0x6c>
    7b56:	ea cf       	rjmp	.-44     	; 0x7b2c <__ultoa_invert+0x58>
    7b58:	b4 e0       	ldi	r27, 0x04	; 4
    7b5a:	a6 95       	lsr	r26
    7b5c:	97 95       	ror	r25
    7b5e:	87 95       	ror	r24
    7b60:	77 95       	ror	r23
    7b62:	67 95       	ror	r22
    7b64:	ba 95       	dec	r27
    7b66:	c9 f7       	brne	.-14     	; 0x7b5a <__ultoa_invert+0x86>
    7b68:	00 97       	sbiw	r24, 0x00	; 0
    7b6a:	61 05       	cpc	r22, r1
    7b6c:	71 05       	cpc	r23, r1
    7b6e:	08 95       	ret
    7b70:	9b 01       	movw	r18, r22
    7b72:	ac 01       	movw	r20, r24
    7b74:	0a 2e       	mov	r0, r26
    7b76:	06 94       	lsr	r0
    7b78:	57 95       	ror	r21
    7b7a:	47 95       	ror	r20
    7b7c:	37 95       	ror	r19
    7b7e:	27 95       	ror	r18
    7b80:	ba 95       	dec	r27
    7b82:	c9 f7       	brne	.-14     	; 0x7b76 <__ultoa_invert+0xa2>
    7b84:	62 0f       	add	r22, r18
    7b86:	73 1f       	adc	r23, r19
    7b88:	84 1f       	adc	r24, r20
    7b8a:	95 1f       	adc	r25, r21
    7b8c:	a0 1d       	adc	r26, r0
    7b8e:	08 95       	ret

00007b90 <_exit>:
    7b90:	f8 94       	cli

00007b92 <__stop_program>:
    7b92:	ff cf       	rjmp	.-2      	; 0x7b92 <__stop_program>
