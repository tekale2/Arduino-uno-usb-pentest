
RNDISEthernet.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000007e  00800100  000029b6  00002a4a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000029b6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000012e5  0080017e  0080017e  00002ac8  2**0
                  ALLOC
  3 .stab         00001278  00000000  00000000  00002ac8  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000ef6  00000000  00000000  00003d40  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  00004c36  2**0
                  CONTENTS, READONLY
  6 .debug_aranges 00000858  00000000  00000000  00004c47  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0000ddbd  00000000  00000000  0000549f  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00003c68  00000000  00000000  0001325c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000051ba  00000000  00000000  00016ec4  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  0000147c  00000000  00000000  0001c080  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000049bb  00000000  00000000  0001d4fc  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0000877f  00000000  00000000  00021eb7  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000888  00000000  00000000  0002a636  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
#include "HIDParser.h"

uint8_t USB_ProcessHIDReport(const uint8_t* ReportData,
                             uint16_t ReportSize,
                             HID_ReportInfo_t* const ParserData)
{
       0:	10 c2       	rjmp	.+1056   	; 0x422 <__ctors_end>
       2:	00 00       	nop
       4:	2c c2       	rjmp	.+1112   	; 0x45e <__bad_interrupt>
       6:	00 00       	nop
       8:	2a c2       	rjmp	.+1108   	; 0x45e <__bad_interrupt>
       a:	00 00       	nop
       c:	28 c2       	rjmp	.+1104   	; 0x45e <__bad_interrupt>
       e:	00 00       	nop
      10:	26 c2       	rjmp	.+1100   	; 0x45e <__bad_interrupt>
      12:	00 00       	nop
      14:	24 c2       	rjmp	.+1096   	; 0x45e <__bad_interrupt>
      16:	00 00       	nop
      18:	22 c2       	rjmp	.+1092   	; 0x45e <__bad_interrupt>
      1a:	00 00       	nop
      1c:	20 c2       	rjmp	.+1088   	; 0x45e <__bad_interrupt>
      1e:	00 00       	nop
      20:	1e c2       	rjmp	.+1084   	; 0x45e <__bad_interrupt>
      22:	00 00       	nop
      24:	1c c2       	rjmp	.+1080   	; 0x45e <__bad_interrupt>
      26:	00 00       	nop
      28:	0c 94 4a 0e 	jmp	0x1c94	; 0x1c94 <__vector_10>
      2c:	18 c2       	rjmp	.+1072   	; 0x45e <__bad_interrupt>
      2e:	00 00       	nop
      30:	16 c2       	rjmp	.+1068   	; 0x45e <__bad_interrupt>
      32:	00 00       	nop
      34:	14 c2       	rjmp	.+1064   	; 0x45e <__bad_interrupt>
      36:	00 00       	nop
	HID_StateTable_t      StateTable[HID_STATETABLE_STACK_DEPTH];
	HID_StateTable_t*     CurrStateTable     = &StateTable[0];
	HID_CollectionPath_t* CurrCollectionPath = NULL;
	HID_ReportSizeInfo_t* CurrReportIDInfo   = &ParserData->ReportIDSizes[0];
      38:	12 c2       	rjmp	.+1060   	; 0x45e <__bad_interrupt>
      3a:	00 00       	nop
      3c:	10 c2       	rjmp	.+1056   	; 0x45e <__bad_interrupt>
      3e:	00 00       	nop
      40:	0e c2       	rjmp	.+1052   	; 0x45e <__bad_interrupt>
      42:	00 00       	nop
      44:	0c c2       	rjmp	.+1048   	; 0x45e <__bad_interrupt>
	uint16_t              UsageList[HID_USAGE_STACK_DEPTH];
	uint8_t               UsageListSize      = 0;
	HID_MinMax_t          UsageMinMax        = {0, 0};

	memset(ParserData,       0x00, sizeof(HID_ReportInfo_t));
      46:	00 00       	nop
      48:	0a c2       	rjmp	.+1044   	; 0x45e <__bad_interrupt>
      4a:	00 00       	nop
      4c:	08 c2       	rjmp	.+1040   	; 0x45e <__bad_interrupt>
      4e:	00 00       	nop
      50:	06 c2       	rjmp	.+1036   	; 0x45e <__bad_interrupt>
      52:	00 00       	nop
	memset(CurrStateTable,   0x00, sizeof(HID_StateTable_t));
      54:	04 c2       	rjmp	.+1032   	; 0x45e <__bad_interrupt>
      56:	00 00       	nop
      58:	02 c2       	rjmp	.+1028   	; 0x45e <__bad_interrupt>
      5a:	00 00       	nop
      5c:	00 c2       	rjmp	.+1024   	; 0x45e <__bad_interrupt>
      5e:	00 00       	nop
      60:	fe c1       	rjmp	.+1020   	; 0x45e <__bad_interrupt>
	memset(CurrReportIDInfo, 0x00, sizeof(HID_ReportSizeInfo_t));
      62:	00 00       	nop
      64:	fc c1       	rjmp	.+1016   	; 0x45e <__bad_interrupt>
      66:	00 00       	nop
      68:	fa c1       	rjmp	.+1012   	; 0x45e <__bad_interrupt>
      6a:	00 00       	nop

	ParserData->TotalDeviceReports = 1;
      6c:	f8 c1       	rjmp	.+1008   	; 0x45e <__bad_interrupt>
      6e:	00 00       	nop
      70:	f6 c1       	rjmp	.+1004   	; 0x45e <__bad_interrupt>
      72:	00 00       	nop
      74:	f4 c1       	rjmp	.+1000   	; 0x45e <__bad_interrupt>
      76:	00 00       	nop
      78:	f2 c1       	rjmp	.+996    	; 0x45e <__bad_interrupt>
      7a:	00 00       	nop
      7c:	f0 c1       	rjmp	.+992    	; 0x45e <__bad_interrupt>
      7e:	00 00       	nop
	HID_StateTable_t*     CurrStateTable     = &StateTable[0];
	HID_CollectionPath_t* CurrCollectionPath = NULL;
	HID_ReportSizeInfo_t* CurrReportIDInfo   = &ParserData->ReportIDSizes[0];
	uint16_t              UsageList[HID_USAGE_STACK_DEPTH];
	uint8_t               UsageListSize      = 0;
	HID_MinMax_t          UsageMinMax        = {0, 0};
      80:	ee c1       	rjmp	.+988    	; 0x45e <__bad_interrupt>
      82:	00 00       	nop
      84:	ec c1       	rjmp	.+984    	; 0x45e <__bad_interrupt>
      86:	00 00       	nop
      88:	ea c1       	rjmp	.+980    	; 0x45e <__bad_interrupt>
      8a:	00 00       	nop
	HID_StateTable_t      StateTable[HID_STATETABLE_STACK_DEPTH];
	HID_StateTable_t*     CurrStateTable     = &StateTable[0];
	HID_CollectionPath_t* CurrCollectionPath = NULL;
	HID_ReportSizeInfo_t* CurrReportIDInfo   = &ParserData->ReportIDSizes[0];
	uint16_t              UsageList[HID_USAGE_STACK_DEPTH];
	uint8_t               UsageListSize      = 0;
      8c:	e8 c1       	rjmp	.+976    	; 0x45e <__bad_interrupt>
      8e:	00 00       	nop
      90:	e6 c1       	rjmp	.+972    	; 0x45e <__bad_interrupt>
                             uint16_t ReportSize,
                             HID_ReportInfo_t* const ParserData)
{
	HID_StateTable_t      StateTable[HID_STATETABLE_STACK_DEPTH];
	HID_StateTable_t*     CurrStateTable     = &StateTable[0];
	HID_CollectionPath_t* CurrCollectionPath = NULL;
      92:	00 00       	nop
      94:	e4 c1       	rjmp	.+968    	; 0x45e <__bad_interrupt>
      96:	00 00       	nop

00000098 <ProductString>:
      98:	28 03 4c 00 55 00 46 00 41 00 20 00 52 00 4e 00     (.L.U.F.A. .R.N.

					NewReportItem.BitOffset = CurrReportIDInfo->ReportSizeBits[NewReportItem.ItemType];

					CurrReportIDInfo->ReportSizeBits[NewReportItem.ItemType] += CurrStateTable->Attributes.BitSize;

					ParserData->LargestReportSizeBits = MAX(ParserData->LargestReportSizeBits, CurrReportIDInfo->ReportSizeBits[NewReportItem.ItemType]);
      a8:	44 00 49 00 53 00 20 00 43 00 44 00 43 00 20 00     D.I.S. .C.D.C. .

					CurrCollectionPath = &ParserData->CollectionPaths[1];

					while (CurrCollectionPath->Parent != NULL)
					{
						if (CurrCollectionPath == &ParserData->CollectionPaths[HID_MAX_COLLECTIONS - 1])
      b8:	44 00 65 00 6d 00 6f 00 00 00                       D.e.m.o...

000000c2 <ManufacturerString>:
				break;

			case HID_RI_REPORT_ID(0):
				CurrStateTable->ReportID                    = ReportItemData;

				if (ParserData->UsingReportIDs)
      c2:	18 03 44 00 65 00 61 00 6e 00 20 00 43 00 61 00     ..D.e.a.n. .C.a.
				{
					CurrReportIDInfo = NULL;

					for (uint8_t i = 0; i < ParserData->TotalDeviceReports; i++)
      d2:	6d 00 65 00 72 00 61 00 00 00                       m.e.r.a...

000000dc <LanguageString>:
	memset(CurrStateTable,   0x00, sizeof(HID_StateTable_t));
	memset(CurrReportIDInfo, 0x00, sizeof(HID_ReportSizeInfo_t));

	ParserData->TotalDeviceReports = 1;

	while (ReportSize)
      dc:	04 03 09 04                                         ....

000000e0 <ConfigurationDescriptor>:
	{
		uint8_t  HIDReportItem  = *ReportData;
      e0:	09 02 3e 00 02 01 00 c0 32 09 04 00 00 01 02 02     ..>.....2.......
		uint32_t ReportItemData;

		ReportData++;
		ReportSize--;

		switch (HIDReportItem & HID_RI_DATA_SIZE_MASK)
      f0:	ff 00 05 24 00 10 01 04 24 02 00 05 24 06 00 01     ...$....$...$...
	{
		uint8_t  HIDReportItem  = *ReportData;
		uint32_t ReportItemData;

		ReportData++;
		ReportSize--;
     100:	07 05 83 03 08 00 ff 09 04 01 00 02 0a 00 00 00     ................

		switch (HIDReportItem & HID_RI_DATA_SIZE_MASK)
		{
			case HID_RI_DATA_BITS_32:
				ReportItemData  = (((uint32_t)ReportData[3] << 24) | ((uint32_t)ReportData[2] << 16) |
     110:	07 05 02 02 40 00 05 07 05 81 02 40 00 05           ....@......@..

0000011e <DeviceDescriptor>:
     11e:	12 01 10 01 02 00 00 08 eb 03 4c 20 01 00 01 02     ..........L ....
			                       ((uint16_t)ReportData[1] << 8)  | ReportData[0]);
     12e:	00 01                                               ..

00000130 <HTTPPage>:
     130:	3c 68 74 6d 6c 3e 09 3c 68 65 61 64 3e 09 09 3c     <html>.<head>..<
		ReportSize--;

		switch (HIDReportItem & HID_RI_DATA_SIZE_MASK)
		{
			case HID_RI_DATA_BITS_32:
				ReportItemData  = (((uint32_t)ReportData[3] << 24) | ((uint32_t)ReportData[2] << 16) |
     140:	74 69 74 6c 65 3e 09 09 09 4c 55 46 41 20 57 65     title>...LUFA We
				ReportSize     -= 4;
				ReportData     += 4;
				break;

			case HID_RI_DATA_BITS_16:
				ReportItemData  = (((uint16_t)ReportData[1] << 8) | (ReportData[0]));
     150:	62 73 65 72 76 65 72 20 44 65 6d 6f 09 09 3c 2f     bserver Demo..</
     160:	74 69 74 6c 65 3e 09 3c 2f 68 65 61 64 3e 09 3c     title>.</head>.<
				ReportSize     -= 2;
				ReportData     += 2;
				break;

			case HID_RI_DATA_BITS_8:
				ReportItemData  = ReportData[0];
     170:	62 6f 64 79 3e 09 09 3c 68 31 3e 48 65 6c 6c 6f     body>..<h1>Hello
				ReportSize     -= 1;
				ReportData     += 1;
     180:	20 66 72 6f 6d 20 79 6f 75 72 20 55 53 42 20 41      from your USB A
			default:
				ReportItemData  = 0;
				break;
		}

		switch (HIDReportItem & (HID_RI_TYPE_MASK | HID_RI_TAG_MASK))
     190:	56 52 21 3c 2f 68 31 3e 09 09 3c 70 3e 09 09 09     VR!</h1>..<p>...
     1a0:	48 65 6c 6c 6f 21 20 57 65 6c 63 6f 6d 65 20 74     Hello! Welcome t

			case HID_RI_USAGE_PAGE(0):
				if ((HIDReportItem & HID_RI_DATA_SIZE_MASK) == HID_RI_DATA_BITS_32)
				  CurrStateTable->Attributes.Usage.Page = (ReportItemData >> 16);

				CurrStateTable->Attributes.Usage.Page       = ReportItemData;
     1b0:	6f 20 74 68 65 20 4c 55 46 41 20 52 4e 44 49 53     o the LUFA RNDIS
			default:
				ReportItemData  = 0;
				break;
		}

		switch (HIDReportItem & (HID_RI_TYPE_MASK | HID_RI_TAG_MASK))
     1c0:	20 44 65 6d 6f 20 57 65 62 73 65 72 76 65 72 20      Demo Webserver 
     1d0:	74 65 73 74 20 70 61 67 65 2c 20 72 75 6e 6e 69     test page, runni
     1e0:	6e 67 20 6f 6e 20 79 6f 75 72 20 55 53 42 20 41     ng on your USB A
     1f0:	56 52 20 76 69 61 20 74 68 65 20 4c 55 46 41 20     VR via the LUFA 
     200:	6c 69 62 72 61 72 79 2e 20 54 68 69 73 20 64 65     library. This de
     210:	6d 6f 6e 73 74 72 61 74 65 73 20 74 68 65 20 48     monstrates the H
     220:	54 54 50 20 77 65 62 73 65 72 76 65 72 2c 20 54     TTP webserver, T
     230:	43 50 2f 49 50 20 73 74 61 63 6b 20 61 6e 64 20     CP/IP stack and 
					  return HID_PARSE_InsufficientReportItems;

					memcpy(&ParserData->ReportItems[ParserData->TotalReportItems],
					       &NewReportItem, sizeof(HID_ReportItem_t));

					if (!(ReportItemData & HID_IOF_CONSTANT) && CALLBACK_HIDParser_FilterHIDReportItem(&NewReportItem))
     240:	52 4e 44 49 53 20 64 65 6d 6f 20 61 6c 6c 20 72     RNDIS demo all r
     250:	75 6e 6e 69 6e 67 20 61 74 6f 70 20 74 68 65 20     unning atop the 
		{
			case HID_RI_PUSH(0):
				if (CurrStateTable == &StateTable[HID_STATETABLE_STACK_DEPTH - 1])
				  return HID_PARSE_HIDStackOverflow;

				memcpy((CurrStateTable + 1),
     260:	4c 55 46 41 20 55 53 42 20 73 74 61 63 6b 2e 09     LUFA USB stack..
				       CurrStateTable,
				       sizeof(HID_ReportItem_t));

				CurrStateTable++;
     270:	09 09 3c 62 72 20 2f 3e 3c 62 72 20 2f 3e 09 09     ..<br /><br />..

			case HID_RI_POP(0):
				if (CurrStateTable == &StateTable[0])
				  return HID_PARSE_HIDStackUnderflow;

				CurrStateTable--;
     280:	09 3c 73 6d 61 6c 6c 3e 50 72 6f 6a 65 63 74 20     .<small>Project 
				CurrStateTable->Attributes.Usage.Page       = ReportItemData;
				break;

			case HID_RI_LOGICAL_MINIMUM(0):
				CurrStateTable->Attributes.Logical.Minimum  = ReportItemData;
				break;
     290:	49 6e 66 6f 72 6d 61 74 69 6f 6e 3a 20 3c 61 20     Information: <a 

			case HID_RI_LOGICAL_MAXIMUM(0):
				CurrStateTable->Attributes.Logical.Maximum  = ReportItemData;
				break;
     2a0:	68 72 65 66 3d 22 68 74 74 70 3a 2f 2f 77 77 77     href="http://www
			case HID_RI_PHYSICAL_MINIMUM(0):
				CurrStateTable->Attributes.Physical.Minimum = ReportItemData;
				break;

			case HID_RI_PHYSICAL_MAXIMUM(0):
				CurrStateTable->Attributes.Physical.Maximum = ReportItemData;
     2b0:	2e 6c 75 66 61 2d 6c 69 62 2e 6f 72 67 22 3e 68     .lufa-lib.org">h
			case HID_RI_UNIT_EXPONENT(0):
				CurrStateTable->Attributes.Unit.Exponent    = ReportItemData;
				break;

			case HID_RI_UNIT(0):
				CurrStateTable->Attributes.Unit.Type        = ReportItemData;
     2c0:	74 74 70 3a 2f 2f 77 77 77 2e 6c 75 66 61 2d 6c     ttp://www.lufa-l
			case HID_RI_REPORT_SIZE(0):
				CurrStateTable->Attributes.BitSize          = ReportItemData;
				break;

			case HID_RI_REPORT_COUNT(0):
				CurrStateTable->ReportCount                 = ReportItemData;
     2d0:	69 62 2e 6f 72 67 3c 2f 61 3e 2e 3c 2f 73 6d 61     ib.org</a>.</sma
				break;

			case HID_RI_REPORT_ID(0):
				CurrStateTable->ReportID                    = ReportItemData;

				if (ParserData->UsingReportIDs)
     2e0:	6c 6c 3e 09 09 09 3c 68 72 20 2f 3e 09 09 09 3c     ll>...<hr />...<
				{
					CurrReportIDInfo = NULL;

					for (uint8_t i = 0; i < ParserData->TotalDeviceReports; i++)
     2f0:	69 3e 4c 55 46 41 20 56 65 72 73 69 6f 6e 3a 20     i>LUFA Version: 
     300:	3c 2f 69 3e 31 34 30 39 32 38 09 09 3c 2f 70 3e     </i>140928..</p>
					{
						if (ParserData->ReportIDSizes[i].ReportID == CurrStateTable->ReportID)
     310:	09 3c 2f 62 6f 64 79 3e 3c 2f 68 74 6d 6c 3e 00     .</body></html>.

00000320 <HTTP404Header>:
						{
							CurrReportIDInfo = &ParserData->ReportIDSizes[i];
     320:	48 54 54 50 2f 31 2e 31 20 34 30 34 20 4e 6f 74     HTTP/1.1 404 Not
     330:	20 46 6f 75 6e 64 0d 0a 53 65 72 76 65 72 3a 20      Found..Server: 
					if (CurrReportIDInfo == NULL)
					{
						if (ParserData->TotalDeviceReports == HID_MAX_REPORT_IDS)
						  return HID_PARSE_InsufficientReportIDItems;

						CurrReportIDInfo = &ParserData->ReportIDSizes[ParserData->TotalDeviceReports++];
     340:	4c 55 46 41 20 52 4e 44 49 53 0d 0a 43 6f 6e 6e     LUFA RNDIS..Conn
     350:	65 63 74 69 6f 6e 3a 20 63 6c 6f 73 65 0d 0a 0d     ection: close...
     360:	0a 00                                               ..

00000362 <HTTP200Header>:
     362:	48 54 54 50 2f 31 2e 31 20 32 30 30 20 4f 4b 0d     HTTP/1.1 200 OK.
						memset(CurrReportIDInfo, 0x00, sizeof(HID_ReportSizeInfo_t));
					}
				}

				ParserData->UsingReportIDs = true;
     372:	0a 53 65 72 76 65 72 3a 20 4c 55 46 41 20 52 4e     .Server: LUFA RN

				CurrReportIDInfo->ReportID = CurrStateTable->ReportID;
     382:	44 49 53 0d 0a 43 6f 6e 74 65 6e 74 2d 74 79 70     DIS..Content-typ
				break;

			case HID_RI_USAGE(0):
				if (UsageListSize == HID_USAGE_STACK_DEPTH)
     392:	65 3a 20 74 65 78 74 2f 68 74 6d 6c 0d 0a 43 6f     e: text/html..Co
				  return HID_PARSE_UsageListOverflow;

				UsageList[UsageListSize++] = ReportItemData;
     3a2:	6e 6e 65 63 74 69 6f 6e 3a 20 63 6c 6f 73 65 0d     nnection: close.
			case HID_RI_USAGE_MAXIMUM(0):
				UsageMinMax.Maximum = ReportItemData;
				break;

			case HID_RI_COLLECTION(0):
				if (CurrCollectionPath == NULL)
     3b2:	0a 0d 0a 00                                         ....

000003b6 <AdapterSupportedOIDList>:
     3b6:	01 01 01 00 02 02 01 00 02 01 01 00 03 01 01 00     ................
				{
					CurrCollectionPath = &ParserData->CollectionPaths[0];
     3c6:	04 01 01 00 06 01 01 00 11 01 01 00 07 01 01 00     ................
				{
					HID_CollectionPath_t* ParentCollectionPath = CurrCollectionPath;

					CurrCollectionPath = &ParserData->CollectionPaths[1];

					while (CurrCollectionPath->Parent != NULL)
     3d6:	0a 01 01 00 0b 01 01 00 0c 01 01 00 0d 01 01 00     ................
					{
						if (CurrCollectionPath == &ParserData->CollectionPaths[HID_MAX_COLLECTIONS - 1])
     3e6:	0e 01 01 00 11 01 01 00 14 01 01 00 01 01 02 00     ................
						  return HID_PARSE_InsufficientCollectionPaths;

						CurrCollectionPath++;
					}

					CurrCollectionPath->Parent = ParentCollectionPath;
     3f6:	02 01 02 00 03 01 02 00 04 01 02 00 05 01 02 00     ................
     406:	01 01 01 01 02 01 01 01 03 01 01 01 04 01 01 01     ................
				}

				CurrCollectionPath->Type       = ReportItemData;
				CurrCollectionPath->Usage.Page = CurrStateTable->Attributes.Usage.Page;
     416:	01 01 02 01 02 01 02 01 03 01 02 01                 ............

00000422 <__ctors_end>:

				if (UsageListSize)
     422:	11 24       	eor	r1, r1
     424:	1f be       	out	0x3f, r1	; 63
     426:	cf ef       	ldi	r28, 0xFF	; 255
     428:	d0 e2       	ldi	r29, 0x20	; 32
				{
					CurrCollectionPath->Usage.Usage = UsageList[0];
     42a:	de bf       	out	0x3e, r29	; 62
     42c:	cd bf       	out	0x3d, r28	; 61

0000042e <__do_copy_data>:
     42e:	11 e0       	ldi	r17, 0x01	; 1
     430:	a0 e0       	ldi	r26, 0x00	; 0
     432:	b1 e0       	ldi	r27, 0x01	; 1
     434:	e6 eb       	ldi	r30, 0xB6	; 182
     436:	f9 e2       	ldi	r31, 0x29	; 41
     438:	00 e0       	ldi	r16, 0x00	; 0
     43a:	0b bf       	out	0x3b, r16	; 59
     43c:	02 c0       	rjmp	.+4      	; 0x442 <__do_copy_data+0x14>
     43e:	07 90       	elpm	r0, Z+

					for (uint8_t i = 1; i < UsageListSize; i++)
     440:	0d 92       	st	X+, r0
     442:	ae 37       	cpi	r26, 0x7E	; 126
     444:	b1 07       	cpc	r27, r17
     446:	d9 f7       	brne	.-10     	; 0x43e <__do_copy_data+0x10>

00000448 <__do_clear_bss>:
     448:	14 e1       	ldi	r17, 0x14	; 20
     44a:	ae e7       	ldi	r26, 0x7E	; 126
					  UsageList[i - 1] = UsageList[i];
     44c:	b1 e0       	ldi	r27, 0x01	; 1
     44e:	01 c0       	rjmp	.+2      	; 0x452 <.do_clear_bss_start>

00000450 <.do_clear_bss_loop>:
     450:	1d 92       	st	X+, r1

00000452 <.do_clear_bss_start>:
     452:	a3 36       	cpi	r26, 0x63	; 99

				if (UsageListSize)
				{
					CurrCollectionPath->Usage.Usage = UsageList[0];

					for (uint8_t i = 1; i < UsageListSize; i++)
     454:	b1 07       	cpc	r27, r17
     456:	e1 f7       	brne	.-8      	; 0x450 <.do_clear_bss_loop>
					  UsageList[i - 1] = UsageList[i];

					UsageListSize--;
     458:	38 d0       	rcall	.+112    	; 0x4ca <main>
     45a:	0c 94 d9 14 	jmp	0x29b2	; 0x29b2 <_exit>

0000045e <__bad_interrupt>:
     45e:	d0 cd       	rjmp	.-1120   	; 0x0 <__vectors>

00000460 <LEDs_SetAllLEDs>:
     460:	9b b1       	in	r25, 0x0b	; 11
				}
				else if (UsageMinMax.Minimum <= UsageMinMax.Maximum)
     462:	9f 70       	andi	r25, 0x0F	; 15
     464:	98 2b       	or	r25, r24
     466:	9b b9       	out	0x0b, r25	; 11
     468:	08 95       	ret

0000046a <SetupHardware>:
     46a:	84 b7       	in	r24, 0x34	; 52
     46c:	87 7f       	andi	r24, 0xF7	; 247
				{
					CurrCollectionPath->Usage.Usage = UsageMinMax.Minimum++;
     46e:	84 bf       	out	0x34, r24	; 52
     470:	88 e1       	ldi	r24, 0x18	; 24
     472:	0f b6       	in	r0, 0x3f	; 63
     474:	f8 94       	cli
     476:	80 93 60 00 	sts	0x0060, r24
     47a:	10 92 60 00 	sts	0x0060, r1
     47e:	0f be       	out	0x3f, r0	; 63
     480:	90 e0       	ldi	r25, 0x00	; 0
     482:	80 e8       	ldi	r24, 0x80	; 128
     484:	0f b6       	in	r0, 0x3f	; 63
     486:	f8 94       	cli
     488:	80 93 61 00 	sts	0x0061, r24
				}

				break;

			case HID_RI_END_COLLECTION(0):
				if (CurrCollectionPath == NULL)
     48c:	90 93 61 00 	sts	0x0061, r25
     490:	0f be       	out	0x3f, r0	; 63
     492:	8a b1       	in	r24, 0x0a	; 10
     494:	80 6f       	ori	r24, 0xF0	; 240
     496:	8a b9       	out	0x0a, r24	; 10
     498:	8b b1       	in	r24, 0x0b	; 11
				  return HID_PARSE_UnexpectedEndCollection;

				CurrCollectionPath = CurrCollectionPath->Parent;
     49a:	8f 70       	andi	r24, 0x0F	; 15
     49c:	8b b9       	out	0x0b, r24	; 11
     49e:	83 e3       	ldi	r24, 0x33	; 51
     4a0:	90 e0       	ldi	r25, 0x00	; 0
     4a2:	90 93 cd 00 	sts	0x00CD, r25
     4a6:	80 93 cc 00 	sts	0x00CC, r24
     4aa:	86 e0       	ldi	r24, 0x06	; 6
				break;
     4ac:	80 93 ca 00 	sts	0x00CA, r24
					ParserData->LargestReportSizeBits = MAX(ParserData->LargestReportSizeBits, CurrReportIDInfo->ReportSizeBits[NewReportItem.ItemType]);

					if (ParserData->TotalReportItems == HID_MAX_REPORTITEMS)
					  return HID_PARSE_InsufficientReportItems;

					memcpy(&ParserData->ReportItems[ParserData->TotalReportItems],
     4b0:	10 92 c8 00 	sts	0x00C8, r1
     4b4:	88 e1       	ldi	r24, 0x18	; 24
     4b6:	80 93 c9 00 	sts	0x00C9, r24
     4ba:	53 9a       	sbi	0x0a, 3	; 10
     4bc:	5a 9a       	sbi	0x0b, 2	; 11
     4be:	0e 94 2f 0e 	call	0x1c5e	; 0x1c5e <USB_Init>
     4c2:	80 e0       	ldi	r24, 0x00	; 0
     4c4:	90 e0       	ldi	r25, 0x00	; 0
     4c6:	0c 94 5e 14 	jmp	0x28bc	; 0x28bc <Serial_CreateStream>

000004ca <main>:
					       &NewReportItem, sizeof(HID_ReportItem_t));

					if (!(ReportItemData & HID_IOF_CONSTANT) && CALLBACK_HIDParser_FilterHIDReportItem(&NewReportItem))
     4ca:	cf df       	rcall	.-98     	; 0x46a <SetupHardware>
     4cc:	d3 d2       	rcall	.+1446   	; 0xa74 <TCP_Init>
     4ce:	0e 94 96 0b 	call	0x172c	; 0x172c <Webserver_Init>
     4d2:	80 e1       	ldi	r24, 0x10	; 16
     4d4:	c5 df       	rcall	.-118    	; 0x460 <LEDs_SetAllLEDs>
     4d6:	78 94       	sei
     4d8:	80 e0       	ldi	r24, 0x00	; 0
     4da:	91 e0       	ldi	r25, 0x01	; 1
     4dc:	0e 94 6a 13 	call	0x26d4	; 0x26d4 <RNDIS_Device_IsPacketReceived>
     4e0:	88 23       	and	r24, r24
     4e2:	11 f1       	breq	.+68     	; 0x528 <main+0x5e>
				break;

			case HID_RI_INPUT(0):
			case HID_RI_OUTPUT(0):
			case HID_RI_FEATURE(0):
				for (uint8_t ReportItemNum = 0; ReportItemNum < CurrStateTable->ReportCount; ReportItemNum++)
     4e4:	80 e2       	ldi	r24, 0x20	; 32
     4e6:	bc df       	rcall	.-136    	; 0x460 <LEDs_SetAllLEDs>
     4e8:	48 e3       	ldi	r20, 0x38	; 56
     4ea:	5d e0       	ldi	r21, 0x0D	; 13
     4ec:	6c e5       	ldi	r22, 0x5C	; 92
     4ee:	77 e0       	ldi	r23, 0x07	; 7
				{
					HID_ReportItem_t NewReportItem;

					memcpy(&NewReportItem.Attributes,
     4f0:	80 e0       	ldi	r24, 0x00	; 0
     4f2:	91 e0       	ldi	r25, 0x01	; 1
     4f4:	0e 94 7e 13 	call	0x26fc	; 0x26fc <RNDIS_Device_ReadPacket>
     4f8:	6e e7       	ldi	r22, 0x7E	; 126
     4fa:	71 e0       	ldi	r23, 0x01	; 1
     4fc:	8c e5       	ldi	r24, 0x5C	; 92
     4fe:	97 e0       	ldi	r25, 0x07	; 7
     500:	63 d0       	rcall	.+198    	; 0x5c8 <Ethernet_ProcessPacket>
					       &CurrStateTable->Attributes,
					       sizeof(HID_ReportItem_Attributes_t));

					NewReportItem.ItemFlags      = ReportItemData;
     502:	40 91 5a 07 	lds	r20, 0x075A
					NewReportItem.CollectionPath = CurrCollectionPath;
     506:	50 91 5b 07 	lds	r21, 0x075B
     50a:	41 15       	cp	r20, r1
     50c:	51 05       	cpc	r21, r1
     50e:	51 f0       	breq	.+20     	; 0x524 <main+0x5a>
     510:	6e e7       	ldi	r22, 0x7E	; 126
     512:	71 e0       	ldi	r23, 0x01	; 1
     514:	80 e0       	ldi	r24, 0x00	; 0
					NewReportItem.ReportID       = CurrStateTable->ReportID;
     516:	91 e0       	ldi	r25, 0x01	; 1
     518:	0e 94 d6 13 	call	0x27ac	; 0x27ac <RNDIS_Device_SendPacket>
     51c:	10 92 5b 07 	sts	0x075B, r1

					if (UsageListSize)
     520:	10 92 5a 07 	sts	0x075A, r1
     524:	80 e6       	ldi	r24, 0x60	; 96
     526:	9c df       	rcall	.-200    	; 0x460 <LEDs_SetAllLEDs>
					{
						NewReportItem.Attributes.Usage.Usage = UsageList[0];
     528:	6e e7       	ldi	r22, 0x7E	; 126
     52a:	71 e0       	ldi	r23, 0x01	; 1
     52c:	80 e0       	ldi	r24, 0x00	; 0
     52e:	91 e0       	ldi	r25, 0x01	; 1
     530:	a6 d1       	rcall	.+844    	; 0x87e <TCP_TCPTask>
     532:	80 e0       	ldi	r24, 0x00	; 0
     534:	91 e0       	ldi	r25, 0x01	; 1
     536:	0e 94 2b 13 	call	0x2656	; 0x2656 <RNDIS_Device_USBTask>
     53a:	0e 94 6b 10 	call	0x20d6	; 0x20d6 <USB_USBTask>

						for (uint8_t i = 1; i < UsageListSize; i++)
     53e:	cc cf       	rjmp	.-104    	; 0x4d8 <main+0xe>

00000540 <EVENT_USB_Device_Connect>:
     540:	80 ea       	ldi	r24, 0xA0	; 160
     542:	8e cf       	rjmp	.-228    	; 0x460 <LEDs_SetAllLEDs>

00000544 <EVENT_USB_Device_Disconnect>:
     544:	80 e1       	ldi	r24, 0x10	; 16
     546:	8c cf       	rjmp	.-232    	; 0x460 <LEDs_SetAllLEDs>

00000548 <EVENT_USB_Device_ConfigurationChanged>:
     548:	80 e0       	ldi	r24, 0x00	; 0
						  UsageList[i - 1] = UsageList[i];
     54a:	91 e0       	ldi	r25, 0x01	; 1
     54c:	0e 94 fd 12 	call	0x25fa	; 0x25fa <RNDIS_Device_ConfigureEndpoints>
     550:	88 23       	and	r24, r24

					if (UsageListSize)
					{
						NewReportItem.Attributes.Usage.Usage = UsageList[0];

						for (uint8_t i = 1; i < UsageListSize; i++)
     552:	11 f0       	breq	.+4      	; 0x558 <EVENT_USB_Device_ConfigurationChanged+0x10>
     554:	80 e6       	ldi	r24, 0x60	; 96
						  UsageList[i - 1] = UsageList[i];

						UsageListSize--;
     556:	01 c0       	rjmp	.+2      	; 0x55a <EVENT_USB_Device_ConfigurationChanged+0x12>
     558:	80 e9       	ldi	r24, 0x90	; 144
     55a:	82 cf       	rjmp	.-252    	; 0x460 <LEDs_SetAllLEDs>

0000055c <EVENT_USB_Device_ControlRequest>:
     55c:	80 e0       	ldi	r24, 0x00	; 0
     55e:	91 e0       	ldi	r25, 0x01	; 1
					}
					else if (UsageMinMax.Minimum <= UsageMinMax.Maximum)
     560:	0c 94 87 10 	jmp	0x210e	; 0x210e <RNDIS_Device_ProcessControlRequest>

00000564 <CALLBACK_USB_GetDescriptor>:
     564:	29 2f       	mov	r18, r25
     566:	33 27       	eor	r19, r19
     568:	22 30       	cpi	r18, 0x02	; 2
					{
						NewReportItem.Attributes.Usage.Usage = UsageMinMax.Minimum++;
     56a:	31 05       	cpc	r19, r1
     56c:	59 f0       	breq	.+22     	; 0x584 <CALLBACK_USB_GetDescriptor+0x20>
     56e:	23 30       	cpi	r18, 0x03	; 3
     570:	31 05       	cpc	r19, r1
     572:	69 f0       	breq	.+26     	; 0x58e <CALLBACK_USB_GetDescriptor+0x2a>
     574:	21 30       	cpi	r18, 0x01	; 1
     576:	31 05       	cpc	r19, r1
     578:	f9 f4       	brne	.+62     	; 0x5b8 <CALLBACK_USB_GetDescriptor+0x54>
     57a:	82 e1       	ldi	r24, 0x12	; 18
					}

					uint8_t ItemTypeTag = (HIDReportItem & (HID_RI_TYPE_MASK | HID_RI_TAG_MASK));

					if (ItemTypeTag == HID_RI_INPUT(0))
     57c:	90 e0       	ldi	r25, 0x00	; 0
     57e:	2e e1       	ldi	r18, 0x1E	; 30
					  NewReportItem.ItemType = HID_REPORT_ITEM_In;
     580:	31 e0       	ldi	r19, 0x01	; 1
     582:	1e c0       	rjmp	.+60     	; 0x5c0 <CALLBACK_USB_GetDescriptor+0x5c>
					else if (ItemTypeTag == HID_RI_OUTPUT(0))
     584:	8e e3       	ldi	r24, 0x3E	; 62
     586:	90 e0       	ldi	r25, 0x00	; 0
					  NewReportItem.ItemType = HID_REPORT_ITEM_Out;
     588:	20 ee       	ldi	r18, 0xE0	; 224
     58a:	30 e0       	ldi	r19, 0x00	; 0
     58c:	19 c0       	rjmp	.+50     	; 0x5c0 <CALLBACK_USB_GetDescriptor+0x5c>
					else
					  NewReportItem.ItemType = HID_REPORT_ITEM_Feature;
     58e:	99 27       	eor	r25, r25
     590:	81 30       	cpi	r24, 0x01	; 1

					NewReportItem.BitOffset = CurrReportIDInfo->ReportSizeBits[NewReportItem.ItemType];
     592:	91 05       	cpc	r25, r1
     594:	41 f0       	breq	.+16     	; 0x5a6 <CALLBACK_USB_GetDescriptor+0x42>
     596:	82 30       	cpi	r24, 0x02	; 2
     598:	91 05       	cpc	r25, r1
     59a:	41 f0       	breq	.+16     	; 0x5ac <CALLBACK_USB_GetDescriptor+0x48>
     59c:	89 2b       	or	r24, r25
     59e:	61 f4       	brne	.+24     	; 0x5b8 <CALLBACK_USB_GetDescriptor+0x54>
     5a0:	ec ed       	ldi	r30, 0xDC	; 220
     5a2:	f0 e0       	ldi	r31, 0x00	; 0
     5a4:	05 c0       	rjmp	.+10     	; 0x5b0 <CALLBACK_USB_GetDescriptor+0x4c>
     5a6:	e2 ec       	ldi	r30, 0xC2	; 194
     5a8:	f0 e0       	ldi	r31, 0x00	; 0
     5aa:	02 c0       	rjmp	.+4      	; 0x5b0 <CALLBACK_USB_GetDescriptor+0x4c>

					CurrReportIDInfo->ReportSizeBits[NewReportItem.ItemType] += CurrStateTable->Attributes.BitSize;
     5ac:	e8 e9       	ldi	r30, 0x98	; 152
     5ae:	f0 e0       	ldi	r31, 0x00	; 0
     5b0:	84 91       	lpm	r24, Z
     5b2:	90 e0       	ldi	r25, 0x00	; 0
     5b4:	9f 01       	movw	r18, r30
     5b6:	04 c0       	rjmp	.+8      	; 0x5c0 <CALLBACK_USB_GetDescriptor+0x5c>
     5b8:	80 e0       	ldi	r24, 0x00	; 0
     5ba:	90 e0       	ldi	r25, 0x00	; 0

					ParserData->LargestReportSizeBits = MAX(ParserData->LargestReportSizeBits, CurrReportIDInfo->ReportSizeBits[NewReportItem.ItemType]);
     5bc:	20 e0       	ldi	r18, 0x00	; 0
     5be:	30 e0       	ldi	r19, 0x00	; 0
     5c0:	fa 01       	movw	r30, r20
     5c2:	31 83       	std	Z+1, r19	; 0x01
     5c4:	20 83       	st	Z, r18
     5c6:	08 95       	ret

000005c8 <Ethernet_ProcessPacket>:
     5c8:	ef 92       	push	r14
     5ca:	ff 92       	push	r15
     5cc:	0f 93       	push	r16
     5ce:	1f 93       	push	r17
     5d0:	cf 93       	push	r28
     5d2:	df 93       	push	r29
     5d4:	ec 01       	movw	r28, r24
     5d6:	8b 01       	movw	r16, r22
     5d8:	91 d0       	rcall	.+290    	; 0x6fc <DecodeEthernetFrameHeader>
     5da:	46 e0       	ldi	r20, 0x06	; 6
     5dc:	50 e0       	ldi	r21, 0x00	; 0
     5de:	64 e3       	ldi	r22, 0x34	; 52
     5e0:	71 e0       	ldi	r23, 0x01	; 1
     5e2:	ce 01       	movw	r24, r28
     5e4:	0e 94 a4 14 	call	0x2948	; 0x2948 <memcmp>
     5e8:	9e 01       	movw	r18, r28
     5ea:	24 52       	subi	r18, 0x24	; 36
     5ec:	3a 4f       	sbci	r19, 0xFA	; 250
     5ee:	79 01       	movw	r14, r18
     5f0:	89 2b       	or	r24, r25
     5f2:	51 f0       	breq	.+20     	; 0x608 <Ethernet_ProcessPacket+0x40>

					if (ParserData->TotalReportItems == HID_MAX_REPORTITEMS)
     5f4:	46 e0       	ldi	r20, 0x06	; 6
     5f6:	50 e0       	ldi	r21, 0x00	; 0
     5f8:	6a e2       	ldi	r22, 0x2A	; 42
     5fa:	71 e0       	ldi	r23, 0x01	; 1
     5fc:	ce 01       	movw	r24, r28
					  return HID_PARSE_InsufficientReportItems;
     5fe:	0e 94 a4 14 	call	0x2948	; 0x2948 <memcmp>

					memcpy(&ParserData->ReportItems[ParserData->TotalReportItems],
					       &NewReportItem, sizeof(HID_ReportItem_t));

					if (!(ReportItemData & HID_IOF_CONSTANT) && CALLBACK_HIDParser_FilterHIDReportItem(&NewReportItem))
     602:	89 2b       	or	r24, r25
     604:	09 f0       	breq	.+2      	; 0x608 <Ethernet_ProcessPacket+0x40>
     606:	3f c0       	rjmp	.+126    	; 0x686 <Ethernet_ProcessPacket+0xbe>
     608:	f7 01       	movw	r30, r14
     60a:	81 81       	ldd	r24, Z+1	; 0x01
     60c:	90 81       	ld	r25, Z
     60e:	81 30       	cpi	r24, 0x01	; 1
     610:	96 40       	sbci	r25, 0x06	; 6
     612:	c8 f1       	brcs	.+114    	; 0x686 <Ethernet_ProcessPacket+0xbe>
     614:	8d 85       	ldd	r24, Y+13	; 0x0d
     616:	9c 85       	ldd	r25, Y+12	; 0x0c
     618:	81 15       	cp	r24, r1
     61a:	28 e0       	ldi	r18, 0x08	; 8
     61c:	92 07       	cpc	r25, r18
     61e:	51 f0       	breq	.+20     	; 0x634 <Ethernet_ProcessPacket+0x6c>
     620:	86 30       	cpi	r24, 0x06	; 6
     622:	98 40       	sbci	r25, 0x08	; 8
     624:	81 f5       	brne	.+96     	; 0x686 <Ethernet_ProcessPacket+0xbe>
     626:	b8 01       	movw	r22, r16
     628:	62 5f       	subi	r22, 0xF2	; 242
     62a:	7f 4f       	sbci	r23, 0xFF	; 255
     62c:	ce 01       	movw	r24, r28
     62e:	0e 96       	adiw	r24, 0x0e	; 14
     630:	a0 d6       	rcall	.+3392   	; 0x1372 <ARP_ProcessARPPacket>
     632:	08 c0       	rjmp	.+16     	; 0x644 <Ethernet_ProcessPacket+0x7c>
     634:	a8 01       	movw	r20, r16
     636:	42 5f       	subi	r20, 0xF2	; 242
     638:	5f 4f       	sbci	r21, 0xFF	; 255
     63a:	be 01       	movw	r22, r28
     63c:	62 5f       	subi	r22, 0xF2	; 242
     63e:	7f 4f       	sbci	r23, 0xFF	; 255
     640:	ce 01       	movw	r24, r28
     642:	fe d6       	rcall	.+3580   	; 0x1440 <IP_ProcessIPPacket>
     644:	18 16       	cp	r1, r24
     646:	19 06       	cpc	r1, r25
     648:	e4 f4       	brge	.+56     	; 0x682 <Ethernet_ProcessPacket+0xba>
     64a:	26 e0       	ldi	r18, 0x06	; 6
     64c:	e4 e3       	ldi	r30, 0x34	; 52
     64e:	f1 e0       	ldi	r31, 0x01	; 1
     650:	d8 01       	movw	r26, r16
     652:	16 96       	adiw	r26, 0x06	; 6
     654:	01 90       	ld	r0, Z+
     656:	0d 92       	st	X+, r0
     658:	2a 95       	dec	r18
     65a:	e1 f7       	brne	.-8      	; 0x654 <Ethernet_ProcessPacket+0x8c>
     65c:	26 e0       	ldi	r18, 0x06	; 6
     65e:	fe 01       	movw	r30, r28
     660:	36 96       	adiw	r30, 0x06	; 6
     662:	d8 01       	movw	r26, r16
     664:	01 90       	ld	r0, Z+
     666:	0d 92       	st	X+, r0
     668:	2a 95       	dec	r18
     66a:	e1 f7       	brne	.-8      	; 0x664 <Ethernet_ProcessPacket+0x9c>
     66c:	2c 85       	ldd	r18, Y+12	; 0x0c
     66e:	3d 85       	ldd	r19, Y+13	; 0x0d
     670:	f8 01       	movw	r30, r16
     672:	35 87       	std	Z+13, r19	; 0x0d
     674:	24 87       	std	Z+12, r18	; 0x0c
     676:	e4 52       	subi	r30, 0x24	; 36
     678:	fa 4f       	sbci	r31, 0xFA	; 250
     67a:	0e 96       	adiw	r24, 0x0e	; 14
     67c:	91 83       	std	Z+1, r25	; 0x01
     67e:	80 83       	st	Z, r24
     680:	02 c0       	rjmp	.+4      	; 0x686 <Ethernet_ProcessPacket+0xbe>
     682:	01 96       	adiw	r24, 0x01	; 1
     684:	19 f0       	breq	.+6      	; 0x68c <Ethernet_ProcessPacket+0xc4>
     686:	f7 01       	movw	r30, r14
					  ParserData->TotalReportItems++;
     688:	11 82       	std	Z+1, r1	; 0x01
     68a:	10 82       	st	Z, r1
     68c:	df 91       	pop	r29
     68e:	cf 91       	pop	r28
     690:	1f 91       	pop	r17

			default:
				break;
		}

		if ((HIDReportItem & HID_RI_TYPE_MASK) == HID_RI_TYPE_MAIN)
     692:	0f 91       	pop	r16
     694:	ff 90       	pop	r15
     696:	ef 90       	pop	r14
     698:	08 95       	ret

0000069a <Ethernet_Checksum16>:
     69a:	cf 93       	push	r28
     69c:	df 93       	push	r29
		{
			UsageMinMax.Minimum = 0;
			UsageMinMax.Maximum = 0;
     69e:	9b 01       	movw	r18, r22
     6a0:	36 95       	lsr	r19
     6a2:	27 95       	ror	r18
				break;
		}

		if ((HIDReportItem & HID_RI_TYPE_MASK) == HID_RI_TYPE_MAIN)
		{
			UsageMinMax.Minimum = 0;
     6a4:	e0 e0       	ldi	r30, 0x00	; 0
     6a6:	f0 e0       	ldi	r31, 0x00	; 0
     6a8:	40 e0       	ldi	r20, 0x00	; 0
			UsageMinMax.Maximum = 0;
			UsageListSize       = 0;
     6aa:	50 e0       	ldi	r21, 0x00	; 0
     6ac:	ba 01       	movw	r22, r20
     6ae:	e2 17       	cp	r30, r18
     6b0:	f3 07       	cpc	r31, r19
		}
	}

	if (!(ParserData->TotalReportItems))
     6b2:	51 f0       	breq	.+20     	; 0x6c8 <Ethernet_Checksum16+0x2e>
     6b4:	ec 01       	movw	r28, r24
     6b6:	a9 91       	ld	r26, Y+
     6b8:	b9 91       	ld	r27, Y+
	  return HID_PARSE_NoUnfilteredReportItems;
     6ba:	ce 01       	movw	r24, r28
     6bc:	4a 0f       	add	r20, r26

		switch (HIDReportItem & (HID_RI_TYPE_MASK | HID_RI_TAG_MASK))
		{
			case HID_RI_PUSH(0):
				if (CurrStateTable == &StateTable[HID_STATETABLE_STACK_DEPTH - 1])
				  return HID_PARSE_HIDStackOverflow;
     6be:	5b 1f       	adc	r21, r27
     6c0:	61 1d       	adc	r22, r1
				CurrStateTable++;
				break;

			case HID_RI_POP(0):
				if (CurrStateTable == &StateTable[0])
				  return HID_PARSE_HIDStackUnderflow;
     6c2:	71 1d       	adc	r23, r1
     6c4:	31 96       	adiw	r30, 0x01	; 1
				CurrReportIDInfo->ReportID = CurrStateTable->ReportID;
				break;

			case HID_RI_USAGE(0):
				if (UsageListSize == HID_USAGE_STACK_DEPTH)
				  return HID_PARSE_UsageListOverflow;
     6c6:	f3 cf       	rjmp	.-26     	; 0x6ae <Ethernet_Checksum16+0x14>
     6c8:	db 01       	movw	r26, r22
					CurrCollectionPath = &ParserData->CollectionPaths[1];

					while (CurrCollectionPath->Parent != NULL)
					{
						if (CurrCollectionPath == &ParserData->CollectionPaths[HID_MAX_COLLECTIONS - 1])
						  return HID_PARSE_InsufficientCollectionPaths;
     6ca:	ca 01       	movw	r24, r20
     6cc:	88 27       	eor	r24, r24

				break;

			case HID_RI_END_COLLECTION(0):
				if (CurrCollectionPath == NULL)
				  return HID_PARSE_UnexpectedEndCollection;
     6ce:	99 27       	eor	r25, r25
     6d0:	89 2b       	or	r24, r25
	}

	if (!(ParserData->TotalReportItems))
	  return HID_PARSE_NoUnfilteredReportItems;

	return HID_PARSE_Successful;
     6d2:	8a 2b       	or	r24, r26
     6d4:	8b 2b       	or	r24, r27
					}

					if (CurrReportIDInfo == NULL)
					{
						if (ParserData->TotalDeviceReports == HID_MAX_REPORT_IDS)
						  return HID_PARSE_InsufficientReportIDItems;
     6d6:	61 f0       	breq	.+24     	; 0x6f0 <Ethernet_Checksum16+0x56>

	if (!(ParserData->TotalReportItems))
	  return HID_PARSE_NoUnfilteredReportItems;

	return HID_PARSE_Successful;
}
     6d8:	db 01       	movw	r26, r22
     6da:	ca 01       	movw	r24, r20
     6dc:	aa 27       	eor	r26, r26
     6de:	bb 27       	eor	r27, r27
     6e0:	ab 01       	movw	r20, r22
     6e2:	66 27       	eor	r22, r22
     6e4:	77 27       	eor	r23, r23
     6e6:	48 0f       	add	r20, r24
     6e8:	59 1f       	adc	r21, r25
     6ea:	6a 1f       	adc	r22, r26
     6ec:	7b 1f       	adc	r23, r27
     6ee:	ec cf       	rjmp	.-40     	; 0x6c8 <Ethernet_Checksum16+0x2e>
     6f0:	ca 01       	movw	r24, r20
     6f2:	80 95       	com	r24
     6f4:	90 95       	com	r25
     6f6:	df 91       	pop	r29
     6f8:	cf 91       	pop	r28
     6fa:	08 95       	ret

000006fc <DecodeEthernetFrameHeader>:
     6fc:	08 95       	ret

000006fe <DecodeARPHeader>:
     6fe:	08 95       	ret

00000700 <DecodeIPHeader>:
     700:	08 95       	ret

00000702 <DecodeICMPHeader>:
     702:	08 95       	ret

00000704 <DecodeTCPHeader>:
     704:	08 95       	ret

00000706 <DecodeUDPHeader>:
     706:	08 95       	ret

00000708 <DecodeDHCPHeader>:
     708:	08 95       	ret

0000070a <ICMP_ProcessICMPPacket>:
     70a:	cf 92       	push	r12
 *  \return The number of bytes written to the out Ethernet frame if any, NO_RESPONSE otherwise
 */
int16_t ICMP_ProcessICMPPacket(Ethernet_Frame_Info_t* const FrameIN,
                               void* InDataStart,
                               void* OutDataStart)
{
     70c:	df 92       	push	r13
     70e:	ef 92       	push	r14
     710:	ff 92       	push	r15
     712:	0f 93       	push	r16
     714:	1f 93       	push	r17
     716:	cf 93       	push	r28
     718:	df 93       	push	r29
     71a:	6c 01       	movw	r12, r24
     71c:	7b 01       	movw	r14, r22
     71e:	ea 01       	movw	r28, r20
	ICMP_Header_t* ICMPHeaderIN  = (ICMP_Header_t*)InDataStart;
	ICMP_Header_t* ICMPHeaderOUT = (ICMP_Header_t*)OutDataStart;

	DecodeICMPHeader(InDataStart);
     720:	cb 01       	movw	r24, r22
     722:	ef df       	rcall	.-34     	; 0x702 <DecodeICMPHeader>
     724:	f7 01       	movw	r30, r14

	/* Determine if the ICMP packet is an echo request (ping) */
	if (ICMPHeaderIN->Type == ICMP_TYPE_ECHOREQUEST)
     726:	80 81       	ld	r24, Z
     728:	88 30       	cpi	r24, 0x08	; 8
     72a:	31 f5       	brne	.+76     	; 0x778 <ICMP_ProcessICMPPacket+0x6e>
     72c:	18 82       	st	Y, r1
	{
		/* Fill out the ICMP response packet */
		ICMPHeaderOUT->Type     = ICMP_TYPE_ECHOREPLY;
     72e:	19 82       	std	Y+1, r1	; 0x01
		ICMPHeaderOUT->Code     = 0;
     730:	1b 82       	std	Y+3, r1	; 0x03
		ICMPHeaderOUT->Checksum = 0;
     732:	1a 82       	std	Y+2, r1	; 0x02
     734:	84 81       	ldd	r24, Z+4	; 0x04
		ICMPHeaderOUT->Id       = ICMPHeaderIN->Id;
     736:	95 81       	ldd	r25, Z+5	; 0x05
     738:	9d 83       	std	Y+5, r25	; 0x05
     73a:	8c 83       	std	Y+4, r24	; 0x04
     73c:	86 81       	ldd	r24, Z+6	; 0x06
		ICMPHeaderOUT->Sequence = ICMPHeaderIN->Sequence;
     73e:	97 81       	ldd	r25, Z+7	; 0x07
     740:	9f 83       	std	Y+7, r25	; 0x07
     742:	8e 83       	std	Y+6, r24	; 0x06
     744:	f6 01       	movw	r30, r12

		intptr_t DataSize = FrameIN->FrameLength - ((((intptr_t)InDataStart + sizeof(ICMP_Header_t)) - (intptr_t)FrameIN->FrameData));
     746:	e4 52       	subi	r30, 0x24	; 36
     748:	fa 4f       	sbci	r31, 0xFA	; 250
     74a:	00 81       	ld	r16, Z
     74c:	11 81       	ldd	r17, Z+1	; 0x01
     74e:	0c 0d       	add	r16, r12
     750:	1d 1d       	adc	r17, r13
     752:	0e 19       	sub	r16, r14
     754:	1f 09       	sbc	r17, r15
     756:	a8 01       	movw	r20, r16
     758:	48 50       	subi	r20, 0x08	; 8
     75a:	51 09       	sbc	r21, r1
     75c:	b7 01       	movw	r22, r14

		/* Copy the remaining payload to the response - echo requests should echo back any sent data */
		memmove(&((uint8_t*)OutDataStart)[sizeof(ICMP_Header_t)],
     75e:	68 5f       	subi	r22, 0xF8	; 248
     760:	7f 4f       	sbci	r23, 0xFF	; 255
     762:	ce 01       	movw	r24, r28
     764:	08 96       	adiw	r24, 0x08	; 8
     766:	0e 94 ba 14 	call	0x2974	; 0x2974 <memmove>
     76a:	b8 01       	movw	r22, r16
		        &((uint8_t*)InDataStart)[sizeof(ICMP_Header_t)],
			    DataSize);

		ICMPHeaderOUT->Checksum = Ethernet_Checksum16(ICMPHeaderOUT, (DataSize + sizeof(ICMP_Header_t)));
     76c:	ce 01       	movw	r24, r28
     76e:	95 df       	rcall	.-214    	; 0x69a <Ethernet_Checksum16>
     770:	9b 83       	std	Y+3, r25	; 0x03
     772:	8a 83       	std	Y+2, r24	; 0x02
     774:	c8 01       	movw	r24, r16
     776:	02 c0       	rjmp	.+4      	; 0x77c <ICMP_ProcessICMPPacket+0x72>

		/* Return the size of the response so far */
		return (DataSize + sizeof(ICMP_Header_t));
     778:	80 e0       	ldi	r24, 0x00	; 0
     77a:	90 e0       	ldi	r25, 0x00	; 0
	}

	return NO_RESPONSE;
     77c:	df 91       	pop	r29
     77e:	cf 91       	pop	r28
}
     780:	1f 91       	pop	r17
     782:	0f 91       	pop	r16
     784:	ff 90       	pop	r15
     786:	ef 90       	pop	r14
     788:	df 90       	pop	r13
     78a:	cf 90       	pop	r12
     78c:	08 95       	ret

0000078e <SwapEndian_32>:
			 *
			 *  \return Input data with the individual bytes reversed.
			 */
			static inline uint32_t SwapEndian_32(const uint32_t DWord) ATTR_WARN_UNUSED_RESULT ATTR_CONST;
			static inline uint32_t SwapEndian_32(const uint32_t DWord)
			{
     78e:	9b 01       	movw	r18, r22
				Temp = Data.Bytes[1];
				Data.Bytes[1] = Data.Bytes[2];
				Data.Bytes[2] = Temp;

				return Data.DWord;
			}
     790:	69 2f       	mov	r22, r25
     792:	78 2f       	mov	r23, r24
     794:	83 2f       	mov	r24, r19
     796:	92 2f       	mov	r25, r18
     798:	08 95       	ret

0000079a <SwapEndian_16.part.1>:
			 *  \param[in] Word  Word of data whose bytes are to be swapped.
			 *
			 *  \return Input data with the individual bytes reversed.
			 */
			static inline uint16_t SwapEndian_16(const uint16_t Word) ATTR_WARN_UNUSED_RESULT ATTR_CONST;
			static inline uint16_t SwapEndian_16(const uint16_t Word)
     79a:	28 2f       	mov	r18, r24
     79c:	89 2f       	mov	r24, r25
				Temp = Data.Bytes[0];
				Data.Bytes[0] = Data.Bytes[1];
				Data.Bytes[1] = Temp;

				return Data.Word;
			}
     79e:	92 2f       	mov	r25, r18
     7a0:	08 95       	ret

000007a2 <TCP_Checksum16>:
 */
static uint16_t TCP_Checksum16(void* TCPHeaderOutStart,
                               const IP_Address_t* SourceAddress,
                               const IP_Address_t* DestinationAddress,
                               uint16_t TCPOutSize)
{
     7a2:	cf 92       	push	r12
     7a4:	df 92       	push	r13
     7a6:	ef 92       	push	r14
     7a8:	ff 92       	push	r15
     7aa:	0f 93       	push	r16
     7ac:	1f 93       	push	r17
     7ae:	cf 93       	push	r28
     7b0:	df 93       	push	r29
     7b2:	ec 01       	movw	r28, r24
     7b4:	fb 01       	movw	r30, r22
     7b6:	89 01       	movw	r16, r18
	/* TCP/IP checksums are the addition of the one's compliment of each word including the IP pseudo-header,
	   complimented */

	Checksum += ((uint16_t*)SourceAddress)[0];
	Checksum += ((uint16_t*)SourceAddress)[1];
	Checksum += ((uint16_t*)DestinationAddress)[0];
     7b8:	da 01       	movw	r26, r20
     7ba:	8d 91       	ld	r24, X+
     7bc:	9c 91       	ld	r25, X
     7be:	11 97       	sbiw	r26, 0x01	; 1
	Checksum += ((uint16_t*)DestinationAddress)[1];
     7c0:	12 96       	adiw	r26, 0x02	; 2
     7c2:	4d 91       	ld	r20, X+
     7c4:	5c 91       	ld	r21, X
     7c6:	13 97       	sbiw	r26, 0x03	; 3
     7c8:	6a 01       	movw	r12, r20
     7ca:	e1 2c       	mov	r14, r1
     7cc:	f1 2c       	mov	r15, r1

	/* TCP/IP checksums are the addition of the one's compliment of each word including the IP pseudo-header,
	   complimented */

	Checksum += ((uint16_t*)SourceAddress)[0];
	Checksum += ((uint16_t*)SourceAddress)[1];
     7ce:	c8 0e       	add	r12, r24
     7d0:	d9 1e       	adc	r13, r25
     7d2:	e1 1c       	adc	r14, r1
     7d4:	f1 1c       	adc	r15, r1
	Checksum += ((uint16_t*)DestinationAddress)[0];
     7d6:	b6 e0       	ldi	r27, 0x06	; 6
     7d8:	db 0e       	add	r13, r27
     7da:	e1 1c       	adc	r14, r1
     7dc:	f1 1c       	adc	r15, r1
	uint32_t Checksum = 0;

	/* TCP/IP checksums are the addition of the one's compliment of each word including the IP pseudo-header,
	   complimented */

	Checksum += ((uint16_t*)SourceAddress)[0];
     7de:	80 81       	ld	r24, Z
     7e0:	91 81       	ldd	r25, Z+1	; 0x01
	Checksum += ((uint16_t*)SourceAddress)[1];
	Checksum += ((uint16_t*)DestinationAddress)[0];
	Checksum += ((uint16_t*)DestinationAddress)[1];
     7e2:	c8 0e       	add	r12, r24
     7e4:	d9 1e       	adc	r13, r25
     7e6:	e1 1c       	adc	r14, r1
     7e8:	f1 1c       	adc	r15, r1

	/* TCP/IP checksums are the addition of the one's compliment of each word including the IP pseudo-header,
	   complimented */

	Checksum += ((uint16_t*)SourceAddress)[0];
	Checksum += ((uint16_t*)SourceAddress)[1];
     7ea:	82 81       	ldd	r24, Z+2	; 0x02
     7ec:	93 81       	ldd	r25, Z+3	; 0x03
	Checksum += ((uint16_t*)DestinationAddress)[0];
	Checksum += ((uint16_t*)DestinationAddress)[1];
	Checksum += SwapEndian_16(PROTOCOL_TCP);
     7ee:	c8 0e       	add	r12, r24
     7f0:	d9 1e       	adc	r13, r25
     7f2:	e1 1c       	adc	r14, r1
     7f4:	f1 1c       	adc	r15, r1
     7f6:	c9 01       	movw	r24, r18
     7f8:	d0 df       	rcall	.-96     	; 0x79a <SwapEndian_16.part.1>
     7fa:	b7 01       	movw	r22, r14
	Checksum += SwapEndian_16(TCPOutSize);
     7fc:	a6 01       	movw	r20, r12
     7fe:	48 0f       	add	r20, r24
     800:	59 1f       	adc	r21, r25
     802:	61 1d       	adc	r22, r1
     804:	71 1d       	adc	r23, r1
     806:	c8 01       	movw	r24, r16

	for (uint16_t CurrWord = 0; CurrWord < (TCPOutSize >> 1); CurrWord++)
     808:	96 95       	lsr	r25
     80a:	87 95       	ror	r24
     80c:	de 01       	movw	r26, r28
     80e:	e0 e0       	ldi	r30, 0x00	; 0
     810:	f0 e0       	ldi	r31, 0x00	; 0
     812:	e8 17       	cp	r30, r24
     814:	f9 07       	cpc	r31, r25
     816:	41 f0       	breq	.+16     	; 0x828 <TCP_Checksum16+0x86>
     818:	2d 91       	ld	r18, X+
	  Checksum += ((uint16_t*)TCPHeaderOutStart)[CurrWord];
     81a:	3d 91       	ld	r19, X+
     81c:	42 0f       	add	r20, r18
     81e:	53 1f       	adc	r21, r19
     820:	61 1d       	adc	r22, r1
     822:	71 1d       	adc	r23, r1
     824:	31 96       	adiw	r30, 0x01	; 1
	Checksum += ((uint16_t*)DestinationAddress)[0];
	Checksum += ((uint16_t*)DestinationAddress)[1];
	Checksum += SwapEndian_16(PROTOCOL_TCP);
	Checksum += SwapEndian_16(TCPOutSize);

	for (uint16_t CurrWord = 0; CurrWord < (TCPOutSize >> 1); CurrWord++)
     826:	f5 cf       	rjmp	.-22     	; 0x812 <TCP_Checksum16+0x70>
     828:	00 ff       	sbrs	r16, 0
	  Checksum += ((uint16_t*)TCPHeaderOutStart)[CurrWord];

	if (TCPOutSize & 0x01)
     82a:	09 c0       	rjmp	.+18     	; 0x83e <TCP_Checksum16+0x9c>
     82c:	ee 0f       	add	r30, r30
	  Checksum += (((uint16_t*)TCPHeaderOutStart)[TCPOutSize >> 1] & 0x00FF);
     82e:	ff 1f       	adc	r31, r31
     830:	ec 0f       	add	r30, r28
     832:	fd 1f       	adc	r31, r29
     834:	80 81       	ld	r24, Z
     836:	48 0f       	add	r20, r24
     838:	51 1d       	adc	r21, r1
     83a:	61 1d       	adc	r22, r1
     83c:	71 1d       	adc	r23, r1
     83e:	db 01       	movw	r26, r22

	while (Checksum & 0xFFFF0000)
     840:	ca 01       	movw	r24, r20
     842:	88 27       	eor	r24, r24
     844:	99 27       	eor	r25, r25
     846:	89 2b       	or	r24, r25
     848:	8a 2b       	or	r24, r26
     84a:	8b 2b       	or	r24, r27
     84c:	61 f0       	breq	.+24     	; 0x866 <TCP_Checksum16+0xc4>
     84e:	db 01       	movw	r26, r22
	  Checksum = ((Checksum & 0xFFFF) + (Checksum >> 16));
     850:	ca 01       	movw	r24, r20
     852:	aa 27       	eor	r26, r26
     854:	bb 27       	eor	r27, r27
     856:	ab 01       	movw	r20, r22
     858:	66 27       	eor	r22, r22
     85a:	77 27       	eor	r23, r23
     85c:	48 0f       	add	r20, r24
     85e:	59 1f       	adc	r21, r25
     860:	6a 1f       	adc	r22, r26
     862:	7b 1f       	adc	r23, r27
     864:	ec cf       	rjmp	.-40     	; 0x83e <TCP_Checksum16+0x9c>
     866:	ca 01       	movw	r24, r20

	return ~Checksum;
     868:	80 95       	com	r24
     86a:	90 95       	com	r25
     86c:	df 91       	pop	r29
}
     86e:	cf 91       	pop	r28
     870:	1f 91       	pop	r17
     872:	0f 91       	pop	r16
     874:	ff 90       	pop	r15
     876:	ef 90       	pop	r14
     878:	df 90       	pop	r13
     87a:	cf 90       	pop	r12
     87c:	08 95       	ret

0000087e <TCP_TCPTask>:
     87e:	af 92       	push	r10
 *  level. If an application produces a response, this task constructs the appropriate Ethernet frame and places it into the Ethernet OUT
 *  buffer for later transmission.
 */
void TCP_TCPTask(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo,
		         Ethernet_Frame_Info_t* const FrameOUT)
{
     880:	bf 92       	push	r11
     882:	cf 92       	push	r12
     884:	df 92       	push	r13
     886:	ef 92       	push	r14
     888:	ff 92       	push	r15
     88a:	0f 93       	push	r16
     88c:	1f 93       	push	r17
     88e:	cf 93       	push	r28
     890:	df 93       	push	r29
     892:	eb 01       	movw	r28, r22
     894:	0b ef       	ldi	r16, 0xFB	; 251
     896:	1d e0       	ldi	r17, 0x0D	; 13
	{
		/* Find the corresponding port entry in the port table */
		for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
		{
			/* Run the application handler for the port */
			if ((PortStateTable[PTableEntry].Port  == ConnectionStateTable[CSTableEntry].Port) &&
     898:	20 91 3d 14 	lds	r18, 0x143D
     89c:	30 91 3e 14 	lds	r19, 0x143E
     8a0:	f8 01       	movw	r30, r16
     8a2:	80 81       	ld	r24, Z
     8a4:	91 81       	ldd	r25, Z+1	; 0x01
     8a6:	28 17       	cp	r18, r24
     8a8:	39 07       	cpc	r19, r25
     8aa:	69 f4       	brne	.+26     	; 0x8c6 <TCP_TCPTask+0x48>
     8ac:	80 91 3f 14 	lds	r24, 0x143F
     8b0:	81 30       	cpi	r24, 0x01	; 1
     8b2:	49 f4       	brne	.+18     	; 0x8c6 <TCP_TCPTask+0x48>
			    (PortStateTable[PTableEntry].State == TCP_Port_Open))
			{
				PortStateTable[PTableEntry].ApplicationHandler(&ConnectionStateTable[CSTableEntry],
     8b4:	e0 91 40 14 	lds	r30, 0x1440
     8b8:	f0 91 41 14 	lds	r31, 0x1441
     8bc:	b8 01       	movw	r22, r16
     8be:	60 5f       	subi	r22, 0xF0	; 240
     8c0:	7f 4f       	sbci	r23, 0xFF	; 255
     8c2:	c8 01       	movw	r24, r16
     8c4:	09 95       	icall
     8c6:	0a 5e       	subi	r16, 0xEA	; 234
     8c8:	1d 4f       	sbci	r17, 0xFD	; 253
 */
void TCP_TCPTask(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo,
		         Ethernet_Frame_Info_t* const FrameOUT)
{
	/* Run each application in sequence, to process incoming and generate outgoing packets */
	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
     8ca:	84 e1       	ldi	r24, 0x14	; 20
     8cc:	0d 33       	cpi	r16, 0x3D	; 61
     8ce:	18 07       	cpc	r17, r24
     8d0:	19 f7       	brne	.-58     	; 0x898 <TCP_TCPTask+0x1a>
			}
		}
	}

	/* Bail out early if there is already a frame waiting to be sent in the Ethernet OUT buffer */
	if (FrameOUT->FrameLength)
     8d2:	5e 01       	movw	r10, r28
     8d4:	f4 e2       	ldi	r31, 0x24	; 36
     8d6:	af 1a       	sub	r10, r31
     8d8:	fa ef       	ldi	r31, 0xFA	; 250
     8da:	bf 0a       	sbc	r11, r31
     8dc:	f5 01       	movw	r30, r10
     8de:	80 81       	ld	r24, Z
     8e0:	91 81       	ldd	r25, Z+1	; 0x01
     8e2:	89 2b       	or	r24, r25
     8e4:	09 f0       	breq	.+2      	; 0x8e8 <TCP_TCPTask+0x6a>
     8e6:	bb c0       	rjmp	.+374    	; 0xa5e <TCP_TCPTask+0x1e0>
     8e8:	ee e0       	ldi	r30, 0x0E	; 14
     8ea:	f0 e1       	ldi	r31, 0x10	; 16
     8ec:	80 e0       	ldi	r24, 0x00	; 0
     8ee:	90 e0       	ldi	r25, 0x00	; 0
     8f0:	df 01       	movw	r26, r30
     8f2:	11 97       	sbiw	r26, 0x01	; 1

	/* Send response packets from each application as the TCP packet buffers are filled by the applications */
	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* For each completely received packet, pass it along to the listening application */
		if ((ConnectionStateTable[CSTableEntry].Info.Buffer.Direction == TCP_PACKETDIR_OUT) &&
     8f4:	2c 91       	ld	r18, X
     8f6:	22 23       	and	r18, r18
     8f8:	09 f4       	brne	.+2      	; 0x8fc <TCP_TCPTask+0x7e>
     8fa:	aa c0       	rjmp	.+340    	; 0xa50 <TCP_TCPTask+0x1d2>
     8fc:	20 81       	ld	r18, Z
     8fe:	22 23       	and	r18, r18
     900:	09 f4       	brne	.+2      	; 0x904 <TCP_TCPTask+0x86>
     902:	a6 c0       	rjmp	.+332    	; 0xa50 <TCP_TCPTask+0x1d2>
			                                                                              sizeof(IP_Header_t)];
			void*                    TCPDataOUT     = &FrameOUT->FrameData[sizeof(Ethernet_Frame_Header_t) +
			                                                               sizeof(IP_Header_t) +
			                                                               sizeof(TCP_Header_t)];

			uint16_t PacketSize = ConnectionStateTable[CSTableEntry].Info.Buffer.Length;
     904:	26 e1       	ldi	r18, 0x16	; 22
     906:	32 e0       	ldi	r19, 0x02	; 2
     908:	82 9f       	mul	r24, r18
     90a:	60 01       	movw	r12, r0
     90c:	83 9f       	mul	r24, r19
     90e:	d0 0c       	add	r13, r0
     910:	92 9f       	mul	r25, r18
     912:	d0 0c       	add	r13, r0
     914:	11 24       	eor	r1, r1
     916:	86 01       	movw	r16, r12
     918:	05 50       	subi	r16, 0x05	; 5
     91a:	12 4f       	sbci	r17, 0xF2	; 242
     91c:	f8 01       	movw	r30, r16
     91e:	e0 88       	ldd	r14, Z+16	; 0x10
     920:	f1 88       	ldd	r15, Z+17	; 0x11

			/* Fill out the TCP data */
			TCPHeaderOUT->SourcePort           = ConnectionStateTable[CSTableEntry].Port;
     922:	80 81       	ld	r24, Z
     924:	91 81       	ldd	r25, Z+1	; 0x01
     926:	9b a3       	std	Y+35, r25	; 0x23
     928:	8a a3       	std	Y+34, r24	; 0x22
			TCPHeaderOUT->DestinationPort      = ConnectionStateTable[CSTableEntry].RemotePort;
     92a:	82 81       	ldd	r24, Z+2	; 0x02
     92c:	93 81       	ldd	r25, Z+3	; 0x03
     92e:	9d a3       	std	Y+37, r25	; 0x25
     930:	8c a3       	std	Y+36, r24	; 0x24
			TCPHeaderOUT->SequenceNumber       = SwapEndian_32(ConnectionStateTable[CSTableEntry].Info.SequenceNumberOut);
     932:	64 85       	ldd	r22, Z+12	; 0x0c
     934:	75 85       	ldd	r23, Z+13	; 0x0d
     936:	86 85       	ldd	r24, Z+14	; 0x0e
     938:	97 85       	ldd	r25, Z+15	; 0x0f
     93a:	29 df       	rcall	.-430    	; 0x78e <SwapEndian_32>
     93c:	6e a3       	std	Y+38, r22	; 0x26
     93e:	7f a3       	std	Y+39, r23	; 0x27
     940:	88 a7       	std	Y+40, r24	; 0x28
     942:	99 a7       	std	Y+41, r25	; 0x29
     944:	f8 01       	movw	r30, r16
			TCPHeaderOUT->AcknowledgmentNumber = SwapEndian_32(ConnectionStateTable[CSTableEntry].Info.SequenceNumberIn);
     946:	60 85       	ldd	r22, Z+8	; 0x08
     948:	71 85       	ldd	r23, Z+9	; 0x09
     94a:	82 85       	ldd	r24, Z+10	; 0x0a
     94c:	93 85       	ldd	r25, Z+11	; 0x0b
     94e:	1f df       	rcall	.-450    	; 0x78e <SwapEndian_32>
     950:	6a a7       	std	Y+42, r22	; 0x2a
     952:	7b a7       	std	Y+43, r23	; 0x2b
     954:	8c a7       	std	Y+44, r24	; 0x2c
     956:	9d a7       	std	Y+45, r25	; 0x2d
     958:	82 e0       	ldi	r24, 0x02	; 2
     95a:	90 e0       	ldi	r25, 0x00	; 0
			TCPHeaderOUT->DataOffset           = (sizeof(TCP_Header_t) / sizeof(uint32_t));
			TCPHeaderOUT->WindowSize           = SwapEndian_16(TCP_WINDOW_SIZE);
     95c:	99 ab       	std	Y+49, r25	; 0x31
     95e:	88 ab       	std	Y+48, r24	; 0x30
     960:	80 e1       	ldi	r24, 0x10	; 16
     962:	8f a7       	std	Y+47, r24	; 0x2f

			TCPHeaderOUT->Flags                = TCP_FLAG_ACK;
     964:	1d aa       	std	Y+53, r1	; 0x35
     966:	1c aa       	std	Y+52, r1	; 0x34
			TCPHeaderOUT->UrgentPointer        = 0;
     968:	1b aa       	std	Y+51, r1	; 0x33
     96a:	1a aa       	std	Y+50, r1	; 0x32
			TCPHeaderOUT->Checksum             = 0;
     96c:	80 e5       	ldi	r24, 0x50	; 80
     96e:	8e a7       	std	Y+46, r24	; 0x2e
			TCPHeaderOUT->Reserved             = 0;
     970:	b6 01       	movw	r22, r12
     972:	63 5f       	subi	r22, 0xF3	; 243

			memcpy(TCPDataOUT, ConnectionStateTable[CSTableEntry].Info.Buffer.Data, PacketSize);
     974:	71 4f       	sbci	r23, 0xF1	; 241
     976:	a7 01       	movw	r20, r14
     978:	ce 01       	movw	r24, r28
     97a:	c6 96       	adiw	r24, 0x36	; 54
     97c:	0e 94 b1 14 	call	0x2962	; 0x2962 <memcpy>
     980:	f8 01       	movw	r30, r16
     982:	84 85       	ldd	r24, Z+12	; 0x0c

			ConnectionStateTable[CSTableEntry].Info.SequenceNumberOut += PacketSize;
     984:	95 85       	ldd	r25, Z+13	; 0x0d
     986:	a6 85       	ldd	r26, Z+14	; 0x0e
     988:	b7 85       	ldd	r27, Z+15	; 0x0f
     98a:	8e 0d       	add	r24, r14
     98c:	9f 1d       	adc	r25, r15
     98e:	a1 1d       	adc	r26, r1
     990:	b1 1d       	adc	r27, r1
     992:	84 87       	std	Z+12, r24	; 0x0c
     994:	95 87       	std	Z+13, r25	; 0x0d
     996:	a6 87       	std	Z+14, r26	; 0x0e
     998:	b7 87       	std	Z+15, r27	; 0x0f
     99a:	97 01       	movw	r18, r14
     99c:	2c 5e       	subi	r18, 0xEC	; 236

			TCPHeaderOUT->Checksum             = TCP_Checksum16(TCPHeaderOUT, &ServerIPAddress,
     99e:	3f 4f       	sbci	r19, 0xFF	; 255
     9a0:	a6 01       	movw	r20, r12
     9a2:	41 50       	subi	r20, 0x01	; 1
			                                                    &ConnectionStateTable[CSTableEntry].RemoteAddress,
     9a4:	52 4f       	sbci	r21, 0xF2	; 242
     9a6:	60 e3       	ldi	r22, 0x30	; 48
     9a8:	71 e0       	ldi	r23, 0x01	; 1

			memcpy(TCPDataOUT, ConnectionStateTable[CSTableEntry].Info.Buffer.Data, PacketSize);

			ConnectionStateTable[CSTableEntry].Info.SequenceNumberOut += PacketSize;

			TCPHeaderOUT->Checksum             = TCP_Checksum16(TCPHeaderOUT, &ServerIPAddress,
     9aa:	ce 01       	movw	r24, r28
     9ac:	82 96       	adiw	r24, 0x22	; 34
     9ae:	f9 de       	rcall	.-526    	; 0x7a2 <TCP_Checksum16>
     9b0:	9b ab       	std	Y+51, r25	; 0x33
     9b2:	8a ab       	std	Y+50, r24	; 0x32
     9b4:	c7 01       	movw	r24, r14
     9b6:	88 96       	adiw	r24, 0x28	; 40
     9b8:	f0 de       	rcall	.-544    	; 0x79a <SwapEndian_16.part.1>
     9ba:	99 8b       	std	Y+17, r25	; 0x11
     9bc:	88 8b       	std	Y+16, r24	; 0x10
     9be:	1f 86       	std	Y+15, r1	; 0x0f
     9c0:	85 e4       	ldi	r24, 0x45	; 69
			                                                    (sizeof(TCP_Header_t) + PacketSize));

			PacketSize += sizeof(TCP_Header_t);

			/* Fill out the response IP header */
			IPHeaderOUT->TotalLength        = SwapEndian_16(sizeof(IP_Header_t) + PacketSize);
     9c2:	8e 87       	std	Y+14, r24	; 0x0e
     9c4:	1c 8a       	std	Y+20, r1	; 0x14
			IPHeaderOUT->TypeOfService      = 0;
     9c6:	1d 8a       	std	Y+21, r1	; 0x15
			IPHeaderOUT->HeaderLength       = (sizeof(IP_Header_t) / sizeof(uint32_t));
			IPHeaderOUT->Version            = 4;
     9c8:	1b 8a       	std	Y+19, r1	; 0x13
     9ca:	1a 8a       	std	Y+18, r1	; 0x12
			IPHeaderOUT->Flags              = 0;
			IPHeaderOUT->FragmentOffset     = 0;
     9cc:	19 8e       	std	Y+25, r1	; 0x19
     9ce:	18 8e       	std	Y+24, r1	; 0x18
			IPHeaderOUT->Identification     = 0;
     9d0:	f6 e0       	ldi	r31, 0x06	; 6
     9d2:	df 2e       	mov	r13, r31
			IPHeaderOUT->HeaderChecksum     = 0;
     9d4:	df 8a       	std	Y+23, r13	; 0x17
     9d6:	80 e8       	ldi	r24, 0x80	; 128
			IPHeaderOUT->Protocol           = PROTOCOL_TCP;
     9d8:	8e 8b       	std	Y+22, r24	; 0x16
     9da:	80 91 30 01 	lds	r24, 0x0130
			IPHeaderOUT->TTL                = DEFAULT_TTL;
     9de:	90 91 31 01 	lds	r25, 0x0131
			IPHeaderOUT->SourceAddress      = ServerIPAddress;
     9e2:	a0 91 32 01 	lds	r26, 0x0132
     9e6:	b0 91 33 01 	lds	r27, 0x0133
     9ea:	8a 8f       	std	Y+26, r24	; 0x1a
     9ec:	9b 8f       	std	Y+27, r25	; 0x1b
     9ee:	ac 8f       	std	Y+28, r26	; 0x1c
     9f0:	bd 8f       	std	Y+29, r27	; 0x1d
     9f2:	f8 01       	movw	r30, r16
     9f4:	84 81       	ldd	r24, Z+4	; 0x04
     9f6:	95 81       	ldd	r25, Z+5	; 0x05
     9f8:	a6 81       	ldd	r26, Z+6	; 0x06
			IPHeaderOUT->DestinationAddress = ConnectionStateTable[CSTableEntry].RemoteAddress;
     9fa:	b7 81       	ldd	r27, Z+7	; 0x07
     9fc:	8e 8f       	std	Y+30, r24	; 0x1e
     9fe:	9f 8f       	std	Y+31, r25	; 0x1f
     a00:	a8 a3       	std	Y+32, r26	; 0x20
     a02:	b9 a3       	std	Y+33, r27	; 0x21
     a04:	64 e1       	ldi	r22, 0x14	; 20
     a06:	70 e0       	ldi	r23, 0x00	; 0
     a08:	ce 01       	movw	r24, r28
     a0a:	0e 96       	adiw	r24, 0x0e	; 14

			IPHeaderOUT->HeaderChecksum     = Ethernet_Checksum16(IPHeaderOUT, sizeof(IP_Header_t));
     a0c:	46 de       	rcall	.-884    	; 0x69a <Ethernet_Checksum16>
     a0e:	99 8f       	std	Y+25, r25	; 0x19
     a10:	88 8f       	std	Y+24, r24	; 0x18
     a12:	e4 e3       	ldi	r30, 0x34	; 52
     a14:	f1 e0       	ldi	r31, 0x01	; 1
     a16:	de 01       	movw	r26, r28
     a18:	16 96       	adiw	r26, 0x06	; 6
     a1a:	8d 2d       	mov	r24, r13

			PacketSize += sizeof(IP_Header_t);

			/* Fill out the response Ethernet frame header */
			FrameOUTHeader->Source          = ServerMACAddress;
     a1c:	01 90       	ld	r0, Z+
     a1e:	0d 92       	st	X+, r0
     a20:	8a 95       	dec	r24
     a22:	e1 f7       	brne	.-8      	; 0xa1c <TCP_TCPTask+0x19e>
     a24:	ea e3       	ldi	r30, 0x3A	; 58
     a26:	f1 e0       	ldi	r31, 0x01	; 1
     a28:	de 01       	movw	r26, r28
     a2a:	01 90       	ld	r0, Z+
     a2c:	0d 92       	st	X+, r0
			FrameOUTHeader->Destination     = (MAC_Address_t){{0x02, 0x00, 0x02, 0x00, 0x02, 0x00}};
     a2e:	da 94       	dec	r13
     a30:	e1 f7       	brne	.-8      	; 0xa2a <TCP_TCPTask+0x1ac>
     a32:	88 e0       	ldi	r24, 0x08	; 8
     a34:	90 e0       	ldi	r25, 0x00	; 0
     a36:	9d 87       	std	Y+13, r25	; 0x0d
     a38:	8c 87       	std	Y+12, r24	; 0x0c
     a3a:	f6 e3       	ldi	r31, 0x36	; 54
			FrameOUTHeader->EtherType       = SwapEndian_16(ETHERTYPE_IPV4);
     a3c:	ef 0e       	add	r14, r31
     a3e:	f1 1c       	adc	r15, r1
     a40:	f5 01       	movw	r30, r10
     a42:	f1 82       	std	Z+1, r15	; 0x01

			PacketSize += sizeof(Ethernet_Frame_Header_t);
     a44:	e0 82       	st	Z, r14
     a46:	f8 01       	movw	r30, r16
     a48:	ed 5e       	subi	r30, 0xED	; 237

			/* Set the response length in the buffer and indicate that a response is ready to be sent */
			FrameOUT->FrameLength           = PacketSize;
     a4a:	fd 4f       	sbci	r31, 0xFD	; 253
     a4c:	10 82       	st	Z, r1
     a4e:	07 c0       	rjmp	.+14     	; 0xa5e <TCP_TCPTask+0x1e0>

			ConnectionStateTable[CSTableEntry].Info.Buffer.Ready = false;
     a50:	01 96       	adiw	r24, 0x01	; 1
     a52:	ea 5e       	subi	r30, 0xEA	; 234
     a54:	fd 4f       	sbci	r31, 0xFD	; 253
     a56:	83 30       	cpi	r24, 0x03	; 3

			break;
     a58:	91 05       	cpc	r25, r1
     a5a:	09 f0       	breq	.+2      	; 0xa5e <TCP_TCPTask+0x1e0>
     a5c:	49 cf       	rjmp	.-366    	; 0x8f0 <TCP_TCPTask+0x72>
     a5e:	df 91       	pop	r29
	/* Bail out early if there is already a frame waiting to be sent in the Ethernet OUT buffer */
	if (FrameOUT->FrameLength)
	  return;

	/* Send response packets from each application as the TCP packet buffers are filled by the applications */
	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
     a60:	cf 91       	pop	r28
     a62:	1f 91       	pop	r17
     a64:	0f 91       	pop	r16
     a66:	ff 90       	pop	r15
			ConnectionStateTable[CSTableEntry].Info.Buffer.Ready = false;

			break;
		}
	}
}
     a68:	ef 90       	pop	r14
     a6a:	df 90       	pop	r13
     a6c:	cf 90       	pop	r12
     a6e:	bf 90       	pop	r11
     a70:	af 90       	pop	r10
     a72:	08 95       	ret

00000a74 <TCP_Init>:
     a74:	10 92 3f 14 	sts	0x143F, r1
     a78:	8a e0       	ldi	r24, 0x0A	; 10
     a7a:	80 93 10 10 	sts	0x1010, r24
	for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
	  PortStateTable[PTableEntry].State = TCP_Port_Closed;

	/* Initialize the connection table with all CLOSED entries */
	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	  ConnectionStateTable[CSTableEntry].State = TCP_Connection_Closed;
     a7e:	80 93 26 12 	sts	0x1226, r24
     a82:	80 93 3c 14 	sts	0x143C, r24
     a86:	08 95       	ret

00000a88 <TCP_SetPortState>:

	/* Check to see if the port entry is already in the port state table */
	for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
	{
		/* Find existing entry for the port in the table, update it if found */
		if (PortStateTable[PTableEntry].Port == Port)
     a88:	20 91 3d 14 	lds	r18, 0x143D
     a8c:	30 91 3e 14 	lds	r19, 0x143E
     a90:	28 17       	cp	r18, r24
     a92:	39 07       	cpc	r19, r25
     a94:	51 f0       	breq	.+20     	; 0xaaa <TCP_SetPortState+0x22>
			return true;
		}
	}

	/* Check if trying to open the port -- if so we need to find an unused (closed) entry and replace it */
	if (State == TCP_Port_Open)
     a96:	61 30       	cpi	r22, 0x01	; 1
     a98:	71 f4       	brne	.+28     	; 0xab6 <TCP_SetPortState+0x2e>
	{
		for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
		{
			/* Find a closed port entry in the table, change it to the given port and state */
			if (PortStateTable[PTableEntry].State == TCP_Port_Closed)
     a9a:	20 91 3f 14 	lds	r18, 0x143F
     a9e:	21 11       	cpse	r18, r1
     aa0:	0c c0       	rjmp	.+24     	; 0xaba <TCP_SetPortState+0x32>
			{
				PortStateTable[PTableEntry].Port  = Port;
     aa2:	90 93 3e 14 	sts	0x143E, r25
     aa6:	80 93 3d 14 	sts	0x143D, r24
				PortStateTable[PTableEntry].State = State;
     aaa:	60 93 3f 14 	sts	0x143F, r22
				PortStateTable[PTableEntry].ApplicationHandler = Handler;
     aae:	50 93 41 14 	sts	0x1441, r21
     ab2:	40 93 40 14 	sts	0x1440, r20
		return false;
	}
	else
	{
		/* Port not in table but trying to close it, so operation successful */
		return true;
     ab6:	81 e0       	ldi	r24, 0x01	; 1
     ab8:	08 95       	ret
				return true;
			}
		}

		/* Port not in table and no room to add it, return failure */
		return false;
     aba:	80 e0       	ldi	r24, 0x00	; 0
	else
	{
		/* Port not in table but trying to close it, so operation successful */
		return true;
	}
}
     abc:	08 95       	ret

00000abe <TCP_GetPortState>:
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
	{
		/* Find existing entry for the port in the table, return the port status if found */
		if (PortStateTable[PTableEntry].Port == Port)
     abe:	20 91 3d 14 	lds	r18, 0x143D
     ac2:	30 91 3e 14 	lds	r19, 0x143E
     ac6:	28 17       	cp	r18, r24
     ac8:	39 07       	cpc	r19, r25
     aca:	19 f4       	brne	.+6      	; 0xad2 <TCP_GetPortState+0x14>
		  return PortStateTable[PTableEntry].State;
     acc:	80 91 3f 14 	lds	r24, 0x143F
     ad0:	08 95       	ret
	}

	/* Port not in table, assume closed */
	return TCP_Port_Closed;
     ad2:	80 e0       	ldi	r24, 0x00	; 0
}
     ad4:	08 95       	ret

00000ad6 <TCP_SetConnectionState>:
 */
bool TCP_SetConnectionState(const uint16_t Port,
                            const IP_Address_t* RemoteAddress,
                            const uint16_t RemotePort,
                            const uint8_t State)
{
     ad6:	8f 92       	push	r8
     ad8:	9f 92       	push	r9
     ada:	af 92       	push	r10
     adc:	bf 92       	push	r11
     ade:	cf 92       	push	r12
     ae0:	df 92       	push	r13
     ae2:	ef 92       	push	r14
     ae4:	ff 92       	push	r15
     ae6:	0f 93       	push	r16
     ae8:	1f 93       	push	r17
     aea:	cf 93       	push	r28
     aec:	df 93       	push	r29
     aee:	1f 92       	push	r1
     af0:	cd b7       	in	r28, 0x3d	; 61
     af2:	de b7       	in	r29, 0x3e	; 62
     af4:	5c 01       	movw	r10, r24
     af6:	6b 01       	movw	r12, r22
     af8:	7a 01       	movw	r14, r20
     afa:	ab ef       	ldi	r26, 0xFB	; 251
     afc:	8a 2e       	mov	r8, r26
     afe:	ad e0       	ldi	r26, 0x0D	; 13
     b00:	9a 2e       	mov	r9, r26
     b02:	00 e0       	ldi	r16, 0x00	; 0
     b04:	10 e0       	ldi	r17, 0x00	; 0
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
     b06:	d4 01       	movw	r26, r8
     b08:	8d 91       	ld	r24, X+
     b0a:	9c 91       	ld	r25, X
     b0c:	8a 15       	cp	r24, r10
     b0e:	9b 05       	cpc	r25, r11
     b10:	e9 f4       	brne	.+58     	; 0xb4c <TCP_SetConnectionState+0x76>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, RemoteAddress) &&
     b12:	44 e0       	ldi	r20, 0x04	; 4
     b14:	50 e0       	ldi	r21, 0x00	; 0
     b16:	b6 01       	movw	r22, r12
     b18:	c4 01       	movw	r24, r8
     b1a:	04 96       	adiw	r24, 0x04	; 4
     b1c:	29 83       	std	Y+1, r18	; 0x01
     b1e:	0e 94 a4 14 	call	0x2948	; 0x2948 <memcmp>
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
     b22:	29 81       	ldd	r18, Y+1	; 0x01
     b24:	89 2b       	or	r24, r25
     b26:	91 f4       	brne	.+36     	; 0xb4c <TCP_SetConnectionState+0x76>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, RemoteAddress) &&
     b28:	f4 01       	movw	r30, r8
     b2a:	82 81       	ldd	r24, Z+2	; 0x02
     b2c:	93 81       	ldd	r25, Z+3	; 0x03
     b2e:	8e 15       	cp	r24, r14
     b30:	9f 05       	cpc	r25, r15
     b32:	61 f4       	brne	.+24     	; 0xb4c <TCP_SetConnectionState+0x76>
			 ConnectionStateTable[CSTableEntry].RemotePort == RemotePort)
		{
			ConnectionStateTable[CSTableEntry].State = State;
     b34:	86 e1       	ldi	r24, 0x16	; 22
     b36:	92 e0       	ldi	r25, 0x02	; 2
     b38:	08 9f       	mul	r16, r24
     b3a:	f0 01       	movw	r30, r0
     b3c:	09 9f       	mul	r16, r25
     b3e:	f0 0d       	add	r31, r0
     b40:	18 9f       	mul	r17, r24
     b42:	f0 0d       	add	r31, r0
     b44:	11 24       	eor	r1, r1
     b46:	e0 5f       	subi	r30, 0xF0	; 240
     b48:	ff 4e       	sbci	r31, 0xEF	; 239
     b4a:	37 c0       	rjmp	.+110    	; 0xbba <TCP_SetConnectionState+0xe4>
     b4c:	0f 5f       	subi	r16, 0xFF	; 255
     b4e:	1f 4f       	sbci	r17, 0xFF	; 255
     b50:	fa ee       	ldi	r31, 0xEA	; 234
     b52:	8f 1a       	sub	r8, r31
     b54:	fd ef       	ldi	r31, 0xFD	; 253
     b56:	9f 0a       	sbc	r9, r31
                            const uint16_t RemotePort,
                            const uint8_t State)
{
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
     b58:	03 30       	cpi	r16, 0x03	; 3
     b5a:	11 05       	cpc	r17, r1
     b5c:	a1 f6       	brne	.-88     	; 0xb06 <TCP_SetConnectionState+0x30>
	}

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find empty entry in the table */
		if (ConnectionStateTable[CSTableEntry].State == TCP_Connection_Closed)
     b5e:	80 91 10 10 	lds	r24, 0x1010
     b62:	8a 30       	cpi	r24, 0x0A	; 10
     b64:	59 f0       	breq	.+22     	; 0xb7c <TCP_SetConnectionState+0xa6>
     b66:	80 91 26 12 	lds	r24, 0x1226
     b6a:	8a 30       	cpi	r24, 0x0A	; 10
     b6c:	51 f0       	breq	.+20     	; 0xb82 <TCP_SetConnectionState+0xac>
     b6e:	80 91 3c 14 	lds	r24, 0x143C
     b72:	8a 30       	cpi	r24, 0x0A	; 10
     b74:	29 f5       	brne	.+74     	; 0xbc0 <TCP_SetConnectionState+0xea>
     b76:	82 e0       	ldi	r24, 0x02	; 2
     b78:	90 e0       	ldi	r25, 0x00	; 0
     b7a:	05 c0       	rjmp	.+10     	; 0xb86 <TCP_SetConnectionState+0xb0>
     b7c:	80 e0       	ldi	r24, 0x00	; 0
     b7e:	90 e0       	ldi	r25, 0x00	; 0
     b80:	02 c0       	rjmp	.+4      	; 0xb86 <TCP_SetConnectionState+0xb0>
     b82:	81 e0       	ldi	r24, 0x01	; 1
     b84:	90 e0       	ldi	r25, 0x00	; 0
		{
			ConnectionStateTable[CSTableEntry].Port          = Port;
     b86:	46 e1       	ldi	r20, 0x16	; 22
     b88:	52 e0       	ldi	r21, 0x02	; 2
     b8a:	84 9f       	mul	r24, r20
     b8c:	f0 01       	movw	r30, r0
     b8e:	85 9f       	mul	r24, r21
     b90:	f0 0d       	add	r31, r0
     b92:	94 9f       	mul	r25, r20
     b94:	f0 0d       	add	r31, r0
     b96:	11 24       	eor	r1, r1
     b98:	e5 50       	subi	r30, 0x05	; 5
     b9a:	f2 4f       	sbci	r31, 0xF2	; 242
     b9c:	b1 82       	std	Z+1, r11	; 0x01
     b9e:	a0 82       	st	Z, r10
			ConnectionStateTable[CSTableEntry].RemoteAddress = *RemoteAddress;
     ba0:	d6 01       	movw	r26, r12
     ba2:	4d 91       	ld	r20, X+
     ba4:	5d 91       	ld	r21, X+
     ba6:	6d 91       	ld	r22, X+
     ba8:	7c 91       	ld	r23, X
     baa:	44 83       	std	Z+4, r20	; 0x04
     bac:	55 83       	std	Z+5, r21	; 0x05
     bae:	66 83       	std	Z+6, r22	; 0x06
     bb0:	77 83       	std	Z+7, r23	; 0x07
			ConnectionStateTable[CSTableEntry].RemotePort    = RemotePort;
     bb2:	f3 82       	std	Z+3, r15	; 0x03
     bb4:	e2 82       	std	Z+2, r14	; 0x02
			ConnectionStateTable[CSTableEntry].State         = State;
     bb6:	eb 5e       	subi	r30, 0xEB	; 235
     bb8:	fd 4f       	sbci	r31, 0xFD	; 253
     bba:	20 83       	st	Z, r18
			return true;
     bbc:	81 e0       	ldi	r24, 0x01	; 1
     bbe:	01 c0       	rjmp	.+2      	; 0xbc2 <TCP_SetConnectionState+0xec>
		}
	}

	return false;
     bc0:	80 e0       	ldi	r24, 0x00	; 0
}
     bc2:	0f 90       	pop	r0
     bc4:	df 91       	pop	r29
     bc6:	cf 91       	pop	r28
     bc8:	1f 91       	pop	r17
     bca:	0f 91       	pop	r16
     bcc:	ff 90       	pop	r15
     bce:	ef 90       	pop	r14
     bd0:	df 90       	pop	r13
     bd2:	cf 90       	pop	r12
     bd4:	bf 90       	pop	r11
     bd6:	af 90       	pop	r10
     bd8:	9f 90       	pop	r9
     bda:	8f 90       	pop	r8
     bdc:	08 95       	ret

00000bde <TCP_GetConnectionState>:
 *  \return A value from the \ref TCP_ConnectionStates_t enum
 */
uint8_t TCP_GetConnectionState(const uint16_t Port,
                               const IP_Address_t* RemoteAddress,
                               const uint16_t RemotePort)
{
     bde:	af 92       	push	r10
     be0:	bf 92       	push	r11
     be2:	cf 92       	push	r12
     be4:	df 92       	push	r13
     be6:	ef 92       	push	r14
     be8:	ff 92       	push	r15
     bea:	0f 93       	push	r16
     bec:	1f 93       	push	r17
     bee:	cf 93       	push	r28
     bf0:	df 93       	push	r29
     bf2:	7c 01       	movw	r14, r24
     bf4:	6b 01       	movw	r12, r22
     bf6:	5a 01       	movw	r10, r20
     bf8:	cb ef       	ldi	r28, 0xFB	; 251
     bfa:	dd e0       	ldi	r29, 0x0D	; 13
     bfc:	00 e0       	ldi	r16, 0x00	; 0
     bfe:	10 e0       	ldi	r17, 0x00	; 0
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
     c00:	88 81       	ld	r24, Y
     c02:	99 81       	ldd	r25, Y+1	; 0x01
     c04:	8e 15       	cp	r24, r14
     c06:	9f 05       	cpc	r25, r15
     c08:	d9 f4       	brne	.+54     	; 0xc40 <TCP_GetConnectionState+0x62>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, RemoteAddress) &&
     c0a:	44 e0       	ldi	r20, 0x04	; 4
     c0c:	50 e0       	ldi	r21, 0x00	; 0
     c0e:	b6 01       	movw	r22, r12
     c10:	ce 01       	movw	r24, r28
     c12:	04 96       	adiw	r24, 0x04	; 4
     c14:	0e 94 a4 14 	call	0x2948	; 0x2948 <memcmp>
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
     c18:	89 2b       	or	r24, r25
     c1a:	91 f4       	brne	.+36     	; 0xc40 <TCP_GetConnectionState+0x62>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, RemoteAddress) &&
     c1c:	8a 81       	ldd	r24, Y+2	; 0x02
     c1e:	9b 81       	ldd	r25, Y+3	; 0x03
     c20:	8a 15       	cp	r24, r10
     c22:	9b 05       	cpc	r25, r11
     c24:	69 f4       	brne	.+26     	; 0xc40 <TCP_GetConnectionState+0x62>
			 ConnectionStateTable[CSTableEntry].RemotePort == RemotePort)

		{
			return ConnectionStateTable[CSTableEntry].State;
     c26:	86 e1       	ldi	r24, 0x16	; 22
     c28:	92 e0       	ldi	r25, 0x02	; 2
     c2a:	08 9f       	mul	r16, r24
     c2c:	f0 01       	movw	r30, r0
     c2e:	09 9f       	mul	r16, r25
     c30:	f0 0d       	add	r31, r0
     c32:	18 9f       	mul	r17, r24
     c34:	f0 0d       	add	r31, r0
     c36:	11 24       	eor	r1, r1
     c38:	e0 5f       	subi	r30, 0xF0	; 240
     c3a:	ff 4e       	sbci	r31, 0xEF	; 239
     c3c:	80 81       	ld	r24, Z
     c3e:	08 c0       	rjmp	.+16     	; 0xc50 <TCP_GetConnectionState+0x72>
     c40:	0f 5f       	subi	r16, 0xFF	; 255
     c42:	1f 4f       	sbci	r17, 0xFF	; 255
     c44:	ca 5e       	subi	r28, 0xEA	; 234
     c46:	dd 4f       	sbci	r29, 0xFD	; 253
                               const IP_Address_t* RemoteAddress,
                               const uint16_t RemotePort)
{
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
     c48:	03 30       	cpi	r16, 0x03	; 3
     c4a:	11 05       	cpc	r17, r1
     c4c:	c9 f6       	brne	.-78     	; 0xc00 <TCP_GetConnectionState+0x22>
		{
			return ConnectionStateTable[CSTableEntry].State;
		}
	}

	return TCP_Connection_Closed;
     c4e:	8a e0       	ldi	r24, 0x0A	; 10
}
     c50:	df 91       	pop	r29
     c52:	cf 91       	pop	r28
     c54:	1f 91       	pop	r17
     c56:	0f 91       	pop	r16
     c58:	ff 90       	pop	r15
     c5a:	ef 90       	pop	r14
     c5c:	df 90       	pop	r13
     c5e:	cf 90       	pop	r12
     c60:	bf 90       	pop	r11
     c62:	af 90       	pop	r10
     c64:	08 95       	ret

00000c66 <TCP_GetConnectionInfo>:
 *  \return ConnectionInfo structure of the connection if found, NULL otherwise
 */
TCP_ConnectionInfo_t* TCP_GetConnectionInfo(const uint16_t Port,
                                            const IP_Address_t* RemoteAddress,
                                            const uint16_t RemotePort)
{
     c66:	af 92       	push	r10
     c68:	bf 92       	push	r11
     c6a:	cf 92       	push	r12
     c6c:	df 92       	push	r13
     c6e:	ef 92       	push	r14
     c70:	ff 92       	push	r15
     c72:	0f 93       	push	r16
     c74:	1f 93       	push	r17
     c76:	cf 93       	push	r28
     c78:	df 93       	push	r29
     c7a:	7c 01       	movw	r14, r24
     c7c:	6b 01       	movw	r12, r22
     c7e:	5a 01       	movw	r10, r20
     c80:	cb ef       	ldi	r28, 0xFB	; 251
     c82:	dd e0       	ldi	r29, 0x0D	; 13
     c84:	00 e0       	ldi	r16, 0x00	; 0
     c86:	10 e0       	ldi	r17, 0x00	; 0
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
     c88:	88 81       	ld	r24, Y
     c8a:	99 81       	ldd	r25, Y+1	; 0x01
     c8c:	8e 15       	cp	r24, r14
     c8e:	9f 05       	cpc	r25, r15
     c90:	d1 f4       	brne	.+52     	; 0xcc6 <TCP_GetConnectionInfo+0x60>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, RemoteAddress) &&
     c92:	44 e0       	ldi	r20, 0x04	; 4
     c94:	50 e0       	ldi	r21, 0x00	; 0
     c96:	b6 01       	movw	r22, r12
     c98:	ce 01       	movw	r24, r28
     c9a:	04 96       	adiw	r24, 0x04	; 4
     c9c:	0e 94 a4 14 	call	0x2948	; 0x2948 <memcmp>
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
     ca0:	89 2b       	or	r24, r25
     ca2:	89 f4       	brne	.+34     	; 0xcc6 <TCP_GetConnectionInfo+0x60>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, RemoteAddress) &&
     ca4:	8a 81       	ldd	r24, Y+2	; 0x02
     ca6:	9b 81       	ldd	r25, Y+3	; 0x03
     ca8:	8a 15       	cp	r24, r10
     caa:	9b 05       	cpc	r25, r11
     cac:	61 f4       	brne	.+24     	; 0xcc6 <TCP_GetConnectionInfo+0x60>
			 ConnectionStateTable[CSTableEntry].RemotePort == RemotePort)
		{
			return &ConnectionStateTable[CSTableEntry].Info;
     cae:	26 e1       	ldi	r18, 0x16	; 22
     cb0:	32 e0       	ldi	r19, 0x02	; 2
     cb2:	02 9f       	mul	r16, r18
     cb4:	c0 01       	movw	r24, r0
     cb6:	03 9f       	mul	r16, r19
     cb8:	90 0d       	add	r25, r0
     cba:	12 9f       	mul	r17, r18
     cbc:	90 0d       	add	r25, r0
     cbe:	11 24       	eor	r1, r1
     cc0:	8d 5f       	subi	r24, 0xFD	; 253
     cc2:	91 4f       	sbci	r25, 0xF1	; 241
     cc4:	09 c0       	rjmp	.+18     	; 0xcd8 <TCP_GetConnectionInfo+0x72>
     cc6:	0f 5f       	subi	r16, 0xFF	; 255
     cc8:	1f 4f       	sbci	r17, 0xFF	; 255
     cca:	ca 5e       	subi	r28, 0xEA	; 234
     ccc:	dd 4f       	sbci	r29, 0xFD	; 253
                                            const IP_Address_t* RemoteAddress,
                                            const uint16_t RemotePort)
{
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
     cce:	03 30       	cpi	r16, 0x03	; 3
     cd0:	11 05       	cpc	r17, r1
     cd2:	d1 f6       	brne	.-76     	; 0xc88 <TCP_GetConnectionInfo+0x22>
		{
			return &ConnectionStateTable[CSTableEntry].Info;
		}
	}

	return NULL;
     cd4:	80 e0       	ldi	r24, 0x00	; 0
     cd6:	90 e0       	ldi	r25, 0x00	; 0
}
     cd8:	df 91       	pop	r29
     cda:	cf 91       	pop	r28
     cdc:	1f 91       	pop	r17
     cde:	0f 91       	pop	r16
     ce0:	ff 90       	pop	r15
     ce2:	ef 90       	pop	r14
     ce4:	df 90       	pop	r13
     ce6:	cf 90       	pop	r12
     ce8:	bf 90       	pop	r11
     cea:	af 90       	pop	r10
     cec:	08 95       	ret

00000cee <TCP_ProcessTCPPacket>:
 *           next Ethernet packet handler iteration
 */
int16_t TCP_ProcessTCPPacket(void* IPHeaderInStart,
                             void* TCPHeaderInStart,
                             void* TCPHeaderOutStart)
{
     cee:	2f 92       	push	r2
     cf0:	3f 92       	push	r3
     cf2:	4f 92       	push	r4
     cf4:	5f 92       	push	r5
     cf6:	6f 92       	push	r6
     cf8:	7f 92       	push	r7
     cfa:	8f 92       	push	r8
     cfc:	9f 92       	push	r9
     cfe:	af 92       	push	r10
     d00:	bf 92       	push	r11
     d02:	cf 92       	push	r12
     d04:	df 92       	push	r13
     d06:	ef 92       	push	r14
     d08:	ff 92       	push	r15
     d0a:	0f 93       	push	r16
     d0c:	1f 93       	push	r17
     d0e:	cf 93       	push	r28
     d10:	df 93       	push	r29
     d12:	00 d0       	rcall	.+0      	; 0xd14 <TCP_ProcessTCPPacket+0x26>
     d14:	1f 92       	push	r1
     d16:	cd b7       	in	r28, 0x3d	; 61
     d18:	de b7       	in	r29, 0x3e	; 62
     d1a:	5c 01       	movw	r10, r24
     d1c:	7b 83       	std	Y+3, r23	; 0x03
     d1e:	6a 83       	std	Y+2, r22	; 0x02
     d20:	8a 01       	movw	r16, r20
	TCP_Header_t* TCPHeaderIN  = (TCP_Header_t*)TCPHeaderInStart;
	TCP_Header_t* TCPHeaderOUT = (TCP_Header_t*)TCPHeaderOutStart;

	TCP_ConnectionInfo_t* ConnectionInfo;

	DecodeTCPHeader(TCPHeaderInStart);
     d22:	cb 01       	movw	r24, r22
     d24:	ef dc       	rcall	.-1570   	; 0x704 <DecodeTCPHeader>
     d26:	aa 81       	ldd	r26, Y+2	; 0x02

	bool PacketResponse = false;

	/* Check if the destination port is open and allows incoming connections */
	if (TCP_GetPortState(TCPHeaderIN->DestinationPort) == TCP_Port_Open)
     d28:	bb 81       	ldd	r27, Y+3	; 0x03
     d2a:	12 96       	adiw	r26, 0x02	; 2
     d2c:	cd 90       	ld	r12, X+
     d2e:	dc 90       	ld	r13, X
     d30:	13 97       	sbiw	r26, 0x03	; 3
     d32:	c6 01       	movw	r24, r12
     d34:	c4 de       	rcall	.-632    	; 0xabe <TCP_GetPortState>
     d36:	f5 01       	movw	r30, r10
     d38:	3c 96       	adiw	r30, 0x0c	; 12
     d3a:	7f 01       	movw	r14, r30
     d3c:	81 30       	cpi	r24, 0x01	; 1
     d3e:	09 f0       	breq	.+2      	; 0xd42 <TCP_ProcessTCPPacket+0x54>
     d40:	8e c1       	rjmp	.+796    	; 0x105e <TCP_ProcessTCPPacket+0x370>
     d42:	aa 81       	ldd	r26, Y+2	; 0x02
     d44:	bb 81       	ldd	r27, Y+3	; 0x03
	{
		/* Detect SYN from host to start a connection */
		if (TCPHeaderIN->Flags & TCP_FLAG_SYN)
     d46:	1d 96       	adiw	r26, 0x0d	; 13
     d48:	8c 91       	ld	r24, X
     d4a:	1d 97       	sbiw	r26, 0x0d	; 13
     d4c:	81 ff       	sbrs	r24, 1
     d4e:	06 c0       	rjmp	.+12     	; 0xd5c <TCP_ProcessTCPPacket+0x6e>
     d50:	4d 91       	ld	r20, X+
     d52:	5c 91       	ld	r21, X
		  TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress, TCPHeaderIN->SourcePort, TCP_Connection_Listen);
     d54:	20 e0       	ldi	r18, 0x00	; 0
     d56:	bf 01       	movw	r22, r30
     d58:	c6 01       	movw	r24, r12
     d5a:	bd de       	rcall	.-646    	; 0xad6 <TCP_SetConnectionState>
     d5c:	ea 81       	ldd	r30, Y+2	; 0x02
     d5e:	fb 81       	ldd	r31, Y+3	; 0x03
     d60:	25 85       	ldd	r18, Z+13	; 0x0d

		/* Detect RST from host to abort existing connection */
		if (TCPHeaderIN->Flags & TCP_FLAG_RST)
     d62:	c2 80       	ldd	r12, Z+2	; 0x02
     d64:	d3 80       	ldd	r13, Z+3	; 0x03
     d66:	80 80       	ld	r8, Z
     d68:	91 80       	ldd	r9, Z+1	; 0x01
     d6a:	22 ff       	sbrs	r18, 2
     d6c:	09 c0       	rjmp	.+18     	; 0xd80 <TCP_ProcessTCPPacket+0x92>
     d6e:	2a e0       	ldi	r18, 0x0A	; 10
     d70:	a4 01       	movw	r20, r8
     d72:	b7 01       	movw	r22, r14
		{
			if (TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
     d74:	c6 01       	movw	r24, r12
     d76:	af de       	rcall	.-674    	; 0xad6 <TCP_SetConnectionState>
     d78:	88 23       	and	r24, r24
     d7a:	09 f4       	brne	.+2      	; 0xd7e <TCP_ProcessTCPPacket+0x90>
     d7c:	d6 c1       	rjmp	.+940    	; 0x112a <TCP_ProcessTCPPacket+0x43c>
     d7e:	6f c1       	rjmp	.+734    	; 0x105e <TCP_ProcessTCPPacket+0x370>
     d80:	a4 01       	movw	r20, r8
     d82:	b7 01       	movw	r22, r14
     d84:	c6 01       	movw	r24, r12
     d86:	29 83       	std	Y+1, r18	; 0x01
			}
		}
		else
		{
			/* Process the incoming TCP packet based on the current connection state for the sender and port */
			switch (TCP_GetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress, TCPHeaderIN->SourcePort))
     d88:	2a df       	rcall	.-428    	; 0xbde <TCP_GetConnectionState>
     d8a:	29 81       	ldd	r18, Y+1	; 0x01
     d8c:	84 30       	cpi	r24, 0x04	; 4
     d8e:	09 f4       	brne	.+2      	; 0xd92 <TCP_ProcessTCPPacket+0xa4>
     d90:	28 c1       	rjmp	.+592    	; 0xfe2 <TCP_ProcessTCPPacket+0x2f4>
     d92:	40 f4       	brcc	.+16     	; 0xda4 <TCP_ProcessTCPPacket+0xb6>
     d94:	82 30       	cpi	r24, 0x02	; 2
     d96:	09 f4       	brne	.+2      	; 0xd9a <TCP_ProcessTCPPacket+0xac>
     d98:	52 c0       	rjmp	.+164    	; 0xe3e <TCP_ProcessTCPPacket+0x150>
     d9a:	08 f0       	brcs	.+2      	; 0xd9e <TCP_ProcessTCPPacket+0xb0>
     d9c:	71 c0       	rjmp	.+226    	; 0xe80 <TCP_ProcessTCPPacket+0x192>
     d9e:	88 23       	and	r24, r24
     da0:	d1 f0       	breq	.+52     	; 0xdd6 <TCP_ProcessTCPPacket+0xe8>
     da2:	c3 c1       	rjmp	.+902    	; 0x112a <TCP_ProcessTCPPacket+0x43c>
     da4:	86 30       	cpi	r24, 0x06	; 6
     da6:	09 f4       	brne	.+2      	; 0xdaa <TCP_ProcessTCPPacket+0xbc>
     da8:	51 c1       	rjmp	.+674    	; 0x104c <TCP_ProcessTCPPacket+0x35e>
     daa:	08 f4       	brcc	.+2      	; 0xdae <TCP_ProcessTCPPacket+0xc0>
     dac:	21 c1       	rjmp	.+578    	; 0xff0 <TCP_ProcessTCPPacket+0x302>
     dae:	87 30       	cpi	r24, 0x07	; 7
     db0:	09 f0       	breq	.+2      	; 0xdb4 <TCP_ProcessTCPPacket+0xc6>
     db2:	bb c1       	rjmp	.+886    	; 0x112a <TCP_ProcessTCPPacket+0x43c>
     db4:	a4 01       	movw	r20, r8
     db6:	b7 01       	movw	r22, r14
     db8:	c6 01       	movw	r24, r12
     dba:	55 df       	rcall	.-342    	; 0xc66 <TCP_GetConnectionInfo>
     dbc:	21 e1       	ldi	r18, 0x11	; 17
						}
					}

					break;
				case TCP_Connection_Closing:
						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
     dbe:	f8 01       	movw	r30, r16
     dc0:	25 87       	std	Z+13, r18	; 0x0d
     dc2:	84 5f       	subi	r24, 0xF4	; 244
     dc4:	9d 4f       	sbci	r25, 0xFD	; 253
     dc6:	dc 01       	movw	r26, r24
															   TCPHeaderIN->SourcePort);

						TCPHeaderOUT->Flags = (TCP_FLAG_ACK | TCP_FLAG_FIN);
     dc8:	1c 92       	st	X, r1
     dca:	ea 81       	ldd	r30, Y+2	; 0x02
     dcc:	fb 81       	ldd	r31, Y+3	; 0x03
						PacketResponse      = true;

						ConnectionInfo->Buffer.InUse = false;
     dce:	40 81       	ld	r20, Z
     dd0:	51 81       	ldd	r21, Z+1	; 0x01
     dd2:	24 e0       	ldi	r18, 0x04	; 4
     dd4:	36 c1       	rjmp	.+620    	; 0x1042 <TCP_ProcessTCPPacket+0x354>

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
     dd6:	22 30       	cpi	r18, 0x02	; 2
     dd8:	09 f0       	breq	.+2      	; 0xddc <TCP_ProcessTCPPacket+0xee>
     dda:	a7 c1       	rjmp	.+846    	; 0x112a <TCP_ProcessTCPPacket+0x43c>
     ddc:	a4 01       	movw	r20, r8
     dde:	b7 01       	movw	r22, r14
     de0:	c6 01       	movw	r24, r12
		{
			/* Process the incoming TCP packet based on the current connection state for the sender and port */
			switch (TCP_GetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress, TCPHeaderIN->SourcePort))
			{
				case TCP_Connection_Listen:
					if (TCPHeaderIN->Flags == TCP_FLAG_SYN)
     de2:	79 de       	rcall	.-782    	; 0xad6 <TCP_SetConnectionState>
     de4:	88 23       	and	r24, r24
     de6:	49 f1       	breq	.+82     	; 0xe3a <TCP_ProcessTCPPacket+0x14c>
					{
						/* SYN connection starts a connection with a peer */
						if (TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
     de8:	82 e1       	ldi	r24, 0x12	; 18
     dea:	f8 01       	movw	r30, r16
     dec:	85 87       	std	Z+13, r24	; 0x0d
     dee:	aa 81       	ldd	r26, Y+2	; 0x02
     df0:	bb 81       	ldd	r27, Y+3	; 0x03
     df2:	4d 91       	ld	r20, X+
     df4:	5c 91       	ld	r21, X
						                           TCPHeaderIN->SourcePort, TCP_Connection_SYNReceived))
						{
							TCPHeaderOUT->Flags = (TCP_FLAG_SYN | TCP_FLAG_ACK);
     df6:	11 97       	sbiw	r26, 0x01	; 1
     df8:	b7 01       	movw	r22, r14
     dfa:	12 96       	adiw	r26, 0x02	; 2

							ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress, TCPHeaderIN->SourcePort);
     dfc:	8d 91       	ld	r24, X+
     dfe:	9c 91       	ld	r25, X
     e00:	13 97       	sbiw	r26, 0x03	; 3
     e02:	31 df       	rcall	.-414    	; 0xc66 <TCP_GetConnectionInfo>
     e04:	6c 01       	movw	r12, r24
     e06:	ea 81       	ldd	r30, Y+2	; 0x02
     e08:	fb 81       	ldd	r31, Y+3	; 0x03
     e0a:	64 81       	ldd	r22, Z+4	; 0x04
     e0c:	75 81       	ldd	r23, Z+5	; 0x05
     e0e:	86 81       	ldd	r24, Z+6	; 0x06
     e10:	97 81       	ldd	r25, Z+7	; 0x07
     e12:	bd dc       	rcall	.-1670   	; 0x78e <SwapEndian_32>
     e14:	6f 5f       	subi	r22, 0xFF	; 255

							ConnectionInfo->SequenceNumberIn  = (SwapEndian_32(TCPHeaderIN->SequenceNumber) + 1);
     e16:	7f 4f       	sbci	r23, 0xFF	; 255
     e18:	8f 4f       	sbci	r24, 0xFF	; 255
     e1a:	9f 4f       	sbci	r25, 0xFF	; 255
     e1c:	d6 01       	movw	r26, r12
     e1e:	6d 93       	st	X+, r22
     e20:	7d 93       	st	X+, r23
     e22:	8d 93       	st	X+, r24
     e24:	9c 93       	st	X, r25
     e26:	13 97       	sbiw	r26, 0x03	; 3
     e28:	f6 01       	movw	r30, r12
     e2a:	14 82       	std	Z+4, r1	; 0x04
     e2c:	15 82       	std	Z+5, r1	; 0x05
     e2e:	16 82       	std	Z+6, r1	; 0x06
     e30:	17 82       	std	Z+7, r1	; 0x07
     e32:	e4 5f       	subi	r30, 0xF4	; 244
     e34:	fd 4f       	sbci	r31, 0xFD	; 253
     e36:	10 82       	st	Z, r1
     e38:	17 c1       	rjmp	.+558    	; 0x1068 <TCP_ProcessTCPPacket+0x37a>
							ConnectionInfo->SequenceNumberOut = 0;
     e3a:	84 e0       	ldi	r24, 0x04	; 4
     e3c:	ce c0       	rjmp	.+412    	; 0xfda <TCP_ProcessTCPPacket+0x2ec>
     e3e:	20 31       	cpi	r18, 0x10	; 16
     e40:	09 f0       	breq	.+2      	; 0xe44 <TCP_ProcessTCPPacket+0x156>
     e42:	73 c1       	rjmp	.+742    	; 0x112a <TCP_ProcessTCPPacket+0x43c>
							ConnectionInfo->Buffer.InUse      = false;
     e44:	23 e0       	ldi	r18, 0x03	; 3
     e46:	a4 01       	movw	r20, r8
     e48:	b7 01       	movw	r22, r14
     e4a:	c6 01       	movw	r24, r12
						}
						else
						{
							TCPHeaderOUT->Flags = TCP_FLAG_RST;
     e4c:	44 de       	rcall	.-888    	; 0xad6 <TCP_SetConnectionState>
     e4e:	ea 81       	ldd	r30, Y+2	; 0x02
						PacketResponse      = true;
					}

					break;
				case TCP_Connection_SYNReceived:
					if (TCPHeaderIN->Flags == TCP_FLAG_ACK)
     e50:	fb 81       	ldd	r31, Y+3	; 0x03
     e52:	40 81       	ld	r20, Z
     e54:	51 81       	ldd	r21, Z+1	; 0x01
					{
						/* ACK during the connection process completes the connection to a peer */

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
     e56:	b7 01       	movw	r22, r14
     e58:	82 81       	ldd	r24, Z+2	; 0x02
     e5a:	93 81       	ldd	r25, Z+3	; 0x03
     e5c:	04 df       	rcall	.-504    	; 0xc66 <TCP_GetConnectionInfo>
     e5e:	dc 01       	movw	r26, r24
     e60:	14 96       	adiw	r26, 0x04	; 4
											   TCPHeaderIN->SourcePort, TCP_Connection_Established);

						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
     e62:	4d 91       	ld	r20, X+
     e64:	5d 91       	ld	r21, X+
     e66:	6d 91       	ld	r22, X+
     e68:	7c 91       	ld	r23, X
     e6a:	17 97       	sbiw	r26, 0x07	; 7
     e6c:	4f 5f       	subi	r20, 0xFF	; 255
     e6e:	5f 4f       	sbci	r21, 0xFF	; 255
     e70:	6f 4f       	sbci	r22, 0xFF	; 255
     e72:	7f 4f       	sbci	r23, 0xFF	; 255
															   TCPHeaderIN->SourcePort);

						ConnectionInfo->SequenceNumberOut++;
     e74:	fc 01       	movw	r30, r24
     e76:	44 83       	std	Z+4, r20	; 0x04
     e78:	55 83       	std	Z+5, r21	; 0x05
     e7a:	66 83       	std	Z+6, r22	; 0x06
     e7c:	77 83       	std	Z+7, r23	; 0x07
     e7e:	55 c1       	rjmp	.+682    	; 0x112a <TCP_ProcessTCPPacket+0x43c>
     e80:	21 31       	cpi	r18, 0x11	; 17
     e82:	89 f5       	brne	.+98     	; 0xee6 <TCP_ProcessTCPPacket+0x1f8>
     e84:	d8 01       	movw	r26, r16
     e86:	1d 96       	adiw	r26, 0x0d	; 13
     e88:	2c 93       	st	X, r18
     e8a:	ea 81       	ldd	r30, Y+2	; 0x02
     e8c:	fb 81       	ldd	r31, Y+3	; 0x03
     e8e:	40 81       	ld	r20, Z
     e90:	51 81       	ldd	r21, Z+1	; 0x01
     e92:	26 e0       	ldi	r18, 0x06	; 6
     e94:	b7 01       	movw	r22, r14
					}

					break;
				case TCP_Connection_Established:
					if (TCPHeaderIN->Flags == (TCP_FLAG_FIN | TCP_FLAG_ACK))
     e96:	82 81       	ldd	r24, Z+2	; 0x02
     e98:	93 81       	ldd	r25, Z+3	; 0x03
					{
						/* FIN ACK when connected to a peer starts the finalization process */

						TCPHeaderOUT->Flags = (TCP_FLAG_FIN | TCP_FLAG_ACK);
     e9a:	1d de       	rcall	.-966    	; 0xad6 <TCP_SetConnectionState>
     e9c:	aa 81       	ldd	r26, Y+2	; 0x02
     e9e:	bb 81       	ldd	r27, Y+3	; 0x03
						PacketResponse      = true;

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
     ea0:	4d 91       	ld	r20, X+
     ea2:	5c 91       	ld	r21, X
     ea4:	11 97       	sbiw	r26, 0x01	; 1
     ea6:	b7 01       	movw	r22, r14
     ea8:	12 96       	adiw	r26, 0x02	; 2
     eaa:	8d 91       	ld	r24, X+
     eac:	9c 91       	ld	r25, X
     eae:	13 97       	sbiw	r26, 0x03	; 3
     eb0:	da de       	rcall	.-588    	; 0xc66 <TCP_GetConnectionInfo>
     eb2:	fc 01       	movw	r30, r24
											   TCPHeaderIN->SourcePort, TCP_Connection_CloseWait);

						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
     eb4:	40 81       	ld	r20, Z
     eb6:	51 81       	ldd	r21, Z+1	; 0x01
     eb8:	62 81       	ldd	r22, Z+2	; 0x02
     eba:	73 81       	ldd	r23, Z+3	; 0x03
     ebc:	4f 5f       	subi	r20, 0xFF	; 255
     ebe:	5f 4f       	sbci	r21, 0xFF	; 255
     ec0:	6f 4f       	sbci	r22, 0xFF	; 255
     ec2:	7f 4f       	sbci	r23, 0xFF	; 255
     ec4:	40 83       	st	Z, r20
     ec6:	51 83       	std	Z+1, r21	; 0x01
     ec8:	62 83       	std	Z+2, r22	; 0x02
     eca:	73 83       	std	Z+3, r23	; 0x03
     ecc:	44 81       	ldd	r20, Z+4	; 0x04
															   TCPHeaderIN->SourcePort);

						ConnectionInfo->SequenceNumberIn++;
     ece:	55 81       	ldd	r21, Z+5	; 0x05
     ed0:	66 81       	ldd	r22, Z+6	; 0x06
     ed2:	77 81       	ldd	r23, Z+7	; 0x07
     ed4:	4f 5f       	subi	r20, 0xFF	; 255
     ed6:	5f 4f       	sbci	r21, 0xFF	; 255
     ed8:	6f 4f       	sbci	r22, 0xFF	; 255
     eda:	7f 4f       	sbci	r23, 0xFF	; 255
     edc:	44 83       	std	Z+4, r20	; 0x04
     ede:	55 83       	std	Z+5, r21	; 0x05
     ee0:	66 83       	std	Z+6, r22	; 0x06
     ee2:	77 83       	std	Z+7, r23	; 0x07
     ee4:	c1 c0       	rjmp	.+386    	; 0x1068 <TCP_ProcessTCPPacket+0x37a>
						ConnectionInfo->SequenceNumberOut++;
     ee6:	27 7f       	andi	r18, 0xF7	; 247
     ee8:	20 31       	cpi	r18, 0x10	; 16
     eea:	09 f0       	breq	.+2      	; 0xeee <TCP_ProcessTCPPacket+0x200>
     eec:	1e c1       	rjmp	.+572    	; 0x112a <TCP_ProcessTCPPacket+0x43c>
     eee:	a4 01       	movw	r20, r8
     ef0:	b7 01       	movw	r22, r14
     ef2:	c6 01       	movw	r24, r12
     ef4:	b8 de       	rcall	.-656    	; 0xc66 <TCP_GetConnectionInfo>
     ef6:	6c 01       	movw	r12, r24
     ef8:	4c 01       	movw	r8, r24
     efa:	b4 ef       	ldi	r27, 0xF4	; 244
     efc:	8b 1a       	sub	r8, r27
     efe:	bd ef       	ldi	r27, 0xFD	; 253
					}
					else if ((TCPHeaderIN->Flags == TCP_FLAG_ACK) || (TCPHeaderIN->Flags == (TCP_FLAG_ACK | TCP_FLAG_PSH)))
     f00:	9b 0a       	sbc	r9, r27
     f02:	f4 01       	movw	r30, r8
     f04:	80 81       	ld	r24, Z
     f06:	f6 01       	movw	r30, r12
					{
						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
     f08:	e6 5f       	subi	r30, 0xF6	; 246
     f0a:	fd 4f       	sbci	r31, 0xFD	; 253
     f0c:	81 11       	cpse	r24, r1
     f0e:	0f c0       	rjmp	.+30     	; 0xf2e <TCP_ProcessTCPPacket+0x240>
     f10:	d6 01       	movw	r26, r12
     f12:	a5 5f       	subi	r26, 0xF5	; 245
															   TCPHeaderIN->SourcePort);

						/* Check if the buffer is currently in use either by a buffered data to send, or receive */
						if ((ConnectionInfo->Buffer.InUse == false) && (ConnectionInfo->Buffer.Ready == false))
     f14:	bd 4f       	sbci	r27, 0xFD	; 253
     f16:	8c 91       	ld	r24, X
     f18:	81 11       	cpse	r24, r1
     f1a:	09 c0       	rjmp	.+18     	; 0xf2e <TCP_ProcessTCPPacket+0x240>
     f1c:	10 82       	st	Z, r1
     f1e:	81 e0       	ldi	r24, 0x01	; 1
     f20:	d4 01       	movw	r26, r8
     f22:	8c 93       	st	X, r24
     f24:	d6 01       	movw	r26, r12
     f26:	19 96       	adiw	r26, 0x09	; 9
     f28:	1c 92       	st	X, r1
     f2a:	1e 92       	st	-X, r1
     f2c:	18 97       	sbiw	r26, 0x08	; 8
     f2e:	80 81       	ld	r24, Z
     f30:	81 11       	cpse	r24, r1
     f32:	97 c0       	rjmp	.+302    	; 0x1062 <TCP_ProcessTCPPacket+0x374>
     f34:	f6 01       	movw	r30, r12
     f36:	40 84       	ldd	r4, Z+8	; 0x08
						{
							ConnectionInfo->Buffer.Direction = TCP_PACKETDIR_IN;
     f38:	51 84       	ldd	r5, Z+9	; 0x09
							ConnectionInfo->Buffer.InUse     = true;
     f3a:	41 14       	cp	r4, r1
     f3c:	f2 e0       	ldi	r31, 0x02	; 2
     f3e:	5f 06       	cpc	r5, r31
							ConnectionInfo->Buffer.Length    = 0;
     f40:	09 f4       	brne	.+2      	; 0xf44 <TCP_ProcessTCPPacket+0x256>
     f42:	8f c0       	rjmp	.+286    	; 0x1062 <TCP_ProcessTCPPacket+0x374>
     f44:	d5 01       	movw	r26, r10
     f46:	8c 91       	ld	r24, X
     f48:	8f 70       	andi	r24, 0x0F	; 15
						}

						/* Check if the buffer has been claimed by us to read in data from the peer */
						if ((ConnectionInfo->Buffer.Direction == TCP_PACKETDIR_IN) &&
     f4a:	b4 e0       	ldi	r27, 0x04	; 4
     f4c:	8b 9f       	mul	r24, r27
     f4e:	30 01       	movw	r6, r0
							(ConnectionInfo->Buffer.Length != TCP_WINDOW_SIZE))
     f50:	11 24       	eor	r1, r1
     f52:	ea 81       	ldd	r30, Y+2	; 0x02
     f54:	fb 81       	ldd	r31, Y+3	; 0x03
							ConnectionInfo->Buffer.InUse     = true;
							ConnectionInfo->Buffer.Length    = 0;
						}

						/* Check if the buffer has been claimed by us to read in data from the peer */
						if ((ConnectionInfo->Buffer.Direction == TCP_PACKETDIR_IN) &&
     f56:	24 84       	ldd	r2, Z+12	; 0x0c
     f58:	22 94       	swap	r2
     f5a:	bf e0       	ldi	r27, 0x0F	; 15
     f5c:	2b 22       	and	r2, r27
     f5e:	f4 e0       	ldi	r31, 0x04	; 4
							(ConnectionInfo->Buffer.Length != TCP_WINDOW_SIZE))
						{
							uint16_t IPOffset   = (IPHeaderIN->HeaderLength * sizeof(uint32_t));
     f60:	2f 9e       	mul	r2, r31
     f62:	10 01       	movw	r2, r0
     f64:	11 24       	eor	r1, r1
     f66:	d5 01       	movw	r26, r10
     f68:	12 96       	adiw	r26, 0x02	; 2
     f6a:	8d 91       	ld	r24, X+
     f6c:	9c 91       	ld	r25, X
							uint16_t TCPOffset  = (TCPHeaderIN->DataOffset * sizeof(uint32_t));
     f6e:	13 97       	sbiw	r26, 0x03	; 3
     f70:	14 dc       	rcall	.-2008   	; 0x79a <SwapEndian_16.part.1>
     f72:	86 19       	sub	r24, r6
     f74:	97 09       	sbc	r25, r7
     f76:	3c 01       	movw	r6, r24
     f78:	62 18       	sub	r6, r2
     f7a:	73 08       	sbc	r7, r3
     f7c:	c2 01       	movw	r24, r4
     f7e:	0a 96       	adiw	r24, 0x0a	; 10
     f80:	6a 81       	ldd	r22, Y+2	; 0x02
     f82:	7b 81       	ldd	r23, Y+3	; 0x03
     f84:	62 0d       	add	r22, r2
     f86:	73 1d       	adc	r23, r3
     f88:	a3 01       	movw	r20, r6
     f8a:	8c 0d       	add	r24, r12
     f8c:	9d 1d       	adc	r25, r13
     f8e:	0e 94 b1 14 	call	0x2962	; 0x2962 <memcpy>
							uint16_t DataLength = (SwapEndian_16(IPHeaderIN->TotalLength) - IPOffset - TCPOffset);
     f92:	f6 01       	movw	r30, r12
     f94:	80 81       	ld	r24, Z
     f96:	91 81       	ldd	r25, Z+1	; 0x01
     f98:	a2 81       	ldd	r26, Z+2	; 0x02

							/* Copy the packet data into the buffer */
							memcpy(&ConnectionInfo->Buffer.Data[ConnectionInfo->Buffer.Length],
     f9a:	b3 81       	ldd	r27, Z+3	; 0x03
     f9c:	86 0d       	add	r24, r6
     f9e:	97 1d       	adc	r25, r7
     fa0:	a1 1d       	adc	r26, r1
     fa2:	b1 1d       	adc	r27, r1
     fa4:	80 83       	st	Z, r24
     fa6:	91 83       	std	Z+1, r25	; 0x01
     fa8:	a2 83       	std	Z+2, r26	; 0x02
     faa:	b3 83       	std	Z+3, r27	; 0x03
     fac:	80 85       	ldd	r24, Z+8	; 0x08
     fae:	91 85       	ldd	r25, Z+9	; 0x09
								   &((uint8_t*)TCPHeaderInStart)[TCPOffset],
								   DataLength);

							ConnectionInfo->SequenceNumberIn += DataLength;
     fb0:	86 0d       	add	r24, r6
     fb2:	97 1d       	adc	r25, r7
     fb4:	91 87       	std	Z+9, r25	; 0x09
     fb6:	80 87       	std	Z+8, r24	; 0x08
     fb8:	81 15       	cp	r24, r1
     fba:	92 40       	sbci	r25, 0x02	; 2
     fbc:	31 f0       	breq	.+12     	; 0xfca <TCP_ProcessTCPPacket+0x2dc>
     fbe:	aa 81       	ldd	r26, Y+2	; 0x02
     fc0:	bb 81       	ldd	r27, Y+3	; 0x03
     fc2:	1d 96       	adiw	r26, 0x0d	; 13
     fc4:	8c 91       	ld	r24, X
     fc6:	83 ff       	sbrs	r24, 3
     fc8:	b0 c0       	rjmp	.+352    	; 0x112a <TCP_ProcessTCPPacket+0x43c>
							ConnectionInfo->Buffer.Length    += DataLength;
     fca:	f4 01       	movw	r30, r8
     fcc:	10 82       	st	Z, r1
     fce:	f6 01       	movw	r30, r12
     fd0:	e5 5f       	subi	r30, 0xF5	; 245
     fd2:	fd 4f       	sbci	r31, 0xFD	; 253
     fd4:	81 e0       	ldi	r24, 0x01	; 1

							/* Check if the buffer is full or if the PSH flag is set, if so indicate buffer ready */
							if ((!(TCP_WINDOW_SIZE - ConnectionInfo->Buffer.Length)) || (TCPHeaderIN->Flags & TCP_FLAG_PSH))
     fd6:	80 83       	st	Z, r24
     fd8:	80 e1       	ldi	r24, 0x10	; 16
     fda:	d8 01       	movw	r26, r16
     fdc:	1d 96       	adiw	r26, 0x0d	; 13
     fde:	8c 93       	st	X, r24
     fe0:	43 c0       	rjmp	.+134    	; 0x1068 <TCP_ProcessTCPPacket+0x37a>
     fe2:	21 31       	cpi	r18, 0x11	; 17
     fe4:	41 f0       	breq	.+16     	; 0xff6 <TCP_ProcessTCPPacket+0x308>
     fe6:	20 31       	cpi	r18, 0x10	; 16
							{
								ConnectionInfo->Buffer.InUse = false;
     fe8:	09 f0       	breq	.+2      	; 0xfec <TCP_ProcessTCPPacket+0x2fe>
     fea:	9f c0       	rjmp	.+318    	; 0x112a <TCP_ProcessTCPPacket+0x43c>
								ConnectionInfo->Buffer.Ready = true;
     fec:	25 e0       	ldi	r18, 0x05	; 5
     fee:	32 c0       	rjmp	.+100    	; 0x1054 <TCP_ProcessTCPPacket+0x366>
     ff0:	21 31       	cpi	r18, 0x11	; 17
     ff2:	09 f0       	breq	.+2      	; 0xff6 <TCP_ProcessTCPPacket+0x308>
     ff4:	9a c0       	rjmp	.+308    	; 0x112a <TCP_ProcessTCPPacket+0x43c>

								TCPHeaderOUT->Flags = TCP_FLAG_ACK;
     ff6:	a4 01       	movw	r20, r8
     ff8:	b7 01       	movw	r22, r14
     ffa:	c6 01       	movw	r24, r12
     ffc:	34 de       	rcall	.-920    	; 0xc66 <TCP_GetConnectionInfo>
     ffe:	fc 01       	movw	r30, r24
						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
											   TCPHeaderIN->SourcePort, TCP_Connection_FINWait1);

					break;
				case TCP_Connection_FINWait1:
					if (TCPHeaderIN->Flags == (TCP_FLAG_FIN | TCP_FLAG_ACK))
    1000:	80 e1       	ldi	r24, 0x10	; 16
    1002:	d8 01       	movw	r26, r16
						ConnectionInfo->SequenceNumberOut++;

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
											   TCPHeaderIN->SourcePort, TCP_Connection_Closed);
					}
					else if (TCPHeaderIN->Flags == TCP_FLAG_ACK)
    1004:	1d 96       	adiw	r26, 0x0d	; 13
    1006:	8c 93       	st	X, r24
    1008:	40 81       	ld	r20, Z
					{
						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    100a:	51 81       	ldd	r21, Z+1	; 0x01
    100c:	62 81       	ldd	r22, Z+2	; 0x02
											   TCPHeaderIN->SourcePort, TCP_Connection_FINWait2);
					}

					break;
				case TCP_Connection_FINWait2:
					if (TCPHeaderIN->Flags == (TCP_FLAG_FIN | TCP_FLAG_ACK))
    100e:	73 81       	ldd	r23, Z+3	; 0x03
    1010:	4f 5f       	subi	r20, 0xFF	; 255
    1012:	5f 4f       	sbci	r21, 0xFF	; 255
					{
						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    1014:	6f 4f       	sbci	r22, 0xFF	; 255
    1016:	7f 4f       	sbci	r23, 0xFF	; 255
    1018:	40 83       	st	Z, r20
    101a:	51 83       	std	Z+1, r21	; 0x01
    101c:	62 83       	std	Z+2, r22	; 0x02
    101e:	73 83       	std	Z+3, r23	; 0x03
															   TCPHeaderIN->SourcePort);

						TCPHeaderOUT->Flags = TCP_FLAG_ACK;
    1020:	44 81       	ldd	r20, Z+4	; 0x04
    1022:	55 81       	ldd	r21, Z+5	; 0x05
    1024:	66 81       	ldd	r22, Z+6	; 0x06
    1026:	77 81       	ldd	r23, Z+7	; 0x07
						PacketResponse      = true;

						ConnectionInfo->SequenceNumberIn++;
    1028:	4f 5f       	subi	r20, 0xFF	; 255
    102a:	5f 4f       	sbci	r21, 0xFF	; 255
    102c:	6f 4f       	sbci	r22, 0xFF	; 255
    102e:	7f 4f       	sbci	r23, 0xFF	; 255
    1030:	44 83       	std	Z+4, r20	; 0x04
    1032:	55 83       	std	Z+5, r21	; 0x05
    1034:	66 83       	std	Z+6, r22	; 0x06
    1036:	77 83       	std	Z+7, r23	; 0x07
    1038:	ea 81       	ldd	r30, Y+2	; 0x02
    103a:	fb 81       	ldd	r31, Y+3	; 0x03
    103c:	40 81       	ld	r20, Z
    103e:	51 81       	ldd	r21, Z+1	; 0x01
						ConnectionInfo->SequenceNumberOut++;
    1040:	2a e0       	ldi	r18, 0x0A	; 10
    1042:	b7 01       	movw	r22, r14
    1044:	82 81       	ldd	r24, Z+2	; 0x02
    1046:	93 81       	ldd	r25, Z+3	; 0x03
    1048:	46 dd       	rcall	.-1396   	; 0xad6 <TCP_SetConnectionState>
    104a:	0e c0       	rjmp	.+28     	; 0x1068 <TCP_ProcessTCPPacket+0x37a>
    104c:	20 31       	cpi	r18, 0x10	; 16
    104e:	09 f0       	breq	.+2      	; 0x1052 <TCP_ProcessTCPPacket+0x364>
    1050:	6c c0       	rjmp	.+216    	; 0x112a <TCP_ProcessTCPPacket+0x43c>
    1052:	2a e0       	ldi	r18, 0x0A	; 10
    1054:	a4 01       	movw	r20, r8
    1056:	b7 01       	movw	r22, r14

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    1058:	c6 01       	movw	r24, r12
    105a:	3d dd       	rcall	.-1414   	; 0xad6 <TCP_SetConnectionState>
    105c:	66 c0       	rjmp	.+204    	; 0x112a <TCP_ProcessTCPPacket+0x43c>
    105e:	84 e1       	ldi	r24, 0x14	; 20
    1060:	bc cf       	rjmp	.-136    	; 0xfda <TCP_ProcessTCPPacket+0x2ec>
    1062:	8f ef       	ldi	r24, 0xFF	; 255
    1064:	9f ef       	ldi	r25, 0xFF	; 255
    1066:	63 c0       	rjmp	.+198    	; 0x112e <TCP_ProcessTCPPacket+0x440>
    1068:	aa 81       	ldd	r26, Y+2	; 0x02
    106a:	bb 81       	ldd	r27, Y+3	; 0x03
    106c:	12 96       	adiw	r26, 0x02	; 2
											   TCPHeaderIN->SourcePort, TCP_Connection_Closed);
					}

					break;
				case TCP_Connection_CloseWait:
					if (TCPHeaderIN->Flags == TCP_FLAG_ACK)
    106e:	8d 90       	ld	r8, X+
    1070:	9c 90       	ld	r9, X
    1072:	13 97       	sbiw	r26, 0x03	; 3
					{
						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    1074:	4d 91       	ld	r20, X+
    1076:	5c 91       	ld	r21, X
    1078:	b7 01       	movw	r22, r14
    107a:	c4 01       	movw	r24, r8
    107c:	f4 dd       	rcall	.-1048   	; 0xc66 <TCP_GetConnectionInfo>
    107e:	6c 01       	movw	r12, r24
    1080:	f8 01       	movw	r30, r16
		}
	}
	else
	{
		/* Port is not open, indicate via a RST/ACK response to the sender */
		TCPHeaderOUT->Flags = (TCP_FLAG_RST | TCP_FLAG_ACK);
    1082:	91 82       	std	Z+1, r9	; 0x01
    1084:	80 82       	st	Z, r8
							}
						}
						else
						{
							/* Buffer is currently in use by the application, defer processing of the incoming packet */
							return NO_PROCESS;
    1086:	aa 81       	ldd	r26, Y+2	; 0x02
    1088:	bb 81       	ldd	r27, Y+3	; 0x03
    108a:	8d 91       	ld	r24, X+
	}

	/* Check if we need to respond to the sent packet */
	if (PacketResponse)
	{
		ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    108c:	9c 91       	ld	r25, X
    108e:	93 83       	std	Z+3, r25	; 0x03
    1090:	82 83       	std	Z+2, r24	; 0x02
    1092:	f6 01       	movw	r30, r12
    1094:	64 81       	ldd	r22, Z+4	; 0x04
    1096:	75 81       	ldd	r23, Z+5	; 0x05
    1098:	86 81       	ldd	r24, Z+6	; 0x06
    109a:	97 81       	ldd	r25, Z+7	; 0x07
    109c:	78 db       	rcall	.-2320   	; 0x78e <SwapEndian_32>
    109e:	d8 01       	movw	r26, r16
    10a0:	14 96       	adiw	r26, 0x04	; 4
    10a2:	6d 93       	st	X+, r22
    10a4:	7d 93       	st	X+, r23
		                                       TCPHeaderIN->SourcePort);

		TCPHeaderOUT->SourcePort           = TCPHeaderIN->DestinationPort;
    10a6:	8d 93       	st	X+, r24
    10a8:	9c 93       	st	X, r25
    10aa:	17 97       	sbiw	r26, 0x07	; 7
		TCPHeaderOUT->DestinationPort      = TCPHeaderIN->SourcePort;
    10ac:	f6 01       	movw	r30, r12
    10ae:	60 81       	ld	r22, Z
    10b0:	71 81       	ldd	r23, Z+1	; 0x01
    10b2:	82 81       	ldd	r24, Z+2	; 0x02
    10b4:	93 81       	ldd	r25, Z+3	; 0x03
    10b6:	6b db       	rcall	.-2346   	; 0x78e <SwapEndian_32>
		TCPHeaderOUT->SequenceNumber       = SwapEndian_32(ConnectionInfo->SequenceNumberOut);
    10b8:	d8 01       	movw	r26, r16
    10ba:	18 96       	adiw	r26, 0x08	; 8
    10bc:	6d 93       	st	X+, r22
    10be:	7d 93       	st	X+, r23
    10c0:	8d 93       	st	X+, r24
    10c2:	9c 93       	st	X, r25
    10c4:	1b 97       	sbiw	r26, 0x0b	; 11
    10c6:	1c 96       	adiw	r26, 0x0c	; 12
    10c8:	8c 91       	ld	r24, X
    10ca:	1c 97       	sbiw	r26, 0x0c	; 12
    10cc:	8f 70       	andi	r24, 0x0F	; 15
    10ce:	80 65       	ori	r24, 0x50	; 80
    10d0:	1c 96       	adiw	r26, 0x0c	; 12
    10d2:	8c 93       	st	X, r24
		TCPHeaderOUT->AcknowledgmentNumber = SwapEndian_32(ConnectionInfo->SequenceNumberIn);
    10d4:	f6 01       	movw	r30, r12
    10d6:	e4 5f       	subi	r30, 0xF4	; 244
    10d8:	fd 4f       	sbci	r31, 0xFD	; 253
    10da:	80 81       	ld	r24, Z
    10dc:	81 11       	cpse	r24, r1
    10de:	03 c0       	rjmp	.+6      	; 0x10e6 <TCP_ProcessTCPPacket+0x3f8>
    10e0:	82 e0       	ldi	r24, 0x02	; 2
    10e2:	90 e0       	ldi	r25, 0x00	; 0
    10e4:	0a c0       	rjmp	.+20     	; 0x10fa <TCP_ProcessTCPPacket+0x40c>
    10e6:	d6 01       	movw	r26, r12
    10e8:	18 96       	adiw	r26, 0x08	; 8
    10ea:	2d 91       	ld	r18, X+
    10ec:	3c 91       	ld	r19, X
    10ee:	19 97       	sbiw	r26, 0x09	; 9
		TCPHeaderOUT->DataOffset           = (sizeof(TCP_Header_t) / sizeof(uint32_t));
    10f0:	80 e0       	ldi	r24, 0x00	; 0
    10f2:	92 e0       	ldi	r25, 0x02	; 2
    10f4:	82 1b       	sub	r24, r18
    10f6:	93 0b       	sbc	r25, r19
    10f8:	50 db       	rcall	.-2400   	; 0x79a <SwapEndian_16.part.1>
    10fa:	f8 01       	movw	r30, r16
    10fc:	97 87       	std	Z+15, r25	; 0x0f

		if (!(ConnectionInfo->Buffer.InUse))
    10fe:	86 87       	std	Z+14, r24	; 0x0e
    1100:	13 8a       	std	Z+19, r1	; 0x13
    1102:	12 8a       	std	Z+18, r1	; 0x12
    1104:	11 8a       	std	Z+17, r1	; 0x11
    1106:	10 8a       	std	Z+16, r1	; 0x10
    1108:	84 85       	ldd	r24, Z+12	; 0x0c
		  TCPHeaderOUT->WindowSize         = SwapEndian_16(TCP_WINDOW_SIZE);
    110a:	80 7f       	andi	r24, 0xF0	; 240
    110c:	84 87       	std	Z+12, r24	; 0x0c
    110e:	b5 01       	movw	r22, r10
		else
		  TCPHeaderOUT->WindowSize         = SwapEndian_16(TCP_WINDOW_SIZE - ConnectionInfo->Buffer.Length);
    1110:	60 5f       	subi	r22, 0xF0	; 240
    1112:	7f 4f       	sbci	r23, 0xFF	; 255
    1114:	24 e1       	ldi	r18, 0x14	; 20
    1116:	30 e0       	ldi	r19, 0x00	; 0
    1118:	a7 01       	movw	r20, r14
    111a:	c8 01       	movw	r24, r16
    111c:	42 db       	rcall	.-2428   	; 0x7a2 <TCP_Checksum16>
    111e:	f8 01       	movw	r30, r16
    1120:	91 8b       	std	Z+17, r25	; 0x11
    1122:	80 8b       	std	Z+16, r24	; 0x10
    1124:	84 e1       	ldi	r24, 0x14	; 20
    1126:	90 e0       	ldi	r25, 0x00	; 0
    1128:	02 c0       	rjmp	.+4      	; 0x112e <TCP_ProcessTCPPacket+0x440>
    112a:	80 e0       	ldi	r24, 0x00	; 0

		TCPHeaderOUT->UrgentPointer        = 0;
    112c:	90 e0       	ldi	r25, 0x00	; 0
    112e:	0f 90       	pop	r0
		TCPHeaderOUT->Checksum             = 0;
    1130:	0f 90       	pop	r0
    1132:	0f 90       	pop	r0
		TCPHeaderOUT->Reserved             = 0;
    1134:	df 91       	pop	r29
    1136:	cf 91       	pop	r28
    1138:	1f 91       	pop	r17

		TCPHeaderOUT->Checksum             = TCP_Checksum16(TCPHeaderOUT, &IPHeaderIN->DestinationAddress,
    113a:	0f 91       	pop	r16
    113c:	ff 90       	pop	r15
    113e:	ef 90       	pop	r14
    1140:	df 90       	pop	r13
    1142:	cf 90       	pop	r12
    1144:	bf 90       	pop	r11
    1146:	af 90       	pop	r10
    1148:	9f 90       	pop	r9
    114a:	8f 90       	pop	r8
    114c:	7f 90       	pop	r7
    114e:	6f 90       	pop	r6
    1150:	5f 90       	pop	r5
		                                                    &IPHeaderIN->SourceAddress, sizeof(TCP_Header_t));

		return sizeof(TCP_Header_t);
    1152:	4f 90       	pop	r4
    1154:	3f 90       	pop	r3
    1156:	2f 90       	pop	r2
	}

	return NO_RESPONSE;
    1158:	08 95       	ret

0000115a <UDP_ProcessUDPPacket>:
 *  \return The number of bytes written to the out Ethernet frame if any, NO_RESPONSE otherwise
 */
int16_t UDP_ProcessUDPPacket(void* IPHeaderInStart,
                             void* UDPHeaderInStart,
                             void* UDPHeaderOutStart)
{
    115a:	ef 92       	push	r14
    115c:	ff 92       	push	r15
    115e:	0f 93       	push	r16
    1160:	1f 93       	push	r17
    1162:	cf 93       	push	r28
    1164:	df 93       	push	r29
    1166:	7c 01       	movw	r14, r24
    1168:	8b 01       	movw	r16, r22
    116a:	ea 01       	movw	r28, r20
	UDP_Header_t* UDPHeaderIN  = (UDP_Header_t*)UDPHeaderInStart;
	UDP_Header_t* UDPHeaderOUT = (UDP_Header_t*)UDPHeaderOutStart;

	int16_t RetSize = NO_RESPONSE;

	DecodeUDPHeader(UDPHeaderInStart);
    116c:	cb 01       	movw	r24, r22
    116e:	cb da       	rcall	.-2666   	; 0x706 <DecodeUDPHeader>
    1170:	f8 01       	movw	r30, r16

				Temp = Data.Bytes[0];
				Data.Bytes[0] = Data.Bytes[1];
				Data.Bytes[1] = Temp;

				return Data.Word;
    1172:	23 81       	ldd	r18, Z+3	; 0x03
    1174:	32 81       	ldd	r19, Z+2	; 0x02
    1176:	23 34       	cpi	r18, 0x43	; 67

	switch (SwapEndian_16(UDPHeaderIN->DestinationPort))
    1178:	31 05       	cpc	r19, r1
    117a:	e9 f4       	brne	.+58     	; 0x11b6 <UDP_ProcessUDPPacket+0x5c>
    117c:	ae 01       	movw	r20, r28
	{
		case UDP_PORT_DHCP_REQUEST:
			RetSize = DHCP_ProcessDHCPPacket(IPHeaderInStart,
    117e:	48 5f       	subi	r20, 0xF8	; 248
    1180:	5f 4f       	sbci	r21, 0xFF	; 255
    1182:	b8 01       	movw	r22, r16
    1184:	68 5f       	subi	r22, 0xF8	; 248
    1186:	7f 4f       	sbci	r23, 0xFF	; 255
    1188:	c7 01       	movw	r24, r14
    118a:	1e d0       	rcall	.+60     	; 0x11c8 <DHCP_ProcessDHCPPacket>
    118c:	18 16       	cp	r1, r24
    118e:	19 06       	cpc	r1, r25
		                                     &((uint8_t*)UDPHeaderOutStart)[sizeof(UDP_Header_t)]);
			break;
	}

	/* Check to see if the protocol processing routine has filled out a response */
	if (RetSize > 0)
    1190:	94 f4       	brge	.+36     	; 0x11b6 <UDP_ProcessUDPPacket+0x5c>
    1192:	f8 01       	movw	r30, r16
    1194:	22 81       	ldd	r18, Z+2	; 0x02
	{
		/* Fill out the response UDP packet header */
		UDPHeaderOUT->SourcePort      = UDPHeaderIN->DestinationPort;
    1196:	33 81       	ldd	r19, Z+3	; 0x03
    1198:	39 83       	std	Y+1, r19	; 0x01
    119a:	28 83       	st	Y, r18
    119c:	20 81       	ld	r18, Z
    119e:	31 81       	ldd	r19, Z+1	; 0x01
		UDPHeaderOUT->DestinationPort = UDPHeaderIN->SourcePort;
    11a0:	3b 83       	std	Y+3, r19	; 0x03
    11a2:	2a 83       	std	Y+2, r18	; 0x02
    11a4:	1f 82       	std	Y+7, r1	; 0x07
    11a6:	1e 82       	std	Y+6, r1	; 0x06
		UDPHeaderOUT->Checksum        = 0;
    11a8:	9c 01       	movw	r18, r24
    11aa:	28 5f       	subi	r18, 0xF8	; 248
		UDPHeaderOUT->Length          = SwapEndian_16(sizeof(UDP_Header_t) + RetSize);
    11ac:	3f 4f       	sbci	r19, 0xFF	; 255
    11ae:	3c 83       	std	Y+4, r19	; 0x04
    11b0:	2d 83       	std	Y+5, r18	; 0x05
    11b2:	c9 01       	movw	r24, r18
    11b4:	02 c0       	rjmp	.+4      	; 0x11ba <UDP_ProcessUDPPacket+0x60>

		/* Return the size of the response so far */
		return (sizeof(UDP_Header_t) + RetSize);
    11b6:	80 e0       	ldi	r24, 0x00	; 0
    11b8:	90 e0       	ldi	r25, 0x00	; 0
	}

	return NO_RESPONSE;
    11ba:	df 91       	pop	r29
    11bc:	cf 91       	pop	r28
}
    11be:	1f 91       	pop	r17
    11c0:	0f 91       	pop	r16
    11c2:	ff 90       	pop	r15
    11c4:	ef 90       	pop	r14
    11c6:	08 95       	ret

000011c8 <DHCP_ProcessDHCPPacket>:
 *  \return The number of bytes written to the out Ethernet frame if any, NO_RESPONSE otherwise
 */
int16_t DHCP_ProcessDHCPPacket(void* IPHeaderInStart,
                               void* DHCPHeaderInStart,
                               void* DHCPHeaderOutStart)
{
    11c8:	8f 92       	push	r8
    11ca:	9f 92       	push	r9
    11cc:	af 92       	push	r10
    11ce:	bf 92       	push	r11
    11d0:	cf 92       	push	r12
    11d2:	df 92       	push	r13
    11d4:	ef 92       	push	r14
    11d6:	ff 92       	push	r15
    11d8:	0f 93       	push	r16
    11da:	1f 93       	push	r17
    11dc:	cf 93       	push	r28
    11de:	df 93       	push	r29
    11e0:	5c 01       	movw	r10, r24
    11e2:	4b 01       	movw	r8, r22
    11e4:	ea 01       	movw	r28, r20
	IP_Header_t*   IPHeaderIN    = (IP_Header_t*)IPHeaderInStart;
	DHCP_Header_t* DHCPHeaderIN  = (DHCP_Header_t*)DHCPHeaderInStart;
	DHCP_Header_t* DHCPHeaderOUT = (DHCP_Header_t*)DHCPHeaderOutStart;

	uint8_t* DHCPOptionsINStart  = ((uint8_t*)DHCPHeaderInStart  + sizeof(DHCP_Header_t));
    11e6:	8b 01       	movw	r16, r22
    11e8:	00 51       	subi	r16, 0x10	; 16
    11ea:	1f 4f       	sbci	r17, 0xFF	; 255
	uint8_t* DHCPOptionsOUTStart = ((uint8_t*)DHCPHeaderOutStart + sizeof(DHCP_Header_t));

	DecodeDHCPHeader(DHCPHeaderInStart);
    11ec:	cb 01       	movw	r24, r22
    11ee:	8c da       	rcall	.-2792   	; 0x708 <DecodeDHCPHeader>
    11f0:	80 ef       	ldi	r24, 0xF0	; 240

	/* Zero out the response DHCP packet, as much of it is legacy and left at 0 */
	memset(DHCPHeaderOUT, 0, sizeof(DHCP_Header_t));
    11f2:	fe 01       	movw	r30, r28
    11f4:	11 92       	st	Z+, r1
    11f6:	8a 95       	dec	r24
    11f8:	e9 f7       	brne	.-6      	; 0x11f4 <DHCP_ProcessDHCPPacket+0x2c>
    11fa:	f4 01       	movw	r30, r8

	/* Fill out the response DHCP packet */
	DHCPHeaderOUT->HardwareType          = DHCPHeaderIN->HardwareType;
    11fc:	81 81       	ldd	r24, Z+1	; 0x01
    11fe:	89 83       	std	Y+1, r24	; 0x01
    1200:	82 e0       	ldi	r24, 0x02	; 2
	DHCPHeaderOUT->Operation             = DHCP_OP_BOOTREPLY;
    1202:	88 83       	st	Y, r24
    1204:	82 81       	ldd	r24, Z+2	; 0x02
	DHCPHeaderOUT->HardwareAddressLength = DHCPHeaderIN->HardwareAddressLength;
    1206:	8a 83       	std	Y+2, r24	; 0x02
    1208:	1b 82       	std	Y+3, r1	; 0x03
	DHCPHeaderOUT->Hops                  = 0;
    120a:	84 81       	ldd	r24, Z+4	; 0x04
	DHCPHeaderOUT->TransactionID         = DHCPHeaderIN->TransactionID;
    120c:	95 81       	ldd	r25, Z+5	; 0x05
    120e:	a6 81       	ldd	r26, Z+6	; 0x06
    1210:	b7 81       	ldd	r27, Z+7	; 0x07
    1212:	8c 83       	std	Y+4, r24	; 0x04
    1214:	9d 83       	std	Y+5, r25	; 0x05
    1216:	ae 83       	std	Y+6, r26	; 0x06
    1218:	bf 83       	std	Y+7, r27	; 0x07
    121a:	19 86       	std	Y+9, r1	; 0x09
	DHCPHeaderOUT->ElapsedSeconds        = 0;
    121c:	18 86       	std	Y+8, r1	; 0x08
    121e:	82 85       	ldd	r24, Z+10	; 0x0a
	DHCPHeaderOUT->Flags                 = DHCPHeaderIN->Flags;
    1220:	93 85       	ldd	r25, Z+11	; 0x0b
    1222:	9b 87       	std	Y+11, r25	; 0x0b
    1224:	8a 87       	std	Y+10, r24	; 0x0a
    1226:	c0 90 22 01 	lds	r12, 0x0122
	DHCPHeaderOUT->YourIP                = ClientIPAddress;
    122a:	d0 90 23 01 	lds	r13, 0x0123
    122e:	e0 90 24 01 	lds	r14, 0x0124
    1232:	f0 90 25 01 	lds	r15, 0x0125
    1236:	c8 8a       	std	Y+16, r12	; 0x10
    1238:	d9 8a       	std	Y+17, r13	; 0x11
    123a:	ea 8a       	std	Y+18, r14	; 0x12
    123c:	fb 8a       	std	Y+19, r15	; 0x13
    123e:	b4 01       	movw	r22, r8
	memmove(&DHCPHeaderOUT->ClientHardwareAddress, &DHCPHeaderIN->ClientHardwareAddress, sizeof(MAC_Address_t));
    1240:	64 5e       	subi	r22, 0xE4	; 228
    1242:	7f 4f       	sbci	r23, 0xFF	; 255
    1244:	46 e0       	ldi	r20, 0x06	; 6
    1246:	50 e0       	ldi	r21, 0x00	; 0
    1248:	ce 01       	movw	r24, r28
    124a:	4c 96       	adiw	r24, 0x1c	; 28
    124c:	0e 94 ba 14 	call	0x2974	; 0x2974 <memmove>
    1250:	fe 01       	movw	r30, r28
	DHCPHeaderOUT->Cookie                = SwapEndian_32(DHCP_MAGIC_COOKIE);
    1252:	e4 51       	subi	r30, 0x14	; 20
    1254:	ff 4f       	sbci	r31, 0xFF	; 255
    1256:	83 e6       	ldi	r24, 0x63	; 99
    1258:	92 e8       	ldi	r25, 0x82	; 130
    125a:	a3 e5       	ldi	r26, 0x53	; 83
    125c:	b3 e6       	ldi	r27, 0x63	; 99
    125e:	80 83       	st	Z, r24
    1260:	91 83       	std	Z+1, r25	; 0x01
    1262:	a2 83       	std	Z+2, r26	; 0x02
    1264:	b3 83       	std	Z+3, r27	; 0x03
    1266:	f5 01       	movw	r30, r10

	/* Alter the incoming IP packet header so that the corrected IP source and destinations are used - this means that
	   when the response IP header is generated, it will use the corrected addresses and not the null/broatcast addresses */
	IPHeaderIN->SourceAddress      = ClientIPAddress;
    1268:	c4 86       	std	Z+12, r12	; 0x0c
    126a:	d5 86       	std	Z+13, r13	; 0x0d
    126c:	e6 86       	std	Z+14, r14	; 0x0e
    126e:	f7 86       	std	Z+15, r15	; 0x0f
    1270:	80 91 30 01 	lds	r24, 0x0130
	IPHeaderIN->DestinationAddress = ServerIPAddress;
    1274:	90 91 31 01 	lds	r25, 0x0131
    1278:	a0 91 32 01 	lds	r26, 0x0132
    127c:	b0 91 33 01 	lds	r27, 0x0133
    1280:	80 8b       	std	Z+16, r24	; 0x10
    1282:	91 8b       	std	Z+17, r25	; 0x11
    1284:	a2 8b       	std	Z+18, r26	; 0x12
    1286:	b3 8b       	std	Z+19, r27	; 0x13
    1288:	f8 01       	movw	r30, r16

	/* Process the incoming DHCP packet options */
	while (DHCPOptionsINStart[0] != DHCP_OPTION_END)
    128a:	80 81       	ld	r24, Z
    128c:	8f 3f       	cpi	r24, 0xFF	; 255
    128e:	09 f4       	brne	.+2      	; 0x1292 <DHCP_ProcessDHCPPacket+0xca>
    1290:	61 c0       	rjmp	.+194    	; 0x1354 <DHCP_ProcessDHCPPacket+0x18c>
    1292:	85 33       	cpi	r24, 0x35	; 53
	{
		/* Find the Message Type DHCP option, to determine the type of DHCP packet */
		if (DHCPOptionsINStart[0] == DHCP_OPTION_MESSAGETYPE)
    1294:	09 f0       	breq	.+2      	; 0x1298 <DHCP_ProcessDHCPPacket+0xd0>
    1296:	52 c0       	rjmp	.+164    	; 0x133c <DHCP_ProcessDHCPPacket+0x174>
    1298:	f8 01       	movw	r30, r16
		{
			if ((DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_DISCOVER) || (DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_REQUEST))
    129a:	92 81       	ldd	r25, Z+2	; 0x02
    129c:	9d 7f       	andi	r25, 0xFD	; 253
    129e:	91 30       	cpi	r25, 0x01	; 1
    12a0:	09 f0       	breq	.+2      	; 0x12a4 <DHCP_ProcessDHCPPacket+0xdc>
    12a2:	4e c0       	rjmp	.+156    	; 0x1340 <DHCP_ProcessDHCPPacket+0x178>
    12a4:	fe 01       	movw	r30, r28
			{
				/* Fill out the response DHCP packet options for a DHCP OFFER or ACK response */

				*(DHCPOptionsOUTStart++) = DHCP_OPTION_MESSAGETYPE;
    12a6:	e0 51       	subi	r30, 0x10	; 16
    12a8:	ff 4f       	sbci	r31, 0xFF	; 255
    12aa:	80 83       	st	Z, r24
    12ac:	fe 01       	movw	r30, r28
				*(DHCPOptionsOUTStart++) = 1;
    12ae:	ef 50       	subi	r30, 0x0F	; 15
    12b0:	ff 4f       	sbci	r31, 0xFF	; 255
    12b2:	90 83       	st	Z, r25
    12b4:	f8 01       	movw	r30, r16
				*(DHCPOptionsOUTStart++) = (DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_DISCOVER) ? DHCP_MESSAGETYPE_OFFER
    12b6:	82 81       	ldd	r24, Z+2	; 0x02
    12b8:	81 30       	cpi	r24, 0x01	; 1
    12ba:	11 f4       	brne	.+4      	; 0x12c0 <DHCP_ProcessDHCPPacket+0xf8>
    12bc:	82 e0       	ldi	r24, 0x02	; 2
    12be:	01 c0       	rjmp	.+2      	; 0x12c2 <DHCP_ProcessDHCPPacket+0xfa>
    12c0:	85 e0       	ldi	r24, 0x05	; 5
    12c2:	fe 01       	movw	r30, r28
    12c4:	ee 50       	subi	r30, 0x0E	; 14
    12c6:	ff 4f       	sbci	r31, 0xFF	; 255
    12c8:	80 83       	st	Z, r24
    12ca:	fe 01       	movw	r30, r28
																								: DHCP_MESSAGETYPE_ACK;

				*(DHCPOptionsOUTStart++) = DHCP_OPTION_SUBNETMASK;
    12cc:	ed 50       	subi	r30, 0x0D	; 13
    12ce:	ff 4f       	sbci	r31, 0xFF	; 255
    12d0:	81 e0       	ldi	r24, 0x01	; 1
    12d2:	80 83       	st	Z, r24
    12d4:	fe 01       	movw	r30, r28
				*(DHCPOptionsOUTStart++) = 4;
    12d6:	ec 50       	subi	r30, 0x0C	; 12
    12d8:	ff 4f       	sbci	r31, 0xFF	; 255
    12da:	84 e0       	ldi	r24, 0x04	; 4
    12dc:	80 83       	st	Z, r24
    12de:	fe 01       	movw	r30, r28
				*(DHCPOptionsOUTStart++) = 0xFF;
    12e0:	eb 50       	subi	r30, 0x0B	; 11
    12e2:	ff 4f       	sbci	r31, 0xFF	; 255
    12e4:	2f ef       	ldi	r18, 0xFF	; 255
    12e6:	20 83       	st	Z, r18
    12e8:	fe 01       	movw	r30, r28
				*(DHCPOptionsOUTStart++) = 0xFF;
    12ea:	ea 50       	subi	r30, 0x0A	; 10
    12ec:	ff 4f       	sbci	r31, 0xFF	; 255
    12ee:	20 83       	st	Z, r18
    12f0:	fe 01       	movw	r30, r28
				*(DHCPOptionsOUTStart++) = 0xFF;
    12f2:	e9 50       	subi	r30, 0x09	; 9
    12f4:	ff 4f       	sbci	r31, 0xFF	; 255
    12f6:	20 83       	st	Z, r18
    12f8:	fe 01       	movw	r30, r28
				*(DHCPOptionsOUTStart++) = 0x00;
    12fa:	e8 50       	subi	r30, 0x08	; 8
    12fc:	ff 4f       	sbci	r31, 0xFF	; 255
    12fe:	10 82       	st	Z, r1
    1300:	fe 01       	movw	r30, r28

				*(DHCPOptionsOUTStart++) = DHCP_OPTION_DHCPSERVER;
    1302:	e7 50       	subi	r30, 0x07	; 7
    1304:	ff 4f       	sbci	r31, 0xFF	; 255
    1306:	96 e3       	ldi	r25, 0x36	; 54
    1308:	90 83       	st	Z, r25
    130a:	fe 01       	movw	r30, r28
				*(DHCPOptionsOUTStart++) = sizeof(IP_Address_t);
    130c:	e6 50       	subi	r30, 0x06	; 6
    130e:	ff 4f       	sbci	r31, 0xFF	; 255
    1310:	80 83       	st	Z, r24
    1312:	fe 01       	movw	r30, r28
				memcpy(DHCPOptionsOUTStart, &ServerIPAddress, sizeof(IP_Address_t));
    1314:	e5 50       	subi	r30, 0x05	; 5
    1316:	ff 4f       	sbci	r31, 0xFF	; 255
    1318:	80 91 30 01 	lds	r24, 0x0130
    131c:	90 91 31 01 	lds	r25, 0x0131
    1320:	a0 91 32 01 	lds	r26, 0x0132
    1324:	b0 91 33 01 	lds	r27, 0x0133
    1328:	80 83       	st	Z, r24
    132a:	91 83       	std	Z+1, r25	; 0x01
    132c:	a2 83       	std	Z+2, r26	; 0x02
    132e:	b3 83       	std	Z+3, r27	; 0x03
    1330:	c1 50       	subi	r28, 0x01	; 1
				DHCPOptionsOUTStart     += sizeof(IP_Address_t);

				*(DHCPOptionsOUTStart++) = DHCP_OPTION_END;
    1332:	df 4f       	sbci	r29, 0xFF	; 255
    1334:	28 83       	st	Y, r18
    1336:	80 e0       	ldi	r24, 0x00	; 0

				return (sizeof(DHCP_Header_t) + 12 + sizeof(IP_Address_t));
    1338:	91 e0       	ldi	r25, 0x01	; 1
    133a:	0e c0       	rjmp	.+28     	; 0x1358 <DHCP_ProcessDHCPPacket+0x190>
    133c:	88 23       	and	r24, r24
			}
		}

		/* Go to the next DHCP option - skip one byte if option is a padding byte, else skip the complete option's size */
		DHCPOptionsINStart += ((DHCPOptionsINStart[0] == DHCP_OPTION_PAD) ? 1 : (DHCPOptionsINStart[1] + 2));
    133e:	29 f0       	breq	.+10     	; 0x134a <DHCP_ProcessDHCPPacket+0x182>
    1340:	f8 01       	movw	r30, r16
    1342:	81 81       	ldd	r24, Z+1	; 0x01
    1344:	90 e0       	ldi	r25, 0x00	; 0
    1346:	02 96       	adiw	r24, 0x02	; 2
    1348:	02 c0       	rjmp	.+4      	; 0x134e <DHCP_ProcessDHCPPacket+0x186>
    134a:	81 e0       	ldi	r24, 0x01	; 1
    134c:	90 e0       	ldi	r25, 0x00	; 0
    134e:	08 0f       	add	r16, r24
    1350:	19 1f       	adc	r17, r25
    1352:	9a cf       	rjmp	.-204    	; 0x1288 <DHCP_ProcessDHCPPacket+0xc0>
    1354:	80 e0       	ldi	r24, 0x00	; 0
	}

	return NO_RESPONSE;
    1356:	90 e0       	ldi	r25, 0x00	; 0
    1358:	df 91       	pop	r29
}
    135a:	cf 91       	pop	r28
    135c:	1f 91       	pop	r17
    135e:	0f 91       	pop	r16
    1360:	ff 90       	pop	r15
    1362:	ef 90       	pop	r14
    1364:	df 90       	pop	r13
    1366:	cf 90       	pop	r12
    1368:	bf 90       	pop	r11
    136a:	af 90       	pop	r10
    136c:	9f 90       	pop	r9
    136e:	8f 90       	pop	r8
    1370:	08 95       	ret

00001372 <ARP_ProcessARPPacket>:
 *
 *  \return The number of bytes written to the out Ethernet frame if any, NO_RESPONSE otherwise
 */
int16_t ARP_ProcessARPPacket(void* InDataStart,
                             void* OutDataStart)
{
    1372:	0f 93       	push	r16
    1374:	1f 93       	push	r17
    1376:	cf 93       	push	r28
    1378:	df 93       	push	r29
    137a:	8c 01       	movw	r16, r24
    137c:	eb 01       	movw	r28, r22
	DecodeARPHeader(InDataStart);
    137e:	bf d9       	rcall	.-3202   	; 0x6fe <DecodeARPHeader>
    1380:	f8 01       	movw	r30, r16
    1382:	83 81       	ldd	r24, Z+3	; 0x03
    1384:	92 81       	ldd	r25, Z+2	; 0x02
    1386:	81 15       	cp	r24, r1

	ARP_Header_t* ARPHeaderIN  = (ARP_Header_t*)InDataStart;
	ARP_Header_t* ARPHeaderOUT = (ARP_Header_t*)OutDataStart;

	/* Ensure that the ARP request is a IPv4 request packet */
	if ((SwapEndian_16(ARPHeaderIN->ProtocolType) == ETHERTYPE_IPV4) &&
    1388:	98 40       	sbci	r25, 0x08	; 8
    138a:	19 f0       	breq	.+6      	; 0x1392 <ARP_ProcessARPPacket+0x20>
    138c:	80 e0       	ldi	r24, 0x00	; 0
			/* Return the size of the response so far */
			return sizeof(ARP_Header_t);
		}
	}

	return NO_RESPONSE;
    138e:	90 e0       	ldi	r25, 0x00	; 0
    1390:	52 c0       	rjmp	.+164    	; 0x1436 <ARP_ProcessARPPacket+0xc4>
    1392:	f8 01       	movw	r30, r16
    1394:	87 81       	ldd	r24, Z+7	; 0x07
    1396:	96 81       	ldd	r25, Z+6	; 0x06
    1398:	01 97       	sbiw	r24, 0x01	; 1

	ARP_Header_t* ARPHeaderIN  = (ARP_Header_t*)InDataStart;
	ARP_Header_t* ARPHeaderOUT = (ARP_Header_t*)OutDataStart;

	/* Ensure that the ARP request is a IPv4 request packet */
	if ((SwapEndian_16(ARPHeaderIN->ProtocolType) == ETHERTYPE_IPV4) &&
    139a:	c1 f7       	brne	.-16     	; 0x138c <ARP_ProcessARPPacket+0x1a>
    139c:	44 e0       	ldi	r20, 0x04	; 4
	    (SwapEndian_16(ARPHeaderIN->Operation) == ARP_OPERATION_REQUEST))
	{
		/* If the ARP packet is requesting the MAC or IP of the virtual webserver, return the response */
		if (IP_COMPARE(&ARPHeaderIN->TPA, &ServerIPAddress) ||
    139e:	50 e0       	ldi	r21, 0x00	; 0
    13a0:	60 e3       	ldi	r22, 0x30	; 48
    13a2:	71 e0       	ldi	r23, 0x01	; 1
    13a4:	c8 01       	movw	r24, r16
    13a6:	48 96       	adiw	r24, 0x18	; 24
    13a8:	0e 94 a4 14 	call	0x2948	; 0x2948 <memcmp>
    13ac:	89 2b       	or	r24, r25
    13ae:	51 f0       	breq	.+20     	; 0x13c4 <ARP_ProcessARPPacket+0x52>
    13b0:	46 e0       	ldi	r20, 0x06	; 6
		    MAC_COMPARE(&ARPHeaderIN->THA, &ServerMACAddress))
    13b2:	50 e0       	ldi	r21, 0x00	; 0
    13b4:	64 e3       	ldi	r22, 0x34	; 52
    13b6:	71 e0       	ldi	r23, 0x01	; 1
    13b8:	c8 01       	movw	r24, r16
    13ba:	42 96       	adiw	r24, 0x12	; 18
    13bc:	0e 94 a4 14 	call	0x2948	; 0x2948 <memcmp>
    13c0:	89 2b       	or	r24, r25
	/* Ensure that the ARP request is a IPv4 request packet */
	if ((SwapEndian_16(ARPHeaderIN->ProtocolType) == ETHERTYPE_IPV4) &&
	    (SwapEndian_16(ARPHeaderIN->Operation) == ARP_OPERATION_REQUEST))
	{
		/* If the ARP packet is requesting the MAC or IP of the virtual webserver, return the response */
		if (IP_COMPARE(&ARPHeaderIN->TPA, &ServerIPAddress) ||
    13c2:	21 f7       	brne	.-56     	; 0x138c <ARP_ProcessARPPacket+0x1a>
    13c4:	f8 01       	movw	r30, r16
		    MAC_COMPARE(&ARPHeaderIN->THA, &ServerMACAddress))
		{
			/* Fill out the ARP response header */
			ARPHeaderOUT->HardwareType = ARPHeaderIN->HardwareType;
    13c6:	80 81       	ld	r24, Z
    13c8:	91 81       	ldd	r25, Z+1	; 0x01
    13ca:	99 83       	std	Y+1, r25	; 0x01
    13cc:	88 83       	st	Y, r24
    13ce:	82 81       	ldd	r24, Z+2	; 0x02
			ARPHeaderOUT->ProtocolType = ARPHeaderIN->ProtocolType;
    13d0:	93 81       	ldd	r25, Z+3	; 0x03
    13d2:	9b 83       	std	Y+3, r25	; 0x03
    13d4:	8a 83       	std	Y+2, r24	; 0x02
    13d6:	84 81       	ldd	r24, Z+4	; 0x04
			ARPHeaderOUT->HLEN         = ARPHeaderIN->HLEN;
    13d8:	8c 83       	std	Y+4, r24	; 0x04
    13da:	85 81       	ldd	r24, Z+5	; 0x05
			ARPHeaderOUT->PLEN         = ARPHeaderIN->PLEN;
    13dc:	8d 83       	std	Y+5, r24	; 0x05
    13de:	80 e0       	ldi	r24, 0x00	; 0
			ARPHeaderOUT->Operation    = SwapEndian_16(ARP_OPERATION_REPLY);
    13e0:	92 e0       	ldi	r25, 0x02	; 2
    13e2:	9f 83       	std	Y+7, r25	; 0x07
    13e4:	8e 83       	std	Y+6, r24	; 0x06
    13e6:	86 e0       	ldi	r24, 0x06	; 6

			/* Copy over the sender MAC/IP to the target fields for the response */
			ARPHeaderOUT->THA = ARPHeaderIN->SHA;
    13e8:	38 96       	adiw	r30, 0x08	; 8
    13ea:	de 01       	movw	r26, r28
    13ec:	52 96       	adiw	r26, 0x12	; 18
    13ee:	01 90       	ld	r0, Z+
    13f0:	0d 92       	st	X+, r0
    13f2:	8a 95       	dec	r24
    13f4:	e1 f7       	brne	.-8      	; 0x13ee <ARP_ProcessARPPacket+0x7c>
    13f6:	f8 01       	movw	r30, r16
			ARPHeaderOUT->TPA = ARPHeaderIN->SPA;
    13f8:	86 85       	ldd	r24, Z+14	; 0x0e
    13fa:	97 85       	ldd	r25, Z+15	; 0x0f
    13fc:	a0 89       	ldd	r26, Z+16	; 0x10
    13fe:	b1 89       	ldd	r27, Z+17	; 0x11
    1400:	88 8f       	std	Y+24, r24	; 0x18
    1402:	99 8f       	std	Y+25, r25	; 0x19
    1404:	aa 8f       	std	Y+26, r26	; 0x1a
    1406:	bb 8f       	std	Y+27, r27	; 0x1b
    1408:	86 e0       	ldi	r24, 0x06	; 6

			/* Copy over the new sender MAC/IP - MAC and IP addresses of the virtual webserver */
			ARPHeaderOUT->SHA = ServerMACAddress;
    140a:	e4 e3       	ldi	r30, 0x34	; 52
    140c:	f1 e0       	ldi	r31, 0x01	; 1
    140e:	de 01       	movw	r26, r28
    1410:	18 96       	adiw	r26, 0x08	; 8
    1412:	01 90       	ld	r0, Z+
    1414:	0d 92       	st	X+, r0
    1416:	8a 95       	dec	r24
    1418:	e1 f7       	brne	.-8      	; 0x1412 <ARP_ProcessARPPacket+0xa0>
    141a:	80 91 30 01 	lds	r24, 0x0130
			ARPHeaderOUT->SPA = ServerIPAddress;
    141e:	90 91 31 01 	lds	r25, 0x0131
    1422:	a0 91 32 01 	lds	r26, 0x0132
    1426:	b0 91 33 01 	lds	r27, 0x0133
    142a:	8e 87       	std	Y+14, r24	; 0x0e
    142c:	9f 87       	std	Y+15, r25	; 0x0f
    142e:	a8 8b       	std	Y+16, r26	; 0x10
    1430:	b9 8b       	std	Y+17, r27	; 0x11
    1432:	8c e1       	ldi	r24, 0x1C	; 28

			/* Return the size of the response so far */
			return sizeof(ARP_Header_t);
    1434:	90 e0       	ldi	r25, 0x00	; 0
    1436:	df 91       	pop	r29
		}
	}

	return NO_RESPONSE;
}
    1438:	cf 91       	pop	r28
    143a:	1f 91       	pop	r17
    143c:	0f 91       	pop	r16
    143e:	08 95       	ret

00001440 <IP_ProcessIPPacket>:
 *           next Ethernet packet handler iteration
 */
int16_t IP_ProcessIPPacket(Ethernet_Frame_Info_t* const FrameIN,
                           void* InDataStart,
                           void* OutDataStart)
{
    1440:	af 92       	push	r10
    1442:	bf 92       	push	r11
    1444:	cf 92       	push	r12
    1446:	df 92       	push	r13
    1448:	ef 92       	push	r14
    144a:	ff 92       	push	r15
    144c:	0f 93       	push	r16
    144e:	1f 93       	push	r17
    1450:	cf 93       	push	r28
    1452:	df 93       	push	r29
    1454:	5c 01       	movw	r10, r24
    1456:	8b 01       	movw	r16, r22
    1458:	ea 01       	movw	r28, r20
	DecodeIPHeader(InDataStart);
    145a:	cb 01       	movw	r24, r22
    145c:	51 d9       	rcall	.-3422   	; 0x700 <DecodeIPHeader>
    145e:	f8 01       	movw	r30, r16

	IP_Header_t* IPHeaderIN  = (IP_Header_t*)InDataStart;
	IP_Header_t* IPHeaderOUT = (IP_Header_t*)OutDataStart;

	/* Header length is specified in number of longs in the packet header, convert to bytes */
	uint16_t HeaderLengthBytes = (IPHeaderIN->HeaderLength * sizeof(uint32_t));
    1460:	80 81       	ld	r24, Z
    1462:	8f 70       	andi	r24, 0x0F	; 15
    1464:	f4 e0       	ldi	r31, 0x04	; 4
    1466:	8f 9f       	mul	r24, r31
    1468:	70 01       	movw	r14, r0
    146a:	11 24       	eor	r1, r1
    146c:	68 01       	movw	r12, r16

	int16_t  RetSize = NO_RESPONSE;

	/* Check to ensure the IP packet is addressed to the virtual webserver's IP or the broadcast IP address */
	if (!(IP_COMPARE(&IPHeaderIN->DestinationAddress, &ServerIPAddress)) &&
    146e:	20 e1       	ldi	r18, 0x10	; 16
    1470:	c2 0e       	add	r12, r18
    1472:	d1 1c       	adc	r13, r1
    1474:	44 e0       	ldi	r20, 0x04	; 4
    1476:	50 e0       	ldi	r21, 0x00	; 0
    1478:	60 e3       	ldi	r22, 0x30	; 48
    147a:	71 e0       	ldi	r23, 0x01	; 1
    147c:	c6 01       	movw	r24, r12
    147e:	0e 94 a4 14 	call	0x2948	; 0x2948 <memcmp>
    1482:	89 2b       	or	r24, r25
    1484:	51 f0       	breq	.+20     	; 0x149a <IP_ProcessIPPacket+0x5a>
    1486:	44 e0       	ldi	r20, 0x04	; 4
	    !(IP_COMPARE(&IPHeaderIN->DestinationAddress, &BroadcastIPAddress)))
    1488:	50 e0       	ldi	r21, 0x00	; 0
    148a:	66 e2       	ldi	r22, 0x26	; 38
    148c:	71 e0       	ldi	r23, 0x01	; 1
    148e:	c6 01       	movw	r24, r12
    1490:	0e 94 a4 14 	call	0x2948	; 0x2948 <memcmp>
    1494:	89 2b       	or	r24, r25
	uint16_t HeaderLengthBytes = (IPHeaderIN->HeaderLength * sizeof(uint32_t));

	int16_t  RetSize = NO_RESPONSE;

	/* Check to ensure the IP packet is addressed to the virtual webserver's IP or the broadcast IP address */
	if (!(IP_COMPARE(&IPHeaderIN->DestinationAddress, &ServerIPAddress)) &&
    1496:	09 f0       	breq	.+2      	; 0x149a <IP_ProcessIPPacket+0x5a>
    1498:	52 c0       	rjmp	.+164    	; 0x153e <IP_ProcessIPPacket+0xfe>
    149a:	f8 01       	movw	r30, r16
	{
		return NO_RESPONSE;
	}

	/* Pass off the IP payload to the appropriate protocol processing routine */
	switch (IPHeaderIN->Protocol)
    149c:	81 85       	ldd	r24, Z+9	; 0x09
    149e:	86 30       	cpi	r24, 0x06	; 6
    14a0:	71 f0       	breq	.+28     	; 0x14be <IP_ProcessIPPacket+0x7e>
    14a2:	81 31       	cpi	r24, 0x11	; 17
    14a4:	a9 f0       	breq	.+42     	; 0x14d0 <IP_ProcessIPPacket+0x90>
    14a6:	81 30       	cpi	r24, 0x01	; 1
    14a8:	09 f0       	breq	.+2      	; 0x14ac <IP_ProcessIPPacket+0x6c>
    14aa:	49 c0       	rjmp	.+146    	; 0x153e <IP_ProcessIPPacket+0xfe>
    14ac:	b8 01       	movw	r22, r16
	{
		case PROTOCOL_ICMP:
			RetSize = ICMP_ProcessICMPPacket(FrameIN,
    14ae:	6e 0d       	add	r22, r14
    14b0:	7f 1d       	adc	r23, r15
    14b2:	ae 01       	movw	r20, r28
    14b4:	4c 5e       	subi	r20, 0xEC	; 236
    14b6:	5f 4f       	sbci	r21, 0xFF	; 255
    14b8:	c5 01       	movw	r24, r10
    14ba:	27 d9       	rcall	.-3506   	; 0x70a <ICMP_ProcessICMPPacket>
    14bc:	11 c0       	rjmp	.+34     	; 0x14e0 <IP_ProcessIPPacket+0xa0>
    14be:	b8 01       	movw	r22, r16
			                                 &((uint8_t*)InDataStart)[HeaderLengthBytes],
			                                 &((uint8_t*)OutDataStart)[sizeof(IP_Header_t)]);
			break;
    14c0:	6e 0d       	add	r22, r14
		case PROTOCOL_TCP:
			RetSize = TCP_ProcessTCPPacket(InDataStart,
    14c2:	7f 1d       	adc	r23, r15
    14c4:	ae 01       	movw	r20, r28
    14c6:	4c 5e       	subi	r20, 0xEC	; 236
    14c8:	5f 4f       	sbci	r21, 0xFF	; 255
    14ca:	c8 01       	movw	r24, r16
    14cc:	10 dc       	rcall	.-2016   	; 0xcee <TCP_ProcessTCPPacket>
    14ce:	08 c0       	rjmp	.+16     	; 0x14e0 <IP_ProcessIPPacket+0xa0>
    14d0:	b8 01       	movw	r22, r16
    14d2:	6e 0d       	add	r22, r14
			                               &((uint8_t*)InDataStart)[HeaderLengthBytes],
			                               &((uint8_t*)OutDataStart)[sizeof(IP_Header_t)]);
			break;
    14d4:	7f 1d       	adc	r23, r15
		case PROTOCOL_UDP:
			RetSize = UDP_ProcessUDPPacket(InDataStart,
    14d6:	ae 01       	movw	r20, r28
    14d8:	4c 5e       	subi	r20, 0xEC	; 236
    14da:	5f 4f       	sbci	r21, 0xFF	; 255
    14dc:	c8 01       	movw	r24, r16
    14de:	3d de       	rcall	.-902    	; 0x115a <UDP_ProcessUDPPacket>
    14e0:	18 16       	cp	r1, r24
    14e2:	19 06       	cpc	r1, r25
    14e4:	74 f5       	brge	.+92     	; 0x1542 <IP_ProcessIPPacket+0x102>
    14e6:	7c 01       	movw	r14, r24
			                               &((uint8_t*)OutDataStart)[sizeof(IP_Header_t)]);
			break;
	}

	/* Check to see if the protocol processing routine has filled out a response */
	if (RetSize > 0)
    14e8:	f4 e1       	ldi	r31, 0x14	; 20
    14ea:	ef 0e       	add	r14, r31
    14ec:	f1 1c       	adc	r15, r1
	{
		/* Fill out the response IP packet header */
		IPHeaderOUT->TotalLength        = SwapEndian_16(sizeof(IP_Header_t) + RetSize);
    14ee:	fa 82       	std	Y+2, r15	; 0x02
    14f0:	eb 82       	std	Y+3, r14	; 0x03
    14f2:	19 82       	std	Y+1, r1	; 0x01
    14f4:	85 e4       	ldi	r24, 0x45	; 69
    14f6:	88 83       	st	Y, r24
    14f8:	1e 82       	std	Y+6, r1	; 0x06
		IPHeaderOUT->TypeOfService      = 0;
    14fa:	1f 82       	std	Y+7, r1	; 0x07
		IPHeaderOUT->HeaderLength       = (sizeof(IP_Header_t) / sizeof(uint32_t));
		IPHeaderOUT->Version            = 4;
    14fc:	1d 82       	std	Y+5, r1	; 0x05
    14fe:	1c 82       	std	Y+4, r1	; 0x04
		IPHeaderOUT->Flags              = 0;
		IPHeaderOUT->FragmentOffset     = 0;
    1500:	1b 86       	std	Y+11, r1	; 0x0b
    1502:	1a 86       	std	Y+10, r1	; 0x0a
		IPHeaderOUT->Identification     = 0;
    1504:	f8 01       	movw	r30, r16
    1506:	81 85       	ldd	r24, Z+9	; 0x09
		IPHeaderOUT->HeaderChecksum     = 0;
    1508:	89 87       	std	Y+9, r24	; 0x09
    150a:	80 e8       	ldi	r24, 0x80	; 128
		IPHeaderOUT->Protocol           = IPHeaderIN->Protocol;
    150c:	88 87       	std	Y+8, r24	; 0x08
    150e:	40 89       	ldd	r20, Z+16	; 0x10
    1510:	51 89       	ldd	r21, Z+17	; 0x11
		IPHeaderOUT->TTL                = DEFAULT_TTL;
    1512:	62 89       	ldd	r22, Z+18	; 0x12
    1514:	73 89       	ldd	r23, Z+19	; 0x13
		IPHeaderOUT->SourceAddress      = IPHeaderIN->DestinationAddress;
    1516:	4c 87       	std	Y+12, r20	; 0x0c
    1518:	5d 87       	std	Y+13, r21	; 0x0d
    151a:	6e 87       	std	Y+14, r22	; 0x0e
    151c:	7f 87       	std	Y+15, r23	; 0x0f
    151e:	04 85       	ldd	r16, Z+12	; 0x0c
    1520:	15 85       	ldd	r17, Z+13	; 0x0d
    1522:	26 85       	ldd	r18, Z+14	; 0x0e
    1524:	37 85       	ldd	r19, Z+15	; 0x0f
		IPHeaderOUT->DestinationAddress = IPHeaderIN->SourceAddress;
    1526:	08 8b       	std	Y+16, r16	; 0x10
    1528:	19 8b       	std	Y+17, r17	; 0x11
    152a:	2a 8b       	std	Y+18, r18	; 0x12
    152c:	3b 8b       	std	Y+19, r19	; 0x13
    152e:	64 e1       	ldi	r22, 0x14	; 20
    1530:	70 e0       	ldi	r23, 0x00	; 0
    1532:	ce 01       	movw	r24, r28
    1534:	b2 d8       	rcall	.-3740   	; 0x69a <Ethernet_Checksum16>

		IPHeaderOUT->HeaderChecksum     = Ethernet_Checksum16(IPHeaderOUT, sizeof(IP_Header_t));
    1536:	9b 87       	std	Y+11, r25	; 0x0b
    1538:	8a 87       	std	Y+10, r24	; 0x0a
    153a:	c7 01       	movw	r24, r14
    153c:	02 c0       	rjmp	.+4      	; 0x1542 <IP_ProcessIPPacket+0x102>
    153e:	80 e0       	ldi	r24, 0x00	; 0
    1540:	90 e0       	ldi	r25, 0x00	; 0
    1542:	df 91       	pop	r29

		/* Return the size of the response so far */
		return (sizeof(IP_Header_t) + RetSize);
    1544:	cf 91       	pop	r28
    1546:	1f 91       	pop	r17
	IP_Header_t* IPHeaderOUT = (IP_Header_t*)OutDataStart;

	/* Header length is specified in number of longs in the packet header, convert to bytes */
	uint16_t HeaderLengthBytes = (IPHeaderIN->HeaderLength * sizeof(uint32_t));

	int16_t  RetSize = NO_RESPONSE;
    1548:	0f 91       	pop	r16
    154a:	ff 90       	pop	r15
		/* Return the size of the response so far */
		return (sizeof(IP_Header_t) + RetSize);
	}

	return RetSize;
}
    154c:	ef 90       	pop	r14
    154e:	df 90       	pop	r13
    1550:	cf 90       	pop	r12
    1552:	bf 90       	pop	r11
    1554:	af 90       	pop	r10
    1556:	08 95       	ret

00001558 <IsHTTPCommand>:
 */
static bool IsHTTPCommand(uint8_t* RequestHeader,
                          char* Command)
{
	/* Returns true if the non null terminated string in RequestHeader matches the null terminated string Command */
	return (strncmp((char*)RequestHeader, Command, strlen(Command)) == 0);
    1558:	fb 01       	movw	r30, r22
    155a:	01 90       	ld	r0, Z+
    155c:	00 20       	and	r0, r0
    155e:	e9 f7       	brne	.-6      	; 0x155a <IsHTTPCommand+0x2>
    1560:	af 01       	movw	r20, r30
    1562:	41 50       	subi	r20, 0x01	; 1
    1564:	51 09       	sbc	r21, r1
    1566:	46 1b       	sub	r20, r22
    1568:	57 0b       	sbc	r21, r23
    156a:	0e 94 cb 14 	call	0x2996	; 0x2996 <strncmp>
    156e:	21 e0       	ldi	r18, 0x01	; 1
    1570:	89 2b       	or	r24, r25
    1572:	09 f0       	breq	.+2      	; 0x1576 <IsHTTPCommand+0x1e>
    1574:	20 e0       	ldi	r18, 0x00	; 0
}
    1576:	82 2f       	mov	r24, r18
    1578:	08 95       	ret

0000157a <Webserver_ApplicationCallback>:
 *  \param[in] ConnectionState  Pointer to a TCP Connection State structure giving connection information
 *  \param[in,out] Buffer       Pointer to the application's send/receive packet buffer
 */
void Webserver_ApplicationCallback(TCP_ConnectionState_t* const ConnectionState,
                                   TCP_ConnectionBuffer_t* const Buffer)
{
    157a:	4f 92       	push	r4
    157c:	5f 92       	push	r5
    157e:	6f 92       	push	r6
    1580:	7f 92       	push	r7
    1582:	8f 92       	push	r8
    1584:	9f 92       	push	r9
    1586:	af 92       	push	r10
    1588:	bf 92       	push	r11
    158a:	cf 92       	push	r12
    158c:	df 92       	push	r13
    158e:	ef 92       	push	r14
    1590:	ff 92       	push	r15
    1592:	0f 93       	push	r16
    1594:	1f 93       	push	r17
    1596:	cf 93       	push	r28
    1598:	df 93       	push	r29
    159a:	00 d0       	rcall	.+0      	; 0x159c <Webserver_ApplicationCallback+0x22>
    159c:	cd b7       	in	r28, 0x3d	; 61
    159e:	de b7       	in	r29, 0x3e	; 62
    15a0:	5c 01       	movw	r10, r24
    15a2:	8b 01       	movw	r16, r22
	char*          BufferDataStr = (char*)Buffer->Data;
    15a4:	2b 01       	movw	r4, r22
    15a6:	82 e0       	ldi	r24, 0x02	; 2
    15a8:	48 0e       	add	r4, r24
    15aa:	51 1c       	adc	r5, r1
	static uint8_t PageBlock     = 0;

	/* Check to see if a packet has been received on the HTTP port from a remote host */
	if (TCP_APP_HAS_RECEIVED_PACKET(Buffer))
    15ac:	7b 01       	movw	r14, r22
    15ae:	ad ef       	ldi	r26, 0xFD	; 253
    15b0:	ea 1a       	sub	r14, r26
    15b2:	fa 0a       	sbc	r15, r26
    15b4:	f7 01       	movw	r30, r14
    15b6:	80 81       	ld	r24, Z
    15b8:	6b 01       	movw	r12, r22
    15ba:	88 23       	and	r24, r24
    15bc:	09 f4       	brne	.+2      	; 0x15c0 <Webserver_ApplicationCallback+0x46>
    15be:	61 c0       	rjmp	.+194    	; 0x1682 <Webserver_ApplicationCallback+0x108>
    15c0:	f2 e0       	ldi	r31, 0x02	; 2
    15c2:	cf 0e       	add	r12, r31
    15c4:	df 1e       	adc	r13, r31
    15c6:	d6 01       	movw	r26, r12
    15c8:	8c 91       	ld	r24, X
    15ca:	81 11       	cpse	r24, r1
    15cc:	9c c0       	rjmp	.+312    	; 0x1706 <Webserver_ApplicationCallback+0x18c>
	{
		if (IsHTTPCommand(Buffer->Data, "GET"))
    15ce:	60 e6       	ldi	r22, 0x60	; 96
    15d0:	71 e0       	ldi	r23, 0x01	; 1
    15d2:	c2 01       	movw	r24, r4
    15d4:	c1 df       	rcall	.-126    	; 0x1558 <IsHTTPCommand>
    15d6:	88 23       	and	r24, r24
    15d8:	01 f1       	breq	.+64     	; 0x161a <Webserver_ApplicationCallback+0xa0>
    15da:	64 e6       	ldi	r22, 0x64	; 100
		{
			if (IsHTTPCommand(Buffer->Data, "GET / "))
    15dc:	71 e0       	ldi	r23, 0x01	; 1
    15de:	c2 01       	movw	r24, r4
    15e0:	bb df       	rcall	.-138    	; 0x1558 <IsHTTPCommand>
    15e2:	88 23       	and	r24, r24
    15e4:	49 f1       	breq	.+82     	; 0x1638 <Webserver_ApplicationCallback+0xbe>
    15e6:	10 92 fa 0d 	sts	0x0DFA, r1
			{
				PageBlock = 0;
    15ea:	62 e6       	ldi	r22, 0x62	; 98
    15ec:	73 e0       	ldi	r23, 0x03	; 3

				/* Copy the HTTP 200 response header into the packet buffer */
				strcpy_P(BufferDataStr, HTTP200Header);
    15ee:	c2 01       	movw	r24, r4
    15f0:	0e 94 85 14 	call	0x290a	; 0x290a <strcpy_P>
    15f4:	81 e0       	ldi	r24, 0x01	; 1
    15f6:	f6 01       	movw	r30, r12

				/* Send the buffer contents to the host */
				TCP_APP_SEND_BUFFER(Buffer, strlen(BufferDataStr));
    15f8:	80 83       	st	Z, r24
    15fa:	f2 01       	movw	r30, r4
    15fc:	01 90       	ld	r0, Z+
    15fe:	00 20       	and	r0, r0
    1600:	e9 f7       	brne	.-6      	; 0x15fc <Webserver_ApplicationCallback+0x82>
    1602:	31 97       	sbiw	r30, 0x01	; 1
    1604:	e4 19       	sub	r30, r4
    1606:	f5 09       	sbc	r31, r5
    1608:	d8 01       	movw	r26, r16
    160a:	ed 93       	st	X+, r30
    160c:	fc 93       	st	X, r31
    160e:	f7 01       	movw	r30, r14
    1610:	80 83       	st	Z, r24
    1612:	f8 01       	movw	r30, r16
    1614:	ec 5f       	subi	r30, 0xFC	; 252

				/* Lock the buffer to Device->Host transmissions only while we send the page contents */
				TCP_APP_CAPTURE_BUFFER(Buffer);
    1616:	fd 4f       	sbci	r31, 0xFD	; 253
    1618:	75 c0       	rjmp	.+234    	; 0x1704 <Webserver_ApplicationCallback+0x18a>
    161a:	6b e6       	ldi	r22, 0x6B	; 107
    161c:	71 e0       	ldi	r23, 0x01	; 1

				/* All data sent, close the connection */
				TCP_APP_CLOSECONNECTION(ConnectionState);
			}
		}
		else if (IsHTTPCommand(Buffer->Data, "HEAD"))
    161e:	c2 01       	movw	r24, r4
    1620:	9b df       	rcall	.-202    	; 0x1558 <IsHTTPCommand>
    1622:	88 23       	and	r24, r24
    1624:	f1 f0       	breq	.+60     	; 0x1662 <Webserver_ApplicationCallback+0xe8>
    1626:	60 e7       	ldi	r22, 0x70	; 112
    1628:	71 e0       	ldi	r23, 0x01	; 1
    162a:	c2 01       	movw	r24, r4
		{
			if (IsHTTPCommand(Buffer->Data, "HEAD / "))
    162c:	95 df       	rcall	.-214    	; 0x1558 <IsHTTPCommand>
    162e:	88 23       	and	r24, r24
    1630:	19 f0       	breq	.+6      	; 0x1638 <Webserver_ApplicationCallback+0xbe>
    1632:	62 e6       	ldi	r22, 0x62	; 98
    1634:	73 e0       	ldi	r23, 0x03	; 3
    1636:	02 c0       	rjmp	.+4      	; 0x163c <Webserver_ApplicationCallback+0xc2>
    1638:	60 e2       	ldi	r22, 0x20	; 32
			{
				/* Copy the HTTP response header into the packet buffer */
				strcpy_P(BufferDataStr, HTTP200Header);
    163a:	73 e0       	ldi	r23, 0x03	; 3
    163c:	c2 01       	movw	r24, r4
    163e:	0e 94 85 14 	call	0x290a	; 0x290a <strcpy_P>
				TCP_APP_SEND_BUFFER(Buffer, strlen(BufferDataStr));
			}
			else
			{
				/* Copy the HTTP response header into the packet buffer */
				strcpy_P(BufferDataStr, HTTP404Header);
    1642:	81 e0       	ldi	r24, 0x01	; 1
    1644:	d6 01       	movw	r26, r12
    1646:	8c 93       	st	X, r24
    1648:	f2 01       	movw	r30, r4

				/* Send the buffer contents to the host */
				TCP_APP_SEND_BUFFER(Buffer, strlen(BufferDataStr));
    164a:	01 90       	ld	r0, Z+
    164c:	00 20       	and	r0, r0
    164e:	e9 f7       	brne	.-6      	; 0x164a <Webserver_ApplicationCallback+0xd0>
    1650:	31 97       	sbiw	r30, 0x01	; 1
    1652:	e4 19       	sub	r30, r4
    1654:	f5 09       	sbc	r31, r5
    1656:	d8 01       	movw	r26, r16
    1658:	ed 93       	st	X+, r30
    165a:	fc 93       	st	X, r31
    165c:	f7 01       	movw	r30, r14
    165e:	80 83       	st	Z, r24
    1660:	4d c0       	rjmp	.+154    	; 0x16fc <Webserver_ApplicationCallback+0x182>
    1662:	68 e7       	ldi	r22, 0x78	; 120
    1664:	71 e0       	ldi	r23, 0x01	; 1
    1666:	c2 01       	movw	r24, r4
    1668:	77 df       	rcall	.-274    	; 0x1558 <IsHTTPCommand>
			}

			/* All data sent, close the connection */
			TCP_APP_CLOSECONNECTION(ConnectionState);
		}
		else if (IsHTTPCommand(Buffer->Data, "TRACE"))
    166a:	88 23       	and	r24, r24
    166c:	21 f0       	breq	.+8      	; 0x1676 <Webserver_ApplicationCallback+0xfc>
    166e:	81 e0       	ldi	r24, 0x01	; 1
    1670:	d6 01       	movw	r26, r12
    1672:	8c 93       	st	X, r24
    1674:	f3 cf       	rjmp	.-26     	; 0x165c <Webserver_ApplicationCallback+0xe2>
    1676:	d7 01       	movw	r26, r14
		{
			/* Echo the host's query back to the host */
			TCP_APP_SEND_BUFFER(Buffer, Buffer->Length);
    1678:	1c 92       	st	X, r1
    167a:	f8 01       	movw	r30, r16
    167c:	11 82       	std	Z+1, r1	; 0x01
    167e:	10 82       	st	Z, r1
			TCP_APP_CLOSECONNECTION(ConnectionState);
		}
		else
		{
			/* Unknown request, just clear the buffer (drop the packet) */
			TCP_APP_CLEAR_BUFFER(Buffer);
    1680:	42 c0       	rjmp	.+132    	; 0x1706 <Webserver_ApplicationCallback+0x18c>
    1682:	fc ef       	ldi	r31, 0xFC	; 252
    1684:	cf 1a       	sub	r12, r31
    1686:	fd ef       	ldi	r31, 0xFD	; 253
    1688:	df 0a       	sbc	r13, r31
    168a:	d6 01       	movw	r26, r12
		}
	}
	else if (TCP_APP_HAVE_CAPTURED_BUFFER(Buffer))
    168c:	8c 91       	ld	r24, X
    168e:	88 23       	and	r24, r24
    1690:	d1 f1       	breq	.+116    	; 0x1706 <Webserver_ApplicationCallback+0x18c>
    1692:	4b 01       	movw	r8, r22
    1694:	b2 e0       	ldi	r27, 0x02	; 2
    1696:	8b 0e       	add	r8, r27
    1698:	9b 1e       	adc	r9, r27
    169a:	f4 01       	movw	r30, r8
    169c:	80 81       	ld	r24, Z
    169e:	88 23       	and	r24, r24
    16a0:	91 f1       	breq	.+100    	; 0x1706 <Webserver_ApplicationCallback+0x18c>
    16a2:	60 91 fa 0d 	lds	r22, 0x0DFA
    16a6:	f0 e8       	ldi	r31, 0x80	; 128
    16a8:	6f 9f       	mul	r22, r31
    16aa:	b0 01       	movw	r22, r0
	{
		uint16_t RemLength = strlen_P(&HTTPPage[PageBlock * HTTP_REPLY_BLOCK_SIZE]);
    16ac:	11 24       	eor	r1, r1
    16ae:	60 5d       	subi	r22, 0xD0	; 208
    16b0:	7e 4f       	sbci	r23, 0xFE	; 254
    16b2:	cb 01       	movw	r24, r22
    16b4:	69 83       	std	Y+1, r22	; 0x01
    16b6:	7a 83       	std	Y+2, r23	; 0x02
    16b8:	0e 94 8c 14 	call	0x2918	; 0x2918 <__strlen_P>


__attribute__((__always_inline__)) static inline size_t strlen_P(const char * s);
static inline size_t strlen_P(const char *s) {
  return __builtin_constant_p(__builtin_strlen(s))
     ? __builtin_strlen(s) : __strlen_P(s);
    16bc:	3c 01       	movw	r6, r24
    16be:	69 81       	ldd	r22, Y+1	; 0x01
    16c0:	7a 81       	ldd	r23, Y+2	; 0x02
    16c2:	81 e8       	ldi	r24, 0x81	; 129
    16c4:	68 16       	cp	r6, r24
    16c6:	71 04       	cpc	r7, r1
		uint16_t Length;

		/* Determine the length of the loaded block */
		Length = ((RemLength > HTTP_REPLY_BLOCK_SIZE) ? HTTP_REPLY_BLOCK_SIZE : RemLength);
    16c8:	18 f0       	brcs	.+6      	; 0x16d0 <Webserver_ApplicationCallback+0x156>
    16ca:	80 e8       	ldi	r24, 0x80	; 128
    16cc:	68 2e       	mov	r6, r24
    16ce:	71 2c       	mov	r7, r1
    16d0:	a3 01       	movw	r20, r6
    16d2:	c2 01       	movw	r24, r4
    16d4:	0e 94 95 14 	call	0x292a	; 0x292a <strncpy_P>
    16d8:	81 e0       	ldi	r24, 0x01	; 1

		/* Copy the next buffer sized block of the page to the packet buffer */
		strncpy_P(BufferDataStr, &HTTPPage[PageBlock * HTTP_REPLY_BLOCK_SIZE], Length);
    16da:	d4 01       	movw	r26, r8
    16dc:	8c 93       	st	X, r24
    16de:	f8 01       	movw	r30, r16
    16e0:	71 82       	std	Z+1, r7	; 0x01

		/* Send the buffer contents to the host */
		TCP_APP_SEND_BUFFER(Buffer, Length);
    16e2:	60 82       	st	Z, r6
    16e4:	d7 01       	movw	r26, r14
    16e6:	8c 93       	st	X, r24
    16e8:	80 91 fa 0d 	lds	r24, 0x0DFA
    16ec:	91 e0       	ldi	r25, 0x01	; 1
    16ee:	98 0f       	add	r25, r24
    16f0:	90 93 fa 0d 	sts	0x0DFA, r25

		/* Check to see if the entire page has been sent */
		if (PageBlock++ == (sizeof(HTTPPage) / HTTP_REPLY_BLOCK_SIZE))
    16f4:	83 30       	cpi	r24, 0x03	; 3
    16f6:	39 f4       	brne	.+14     	; 0x1706 <Webserver_ApplicationCallback+0x18c>
    16f8:	f6 01       	movw	r30, r12
    16fa:	10 82       	st	Z, r1
    16fc:	f5 01       	movw	r30, r10
    16fe:	eb 5e       	subi	r30, 0xEB	; 235
    1700:	fd 4f       	sbci	r31, 0xFD	; 253
		{
			/* Unlock the buffer so that the host can fill it with future packets */
			TCP_APP_RELEASE_BUFFER(Buffer);
    1702:	87 e0       	ldi	r24, 0x07	; 7
    1704:	80 83       	st	Z, r24

			/* Close the connection to the host */
			TCP_APP_CLOSECONNECTION(ConnectionState);
    1706:	0f 90       	pop	r0
    1708:	0f 90       	pop	r0
    170a:	df 91       	pop	r29
    170c:	cf 91       	pop	r28
    170e:	1f 91       	pop	r17
		}
	}
}
    1710:	0f 91       	pop	r16
    1712:	ff 90       	pop	r15
    1714:	ef 90       	pop	r14
    1716:	df 90       	pop	r13
    1718:	cf 90       	pop	r12
    171a:	bf 90       	pop	r11
    171c:	af 90       	pop	r10
    171e:	9f 90       	pop	r9
    1720:	8f 90       	pop	r8
    1722:	7f 90       	pop	r7
    1724:	6f 90       	pop	r6
    1726:	5f 90       	pop	r5
    1728:	4f 90       	pop	r4
    172a:	08 95       	ret

0000172c <Webserver_Init>:
    172c:	4d eb       	ldi	r20, 0xBD	; 189
    172e:	5a e0       	ldi	r21, 0x0A	; 10
    1730:	61 e0       	ldi	r22, 0x01	; 1
    1732:	80 e0       	ldi	r24, 0x00	; 0
    1734:	90 e5       	ldi	r25, 0x50	; 80
 *  callback routine for packets sent to the HTTP protocol port.
 */
void Webserver_Init(void)
{
	/* Open the HTTP port in the TCP protocol so that HTTP connections to the device can be established */
	TCP_SetPortState(TCP_PORT_HTTP, TCP_Port_Open, Webserver_ApplicationCallback);
    1736:	a8 c9       	rjmp	.-3248   	; 0xa88 <TCP_SetPortState>

00001738 <Endpoint_Write_Stream_LE>:
    1738:	cf 92       	push	r12
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
    173a:	df 92       	push	r13
    173c:	ef 92       	push	r14
    173e:	ff 92       	push	r15
    1740:	0f 93       	push	r16
    1742:	1f 93       	push	r17
    1744:	cf 93       	push	r28
    1746:	df 93       	push	r29
    1748:	7c 01       	movw	r14, r24
    174a:	8b 01       	movw	r16, r22
    174c:	ea 01       	movw	r28, r20
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	uint16_t BytesInTransfer = 0;
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
    174e:	12 d2       	rcall	.+1060   	; 0x1b74 <Endpoint_WaitUntilReady>
    1750:	81 11       	cpse	r24, r1
    1752:	31 c0       	rjmp	.+98     	; 0x17b6 <Endpoint_Write_Stream_LE+0x7e>
    1754:	20 97       	sbiw	r28, 0x00	; 0
	  return ErrorCode;

	if (BytesProcessed != NULL)
    1756:	31 f0       	breq	.+12     	; 0x1764 <Endpoint_Write_Stream_LE+0x2c>
    1758:	88 81       	ld	r24, Y
	{
		Length -= *BytesProcessed;
    175a:	99 81       	ldd	r25, Y+1	; 0x01
    175c:	08 1b       	sub	r16, r24
    175e:	19 0b       	sbc	r17, r25
    1760:	e8 0e       	add	r14, r24
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
    1762:	f9 1e       	adc	r15, r25
    1764:	c1 2c       	mov	r12, r1

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    1766:	d1 2c       	mov	r13, r1
    1768:	01 15       	cp	r16, r1
	{
		Length -= *BytesProcessed;
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
    176a:	11 05       	cpc	r17, r1
    176c:	19 f1       	breq	.+70     	; 0x17b4 <Endpoint_Write_Stream_LE+0x7c>
    176e:	80 91 e8 00 	lds	r24, 0x00E8
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    1772:	85 fd       	sbrc	r24, 5
	{
		if (!(Endpoint_IsReadWriteAllowed()))
    1774:	14 c0       	rjmp	.+40     	; 0x179e <Endpoint_Write_Stream_LE+0x66>
    1776:	80 91 e8 00 	lds	r24, 0x00E8
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    177a:	8e 77       	andi	r24, 0x7E	; 126
    177c:	80 93 e8 00 	sts	0x00E8, r24
    1780:	aa d4       	rcall	.+2388   	; 0x20d6 <USB_USBTask>
		{
			TEMPLATE_CLEAR_ENDPOINT();

			#if !defined(INTERRUPT_CONTROL_ENDPOINT)
			USB_USBTask();
    1782:	20 97       	sbiw	r28, 0x00	; 0
    1784:	41 f0       	breq	.+16     	; 0x1796 <Endpoint_Write_Stream_LE+0x5e>
			#endif

			if (BytesProcessed != NULL)
    1786:	88 81       	ld	r24, Y
    1788:	99 81       	ldd	r25, Y+1	; 0x01
			{
				*BytesProcessed += BytesInTransfer;
    178a:	8c 0d       	add	r24, r12
    178c:	9d 1d       	adc	r25, r13
    178e:	99 83       	std	Y+1, r25	; 0x01
    1790:	88 83       	st	Y, r24
    1792:	85 e0       	ldi	r24, 0x05	; 5
    1794:	10 c0       	rjmp	.+32     	; 0x17b6 <Endpoint_Write_Stream_LE+0x7e>
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
    1796:	ee d1       	rcall	.+988    	; 0x1b74 <Endpoint_WaitUntilReady>
    1798:	88 23       	and	r24, r24
			}

			if ((ErrorCode = Endpoint_WaitUntilReady()))
    179a:	31 f3       	breq	.-52     	; 0x1768 <Endpoint_Write_Stream_LE+0x30>
    179c:	0c c0       	rjmp	.+24     	; 0x17b6 <Endpoint_Write_Stream_LE+0x7e>
    179e:	f7 01       	movw	r30, r14
    17a0:	81 91       	ld	r24, Z+
    17a2:	7f 01       	movw	r14, r30
			  return ErrorCode;
		}
		else
		{
			TEMPLATE_TRANSFER_BYTE(DataStream);
    17a4:	80 93 f1 00 	sts	0x00F1, r24
    17a8:	01 50       	subi	r16, 0x01	; 1
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    17aa:	11 09       	sbc	r17, r1
    17ac:	ff ef       	ldi	r31, 0xFF	; 255
			TEMPLATE_BUFFER_MOVE(DataStream, 1);
			Length--;
    17ae:	cf 1a       	sub	r12, r31
    17b0:	df 0a       	sbc	r13, r31
			BytesInTransfer++;
    17b2:	da cf       	rjmp	.-76     	; 0x1768 <Endpoint_Write_Stream_LE+0x30>
    17b4:	80 e0       	ldi	r24, 0x00	; 0
    17b6:	df 91       	pop	r29
    17b8:	cf 91       	pop	r28
		}
	}

	return ENDPOINT_RWSTREAM_NoError;
    17ba:	1f 91       	pop	r17
}
    17bc:	0f 91       	pop	r16
    17be:	ff 90       	pop	r15
    17c0:	ef 90       	pop	r14
    17c2:	df 90       	pop	r13
    17c4:	cf 90       	pop	r12
    17c6:	08 95       	ret

000017c8 <Endpoint_Read_Stream_LE>:
    17c8:	cf 92       	push	r12
    17ca:	df 92       	push	r13
    17cc:	ef 92       	push	r14
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
    17ce:	ff 92       	push	r15
    17d0:	0f 93       	push	r16
    17d2:	1f 93       	push	r17
    17d4:	cf 93       	push	r28
    17d6:	df 93       	push	r29
    17d8:	7c 01       	movw	r14, r24
    17da:	8b 01       	movw	r16, r22
    17dc:	ea 01       	movw	r28, r20
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	uint16_t BytesInTransfer = 0;
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
    17de:	ca d1       	rcall	.+916    	; 0x1b74 <Endpoint_WaitUntilReady>
    17e0:	81 11       	cpse	r24, r1
    17e2:	31 c0       	rjmp	.+98     	; 0x1846 <Endpoint_Read_Stream_LE+0x7e>
    17e4:	20 97       	sbiw	r28, 0x00	; 0
	  return ErrorCode;

	if (BytesProcessed != NULL)
    17e6:	31 f0       	breq	.+12     	; 0x17f4 <Endpoint_Read_Stream_LE+0x2c>
    17e8:	88 81       	ld	r24, Y
	{
		Length -= *BytesProcessed;
    17ea:	99 81       	ldd	r25, Y+1	; 0x01
    17ec:	08 1b       	sub	r16, r24
    17ee:	19 0b       	sbc	r17, r25
    17f0:	e8 0e       	add	r14, r24
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
    17f2:	f9 1e       	adc	r15, r25
    17f4:	c1 2c       	mov	r12, r1

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    17f6:	d1 2c       	mov	r13, r1
    17f8:	01 15       	cp	r16, r1
	{
		Length -= *BytesProcessed;
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
    17fa:	11 05       	cpc	r17, r1
    17fc:	19 f1       	breq	.+70     	; 0x1844 <Endpoint_Read_Stream_LE+0x7c>
    17fe:	80 91 e8 00 	lds	r24, 0x00E8
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    1802:	85 fd       	sbrc	r24, 5
	{
		if (!(Endpoint_IsReadWriteAllowed()))
    1804:	14 c0       	rjmp	.+40     	; 0x182e <Endpoint_Read_Stream_LE+0x66>
    1806:	80 91 e8 00 	lds	r24, 0x00E8
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    180a:	8b 77       	andi	r24, 0x7B	; 123
    180c:	80 93 e8 00 	sts	0x00E8, r24
    1810:	62 d4       	rcall	.+2244   	; 0x20d6 <USB_USBTask>
		{
			TEMPLATE_CLEAR_ENDPOINT();

			#if !defined(INTERRUPT_CONTROL_ENDPOINT)
			USB_USBTask();
    1812:	20 97       	sbiw	r28, 0x00	; 0
    1814:	41 f0       	breq	.+16     	; 0x1826 <Endpoint_Read_Stream_LE+0x5e>
			#endif

			if (BytesProcessed != NULL)
    1816:	88 81       	ld	r24, Y
    1818:	99 81       	ldd	r25, Y+1	; 0x01
			{
				*BytesProcessed += BytesInTransfer;
    181a:	8c 0d       	add	r24, r12
    181c:	9d 1d       	adc	r25, r13
    181e:	99 83       	std	Y+1, r25	; 0x01
    1820:	88 83       	st	Y, r24
    1822:	85 e0       	ldi	r24, 0x05	; 5
    1824:	10 c0       	rjmp	.+32     	; 0x1846 <Endpoint_Read_Stream_LE+0x7e>
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
    1826:	a6 d1       	rcall	.+844    	; 0x1b74 <Endpoint_WaitUntilReady>
    1828:	88 23       	and	r24, r24
			}

			if ((ErrorCode = Endpoint_WaitUntilReady()))
    182a:	31 f3       	breq	.-52     	; 0x17f8 <Endpoint_Read_Stream_LE+0x30>
    182c:	0c c0       	rjmp	.+24     	; 0x1846 <Endpoint_Read_Stream_LE+0x7e>
    182e:	80 91 f1 00 	lds	r24, 0x00F1
    1832:	f7 01       	movw	r30, r14
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    1834:	81 93       	st	Z+, r24
    1836:	7f 01       	movw	r14, r30
			  return ErrorCode;
		}
		else
		{
			TEMPLATE_TRANSFER_BYTE(DataStream);
    1838:	01 50       	subi	r16, 0x01	; 1
    183a:	11 09       	sbc	r17, r1
    183c:	ff ef       	ldi	r31, 0xFF	; 255
			TEMPLATE_BUFFER_MOVE(DataStream, 1);
			Length--;
    183e:	cf 1a       	sub	r12, r31
    1840:	df 0a       	sbc	r13, r31
			BytesInTransfer++;
    1842:	da cf       	rjmp	.-76     	; 0x17f8 <Endpoint_Read_Stream_LE+0x30>
    1844:	80 e0       	ldi	r24, 0x00	; 0
    1846:	df 91       	pop	r29
    1848:	cf 91       	pop	r28
		}
	}

	return ENDPOINT_RWSTREAM_NoError;
    184a:	1f 91       	pop	r17
}
    184c:	0f 91       	pop	r16
    184e:	ff 90       	pop	r15
    1850:	ef 90       	pop	r14
    1852:	df 90       	pop	r13
    1854:	cf 90       	pop	r12
    1856:	08 95       	ret

00001858 <Endpoint_Write_Control_Stream_LE>:
    1858:	20 91 4d 14 	lds	r18, 0x144D
    185c:	30 91 4e 14 	lds	r19, 0x144E
                            uint16_t Length)
{
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
    1860:	26 17       	cp	r18, r22
    1862:	37 07       	cpc	r19, r23
    1864:	48 f0       	brcs	.+18     	; 0x1878 <Endpoint_Write_Control_Stream_LE+0x20>
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
    1866:	61 15       	cp	r22, r1
    1868:	71 05       	cpc	r23, r1
    186a:	39 f4       	brne	.+14     	; 0x187a <Endpoint_Write_Control_Stream_LE+0x22>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    186c:	20 91 e8 00 	lds	r18, 0x00E8
    1870:	2e 77       	andi	r18, 0x7E	; 126
    1872:	20 93 e8 00 	sts	0x00E8, r18
    1876:	01 c0       	rjmp	.+2      	; 0x187a <Endpoint_Write_Control_Stream_LE+0x22>
    1878:	b9 01       	movw	r22, r18
    187a:	fc 01       	movw	r30, r24
    187c:	20 e0       	ldi	r18, 0x00	; 0
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    187e:	61 15       	cp	r22, r1
    1880:	71 05       	cpc	r23, r1
    1882:	99 f1       	breq	.+102    	; 0x18ea <Endpoint_Write_Control_Stream_LE+0x92>
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    1884:	80 91 46 14 	lds	r24, 0x1446

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    1888:	88 23       	and	r24, r24
    188a:	e9 f1       	breq	.+122    	; 0x1906 <Endpoint_Write_Control_Stream_LE+0xae>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    188c:	85 30       	cpi	r24, 0x05	; 5
    188e:	e9 f1       	breq	.+122    	; 0x190a <Endpoint_Write_Control_Stream_LE+0xb2>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    1890:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    1894:	83 fd       	sbrc	r24, 3
    1896:	3b c0       	rjmp	.+118    	; 0x190e <Endpoint_Write_Control_Stream_LE+0xb6>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    1898:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
    189c:	82 ff       	sbrs	r24, 2
    189e:	06 c0       	rjmp	.+12     	; 0x18ac <Endpoint_Write_Control_Stream_LE+0x54>
    18a0:	80 91 e8 00 	lds	r24, 0x00E8
			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}

	while (!(Endpoint_IsOUTReceived()))
    18a4:	82 ff       	sbrs	r24, 2
    18a6:	24 c0       	rjmp	.+72     	; 0x18f0 <Endpoint_Write_Control_Stream_LE+0x98>
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
	}

	return ENDPOINT_RWCSTREAM_NoError;
    18a8:	80 e0       	ldi	r24, 0x00	; 0
    18aa:	08 95       	ret
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    18ac:	80 91 e8 00 	lds	r24, 0x00E8
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
		  break;

		if (Endpoint_IsINReady())
    18b0:	80 ff       	sbrs	r24, 0
    18b2:	e5 cf       	rjmp	.-54     	; 0x187e <Endpoint_Write_Control_Stream_LE+0x26>
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					return UEBCX;
    18b4:	80 91 f2 00 	lds	r24, 0x00F2
    18b8:	90 91 f3 00 	lds	r25, 0x00F3
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    18bc:	61 15       	cp	r22, r1
    18be:	71 05       	cpc	r23, r1
    18c0:	51 f0       	breq	.+20     	; 0x18d6 <Endpoint_Write_Control_Stream_LE+0x7e>
    18c2:	88 30       	cpi	r24, 0x08	; 8
    18c4:	91 05       	cpc	r25, r1
    18c6:	38 f4       	brcc	.+14     	; 0x18d6 <Endpoint_Write_Control_Stream_LE+0x7e>
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    18c8:	21 91       	ld	r18, Z+
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    18ca:	20 93 f1 00 	sts	0x00F1, r18
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
    18ce:	61 50       	subi	r22, 0x01	; 1
    18d0:	71 09       	sbc	r23, r1
				BytesInEndpoint++;
    18d2:	01 96       	adiw	r24, 0x01	; 1
    18d4:	f3 cf       	rjmp	.-26     	; 0x18bc <Endpoint_Write_Control_Stream_LE+0x64>
			}

			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
    18d6:	21 e0       	ldi	r18, 0x01	; 1
    18d8:	08 97       	sbiw	r24, 0x08	; 8
    18da:	09 f0       	breq	.+2      	; 0x18de <Endpoint_Write_Control_Stream_LE+0x86>
    18dc:	20 e0       	ldi	r18, 0x00	; 0
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    18de:	80 91 e8 00 	lds	r24, 0x00E8
    18e2:	8e 77       	andi	r24, 0x7E	; 126
    18e4:	80 93 e8 00 	sts	0x00E8, r24
    18e8:	ca cf       	rjmp	.-108    	; 0x187e <Endpoint_Write_Control_Stream_LE+0x26>
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    18ea:	21 11       	cpse	r18, r1
    18ec:	cb cf       	rjmp	.-106    	; 0x1884 <Endpoint_Write_Control_Stream_LE+0x2c>
    18ee:	d8 cf       	rjmp	.-80     	; 0x18a0 <Endpoint_Write_Control_Stream_LE+0x48>
		}
	}

	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    18f0:	80 91 46 14 	lds	r24, 0x1446

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    18f4:	88 23       	and	r24, r24
    18f6:	39 f0       	breq	.+14     	; 0x1906 <Endpoint_Write_Control_Stream_LE+0xae>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    18f8:	85 30       	cpi	r24, 0x05	; 5
    18fa:	39 f0       	breq	.+14     	; 0x190a <Endpoint_Write_Control_Stream_LE+0xb2>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    18fc:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    1900:	83 ff       	sbrs	r24, 3
    1902:	ce cf       	rjmp	.-100    	; 0x18a0 <Endpoint_Write_Control_Stream_LE+0x48>
    1904:	04 c0       	rjmp	.+8      	; 0x190e <Endpoint_Write_Control_Stream_LE+0xb6>
	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
    1906:	82 e0       	ldi	r24, 0x02	; 2
    1908:	08 95       	ret
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    190a:	83 e0       	ldi	r24, 0x03	; 3
    190c:	08 95       	ret
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
    190e:	81 e0       	ldi	r24, 0x01	; 1
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    1910:	08 95       	ret

00001912 <Endpoint_Read_Control_Stream_LE>:
uint8_t TEMPLATE_FUNC_NAME (void* const Buffer,
                            uint16_t Length)
{
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));

	if (!(Length))
    1912:	61 15       	cp	r22, r1
    1914:	71 05       	cpc	r23, r1
    1916:	29 f4       	brne	.+10     	; 0x1922 <Endpoint_Read_Control_Stream_LE+0x10>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    1918:	20 91 e8 00 	lds	r18, 0x00E8
    191c:	2b 77       	andi	r18, 0x7B	; 123
    191e:	20 93 e8 00 	sts	0x00E8, r18
	  Endpoint_ClearOUT();

	while (Length)
    1922:	61 15       	cp	r22, r1
    1924:	71 05       	cpc	r23, r1
    1926:	31 f1       	breq	.+76     	; 0x1974 <Endpoint_Read_Control_Stream_LE+0x62>
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    1928:	20 91 46 14 	lds	r18, 0x1446

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    192c:	22 23       	and	r18, r18
    192e:	59 f1       	breq	.+86     	; 0x1986 <Endpoint_Read_Control_Stream_LE+0x74>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    1930:	25 30       	cpi	r18, 0x05	; 5
    1932:	59 f1       	breq	.+86     	; 0x198a <Endpoint_Read_Control_Stream_LE+0x78>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    1934:	20 91 e8 00 	lds	r18, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    1938:	23 fd       	sbrc	r18, 3
    193a:	21 c0       	rjmp	.+66     	; 0x197e <Endpoint_Read_Control_Stream_LE+0x6c>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    193c:	20 91 e8 00 	lds	r18, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;

		if (Endpoint_IsOUTReceived())
    1940:	22 ff       	sbrs	r18, 2
    1942:	f2 cf       	rjmp	.-28     	; 0x1928 <Endpoint_Read_Control_Stream_LE+0x16>
    1944:	fc 01       	movw	r30, r24
    1946:	cf 01       	movw	r24, r30
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					return UEBCX;
    1948:	20 91 f2 00 	lds	r18, 0x00F2
    194c:	30 91 f3 00 	lds	r19, 0x00F3
		{
			while (Length && Endpoint_BytesInEndpoint())
    1950:	23 2b       	or	r18, r19
    1952:	11 f3       	breq	.-60     	; 0x1918 <Endpoint_Read_Control_Stream_LE+0x6>
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    1954:	80 91 f1 00 	lds	r24, 0x00F1
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    1958:	81 93       	st	Z+, r24
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
    195a:	cf 01       	movw	r24, r30
				Length--;
    195c:	61 50       	subi	r22, 0x01	; 1
    195e:	71 09       	sbc	r23, r1
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;

		if (Endpoint_IsOUTReceived())
		{
			while (Length && Endpoint_BytesInEndpoint())
    1960:	61 15       	cp	r22, r1
    1962:	71 05       	cpc	r23, r1
    1964:	81 f7       	brne	.-32     	; 0x1946 <Endpoint_Read_Control_Stream_LE+0x34>
    1966:	d8 cf       	rjmp	.-80     	; 0x1918 <Endpoint_Read_Control_Stream_LE+0x6>
		}
	}

	while (!(Endpoint_IsINReady()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    1968:	80 91 46 14 	lds	r24, 0x1446

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    196c:	88 23       	and	r24, r24
    196e:	59 f0       	breq	.+22     	; 0x1986 <Endpoint_Read_Control_Stream_LE+0x74>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    1970:	85 30       	cpi	r24, 0x05	; 5
    1972:	59 f0       	breq	.+22     	; 0x198a <Endpoint_Read_Control_Stream_LE+0x78>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    1974:	80 91 e8 00 	lds	r24, 0x00E8

			Endpoint_ClearOUT();
		}
	}

	while (!(Endpoint_IsINReady()))
    1978:	80 ff       	sbrs	r24, 0
    197a:	f6 cf       	rjmp	.-20     	; 0x1968 <Endpoint_Read_Control_Stream_LE+0x56>
    197c:	02 c0       	rjmp	.+4      	; 0x1982 <Endpoint_Read_Control_Stream_LE+0x70>
		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
    197e:	81 e0       	ldi	r24, 0x01	; 1
    1980:	08 95       	ret
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
    1982:	80 e0       	ldi	r24, 0x00	; 0
    1984:	08 95       	ret
	while (Length)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
    1986:	82 e0       	ldi	r24, 0x02	; 2
    1988:	08 95       	ret
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    198a:	83 e0       	ldi	r24, 0x03	; 3
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    198c:	08 95       	ret

0000198e <Endpoint_Write_Control_PStream_LE>:
                            uint16_t Length)
{
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
    198e:	20 91 4d 14 	lds	r18, 0x144D
    1992:	30 91 4e 14 	lds	r19, 0x144E
    1996:	26 17       	cp	r18, r22
    1998:	37 07       	cpc	r19, r23
    199a:	48 f0       	brcs	.+18     	; 0x19ae <Endpoint_Write_Control_PStream_LE+0x20>
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
    199c:	61 15       	cp	r22, r1
    199e:	71 05       	cpc	r23, r1
    19a0:	39 f4       	brne	.+14     	; 0x19b0 <Endpoint_Write_Control_PStream_LE+0x22>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    19a2:	20 91 e8 00 	lds	r18, 0x00E8
    19a6:	2e 77       	andi	r18, 0x7E	; 126
    19a8:	20 93 e8 00 	sts	0x00E8, r18
    19ac:	01 c0       	rjmp	.+2      	; 0x19b0 <Endpoint_Write_Control_PStream_LE+0x22>
    19ae:	b9 01       	movw	r22, r18
    19b0:	fc 01       	movw	r30, r24
    19b2:	20 e0       	ldi	r18, 0x00	; 0
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    19b4:	61 15       	cp	r22, r1
    19b6:	71 05       	cpc	r23, r1
    19b8:	b1 f1       	breq	.+108    	; 0x1a26 <Endpoint_Write_Control_PStream_LE+0x98>
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    19ba:	80 91 46 14 	lds	r24, 0x1446

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    19be:	88 23       	and	r24, r24
    19c0:	09 f4       	brne	.+2      	; 0x19c4 <Endpoint_Write_Control_PStream_LE+0x36>
    19c2:	3f c0       	rjmp	.+126    	; 0x1a42 <Endpoint_Write_Control_PStream_LE+0xb4>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    19c4:	85 30       	cpi	r24, 0x05	; 5
    19c6:	09 f4       	brne	.+2      	; 0x19ca <Endpoint_Write_Control_PStream_LE+0x3c>
    19c8:	3e c0       	rjmp	.+124    	; 0x1a46 <Endpoint_Write_Control_PStream_LE+0xb8>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    19ca:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    19ce:	83 fd       	sbrc	r24, 3
    19d0:	3c c0       	rjmp	.+120    	; 0x1a4a <Endpoint_Write_Control_PStream_LE+0xbc>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    19d2:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
    19d6:	82 ff       	sbrs	r24, 2
    19d8:	06 c0       	rjmp	.+12     	; 0x19e6 <Endpoint_Write_Control_PStream_LE+0x58>
    19da:	80 91 e8 00 	lds	r24, 0x00E8
			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}

	while (!(Endpoint_IsOUTReceived()))
    19de:	82 ff       	sbrs	r24, 2
    19e0:	25 c0       	rjmp	.+74     	; 0x1a2c <Endpoint_Write_Control_PStream_LE+0x9e>
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
	}

	return ENDPOINT_RWCSTREAM_NoError;
    19e2:	80 e0       	ldi	r24, 0x00	; 0
    19e4:	08 95       	ret
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    19e6:	80 91 e8 00 	lds	r24, 0x00E8
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
		  break;

		if (Endpoint_IsINReady())
    19ea:	80 ff       	sbrs	r24, 0
    19ec:	e3 cf       	rjmp	.-58     	; 0x19b4 <Endpoint_Write_Control_PStream_LE+0x26>
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					return UEBCX;
    19ee:	80 91 f2 00 	lds	r24, 0x00F2
    19f2:	90 91 f3 00 	lds	r25, 0x00F3
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    19f6:	61 15       	cp	r22, r1
    19f8:	71 05       	cpc	r23, r1
    19fa:	59 f0       	breq	.+22     	; 0x1a12 <Endpoint_Write_Control_PStream_LE+0x84>
    19fc:	88 30       	cpi	r24, 0x08	; 8
    19fe:	91 05       	cpc	r25, r1
    1a00:	40 f4       	brcc	.+16     	; 0x1a12 <Endpoint_Write_Control_PStream_LE+0x84>
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    1a02:	24 91       	lpm	r18, Z
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    1a04:	20 93 f1 00 	sts	0x00F1, r18
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
    1a08:	31 96       	adiw	r30, 0x01	; 1
				Length--;
    1a0a:	61 50       	subi	r22, 0x01	; 1
    1a0c:	71 09       	sbc	r23, r1
				BytesInEndpoint++;
    1a0e:	01 96       	adiw	r24, 0x01	; 1
    1a10:	f2 cf       	rjmp	.-28     	; 0x19f6 <Endpoint_Write_Control_PStream_LE+0x68>
			}

			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
    1a12:	21 e0       	ldi	r18, 0x01	; 1
    1a14:	08 97       	sbiw	r24, 0x08	; 8
    1a16:	09 f0       	breq	.+2      	; 0x1a1a <Endpoint_Write_Control_PStream_LE+0x8c>
    1a18:	20 e0       	ldi	r18, 0x00	; 0
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    1a1a:	80 91 e8 00 	lds	r24, 0x00E8
    1a1e:	8e 77       	andi	r24, 0x7E	; 126
    1a20:	80 93 e8 00 	sts	0x00E8, r24
    1a24:	c7 cf       	rjmp	.-114    	; 0x19b4 <Endpoint_Write_Control_PStream_LE+0x26>
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    1a26:	21 11       	cpse	r18, r1
    1a28:	c8 cf       	rjmp	.-112    	; 0x19ba <Endpoint_Write_Control_PStream_LE+0x2c>
    1a2a:	d7 cf       	rjmp	.-82     	; 0x19da <Endpoint_Write_Control_PStream_LE+0x4c>
		}
	}

	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    1a2c:	80 91 46 14 	lds	r24, 0x1446

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    1a30:	88 23       	and	r24, r24
    1a32:	39 f0       	breq	.+14     	; 0x1a42 <Endpoint_Write_Control_PStream_LE+0xb4>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    1a34:	85 30       	cpi	r24, 0x05	; 5
    1a36:	39 f0       	breq	.+14     	; 0x1a46 <Endpoint_Write_Control_PStream_LE+0xb8>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    1a38:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    1a3c:	83 ff       	sbrs	r24, 3
    1a3e:	cd cf       	rjmp	.-102    	; 0x19da <Endpoint_Write_Control_PStream_LE+0x4c>
    1a40:	04 c0       	rjmp	.+8      	; 0x1a4a <Endpoint_Write_Control_PStream_LE+0xbc>
	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
    1a42:	82 e0       	ldi	r24, 0x02	; 2
    1a44:	08 95       	ret
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    1a46:	83 e0       	ldi	r24, 0x03	; 3
    1a48:	08 95       	ret
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
    1a4a:	81 e0       	ldi	r24, 0x01	; 1
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    1a4c:	08 95       	ret

00001a4e <Endpoint_ConfigureEndpoint_Prv>:
	UECFG0X = UECFG0XData;
	UECFG1X = UECFG1XData;

	return Endpoint_IsConfigured();
#else
	for (uint8_t EPNum = Number; EPNum < ENDPOINT_TOTAL_ENDPOINTS; EPNum++)
    1a4e:	98 2f       	mov	r25, r24
    1a50:	97 30       	cpi	r25, 0x07	; 7
    1a52:	58 f5       	brcc	.+86     	; 0x1aaa <Endpoint_ConfigureEndpoint_Prv+0x5c>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    1a54:	90 93 e9 00 	sts	0x00E9, r25
		uint8_t UECFG1XTemp;
		uint8_t UEIENXTemp;

		Endpoint_SelectEndpoint(EPNum);

		if (EPNum == Number)
    1a58:	98 17       	cp	r25, r24
    1a5a:	39 f0       	breq	.+14     	; 0x1a6a <Endpoint_ConfigureEndpoint_Prv+0x1c>
			UECFG1XTemp = UECFG1XData;
			UEIENXTemp  = 0;
		}
		else
		{
			UECFG0XTemp = UECFG0X;
    1a5c:	70 91 ec 00 	lds	r23, 0x00EC
			UECFG1XTemp = UECFG1X;
    1a60:	20 91 ed 00 	lds	r18, 0x00ED
			UEIENXTemp  = UEIENX;
    1a64:	50 91 f0 00 	lds	r21, 0x00F0
    1a68:	03 c0       	rjmp	.+6      	; 0x1a70 <Endpoint_ConfigureEndpoint_Prv+0x22>
		Endpoint_SelectEndpoint(EPNum);

		if (EPNum == Number)
		{
			UECFG0XTemp = UECFG0XData;
			UECFG1XTemp = UECFG1XData;
    1a6a:	24 2f       	mov	r18, r20

		Endpoint_SelectEndpoint(EPNum);

		if (EPNum == Number)
		{
			UECFG0XTemp = UECFG0XData;
    1a6c:	76 2f       	mov	r23, r22
			UECFG1XTemp = UECFG1XData;
			UEIENXTemp  = 0;
    1a6e:	50 e0       	ldi	r21, 0x00	; 0
			UECFG0XTemp = UECFG0X;
			UECFG1XTemp = UECFG1X;
			UEIENXTemp  = UEIENX;
		}

		if (!(UECFG1XTemp & (1 << ALLOC)))
    1a70:	21 ff       	sbrs	r18, 1
    1a72:	19 c0       	rjmp	.+50     	; 0x1aa6 <Endpoint_ConfigureEndpoint_Prv+0x58>
			 *  to and from a host.
			 */
			static inline void Endpoint_DisableEndpoint(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_DisableEndpoint(void)
			{
				UECONX &= ~(1 << EPEN);
    1a74:	30 91 eb 00 	lds	r19, 0x00EB
    1a78:	3e 7f       	andi	r19, 0xFE	; 254
    1a7a:	30 93 eb 00 	sts	0x00EB, r19
		  continue;

		Endpoint_DisableEndpoint();
		UECFG1X &= ~(1 << ALLOC);
    1a7e:	30 91 ed 00 	lds	r19, 0x00ED
    1a82:	3d 7f       	andi	r19, 0xFD	; 253
    1a84:	30 93 ed 00 	sts	0x00ED, r19
			 *  \note Endpoints must first be configured properly via \ref Endpoint_ConfigureEndpoint().
			 */
			static inline void Endpoint_EnableEndpoint(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_EnableEndpoint(void)
			{
				UECONX |= (1 << EPEN);
    1a88:	30 91 eb 00 	lds	r19, 0x00EB
    1a8c:	31 60       	ori	r19, 0x01	; 1
    1a8e:	30 93 eb 00 	sts	0x00EB, r19

		Endpoint_EnableEndpoint();
		UECFG0X = UECFG0XTemp;
    1a92:	70 93 ec 00 	sts	0x00EC, r23
		UECFG1X = UECFG1XTemp;
    1a96:	20 93 ed 00 	sts	0x00ED, r18
		UEIENX  = UEIENXTemp;
    1a9a:	50 93 f0 00 	sts	0x00F0, r21
			 *  \return Boolean \c true if the currently selected endpoint has been configured, \c false otherwise.
			 */
			static inline bool Endpoint_IsConfigured(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsConfigured(void)
			{
				return ((UESTA0X & (1 << CFGOK)) ? true : false);
    1a9e:	20 91 ee 00 	lds	r18, 0x00EE

		if (!(Endpoint_IsConfigured()))
    1aa2:	27 ff       	sbrs	r18, 7
    1aa4:	07 c0       	rjmp	.+14     	; 0x1ab4 <Endpoint_ConfigureEndpoint_Prv+0x66>
	UECFG0X = UECFG0XData;
	UECFG1X = UECFG1XData;

	return Endpoint_IsConfigured();
#else
	for (uint8_t EPNum = Number; EPNum < ENDPOINT_TOTAL_ENDPOINTS; EPNum++)
    1aa6:	9f 5f       	subi	r25, 0xFF	; 255
    1aa8:	d3 cf       	rjmp	.-90     	; 0x1a50 <Endpoint_ConfigureEndpoint_Prv+0x2>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    1aaa:	8f 70       	andi	r24, 0x0F	; 15
    1aac:	80 93 e9 00 	sts	0x00E9, r24
		if (!(Endpoint_IsConfigured()))
		  return false;
	}

	Endpoint_SelectEndpoint(Number);
	return true;
    1ab0:	81 e0       	ldi	r24, 0x01	; 1
    1ab2:	08 95       	ret
		UECFG0X = UECFG0XTemp;
		UECFG1X = UECFG1XTemp;
		UEIENX  = UEIENXTemp;

		if (!(Endpoint_IsConfigured()))
		  return false;
    1ab4:	80 e0       	ldi	r24, 0x00	; 0
	}

	Endpoint_SelectEndpoint(Number);
	return true;
#endif
}
    1ab6:	08 95       	ret

00001ab8 <Endpoint_ConfigureEndpointTable>:
uint8_t USB_Device_ControlEndpointSize = ENDPOINT_CONTROLEP_DEFAULT_SIZE;
#endif

bool Endpoint_ConfigureEndpointTable(const USB_Endpoint_Table_t* const Table,
                                     const uint8_t Entries)
{
    1ab8:	0f 93       	push	r16
    1aba:	1f 93       	push	r17
    1abc:	cf 93       	push	r28
    1abe:	df 93       	push	r29
    1ac0:	06 2f       	mov	r16, r22
    1ac2:	ec 01       	movw	r28, r24
	for (uint8_t i = 0; i < Entries; i++)
    1ac4:	10 e0       	ldi	r17, 0x00	; 0
    1ac6:	10 17       	cp	r17, r16
    1ac8:	71 f1       	breq	.+92     	; 0x1b26 <Endpoint_ConfigureEndpointTable+0x6e>
	{
		if (!(Table[i].Address))
    1aca:	98 81       	ld	r25, Y
    1acc:	99 23       	and	r25, r25
    1ace:	41 f1       	breq	.+80     	; 0x1b20 <Endpoint_ConfigureEndpointTable+0x68>
		  continue;

		if (!(Endpoint_ConfigureEndpoint(Table[i].Address, Table[i].Type, Table[i].Size, Table[i].Banks)))
    1ad0:	2c 81       	ldd	r18, Y+4	; 0x04
    1ad2:	e9 81       	ldd	r30, Y+1	; 0x01
    1ad4:	fa 81       	ldd	r31, Y+2	; 0x02
    1ad6:	7b 81       	ldd	r23, Y+3	; 0x03
			static inline bool Endpoint_ConfigureEndpoint(const uint8_t Address,
			                                              const uint8_t Type,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				uint8_t Number = (Address & ENDPOINT_EPNUM_MASK);
    1ad8:	89 2f       	mov	r24, r25
    1ada:	8f 70       	andi	r24, 0x0F	; 15

				if (Number >= ENDPOINT_TOTAL_ENDPOINTS)
    1adc:	87 30       	cpi	r24, 0x07	; 7
    1ade:	10 f0       	brcs	.+4      	; 0x1ae4 <Endpoint_ConfigureEndpointTable+0x2c>
		  return false;
    1ae0:	80 e0       	ldi	r24, 0x00	; 0
    1ae2:	22 c0       	rjmp	.+68     	; 0x1b28 <Endpoint_ConfigureEndpointTable+0x70>
				  return false;

				return Endpoint_ConfigureEndpoint_Prv(Number,
    1ae4:	22 30       	cpi	r18, 0x02	; 2
    1ae6:	10 f0       	brcs	.+4      	; 0x1aec <Endpoint_ConfigureEndpointTable+0x34>
    1ae8:	56 e0       	ldi	r21, 0x06	; 6
    1aea:	01 c0       	rjmp	.+2      	; 0x1aee <Endpoint_ConfigureEndpointTable+0x36>
    1aec:	52 e0       	ldi	r21, 0x02	; 2
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes) ATTR_WARN_UNUSED_RESULT ATTR_CONST
			                                                                       ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes)
			{
				uint8_t  MaskVal    = 0;
				uint16_t CheckBytes = 8;
    1aee:	28 e0       	ldi	r18, 0x08	; 8
    1af0:	30 e0       	ldi	r19, 0x00	; 0
		/* Inline Functions: */
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes) ATTR_WARN_UNUSED_RESULT ATTR_CONST
			                                                                       ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes)
			{
				uint8_t  MaskVal    = 0;
    1af2:	40 e0       	ldi	r20, 0x00	; 0
				uint16_t CheckBytes = 8;

				while (CheckBytes < Bytes)
    1af4:	2e 17       	cp	r18, r30
    1af6:	3f 07       	cpc	r19, r31
    1af8:	20 f4       	brcc	.+8      	; 0x1b02 <Endpoint_ConfigureEndpointTable+0x4a>
				{
					MaskVal++;
    1afa:	4f 5f       	subi	r20, 0xFF	; 255
					CheckBytes <<= 1;
    1afc:	22 0f       	add	r18, r18
    1afe:	33 1f       	adc	r19, r19
    1b00:	f9 cf       	rjmp	.-14     	; 0x1af4 <Endpoint_ConfigureEndpointTable+0x3c>
				}

				return (MaskVal << EPSIZE0);
    1b02:	42 95       	swap	r20
    1b04:	40 7f       	andi	r20, 0xF0	; 240
				uint8_t Number = (Address & ENDPOINT_EPNUM_MASK);

				if (Number >= ENDPOINT_TOTAL_ENDPOINTS)
				  return false;

				return Endpoint_ConfigureEndpoint_Prv(Number,
    1b06:	45 2b       	or	r20, r21
				                                      ((Type << EPTYPE0) | ((Address & ENDPOINT_DIR_IN) ? (1 << EPDIR) : 0)),
    1b08:	69 2f       	mov	r22, r25
    1b0a:	66 1f       	adc	r22, r22
    1b0c:	66 27       	eor	r22, r22
    1b0e:	66 1f       	adc	r22, r22
    1b10:	90 e4       	ldi	r25, 0x40	; 64
    1b12:	79 9f       	mul	r23, r25
    1b14:	90 01       	movw	r18, r0
    1b16:	11 24       	eor	r1, r1
				uint8_t Number = (Address & ENDPOINT_EPNUM_MASK);

				if (Number >= ENDPOINT_TOTAL_ENDPOINTS)
				  return false;

				return Endpoint_ConfigureEndpoint_Prv(Number,
    1b18:	62 2b       	or	r22, r18
    1b1a:	99 df       	rcall	.-206    	; 0x1a4e <Endpoint_ConfigureEndpoint_Prv>
    1b1c:	88 23       	and	r24, r24
	for (uint8_t i = 0; i < Entries; i++)
	{
		if (!(Table[i].Address))
		  continue;

		if (!(Endpoint_ConfigureEndpoint(Table[i].Address, Table[i].Type, Table[i].Size, Table[i].Banks)))
    1b1e:	01 f3       	breq	.-64     	; 0x1ae0 <Endpoint_ConfigureEndpointTable+0x28>
    1b20:	1f 5f       	subi	r17, 0xFF	; 255
#endif

bool Endpoint_ConfigureEndpointTable(const USB_Endpoint_Table_t* const Table,
                                     const uint8_t Entries)
{
	for (uint8_t i = 0; i < Entries; i++)
    1b22:	25 96       	adiw	r28, 0x05	; 5
    1b24:	d0 cf       	rjmp	.-96     	; 0x1ac6 <Endpoint_ConfigureEndpointTable+0xe>
    1b26:	81 e0       	ldi	r24, 0x01	; 1

		if (!(Endpoint_ConfigureEndpoint(Table[i].Address, Table[i].Type, Table[i].Size, Table[i].Banks)))
		  return false;
	}

	return true;
    1b28:	df 91       	pop	r29
}
    1b2a:	cf 91       	pop	r28
    1b2c:	1f 91       	pop	r17
    1b2e:	0f 91       	pop	r16
    1b30:	08 95       	ret

00001b32 <Endpoint_ClearStatusStage>:
    1b32:	80 91 47 14 	lds	r24, 0x1447
	}
}

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
    1b36:	87 fd       	sbrc	r24, 7
    1b38:	05 c0       	rjmp	.+10     	; 0x1b44 <Endpoint_ClearStatusStage+0x12>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    1b3a:	80 91 e8 00 	lds	r24, 0x00E8

		Endpoint_ClearOUT();
	}
	else
	{
		while (!(Endpoint_IsINReady()))
    1b3e:	80 ff       	sbrs	r24, 0
    1b40:	0e c0       	rjmp	.+28     	; 0x1b5e <Endpoint_ClearStatusStage+0x2c>
    1b42:	12 c0       	rjmp	.+36     	; 0x1b68 <Endpoint_ClearStatusStage+0x36>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    1b44:	80 91 e8 00 	lds	r24, 0x00E8

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
	{
		while (!(Endpoint_IsOUTReceived()))
    1b48:	82 fd       	sbrc	r24, 2
    1b4a:	05 c0       	rjmp	.+10     	; 0x1b56 <Endpoint_ClearStatusStage+0x24>
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    1b4c:	80 91 46 14 	lds	r24, 0x1446
    1b50:	81 11       	cpse	r24, r1
    1b52:	f8 cf       	rjmp	.-16     	; 0x1b44 <Endpoint_ClearStatusStage+0x12>
    1b54:	08 95       	ret
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    1b56:	80 91 e8 00 	lds	r24, 0x00E8
    1b5a:	8b 77       	andi	r24, 0x7B	; 123
    1b5c:	08 c0       	rjmp	.+16     	; 0x1b6e <Endpoint_ClearStatusStage+0x3c>
	}
	else
	{
		while (!(Endpoint_IsINReady()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    1b5e:	80 91 46 14 	lds	r24, 0x1446
    1b62:	81 11       	cpse	r24, r1
    1b64:	ea cf       	rjmp	.-44     	; 0x1b3a <Endpoint_ClearStatusStage+0x8>
    1b66:	08 95       	ret
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    1b68:	80 91 e8 00 	lds	r24, 0x00E8
    1b6c:	8e 77       	andi	r24, 0x7E	; 126
    1b6e:	80 93 e8 00 	sts	0x00E8, r24
    1b72:	08 95       	ret

00001b74 <Endpoint_WaitUntilReady>:
			 *  \return Current USB frame number from the USB controller.
			 */
			static inline uint16_t USB_Device_GetFrameNumber(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint16_t USB_Device_GetFrameNumber(void)
			{
				return UDFNUM;
    1b74:	80 91 e4 00 	lds	r24, 0x00E4
    1b78:	90 91 e5 00 	lds	r25, 0x00E5
    1b7c:	45 e6       	ldi	r20, 0x65	; 101
			 *  \return The currently selected endpoint's direction, as a \c ENDPOINT_DIR_* mask.
			 */
			static inline uint8_t Endpoint_GetEndpointDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetEndpointDirection(void)
			{
				return (UECFG0X & (1 << EPDIR)) ? ENDPOINT_DIR_IN : ENDPOINT_DIR_OUT;
    1b7e:	20 91 ec 00 	lds	r18, 0x00EC
    1b82:	20 ff       	sbrs	r18, 0
    1b84:	21 c0       	rjmp	.+66     	; 0x1bc8 <Endpoint_WaitUntilReady+0x54>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    1b86:	20 91 e8 00 	lds	r18, 0x00E8

	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
		{
			if (Endpoint_IsINReady())
    1b8a:	20 fd       	sbrc	r18, 0
    1b8c:	21 c0       	rjmp	.+66     	; 0x1bd0 <Endpoint_WaitUntilReady+0x5c>
		{
			if (Endpoint_IsOUTReceived())
			  return ENDPOINT_READYWAIT_NoError;
		}

		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    1b8e:	20 91 46 14 	lds	r18, 0x1446

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    1b92:	22 23       	and	r18, r18
    1b94:	89 f0       	breq	.+34     	; 0x1bb8 <Endpoint_WaitUntilReady+0x44>
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    1b96:	25 30       	cpi	r18, 0x05	; 5
    1b98:	89 f0       	breq	.+34     	; 0x1bbc <Endpoint_WaitUntilReady+0x48>
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    1b9a:	20 91 eb 00 	lds	r18, 0x00EB
		  return ENDPOINT_READYWAIT_BusSuspended;
		else if (Endpoint_IsStalled())
    1b9e:	25 fd       	sbrc	r18, 5
    1ba0:	0f c0       	rjmp	.+30     	; 0x1bc0 <Endpoint_WaitUntilReady+0x4c>
    1ba2:	20 91 e4 00 	lds	r18, 0x00E4
    1ba6:	30 91 e5 00 	lds	r19, 0x00E5
		  return ENDPOINT_READYWAIT_EndpointStalled;

		uint16_t CurrentFrameNumber = USB_Device_GetFrameNumber();

		if (CurrentFrameNumber != PreviousFrameNumber)
    1baa:	28 17       	cp	r18, r24
    1bac:	39 07       	cpc	r19, r25
    1bae:	39 f3       	breq	.-50     	; 0x1b7e <Endpoint_WaitUntilReady+0xa>
    1bb0:	41 50       	subi	r20, 0x01	; 1
		{
			PreviousFrameNumber = CurrentFrameNumber;

			if (!(TimeoutMSRem--))
    1bb2:	41 f0       	breq	.+16     	; 0x1bc4 <Endpoint_WaitUntilReady+0x50>
    1bb4:	c9 01       	movw	r24, r18
    1bb6:	e3 cf       	rjmp	.-58     	; 0x1b7e <Endpoint_WaitUntilReady+0xa>
		}

		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
    1bb8:	82 e0       	ldi	r24, 0x02	; 2
    1bba:	08 95       	ret
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_READYWAIT_BusSuspended;
    1bbc:	83 e0       	ldi	r24, 0x03	; 3
    1bbe:	08 95       	ret
		else if (Endpoint_IsStalled())
		  return ENDPOINT_READYWAIT_EndpointStalled;
    1bc0:	81 e0       	ldi	r24, 0x01	; 1
    1bc2:	08 95       	ret
		if (CurrentFrameNumber != PreviousFrameNumber)
		{
			PreviousFrameNumber = CurrentFrameNumber;

			if (!(TimeoutMSRem--))
			  return ENDPOINT_READYWAIT_Timeout;
    1bc4:	84 e0       	ldi	r24, 0x04	; 4
    1bc6:	08 95       	ret
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    1bc8:	20 91 e8 00 	lds	r18, 0x00E8
			if (Endpoint_IsINReady())
			  return ENDPOINT_READYWAIT_NoError;
		}
		else
		{
			if (Endpoint_IsOUTReceived())
    1bcc:	22 ff       	sbrs	r18, 2
    1bce:	df cf       	rjmp	.-66     	; 0x1b8e <Endpoint_WaitUntilReady+0x1a>
	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
		{
			if (Endpoint_IsINReady())
			  return ENDPOINT_READYWAIT_NoError;
    1bd0:	80 e0       	ldi	r24, 0x00	; 0
    1bd2:	08 95       	ret

00001bd4 <USB_ResetInterface>:

	USB_IsInitialized = false;
}

void USB_ResetInterface(void)
{
    1bd4:	0f 93       	push	r16
    1bd6:	1f 93       	push	r17
    1bd8:	cf 93       	push	r28
    1bda:	df 93       	push	r29
	#if defined(USB_CAN_BE_BOTH)
	bool UIDModeSelectEnabled = ((UHWCON & (1 << UIDE)) != 0);
	#endif

	USB_INT_DisableAllInterrupts();
    1bdc:	4e d0       	rcall	.+156    	; 0x1c7a <USB_INT_DisableAllInterrupts>
    1bde:	55 d0       	rcall	.+170    	; 0x1c8a <USB_INT_ClearAllInterrupts>
	USB_INT_ClearAllInterrupts();
    1be0:	c8 ed       	ldi	r28, 0xD8	; 216
    1be2:	d0 e0       	ldi	r29, 0x00	; 0
			}

			static inline void USB_Controller_Reset(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Controller_Reset(void)
			{
				USBCON &= ~(1 << USBE);
    1be4:	88 81       	ld	r24, Y
    1be6:	8f 77       	andi	r24, 0x7F	; 127
    1be8:	88 83       	st	Y, r24
    1bea:	88 81       	ld	r24, Y
    1bec:	80 68       	ori	r24, 0x80	; 128
				USBCON |=  (1 << USBE);
    1bee:	88 83       	st	Y, r24
    1bf0:	88 81       	ld	r24, Y
    1bf2:	8f 7d       	andi	r24, 0xDF	; 223
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON &= ~(1 << FRZCLK);
    1bf4:	88 83       	st	Y, r24
    1bf6:	e7 ed       	ldi	r30, 0xD7	; 215
    1bf8:	f0 e0       	ldi	r31, 0x00	; 0

	if (USB_CurrentMode == USB_MODE_Device)
	{
		#if defined(USB_CAN_BE_DEVICE)
		#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
		UHWCON |=  (1 << UIMOD);
    1bfa:	80 81       	ld	r24, Z
    1bfc:	80 68       	ori	r24, 0x80	; 128
    1bfe:	80 83       	st	Z, r24
    1c00:	19 bc       	out	0x29, r1	; 41
    1c02:	10 92 46 14 	sts	0x1446, r1
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_Init_Device(void)
{
	USB_DeviceState                 = DEVICE_STATE_Unattached;
    1c06:	10 92 42 14 	sts	0x1442, r1
	USB_Device_ConfigurationNumber  = 0;
    1c0a:	10 92 44 14 	sts	0x1444, r1

	#if !defined(NO_DEVICE_REMOTE_WAKEUP)
	USB_Device_RemoteWakeupEnabled  = false;
    1c0e:	10 92 43 14 	sts	0x1443, r1
	#endif

	#if !defined(NO_DEVICE_SELF_POWER)
	USB_Device_CurrentlySelfPowered = false;
    1c12:	00 ee       	ldi	r16, 0xE0	; 224
    1c14:	10 e0       	ldi	r17, 0x00	; 0
			}

			static inline void USB_Device_SetFullSpeed(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetFullSpeed(void)
			{
				UDCON &= ~(1 << LSM);
    1c16:	f8 01       	movw	r30, r16
    1c18:	80 81       	ld	r24, Z
    1c1a:	8b 7f       	andi	r24, 0xFB	; 251
    1c1c:	80 83       	st	Z, r24
    1c1e:	88 81       	ld	r24, Y
    1c20:	81 60       	ori	r24, 0x01	; 1
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						USBCON |= (1 << VBUSTE);
    1c22:	88 83       	st	Y, r24
    1c24:	42 e0       	ldi	r20, 0x02	; 2
    1c26:	60 e0       	ldi	r22, 0x00	; 0
				uint8_t Number = (Address & ENDPOINT_EPNUM_MASK);

				if (Number >= ENDPOINT_TOTAL_ENDPOINTS)
				  return false;

				return Endpoint_ConfigureEndpoint_Prv(Number,
    1c28:	80 e0       	ldi	r24, 0x00	; 0
    1c2a:	11 df       	rcall	.-478    	; 0x1a4e <Endpoint_ConfigureEndpoint_Prv>
    1c2c:	e1 ee       	ldi	r30, 0xE1	; 225
    1c2e:	f0 e0       	ldi	r31, 0x00	; 0
    1c30:	80 81       	ld	r24, Z
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
    1c32:	8e 7f       	andi	r24, 0xFE	; 254
    1c34:	80 83       	st	Z, r24
    1c36:	e2 ee       	ldi	r30, 0xE2	; 226
    1c38:	f0 e0       	ldi	r31, 0x00	; 0
    1c3a:	80 81       	ld	r24, Z
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  |= (1 << SUSPE);
    1c3c:	81 60       	ori	r24, 0x01	; 1
    1c3e:	80 83       	st	Z, r24
    1c40:	80 81       	ld	r24, Z
    1c42:	88 60       	ori	r24, 0x08	; 8
    1c44:	80 83       	st	Z, r24
						break;
					case USB_INT_EORSTI:
						UDIEN  |= (1 << EORSTE);
    1c46:	f8 01       	movw	r30, r16
    1c48:	80 81       	ld	r24, Z
    1c4a:	8e 7f       	andi	r24, 0xFE	; 254
			 *  register and despite the datasheet making no mention of its requirement in host mode.
			 */
			static inline void USB_Attach(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Attach(void)
			{
				UDCON  &= ~(1 << DETACH);
    1c4c:	80 83       	st	Z, r24
    1c4e:	88 81       	ld	r24, Y
    1c50:	80 61       	ori	r24, 0x10	; 16
    1c52:	88 83       	st	Y, r24

			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
			static inline void USB_OTGPAD_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_OTGPAD_On(void)
			{
				USBCON |=  (1 << OTGPADE);
    1c54:	df 91       	pop	r29
    1c56:	cf 91       	pop	r28
    1c58:	1f 91       	pop	r17
	}

	#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
	USB_OTGPAD_On();
	#endif
}
    1c5a:	0f 91       	pop	r16
    1c5c:	08 95       	ret

00001c5e <USB_Init>:
    1c5e:	e8 ed       	ldi	r30, 0xD8	; 216
    1c60:	f0 e0       	ldi	r31, 0x00	; 0
    1c62:	80 81       	ld	r24, Z
			}

			static inline void USB_OTGPAD_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_OTGPAD_Off(void)
			{
				USBCON &= ~(1 << OTGPADE);
    1c64:	8f 7e       	andi	r24, 0xEF	; 239
    1c66:	80 83       	st	Z, r24

			static inline void USB_REG_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_REG_On(void)
			{
			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
				UHWCON |=  (1 << UVREGE);
    1c68:	e7 ed       	ldi	r30, 0xD7	; 215
    1c6a:	f0 e0       	ldi	r31, 0x00	; 0
    1c6c:	80 81       	ld	r24, Z
    1c6e:	81 60       	ori	r24, 0x01	; 1
    1c70:	80 83       	st	Z, r24
		UHWCON &= ~(1 << UIDE);
		USB_CurrentMode = Mode;
	}
	#endif

	USB_IsInitialized = true;
    1c72:	81 e0       	ldi	r24, 0x01	; 1
    1c74:	80 93 45 14 	sts	0x1445, r24

	USB_ResetInterface();
    1c78:	ad cf       	rjmp	.-166    	; 0x1bd4 <USB_ResetInterface>

00001c7a <USB_INT_DisableAllInterrupts>:
    1c7a:	e8 ed       	ldi	r30, 0xD8	; 216
#include "../USBInterrupt.h"

void USB_INT_DisableAllInterrupts(void)
{
	#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBCON &= ~((1 << VBUSTE) | (1 << IDTE));
    1c7c:	f0 e0       	ldi	r31, 0x00	; 0
    1c7e:	80 81       	ld	r24, Z
    1c80:	8c 7f       	andi	r24, 0xFC	; 252
    1c82:	80 83       	st	Z, r24
	#if defined(USB_CAN_BE_HOST)
	UHIEN   = 0;
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDIEN   = 0;
    1c84:	10 92 e2 00 	sts	0x00E2, r1
    1c88:	08 95       	ret

00001c8a <USB_INT_ClearAllInterrupts>:
}

void USB_INT_ClearAllInterrupts(void)
{
	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBINT = 0;
    1c8a:	10 92 da 00 	sts	0x00DA, r1
	#if defined(USB_CAN_BE_HOST)
	UHINT  = 0;
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDINT  = 0;
    1c8e:	10 92 e1 00 	sts	0x00E1, r1
    1c92:	08 95       	ret

00001c94 <__vector_10>:
	#endif
}

ISR(USB_GEN_vect, ISR_BLOCK)
{
    1c94:	1f 92       	push	r1
    1c96:	0f 92       	push	r0
    1c98:	0f b6       	in	r0, 0x3f	; 63
    1c9a:	0f 92       	push	r0
    1c9c:	11 24       	eor	r1, r1
    1c9e:	0b b6       	in	r0, 0x3b	; 59
    1ca0:	0f 92       	push	r0
    1ca2:	2f 93       	push	r18
    1ca4:	3f 93       	push	r19
    1ca6:	4f 93       	push	r20
    1ca8:	5f 93       	push	r21
    1caa:	6f 93       	push	r22
    1cac:	7f 93       	push	r23
    1cae:	8f 93       	push	r24
    1cb0:	9f 93       	push	r25
    1cb2:	af 93       	push	r26
    1cb4:	bf 93       	push	r27
    1cb6:	ef 93       	push	r30
    1cb8:	ff 93       	push	r31
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
					case USB_INT_EORSTI:
						return (UDINT  & (1 << EORSTI));
					case USB_INT_SOFI:
						return (UDINT  & (1 << SOFI));
    1cba:	80 91 e1 00 	lds	r24, 0x00E1
	#if defined(USB_CAN_BE_DEVICE)
	#if !defined(NO_SOF_EVENTS)
	if (USB_INT_HasOccurred(USB_INT_SOFI) && USB_INT_IsEnabled(USB_INT_SOFI))
    1cbe:	82 ff       	sbrs	r24, 2
    1cc0:	0a c0       	rjmp	.+20     	; 0x1cd6 <__vector_10+0x42>
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
					case USB_INT_EORSTI:
						return (UDIEN  & (1 << EORSTE));
					case USB_INT_SOFI:
						return (UDIEN  & (1 << SOFE));
    1cc2:	80 91 e2 00 	lds	r24, 0x00E2
    1cc6:	82 ff       	sbrs	r24, 2
    1cc8:	06 c0       	rjmp	.+12     	; 0x1cd6 <__vector_10+0x42>
						break;
					case USB_INT_EORSTI:
						UDINT  &= ~(1 << EORSTI);
						break;
					case USB_INT_SOFI:
						UDINT  &= ~(1 << SOFI);
    1cca:	80 91 e1 00 	lds	r24, 0x00E1
    1cce:	8b 7f       	andi	r24, 0xFB	; 251
    1cd0:	80 93 e1 00 	sts	0x00E1, r24
	{
		USB_INT_Clear(USB_INT_SOFI);

		EVENT_USB_Device_StartOfFrame();
    1cd4:	ff d1       	rcall	.+1022   	; 0x20d4 <USB_Event_Stub>
    1cd6:	80 91 da 00 	lds	r24, 0x00DA
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						return (USBINT & (1 << VBUSTI));
    1cda:	80 ff       	sbrs	r24, 0
	}
	#endif

	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	if (USB_INT_HasOccurred(USB_INT_VBUSTI) && USB_INT_IsEnabled(USB_INT_VBUSTI))
    1cdc:	1f c0       	rjmp	.+62     	; 0x1d1c <__vector_10+0x88>
    1cde:	80 91 d8 00 	lds	r24, 0x00D8
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						return (USBCON & (1 << VBUSTE));
    1ce2:	80 ff       	sbrs	r24, 0
    1ce4:	1b c0       	rjmp	.+54     	; 0x1d1c <__vector_10+0x88>
    1ce6:	80 91 da 00 	lds	r24, 0x00DA
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						USBINT &= ~(1 << VBUSTI);
    1cea:	8e 7f       	andi	r24, 0xFE	; 254
    1cec:	80 93 da 00 	sts	0x00DA, r24
    1cf0:	80 91 d9 00 	lds	r24, 0x00D9
				 *  \return Boolean \c true if the VBUS line is currently detecting power from a host, \c false otherwise.
				 */
				static inline bool USB_VBUS_GetStatus(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
				static inline bool USB_VBUS_GetStatus(void)
				{
					return ((USBSTA & (1 << VBUS)) ? true : false);
    1cf4:	80 ff       	sbrs	r24, 0
	{
		USB_INT_Clear(USB_INT_VBUSTI);

		if (USB_VBUS_GetStatus())
    1cf6:	0d c0       	rjmp	.+26     	; 0x1d12 <__vector_10+0x7e>
    1cf8:	8c e0       	ldi	r24, 0x0C	; 12

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR = USB_PLL_PSC;
    1cfa:	89 bd       	out	0x29, r24	; 41
    1cfc:	8e e0       	ldi	r24, 0x0E	; 14
				PLLCSR = (USB_PLL_PSC | (1 << PLLE));
    1cfe:	89 bd       	out	0x29, r24	; 41
    1d00:	09 b4       	in	r0, 0x29	; 41
		{
			if (!(USB_Options & USB_OPT_MANUAL_PLL))
			{
				USB_PLL_On();
				while (!(USB_PLL_IsReady()));
    1d02:	00 fe       	sbrs	r0, 0
    1d04:	fd cf       	rjmp	.-6      	; 0x1d00 <__vector_10+0x6c>
    1d06:	81 e0       	ldi	r24, 0x01	; 1
			}

			USB_DeviceState = DEVICE_STATE_Powered;
    1d08:	80 93 46 14 	sts	0x1446, r24
    1d0c:	0e 94 a0 02 	call	0x540	; 0x540 <EVENT_USB_Device_Connect>
			EVENT_USB_Device_Connect();
    1d10:	05 c0       	rjmp	.+10     	; 0x1d1c <__vector_10+0x88>
    1d12:	19 bc       	out	0x29, r1	; 41
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    1d14:	10 92 46 14 	sts	0x1446, r1
		else
		{
			if (!(USB_Options & USB_OPT_MANUAL_PLL))
			  USB_PLL_Off();

			USB_DeviceState = DEVICE_STATE_Unattached;
    1d18:	0e 94 a2 02 	call	0x544	; 0x544 <EVENT_USB_Device_Disconnect>
			EVENT_USB_Device_Disconnect();
    1d1c:	80 91 e1 00 	lds	r24, 0x00E1
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
    1d20:	80 ff       	sbrs	r24, 0
		}
	}
	#endif

	if (USB_INT_HasOccurred(USB_INT_SUSPI) && USB_INT_IsEnabled(USB_INT_SUSPI))
    1d22:	18 c0       	rjmp	.+48     	; 0x1d54 <__vector_10+0xc0>
    1d24:	80 91 e2 00 	lds	r24, 0x00E2
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
    1d28:	80 ff       	sbrs	r24, 0
    1d2a:	14 c0       	rjmp	.+40     	; 0x1d54 <__vector_10+0xc0>
    1d2c:	80 91 e2 00 	lds	r24, 0x00E2
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  &= ~(1 << SUSPE);
    1d30:	8e 7f       	andi	r24, 0xFE	; 254
    1d32:	80 93 e2 00 	sts	0x00E2, r24
    1d36:	80 91 e2 00 	lds	r24, 0x00E2
						USBCON |= (1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
    1d3a:	80 61       	ori	r24, 0x10	; 16
    1d3c:	80 93 e2 00 	sts	0x00E2, r24
    1d40:	80 91 d8 00 	lds	r24, 0x00D8
			#endif

			static inline void USB_CLK_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Freeze(void)
			{
				USBCON |=  (1 << FRZCLK);
    1d44:	80 62       	ori	r24, 0x20	; 32
    1d46:	80 93 d8 00 	sts	0x00D8, r24
    1d4a:	19 bc       	out	0x29, r1	; 41
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    1d4c:	85 e0       	ldi	r24, 0x05	; 5

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		USB_DeviceState = DEVICE_STATE_Unattached;
		EVENT_USB_Device_Disconnect();
		#else
		USB_DeviceState = DEVICE_STATE_Suspended;
    1d4e:	80 93 46 14 	sts	0x1446, r24
    1d52:	c0 d1       	rcall	.+896    	; 0x20d4 <USB_Event_Stub>
		EVENT_USB_Device_Suspend();
    1d54:	80 91 e1 00 	lds	r24, 0x00E1
					case USB_INT_IDTI:
						return (USBINT & (1 << IDTI));
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
    1d58:	84 ff       	sbrs	r24, 4
    1d5a:	2f c0       	rjmp	.+94     	; 0x1dba <__vector_10+0x126>
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_WAKEUPI) && USB_INT_IsEnabled(USB_INT_WAKEUPI))
    1d5c:	80 91 e2 00 	lds	r24, 0x00E2
					case USB_INT_IDTI:
						return (USBCON & (1 << IDTE));
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
    1d60:	84 ff       	sbrs	r24, 4
    1d62:	2b c0       	rjmp	.+86     	; 0x1dba <__vector_10+0x126>
    1d64:	8c e0       	ldi	r24, 0x0C	; 12
    1d66:	89 bd       	out	0x29, r24	; 41

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR = USB_PLL_PSC;
    1d68:	8e e0       	ldi	r24, 0x0E	; 14
    1d6a:	89 bd       	out	0x29, r24	; 41
				PLLCSR = (USB_PLL_PSC | (1 << PLLE));
    1d6c:	09 b4       	in	r0, 0x29	; 41
    1d6e:	00 fe       	sbrs	r0, 0
	{
		if (!(USB_Options & USB_OPT_MANUAL_PLL))
		{
			USB_PLL_On();
			while (!(USB_PLL_IsReady()));
    1d70:	fd cf       	rjmp	.-6      	; 0x1d6c <__vector_10+0xd8>
    1d72:	80 91 d8 00 	lds	r24, 0x00D8
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON &= ~(1 << FRZCLK);
    1d76:	8f 7d       	andi	r24, 0xDF	; 223
    1d78:	80 93 d8 00 	sts	0x00D8, r24
    1d7c:	80 91 e1 00 	lds	r24, 0x00E1
						USBINT &= ~(1 << IDTI);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
    1d80:	8f 7e       	andi	r24, 0xEF	; 239
    1d82:	80 93 e1 00 	sts	0x00E1, r24
    1d86:	80 91 e2 00 	lds	r24, 0x00E2
						USBCON &= ~(1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
    1d8a:	8f 7e       	andi	r24, 0xEF	; 239
    1d8c:	80 93 e2 00 	sts	0x00E2, r24
    1d90:	80 91 e2 00 	lds	r24, 0x00E2
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  |= (1 << SUSPE);
    1d94:	81 60       	ori	r24, 0x01	; 1
    1d96:	80 93 e2 00 	sts	0x00E2, r24
    1d9a:	80 91 42 14 	lds	r24, 0x1442
		USB_INT_Clear(USB_INT_WAKEUPI);

		USB_INT_Disable(USB_INT_WAKEUPI);
		USB_INT_Enable(USB_INT_SUSPI);

		if (USB_Device_ConfigurationNumber)
    1d9e:	88 23       	and	r24, r24
    1da0:	11 f0       	breq	.+4      	; 0x1da6 <__vector_10+0x112>
    1da2:	84 e0       	ldi	r24, 0x04	; 4
    1da4:	07 c0       	rjmp	.+14     	; 0x1db4 <__vector_10+0x120>
		  USB_DeviceState = DEVICE_STATE_Configured;
    1da6:	80 91 e3 00 	lds	r24, 0x00E3
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
    1daa:	87 ff       	sbrs	r24, 7
    1dac:	02 c0       	rjmp	.+4      	; 0x1db2 <__vector_10+0x11e>
		else
		  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Addressed : DEVICE_STATE_Powered;
    1dae:	83 e0       	ldi	r24, 0x03	; 3
    1db0:	01 c0       	rjmp	.+2      	; 0x1db4 <__vector_10+0x120>
    1db2:	81 e0       	ldi	r24, 0x01	; 1
    1db4:	80 93 46 14 	sts	0x1446, r24
    1db8:	8d d1       	rcall	.+794    	; 0x20d4 <USB_Event_Stub>
    1dba:	80 91 e1 00 	lds	r24, 0x00E1

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		EVENT_USB_Device_Connect();
		#else
		EVENT_USB_Device_WakeUp();
    1dbe:	83 ff       	sbrs	r24, 3
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
					case USB_INT_EORSTI:
						return (UDINT  & (1 << EORSTI));
    1dc0:	22 c0       	rjmp	.+68     	; 0x1e06 <__vector_10+0x172>
    1dc2:	80 91 e2 00 	lds	r24, 0x00E2
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_EORSTI) && USB_INT_IsEnabled(USB_INT_EORSTI))
    1dc6:	83 ff       	sbrs	r24, 3
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
					case USB_INT_EORSTI:
						return (UDIEN  & (1 << EORSTE));
    1dc8:	1e c0       	rjmp	.+60     	; 0x1e06 <__vector_10+0x172>
    1dca:	80 91 e1 00 	lds	r24, 0x00E1
    1dce:	87 7f       	andi	r24, 0xF7	; 247
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
						break;
					case USB_INT_EORSTI:
						UDINT  &= ~(1 << EORSTI);
    1dd0:	80 93 e1 00 	sts	0x00E1, r24
    1dd4:	82 e0       	ldi	r24, 0x02	; 2
    1dd6:	80 93 46 14 	sts	0x1446, r24
	{
		USB_INT_Clear(USB_INT_EORSTI);

		USB_DeviceState                = DEVICE_STATE_Default;
    1dda:	10 92 42 14 	sts	0x1442, r1
    1dde:	80 91 e1 00 	lds	r24, 0x00E1
		USB_Device_ConfigurationNumber = 0;
    1de2:	8e 7f       	andi	r24, 0xFE	; 254
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
    1de4:	80 93 e1 00 	sts	0x00E1, r24
    1de8:	80 91 e2 00 	lds	r24, 0x00E2
    1dec:	8e 7f       	andi	r24, 0xFE	; 254
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  &= ~(1 << SUSPE);
    1dee:	80 93 e2 00 	sts	0x00E2, r24
    1df2:	80 91 e2 00 	lds	r24, 0x00E2
    1df6:	80 61       	ori	r24, 0x10	; 16
						USBCON |= (1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
    1df8:	80 93 e2 00 	sts	0x00E2, r24
    1dfc:	42 e0       	ldi	r20, 0x02	; 2
    1dfe:	60 e0       	ldi	r22, 0x00	; 0
    1e00:	80 e0       	ldi	r24, 0x00	; 0
				uint8_t Number = (Address & ENDPOINT_EPNUM_MASK);

				if (Number >= ENDPOINT_TOTAL_ENDPOINTS)
				  return false;

				return Endpoint_ConfigureEndpoint_Prv(Number,
    1e02:	25 de       	rcall	.-950    	; 0x1a4e <Endpoint_ConfigureEndpoint_Prv>
    1e04:	67 d1       	rcall	.+718    	; 0x20d4 <USB_Event_Stub>
    1e06:	ff 91       	pop	r31
    1e08:	ef 91       	pop	r30
    1e0a:	bf 91       	pop	r27

		#if defined(INTERRUPT_CONTROL_ENDPOINT)
		USB_INT_Enable(USB_INT_RXSTPI);
		#endif

		EVENT_USB_Device_Reset();
    1e0c:	af 91       	pop	r26
    1e0e:	9f 91       	pop	r25
		USB_ResetInterface();

		EVENT_USB_UIDChange();
	}
	#endif
}
    1e10:	8f 91       	pop	r24
    1e12:	7f 91       	pop	r23
    1e14:	6f 91       	pop	r22
    1e16:	5f 91       	pop	r21
    1e18:	4f 91       	pop	r20
    1e1a:	3f 91       	pop	r19
    1e1c:	2f 91       	pop	r18
    1e1e:	0f 90       	pop	r0
    1e20:	0b be       	out	0x3b, r0	; 59
    1e22:	0f 90       	pop	r0
    1e24:	0f be       	out	0x3f, r0	; 63
    1e26:	0f 90       	pop	r0
    1e28:	1f 90       	pop	r1
    1e2a:	18 95       	reti

00001e2c <USB_Device_ProcessControlRequest>:
    1e2c:	1f 93       	push	r17
    1e2e:	cf 93       	push	r28
    1e30:	df 93       	push	r29
    1e32:	cd b7       	in	r28, 0x3d	; 61
    1e34:	de b7       	in	r29, 0x3e	; 62
#if !defined(NO_DEVICE_REMOTE_WAKEUP)
bool    USB_Device_RemoteWakeupEnabled;
#endif

void USB_Device_ProcessControlRequest(void)
{
    1e36:	aa 97       	sbiw	r28, 0x2a	; 42
    1e38:	0f b6       	in	r0, 0x3f	; 63
    1e3a:	f8 94       	cli
    1e3c:	de bf       	out	0x3e, r29	; 62
    1e3e:	0f be       	out	0x3f, r0	; 63
    1e40:	cd bf       	out	0x3d, r28	; 61
    1e42:	e7 e4       	ldi	r30, 0x47	; 71
    1e44:	f4 e1       	ldi	r31, 0x14	; 20
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    1e46:	80 91 f1 00 	lds	r24, 0x00F1
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
	  *(RequestHeader++) = Endpoint_Read_8();
    1e4a:	81 93       	st	Z+, r24
	USB_ControlRequest.wIndex        = Endpoint_Read_16_LE();
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
    1e4c:	24 e1       	ldi	r18, 0x14	; 20
    1e4e:	ef 34       	cpi	r30, 0x4F	; 79
    1e50:	f2 07       	cpc	r31, r18
    1e52:	c9 f7       	brne	.-14     	; 0x1e46 <USB_Device_ProcessControlRequest+0x1a>
	  *(RequestHeader++) = Endpoint_Read_8();
	#endif

	EVENT_USB_Device_ControlRequest();
    1e54:	0e 94 ae 02 	call	0x55c	; 0x55c <EVENT_USB_Device_ControlRequest>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    1e58:	80 91 e8 00 	lds	r24, 0x00E8

	if (Endpoint_IsSETUPReceived())
    1e5c:	83 ff       	sbrs	r24, 3
    1e5e:	22 c1       	rjmp	.+580    	; 0x20a4 <USB_Device_ProcessControlRequest+0x278>
	{
		uint8_t bmRequestType = USB_ControlRequest.bmRequestType;
    1e60:	90 91 47 14 	lds	r25, 0x1447

		switch (USB_ControlRequest.bRequest)
    1e64:	80 91 48 14 	lds	r24, 0x1448
    1e68:	85 30       	cpi	r24, 0x05	; 5
    1e6a:	09 f4       	brne	.+2      	; 0x1e6e <USB_Device_ProcessControlRequest+0x42>
    1e6c:	77 c0       	rjmp	.+238    	; 0x1f5c <USB_Device_ProcessControlRequest+0x130>
    1e6e:	30 f4       	brcc	.+12     	; 0x1e7c <USB_Device_ProcessControlRequest+0x50>
    1e70:	81 30       	cpi	r24, 0x01	; 1
    1e72:	81 f1       	breq	.+96     	; 0x1ed4 <USB_Device_ProcessControlRequest+0xa8>
    1e74:	68 f0       	brcs	.+26     	; 0x1e90 <USB_Device_ProcessControlRequest+0x64>
    1e76:	83 30       	cpi	r24, 0x03	; 3
    1e78:	69 f1       	breq	.+90     	; 0x1ed4 <USB_Device_ProcessControlRequest+0xa8>
    1e7a:	14 c1       	rjmp	.+552    	; 0x20a4 <USB_Device_ProcessControlRequest+0x278>
    1e7c:	88 30       	cpi	r24, 0x08	; 8
    1e7e:	09 f4       	brne	.+2      	; 0x1e82 <USB_Device_ProcessControlRequest+0x56>
    1e80:	e2 c0       	rjmp	.+452    	; 0x2046 <USB_Device_ProcessControlRequest+0x21a>
    1e82:	89 30       	cpi	r24, 0x09	; 9
    1e84:	09 f4       	brne	.+2      	; 0x1e88 <USB_Device_ProcessControlRequest+0x5c>
    1e86:	f1 c0       	rjmp	.+482    	; 0x206a <USB_Device_ProcessControlRequest+0x23e>
    1e88:	86 30       	cpi	r24, 0x06	; 6
    1e8a:	09 f0       	breq	.+2      	; 0x1e8e <USB_Device_ProcessControlRequest+0x62>
    1e8c:	0b c1       	rjmp	.+534    	; 0x20a4 <USB_Device_ProcessControlRequest+0x278>
    1e8e:	88 c0       	rjmp	.+272    	; 0x1fa0 <USB_Device_ProcessControlRequest+0x174>
		{
			case REQ_GetStatus:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    1e90:	90 38       	cpi	r25, 0x80	; 128
    1e92:	81 f0       	breq	.+32     	; 0x1eb4 <USB_Device_ProcessControlRequest+0x88>
    1e94:	92 38       	cpi	r25, 0x82	; 130
    1e96:	09 f0       	breq	.+2      	; 0x1e9a <USB_Device_ProcessControlRequest+0x6e>
    1e98:	05 c1       	rjmp	.+522    	; 0x20a4 <USB_Device_ProcessControlRequest+0x278>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    1e9a:	80 91 4b 14 	lds	r24, 0x144B
    1e9e:	8f 70       	andi	r24, 0x0F	; 15
    1ea0:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    1ea4:	80 91 eb 00 	lds	r24, 0x00EB
    1ea8:	85 fb       	bst	r24, 5
    1eaa:	88 27       	eor	r24, r24
    1eac:	80 f9       	bld	r24, 0
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    1eae:	10 92 e9 00 	sts	0x00E9, r1
    1eb2:	06 c0       	rjmp	.+12     	; 0x1ec0 <USB_Device_ProcessControlRequest+0x94>
	Endpoint_ClearOUT();
}

static void USB_Device_GetStatus(void)
{
	uint8_t CurrentStatus = 0;
    1eb4:	80 91 43 14 	lds	r24, 0x1443
			if (USB_Device_CurrentlySelfPowered)
			  CurrentStatus |= FEATURE_SELFPOWERED_ENABLED;
			#endif

			#if !defined(NO_DEVICE_REMOTE_WAKEUP)
			if (USB_Device_RemoteWakeupEnabled)
    1eb8:	90 91 44 14 	lds	r25, 0x1444
    1ebc:	91 11       	cpse	r25, r1
			  CurrentStatus |= FEATURE_REMOTE_WAKEUP_ENABLED;
    1ebe:	82 60       	ori	r24, 0x02	; 2
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    1ec0:	90 91 e8 00 	lds	r25, 0x00E8
    1ec4:	97 7f       	andi	r25, 0xF7	; 247
    1ec6:	90 93 e8 00 	sts	0x00E8, r25
			 *  \param[in] Data  Data to write to the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_16_LE(const uint16_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_16_LE(const uint16_t Data)
			{
				UEDATX = (Data & 0xFF);
    1eca:	80 93 f1 00 	sts	0x00F1, r24
				UEDATX = (Data >> 8);
    1ece:	10 92 f1 00 	sts	0x00F1, r1
    1ed2:	c4 c0       	rjmp	.+392    	; 0x205c <USB_Device_ProcessControlRequest+0x230>
				}

				break;
			case REQ_ClearFeature:
			case REQ_SetFeature:
				if ((bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    1ed4:	29 2f       	mov	r18, r25
    1ed6:	2d 7f       	andi	r18, 0xFD	; 253
    1ed8:	09 f0       	breq	.+2      	; 0x1edc <USB_Device_ProcessControlRequest+0xb0>
    1eda:	e4 c0       	rjmp	.+456    	; 0x20a4 <USB_Device_ProcessControlRequest+0x278>
	Endpoint_ClearStatusStage();
}

static void USB_Device_ClearSetFeature(void)
{
	switch (USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_RECIPIENT)
    1edc:	99 23       	and	r25, r25
    1ede:	19 f0       	breq	.+6      	; 0x1ee6 <USB_Device_ProcessControlRequest+0xba>
    1ee0:	92 30       	cpi	r25, 0x02	; 2
    1ee2:	61 f0       	breq	.+24     	; 0x1efc <USB_Device_ProcessControlRequest+0xd0>
    1ee4:	df c0       	rjmp	.+446    	; 0x20a4 <USB_Device_ProcessControlRequest+0x278>
	{
		#if !defined(NO_DEVICE_REMOTE_WAKEUP)
		case REQREC_DEVICE:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_DeviceRemoteWakeup)
    1ee6:	90 91 49 14 	lds	r25, 0x1449
    1eea:	91 30       	cpi	r25, 0x01	; 1
    1eec:	09 f0       	breq	.+2      	; 0x1ef0 <USB_Device_ProcessControlRequest+0xc4>
    1eee:	da c0       	rjmp	.+436    	; 0x20a4 <USB_Device_ProcessControlRequest+0x278>
			  USB_Device_RemoteWakeupEnabled = (USB_ControlRequest.bRequest == REQ_SetFeature);
    1ef0:	83 30       	cpi	r24, 0x03	; 3
    1ef2:	09 f0       	breq	.+2      	; 0x1ef6 <USB_Device_ProcessControlRequest+0xca>
    1ef4:	90 e0       	ldi	r25, 0x00	; 0
    1ef6:	90 93 44 14 	sts	0x1444, r25
    1efa:	2a c0       	rjmp	.+84     	; 0x1f50 <USB_Device_ProcessControlRequest+0x124>

			break;
		#endif
		#if !defined(CONTROL_ONLY_DEVICE)
		case REQREC_ENDPOINT:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_EndpointHalt)
    1efc:	90 91 49 14 	lds	r25, 0x1449
    1f00:	91 11       	cpse	r25, r1
    1f02:	26 c0       	rjmp	.+76     	; 0x1f50 <USB_Device_ProcessControlRequest+0x124>
			{
				uint8_t EndpointIndex = ((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
    1f04:	20 91 4b 14 	lds	r18, 0x144B
    1f08:	2f 70       	andi	r18, 0x0F	; 15

				if (EndpointIndex == ENDPOINT_CONTROLEP)
    1f0a:	09 f4       	brne	.+2      	; 0x1f0e <USB_Device_ProcessControlRequest+0xe2>
    1f0c:	cb c0       	rjmp	.+406    	; 0x20a4 <USB_Device_ProcessControlRequest+0x278>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    1f0e:	20 93 e9 00 	sts	0x00E9, r18
			 * \return Boolean \c true if the currently selected endpoint is enabled, \c false otherwise.
			 */
			static inline bool Endpoint_IsEnabled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsEnabled(void)
			{
				return ((UECONX & (1 << EPEN)) ? true : false);
    1f12:	90 91 eb 00 	lds	r25, 0x00EB
				  return;

				Endpoint_SelectEndpoint(EndpointIndex);

				if (Endpoint_IsEnabled())
    1f16:	90 ff       	sbrs	r25, 0
    1f18:	1b c0       	rjmp	.+54     	; 0x1f50 <USB_Device_ProcessControlRequest+0x124>
				{
					if (USB_ControlRequest.bRequest == REQ_SetFeature)
    1f1a:	83 30       	cpi	r24, 0x03	; 3
    1f1c:	21 f4       	brne	.+8      	; 0x1f26 <USB_Device_ProcessControlRequest+0xfa>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    1f1e:	80 91 eb 00 	lds	r24, 0x00EB
    1f22:	80 62       	ori	r24, 0x20	; 32
    1f24:	13 c0       	rjmp	.+38     	; 0x1f4c <USB_Device_ProcessControlRequest+0x120>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearStall(void)
			{
				UECONX |= (1 << STALLRQC);
    1f26:	80 91 eb 00 	lds	r24, 0x00EB
    1f2a:	80 61       	ori	r24, 0x10	; 16
    1f2c:	80 93 eb 00 	sts	0x00EB, r24
			 *  \param[in] Address  Endpoint address whose FIFO buffers are to be reset.
			 */
			static inline void Endpoint_ResetEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetEndpoint(const uint8_t Address)
			{
				UERST = (1 << (Address & ENDPOINT_EPNUM_MASK));
    1f30:	81 e0       	ldi	r24, 0x01	; 1
    1f32:	90 e0       	ldi	r25, 0x00	; 0
    1f34:	02 2e       	mov	r0, r18
    1f36:	01 c0       	rjmp	.+2      	; 0x1f3a <USB_Device_ProcessControlRequest+0x10e>
    1f38:	88 0f       	add	r24, r24
    1f3a:	0a 94       	dec	r0
    1f3c:	ea f7       	brpl	.-6      	; 0x1f38 <USB_Device_ProcessControlRequest+0x10c>
    1f3e:	80 93 ea 00 	sts	0x00EA, r24
				UERST = 0;
    1f42:	10 92 ea 00 	sts	0x00EA, r1

			/** Resets the data toggle of the currently selected endpoint. */
			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetDataToggle(void)
			{
				UECONX |= (1 << RSTDT);
    1f46:	80 91 eb 00 	lds	r24, 0x00EB
    1f4a:	88 60       	ori	r24, 0x08	; 8
    1f4c:	80 93 eb 00 	sts	0x00EB, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    1f50:	10 92 e9 00 	sts	0x00E9, r1
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    1f54:	80 91 e8 00 	lds	r24, 0x00E8
    1f58:	87 7f       	andi	r24, 0xF7	; 247
    1f5a:	83 c0       	rjmp	.+262    	; 0x2062 <USB_Device_ProcessControlRequest+0x236>
					USB_Device_ClearSetFeature();
				}

				break;
			case REQ_SetAddress:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    1f5c:	91 11       	cpse	r25, r1
    1f5e:	a2 c0       	rjmp	.+324    	; 0x20a4 <USB_Device_ProcessControlRequest+0x278>
	}
}

static void USB_Device_SetAddress(void)
{
	uint8_t DeviceAddress = (USB_ControlRequest.wValue & 0x7F);
    1f60:	10 91 49 14 	lds	r17, 0x1449
    1f64:	1f 77       	andi	r17, 0x7F	; 127
			#endif

			static inline void USB_Device_SetDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetDeviceAddress(const uint8_t Address)
			{
				UDADDR = (UDADDR & (1 << ADDEN)) | (Address & 0x7F);
    1f66:	80 91 e3 00 	lds	r24, 0x00E3
    1f6a:	80 78       	andi	r24, 0x80	; 128
    1f6c:	81 2b       	or	r24, r17
    1f6e:	80 93 e3 00 	sts	0x00E3, r24
    1f72:	80 91 e8 00 	lds	r24, 0x00E8
    1f76:	87 7f       	andi	r24, 0xF7	; 247
    1f78:	80 93 e8 00 	sts	0x00E8, r24

	USB_Device_SetDeviceAddress(DeviceAddress);

	Endpoint_ClearSETUP();

	Endpoint_ClearStatusStage();
    1f7c:	da dd       	rcall	.-1100   	; 0x1b32 <Endpoint_ClearStatusStage>
    1f7e:	80 91 e8 00 	lds	r24, 0x00E8
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    1f82:	80 ff       	sbrs	r24, 0

	while (!(Endpoint_IsINReady()));
    1f84:	fc cf       	rjmp	.-8      	; 0x1f7e <USB_Device_ProcessControlRequest+0x152>
    1f86:	80 91 e3 00 	lds	r24, 0x00E3
			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address)
			{
				(void)Address;

				UDADDR |= (1 << ADDEN);
    1f8a:	80 68       	ori	r24, 0x80	; 128
    1f8c:	80 93 e3 00 	sts	0x00E3, r24
    1f90:	11 23       	and	r17, r17

	USB_Device_EnableDeviceAddress(DeviceAddress);

	USB_DeviceState = (DeviceAddress) ? DEVICE_STATE_Addressed : DEVICE_STATE_Default;
    1f92:	11 f0       	breq	.+4      	; 0x1f98 <USB_Device_ProcessControlRequest+0x16c>
    1f94:	83 e0       	ldi	r24, 0x03	; 3
    1f96:	01 c0       	rjmp	.+2      	; 0x1f9a <USB_Device_ProcessControlRequest+0x16e>
    1f98:	82 e0       	ldi	r24, 0x02	; 2
    1f9a:	80 93 46 14 	sts	0x1446, r24
    1f9e:	82 c0       	rjmp	.+260    	; 0x20a4 <USB_Device_ProcessControlRequest+0x278>
    1fa0:	90 58       	subi	r25, 0x80	; 128
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_SetAddress();

				break;
			case REQ_GetDescriptor:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    1fa2:	92 30       	cpi	r25, 0x02	; 2
    1fa4:	08 f0       	brcs	.+2      	; 0x1fa8 <USB_Device_ProcessControlRequest+0x17c>
    1fa6:	7e c0       	rjmp	.+252    	; 0x20a4 <USB_Device_ProcessControlRequest+0x278>
    1fa8:	80 91 49 14 	lds	r24, 0x1449
	    !(defined(USE_FLASH_DESCRIPTORS) || defined(USE_EEPROM_DESCRIPTORS) || defined(USE_RAM_DESCRIPTORS))
	uint8_t DescriptorAddressSpace;
	#endif

	#if !defined(NO_INTERNAL_SERIAL) && (USE_INTERNAL_SERIAL != NO_DESCRIPTOR)
	if (USB_ControlRequest.wValue == ((DTYPE_String << 8) | USE_INTERNAL_SERIAL))
    1fac:	90 91 4a 14 	lds	r25, 0x144A
    1fb0:	8c 3d       	cpi	r24, 0xDC	; 220
    1fb2:	23 e0       	ldi	r18, 0x03	; 3
    1fb4:	92 07       	cpc	r25, r18
    1fb6:	71 f5       	brne	.+92     	; 0x2014 <USB_Device_ProcessControlRequest+0x1e8>
    1fb8:	83 e0       	ldi	r24, 0x03	; 3
	{
		USB_Descriptor_Header_t Header;
		uint16_t                UnicodeString[INTERNAL_SERIAL_LENGTH_BITS / 4];
	} SignatureDescriptor;

	SignatureDescriptor.Header.Type = DTYPE_String;
    1fba:	8a 83       	std	Y+2, r24	; 0x02
    1fbc:	8a e2       	ldi	r24, 0x2A	; 42
	SignatureDescriptor.Header.Size = USB_STRING_LEN(INTERNAL_SERIAL_LENGTH_BITS / 4);
    1fbe:	89 83       	std	Y+1, r24	; 0x01
    1fc0:	4f b7       	in	r20, 0x3f	; 63
			static inline uint_reg_t GetGlobalInterruptMask(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				return SREG;
    1fc2:	f8 94       	cli
			static inline void GlobalInterruptDisable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				cli();
    1fc4:	de 01       	movw	r26, r28
				__builtin_ssrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				cli();
				#endif

				GCC_MEMORY_BARRIER();
    1fc6:	13 96       	adiw	r26, 0x03	; 3
    1fc8:	20 e0       	ldi	r18, 0x00	; 0
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
    1fca:	3e e0       	ldi	r19, 0x0E	; 14
			static inline void USB_Device_GetSerialString(uint16_t* const UnicodeString)
			{
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;
    1fcc:	51 e2       	ldi	r21, 0x21	; 33

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
				{
					uint8_t SerialByte = boot_signature_byte_get(SigReadAddress);
    1fce:	e3 2f       	mov	r30, r19
    1fd0:	f0 e0       	ldi	r31, 0x00	; 0
    1fd2:	50 93 57 00 	sts	0x0057, r21
    1fd6:	e4 91       	lpm	r30, Z
    1fd8:	20 ff       	sbrs	r18, 0

					if (SerialCharNum & 0x01)
    1fda:	03 c0       	rjmp	.+6      	; 0x1fe2 <USB_Device_ProcessControlRequest+0x1b6>
    1fdc:	e2 95       	swap	r30
					{
						SerialByte >>= 4;
    1fde:	ef 70       	andi	r30, 0x0F	; 15
    1fe0:	3f 5f       	subi	r19, 0xFF	; 255
						SigReadAddress++;
    1fe2:	ef 70       	andi	r30, 0x0F	; 15
					}

					SerialByte &= 0x0F;
    1fe4:	8e 2f       	mov	r24, r30
    1fe6:	90 e0       	ldi	r25, 0x00	; 0
    1fe8:	ea 30       	cpi	r30, 0x0A	; 10

					UnicodeString[SerialCharNum] = cpu_to_le16((SerialByte >= 10) ?
    1fea:	10 f0       	brcs	.+4      	; 0x1ff0 <USB_Device_ProcessControlRequest+0x1c4>
    1fec:	c7 96       	adiw	r24, 0x37	; 55
    1fee:	01 c0       	rjmp	.+2      	; 0x1ff2 <USB_Device_ProcessControlRequest+0x1c6>
    1ff0:	c0 96       	adiw	r24, 0x30	; 48
    1ff2:	8d 93       	st	X+, r24
    1ff4:	9d 93       	st	X+, r25
    1ff6:	2f 5f       	subi	r18, 0xFF	; 255
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
    1ff8:	24 31       	cpi	r18, 0x14	; 20
    1ffa:	49 f7       	brne	.-46     	; 0x1fce <USB_Device_ProcessControlRequest+0x1a2>
    1ffc:	4f bf       	out	0x3f, r20	; 63
			static inline void SetGlobalInterruptMask(const uint_reg_t GlobalIntState)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				SREG = GlobalIntState;
    1ffe:	80 91 e8 00 	lds	r24, 0x00E8
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2002:	87 7f       	andi	r24, 0xF7	; 247
    2004:	80 93 e8 00 	sts	0x00E8, r24
    2008:	6a e2       	ldi	r22, 0x2A	; 42

	USB_Device_GetSerialString(SignatureDescriptor.UnicodeString);

	Endpoint_ClearSETUP();

	Endpoint_Write_Control_Stream_LE(&SignatureDescriptor, sizeof(SignatureDescriptor));
    200a:	70 e0       	ldi	r23, 0x00	; 0
    200c:	ce 01       	movw	r24, r28
    200e:	01 96       	adiw	r24, 0x01	; 1
    2010:	23 dc       	rcall	.-1978   	; 0x1858 <Endpoint_Write_Control_Stream_LE>
    2012:	13 c0       	rjmp	.+38     	; 0x203a <USB_Device_ProcessControlRequest+0x20e>
    2014:	ae 01       	movw	r20, r28
    2016:	4f 5f       	subi	r20, 0xFF	; 255
		USB_Device_GetInternalSerialDescriptor();
		return;
	}
	#endif

	if ((DescriptorSize = CALLBACK_USB_GetDescriptor(USB_ControlRequest.wValue, USB_ControlRequest.wIndex,
    2018:	5f 4f       	sbci	r21, 0xFF	; 255
    201a:	60 91 4b 14 	lds	r22, 0x144B
    201e:	0e 94 b2 02 	call	0x564	; 0x564 <CALLBACK_USB_GetDescriptor>
    2022:	00 97       	sbiw	r24, 0x00	; 0
    2024:	09 f4       	brne	.+2      	; 0x2028 <USB_Device_ProcessControlRequest+0x1fc>
    2026:	3e c0       	rjmp	.+124    	; 0x20a4 <USB_Device_ProcessControlRequest+0x278>
    2028:	20 91 e8 00 	lds	r18, 0x00E8
    202c:	27 7f       	andi	r18, 0xF7	; 247
    202e:	20 93 e8 00 	sts	0x00E8, r18
    2032:	bc 01       	movw	r22, r24
    2034:	89 81       	ldd	r24, Y+1	; 0x01
	#if defined(USE_RAM_DESCRIPTORS) || !defined(ARCH_HAS_MULTI_ADDRESS_SPACE)
	Endpoint_Write_Control_Stream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_EEPROM_DESCRIPTORS)
	Endpoint_Write_Control_EStream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_FLASH_DESCRIPTORS)
	Endpoint_Write_Control_PStream_LE(DescriptorPointer, DescriptorSize);
    2036:	9a 81       	ldd	r25, Y+2	; 0x02
    2038:	aa dc       	rcall	.-1708   	; 0x198e <Endpoint_Write_Control_PStream_LE>
    203a:	80 91 e8 00 	lds	r24, 0x00E8
    203e:	8b 77       	andi	r24, 0x7B	; 123
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    2040:	80 93 e8 00 	sts	0x00E8, r24
    2044:	2f c0       	rjmp	.+94     	; 0x20a4 <USB_Device_ProcessControlRequest+0x278>
    2046:	90 38       	cpi	r25, 0x80	; 128
    2048:	69 f5       	brne	.+90     	; 0x20a4 <USB_Device_ProcessControlRequest+0x278>
    204a:	80 91 e8 00 	lds	r24, 0x00E8
					USB_Device_GetDescriptor();
				}

				break;
			case REQ_GetConfiguration:
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
    204e:	87 7f       	andi	r24, 0xF7	; 247
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2050:	80 93 e8 00 	sts	0x00E8, r24
    2054:	80 91 42 14 	lds	r24, 0x1442
    2058:	80 93 f1 00 	sts	0x00F1, r24

static void USB_Device_GetConfiguration(void)
{
	Endpoint_ClearSETUP();

	Endpoint_Write_8(USB_Device_ConfigurationNumber);
    205c:	80 91 e8 00 	lds	r24, 0x00E8
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    2060:	8e 77       	andi	r24, 0x7E	; 126
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    2062:	80 93 e8 00 	sts	0x00E8, r24
    2066:	65 dd       	rcall	.-1334   	; 0x1b32 <Endpoint_ClearStatusStage>
    2068:	1d c0       	rjmp	.+58     	; 0x20a4 <USB_Device_ProcessControlRequest+0x278>
    206a:	91 11       	cpse	r25, r1
	Endpoint_ClearIN();

	Endpoint_ClearStatusStage();
    206c:	1b c0       	rjmp	.+54     	; 0x20a4 <USB_Device_ProcessControlRequest+0x278>
    206e:	90 91 49 14 	lds	r25, 0x1449
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_GetConfiguration();

				break;
			case REQ_SetConfiguration:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    2072:	92 30       	cpi	r25, 0x02	; 2
    2074:	b8 f4       	brcc	.+46     	; 0x20a4 <USB_Device_ProcessControlRequest+0x278>
}

static void USB_Device_SetConfiguration(void)
{
	#if defined(FIXED_NUM_CONFIGURATIONS)
	if ((uint8_t)USB_ControlRequest.wValue > FIXED_NUM_CONFIGURATIONS)
    2076:	80 91 e8 00 	lds	r24, 0x00E8
    207a:	87 7f       	andi	r24, 0xF7	; 247
    207c:	80 93 e8 00 	sts	0x00E8, r24
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2080:	90 93 42 14 	sts	0x1442, r25
    2084:	56 dd       	rcall	.-1364   	; 0x1b32 <Endpoint_ClearStatusStage>
    2086:	80 91 42 14 	lds	r24, 0x1442
	#endif
	#endif

	Endpoint_ClearSETUP();

	USB_Device_ConfigurationNumber = (uint8_t)USB_ControlRequest.wValue;
    208a:	81 11       	cpse	r24, r1

	Endpoint_ClearStatusStage();
    208c:	04 c0       	rjmp	.+8      	; 0x2096 <USB_Device_ProcessControlRequest+0x26a>
    208e:	80 91 e3 00 	lds	r24, 0x00E3

	if (USB_Device_ConfigurationNumber)
    2092:	87 ff       	sbrs	r24, 7
    2094:	02 c0       	rjmp	.+4      	; 0x209a <USB_Device_ProcessControlRequest+0x26e>
    2096:	84 e0       	ldi	r24, 0x04	; 4
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
    2098:	01 c0       	rjmp	.+2      	; 0x209c <USB_Device_ProcessControlRequest+0x270>
    209a:	81 e0       	ldi	r24, 0x01	; 1
	  USB_DeviceState = DEVICE_STATE_Configured;
	else
	  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
    209c:	80 93 46 14 	sts	0x1446, r24
    20a0:	0e 94 a4 02 	call	0x548	; 0x548 <EVENT_USB_Device_ConfigurationChanged>
    20a4:	80 91 e8 00 	lds	r24, 0x00E8
    20a8:	83 ff       	sbrs	r24, 3

	EVENT_USB_Device_ConfigurationChanged();
    20aa:	0a c0       	rjmp	.+20     	; 0x20c0 <USB_Device_ProcessControlRequest+0x294>
    20ac:	80 91 e8 00 	lds	r24, 0x00E8
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    20b0:	87 7f       	andi	r24, 0xF7	; 247
			default:
				break;
		}
	}

	if (Endpoint_IsSETUPReceived())
    20b2:	80 93 e8 00 	sts	0x00E8, r24
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    20b6:	80 91 eb 00 	lds	r24, 0x00EB
    20ba:	80 62       	ori	r24, 0x20	; 32
    20bc:	80 93 eb 00 	sts	0x00EB, r24
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    20c0:	aa 96       	adiw	r28, 0x2a	; 42
    20c2:	0f b6       	in	r0, 0x3f	; 63
    20c4:	f8 94       	cli
    20c6:	de bf       	out	0x3e, r29	; 62
    20c8:	0f be       	out	0x3f, r0	; 63
	{
		Endpoint_ClearSETUP();
		Endpoint_StallTransaction();
	}
}
    20ca:	cd bf       	out	0x3d, r28	; 61
    20cc:	df 91       	pop	r29
    20ce:	cf 91       	pop	r28
    20d0:	1f 91       	pop	r17
    20d2:	08 95       	ret

000020d4 <USB_Event_Stub>:
    20d4:	08 95       	ret

000020d6 <USB_USBTask>:
    20d6:	cf 93       	push	r28
    20d8:	80 91 46 14 	lds	r24, 0x1446
    20dc:	88 23       	and	r24, r24
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_DeviceTask(void)
{
	if (USB_DeviceState == DEVICE_STATE_Unattached)
    20de:	a9 f0       	breq	.+42     	; 0x210a <__stack+0xb>
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return ((UENUM & ENDPOINT_EPNUM_MASK) | Endpoint_GetEndpointDirection());
    20e0:	80 91 e9 00 	lds	r24, 0x00E9
    20e4:	8f 70       	andi	r24, 0x0F	; 15
			 *  \return The currently selected endpoint's direction, as a \c ENDPOINT_DIR_* mask.
			 */
			static inline uint8_t Endpoint_GetEndpointDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetEndpointDirection(void)
			{
				return (UECFG0X & (1 << EPDIR)) ? ENDPOINT_DIR_IN : ENDPOINT_DIR_OUT;
    20e6:	90 91 ec 00 	lds	r25, 0x00EC
    20ea:	90 ff       	sbrs	r25, 0
    20ec:	02 c0       	rjmp	.+4      	; 0x20f2 <USB_USBTask+0x1c>
    20ee:	90 e8       	ldi	r25, 0x80	; 128
    20f0:	01 c0       	rjmp	.+2      	; 0x20f4 <USB_USBTask+0x1e>
    20f2:	90 e0       	ldi	r25, 0x00	; 0
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return ((UENUM & ENDPOINT_EPNUM_MASK) | Endpoint_GetEndpointDirection());
    20f4:	c9 2f       	mov	r28, r25
    20f6:	c8 2b       	or	r28, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    20f8:	10 92 e9 00 	sts	0x00E9, r1
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    20fc:	80 91 e8 00 	lds	r24, 0x00E8

	uint8_t PrevEndpoint = Endpoint_GetCurrentEndpoint();

	Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);

	if (Endpoint_IsSETUPReceived())
    2100:	83 fd       	sbrc	r24, 3
	  USB_Device_ProcessControlRequest();
    2102:	94 de       	rcall	.-728    	; 0x1e2c <USB_Device_ProcessControlRequest>
    2104:	cf 70       	andi	r28, 0x0F	; 15
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    2106:	c0 93 e9 00 	sts	0x00E9, r28
    210a:	cf 91       	pop	r28
	#elif defined(USB_CAN_BE_HOST)
		USB_HostTask();
	#elif defined(USB_CAN_BE_DEVICE)
		USB_DeviceTask();
	#endif
}
    210c:	08 95       	ret

0000210e <RNDIS_Device_ProcessControlRequest>:
    210e:	cf 92       	push	r12
		CPU_TO_LE32(OID_802_3_XMIT_ONE_COLLISION),
		CPU_TO_LE32(OID_802_3_XMIT_MORE_COLLISIONS),
	};

void RNDIS_Device_ProcessControlRequest(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
    2110:	df 92       	push	r13
    2112:	ef 92       	push	r14
    2114:	ff 92       	push	r15
    2116:	0f 93       	push	r16
    2118:	1f 93       	push	r17
    211a:	cf 93       	push	r28
    211c:	df 93       	push	r29
    211e:	8c 01       	movw	r16, r24
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    2120:	80 91 e8 00 	lds	r24, 0x00E8
	if (!(Endpoint_IsSETUPReceived()))
    2124:	83 ff       	sbrs	r24, 3
    2126:	60 c2       	rjmp	.+1216   	; 0x25e8 <RNDIS_Device_ProcessControlRequest+0x4da>
	  return;

	if (USB_ControlRequest.wIndex != RNDISInterfaceInfo->Config.ControlInterfaceNumber)
    2128:	f8 01       	movw	r30, r16
    212a:	80 81       	ld	r24, Z
    212c:	90 e0       	ldi	r25, 0x00	; 0
    212e:	20 91 4b 14 	lds	r18, 0x144B
    2132:	30 91 4c 14 	lds	r19, 0x144C
    2136:	28 17       	cp	r18, r24
    2138:	39 07       	cpc	r19, r25
    213a:	09 f0       	breq	.+2      	; 0x213e <RNDIS_Device_ProcessControlRequest+0x30>
    213c:	55 c2       	rjmp	.+1194   	; 0x25e8 <RNDIS_Device_ProcessControlRequest+0x4da>
	  return;

	switch (USB_ControlRequest.bRequest)
    213e:	80 91 48 14 	lds	r24, 0x1448
    2142:	88 23       	and	r24, r24
    2144:	21 f0       	breq	.+8      	; 0x214e <RNDIS_Device_ProcessControlRequest+0x40>
    2146:	81 30       	cpi	r24, 0x01	; 1
    2148:	09 f4       	brne	.+2      	; 0x214c <RNDIS_Device_ProcessControlRequest+0x3e>
    214a:	ec c1       	rjmp	.+984    	; 0x2524 <RNDIS_Device_ProcessControlRequest+0x416>
    214c:	4d c2       	rjmp	.+1178   	; 0x25e8 <RNDIS_Device_ProcessControlRequest+0x4da>
	{
		case RNDIS_REQ_SendEncapsulatedCommand:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
    214e:	80 91 47 14 	lds	r24, 0x1447
    2152:	81 32       	cpi	r24, 0x21	; 33
    2154:	09 f0       	breq	.+2      	; 0x2158 <RNDIS_Device_ProcessControlRequest+0x4a>
    2156:	48 c2       	rjmp	.+1168   	; 0x25e8 <RNDIS_Device_ProcessControlRequest+0x4da>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2158:	80 91 e8 00 	lds	r24, 0x00E8
    215c:	87 7f       	andi	r24, 0xF7	; 247
    215e:	80 93 e8 00 	sts	0x00E8, r24
			{
				Endpoint_ClearSETUP();
				Endpoint_Read_Control_Stream_LE(RNDISInterfaceInfo->Config.MessageBuffer, USB_ControlRequest.wLength);
    2162:	60 91 4d 14 	lds	r22, 0x144D
    2166:	70 91 4e 14 	lds	r23, 0x144E
    216a:	f8 01       	movw	r30, r16
    216c:	80 8d       	ldd	r24, Z+24	; 0x18
    216e:	91 8d       	ldd	r25, Z+25	; 0x19
    2170:	d0 db       	rcall	.-2144   	; 0x1912 <Endpoint_Read_Control_Stream_LE>
    2172:	80 91 e8 00 	lds	r24, 0x00E8
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    2176:	8e 77       	andi	r24, 0x7E	; 126
    2178:	80 93 e8 00 	sts	0x00E8, r24
    217c:	f8 01       	movw	r30, r16
void RNDIS_Device_ProcessRNDISControlMessage(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
	/* Note: Only a single buffer is used for both the received message and its response to save SRAM. Because of
	         this, response bytes should be filled in order so that they do not clobber unread data in the buffer. */

	RNDIS_Message_Header_t* MessageHeader = (RNDIS_Message_Header_t*)RNDISInterfaceInfo->Config.MessageBuffer;
    217e:	c0 8d       	ldd	r28, Z+24	; 0x18
    2180:	d1 8d       	ldd	r29, Z+25	; 0x19
    2182:	48 81       	ld	r20, Y

	switch (le32_to_cpu(MessageHeader->MessageType))
    2184:	59 81       	ldd	r21, Y+1	; 0x01
    2186:	6a 81       	ldd	r22, Y+2	; 0x02
    2188:	7b 81       	ldd	r23, Y+3	; 0x03
    218a:	44 30       	cpi	r20, 0x04	; 4
    218c:	51 05       	cpc	r21, r1
    218e:	61 05       	cpc	r22, r1
    2190:	71 05       	cpc	r23, r1
    2192:	09 f4       	brne	.+2      	; 0x2196 <RNDIS_Device_ProcessControlRequest+0x88>
    2194:	7b c0       	rjmp	.+246    	; 0x228c <RNDIS_Device_ProcessControlRequest+0x17e>
    2196:	98 f4       	brcc	.+38     	; 0x21be <RNDIS_Device_ProcessControlRequest+0xb0>
    2198:	42 30       	cpi	r20, 0x02	; 2
    219a:	51 05       	cpc	r21, r1
    219c:	61 05       	cpc	r22, r1
    219e:	71 05       	cpc	r23, r1
    21a0:	81 f1       	breq	.+96     	; 0x2202 <RNDIS_Device_ProcessControlRequest+0xf4>
    21a2:	43 30       	cpi	r20, 0x03	; 3
    21a4:	51 05       	cpc	r21, r1
    21a6:	61 05       	cpc	r22, r1
    21a8:	71 05       	cpc	r23, r1
    21aa:	09 f0       	breq	.+2      	; 0x21ae <RNDIS_Device_ProcessControlRequest+0xa0>
    21ac:	1d c2       	rjmp	.+1082   	; 0x25e8 <RNDIS_Device_ProcessControlRequest+0x4da>
    21ae:	f8 01       	movw	r30, r16
			INITIALIZE_Response->AFListSize             = CPU_TO_LE32(0);

			RNDISInterfaceInfo->State.CurrRNDISState    = RNDIS_Initialized;
			break;
		case REMOTE_NDIS_HALT_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = false;
    21b0:	14 8e       	std	Z+28, r1	; 0x1c
    21b2:	1c 82       	std	Y+4, r1	; 0x04

			MessageHeader->MessageLength                = CPU_TO_LE32(0);
    21b4:	1d 82       	std	Y+5, r1	; 0x05
    21b6:	1e 82       	std	Y+6, r1	; 0x06
    21b8:	1f 82       	std	Y+7, r1	; 0x07
    21ba:	15 8e       	std	Z+29, r1	; 0x1d

			RNDISInterfaceInfo->State.CurrRNDISState    = RNDIS_Uninitialized;
    21bc:	15 c2       	rjmp	.+1066   	; 0x25e8 <RNDIS_Device_ProcessControlRequest+0x4da>
    21be:	46 30       	cpi	r20, 0x06	; 6
	/* Note: Only a single buffer is used for both the received message and its response to save SRAM. Because of
	         this, response bytes should be filled in order so that they do not clobber unread data in the buffer. */

	RNDIS_Message_Header_t* MessageHeader = (RNDIS_Message_Header_t*)RNDISInterfaceInfo->Config.MessageBuffer;

	switch (le32_to_cpu(MessageHeader->MessageType))
    21c0:	51 05       	cpc	r21, r1
    21c2:	61 05       	cpc	r22, r1
    21c4:	71 05       	cpc	r23, r1
    21c6:	09 f4       	brne	.+2      	; 0x21ca <RNDIS_Device_ProcessControlRequest+0xbc>
    21c8:	91 c1       	rjmp	.+802    	; 0x24ec <RNDIS_Device_ProcessControlRequest+0x3de>
    21ca:	08 f4       	brcc	.+2      	; 0x21ce <RNDIS_Device_ProcessControlRequest+0xc0>
    21cc:	45 c1       	rjmp	.+650    	; 0x2458 <RNDIS_Device_ProcessControlRequest+0x34a>
    21ce:	48 30       	cpi	r20, 0x08	; 8
    21d0:	51 05       	cpc	r21, r1
    21d2:	61 05       	cpc	r22, r1
    21d4:	71 05       	cpc	r23, r1
    21d6:	09 f0       	breq	.+2      	; 0x21da <RNDIS_Device_ProcessControlRequest+0xcc>
    21d8:	07 c2       	rjmp	.+1038   	; 0x25e8 <RNDIS_Device_ProcessControlRequest+0x4da>
    21da:	81 e0       	ldi	r24, 0x01	; 1
			RESET_Response->Status                      = CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS);
			RESET_Response->AddressingReset             = CPU_TO_LE32(0);

			break;
		case REMOTE_NDIS_KEEPALIVE_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = true;
    21dc:	f8 01       	movw	r30, r16
    21de:	84 8f       	std	Z+28, r24	; 0x1c
    21e0:	88 e0       	ldi	r24, 0x08	; 8
			RNDIS_KeepAlive_Message_t*  KEEPALIVE_Message  =
			                (RNDIS_KeepAlive_Message_t*)RNDISInterfaceInfo->Config.MessageBuffer;
			RNDIS_KeepAlive_Complete_t* KEEPALIVE_Response =
			                (RNDIS_KeepAlive_Complete_t*)RNDISInterfaceInfo->Config.MessageBuffer;

			KEEPALIVE_Response->MessageType             = CPU_TO_LE32(REMOTE_NDIS_KEEPALIVE_CMPLT);
    21e2:	90 e0       	ldi	r25, 0x00	; 0
    21e4:	a0 e0       	ldi	r26, 0x00	; 0
    21e6:	b0 e8       	ldi	r27, 0x80	; 128
    21e8:	88 83       	st	Y, r24
    21ea:	99 83       	std	Y+1, r25	; 0x01
    21ec:	aa 83       	std	Y+2, r26	; 0x02
    21ee:	bb 83       	std	Y+3, r27	; 0x03
    21f0:	80 e1       	ldi	r24, 0x10	; 16
			KEEPALIVE_Response->MessageLength           = CPU_TO_LE32(sizeof(RNDIS_KeepAlive_Complete_t));
    21f2:	90 e0       	ldi	r25, 0x00	; 0
    21f4:	a0 e0       	ldi	r26, 0x00	; 0
    21f6:	b0 e0       	ldi	r27, 0x00	; 0
    21f8:	8c 83       	std	Y+4, r24	; 0x04
    21fa:	9d 83       	std	Y+5, r25	; 0x05
    21fc:	ae 83       	std	Y+6, r26	; 0x06
    21fe:	bf 83       	std	Y+7, r27	; 0x07
    2200:	8c c1       	rjmp	.+792    	; 0x251a <RNDIS_Device_ProcessControlRequest+0x40c>
    2202:	21 e0       	ldi	r18, 0x01	; 1
	RNDIS_Message_Header_t* MessageHeader = (RNDIS_Message_Header_t*)RNDISInterfaceInfo->Config.MessageBuffer;

	switch (le32_to_cpu(MessageHeader->MessageType))
	{
		case REMOTE_NDIS_INITIALIZE_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = true;
    2204:	f8 01       	movw	r30, r16
    2206:	24 8f       	std	Z+28, r18	; 0x1c
    2208:	82 e0       	ldi	r24, 0x02	; 2
			RNDIS_Initialize_Message_t*  INITIALIZE_Message  =
			               (RNDIS_Initialize_Message_t*)RNDISInterfaceInfo->Config.MessageBuffer;
			RNDIS_Initialize_Complete_t* INITIALIZE_Response =
			               (RNDIS_Initialize_Complete_t*)RNDISInterfaceInfo->Config.MessageBuffer;

			INITIALIZE_Response->MessageType            = CPU_TO_LE32(REMOTE_NDIS_INITIALIZE_CMPLT);
    220a:	90 e0       	ldi	r25, 0x00	; 0
    220c:	a0 e0       	ldi	r26, 0x00	; 0
    220e:	b0 e8       	ldi	r27, 0x80	; 128
    2210:	88 83       	st	Y, r24
    2212:	99 83       	std	Y+1, r25	; 0x01
    2214:	aa 83       	std	Y+2, r26	; 0x02
    2216:	bb 83       	std	Y+3, r27	; 0x03
    2218:	84 e3       	ldi	r24, 0x34	; 52
			INITIALIZE_Response->MessageLength          = CPU_TO_LE32(sizeof(RNDIS_Initialize_Complete_t));
    221a:	90 e0       	ldi	r25, 0x00	; 0
    221c:	a0 e0       	ldi	r26, 0x00	; 0
    221e:	b0 e0       	ldi	r27, 0x00	; 0
    2220:	8c 83       	std	Y+4, r24	; 0x04
    2222:	9d 83       	std	Y+5, r25	; 0x05
    2224:	ae 83       	std	Y+6, r26	; 0x06
    2226:	bf 83       	std	Y+7, r27	; 0x07
    2228:	1c 86       	std	Y+12, r1	; 0x0c
			INITIALIZE_Response->RequestId              = INITIALIZE_Message->RequestId;
			INITIALIZE_Response->Status                 = CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS);
    222a:	1d 86       	std	Y+13, r1	; 0x0d
    222c:	1e 86       	std	Y+14, r1	; 0x0e
    222e:	1f 86       	std	Y+15, r1	; 0x0f
    2230:	81 e0       	ldi	r24, 0x01	; 1

			INITIALIZE_Response->MajorVersion           = CPU_TO_LE32(REMOTE_NDIS_VERSION_MAJOR);
    2232:	90 e0       	ldi	r25, 0x00	; 0
    2234:	a0 e0       	ldi	r26, 0x00	; 0
    2236:	b0 e0       	ldi	r27, 0x00	; 0
    2238:	88 8b       	std	Y+16, r24	; 0x10
    223a:	99 8b       	std	Y+17, r25	; 0x11
    223c:	aa 8b       	std	Y+18, r26	; 0x12
    223e:	bb 8b       	std	Y+19, r27	; 0x13
    2240:	1c 8a       	std	Y+20, r1	; 0x14
			INITIALIZE_Response->MinorVersion           = CPU_TO_LE32(REMOTE_NDIS_VERSION_MINOR);
    2242:	1d 8a       	std	Y+21, r1	; 0x15
    2244:	1e 8a       	std	Y+22, r1	; 0x16
    2246:	1f 8a       	std	Y+23, r1	; 0x17
    2248:	88 8f       	std	Y+24, r24	; 0x18
			INITIALIZE_Response->DeviceFlags            = CPU_TO_LE32(REMOTE_NDIS_DF_CONNECTIONLESS);
    224a:	99 8f       	std	Y+25, r25	; 0x19
    224c:	aa 8f       	std	Y+26, r26	; 0x1a
    224e:	bb 8f       	std	Y+27, r27	; 0x1b
    2250:	1c 8e       	std	Y+28, r1	; 0x1c
			INITIALIZE_Response->Medium                 = CPU_TO_LE32(REMOTE_NDIS_MEDIUM_802_3);
    2252:	1d 8e       	std	Y+29, r1	; 0x1d
    2254:	1e 8e       	std	Y+30, r1	; 0x1e
    2256:	1f 8e       	std	Y+31, r1	; 0x1f
    2258:	88 a3       	std	Y+32, r24	; 0x20
			INITIALIZE_Response->MaxPacketsPerTransfer  = CPU_TO_LE32(1);
    225a:	99 a3       	std	Y+33, r25	; 0x21
    225c:	aa a3       	std	Y+34, r26	; 0x22
    225e:	bb a3       	std	Y+35, r27	; 0x23
    2260:	88 e0       	ldi	r24, 0x08	; 8
			INITIALIZE_Response->MaxTransferSize        = CPU_TO_LE32(sizeof(RNDIS_Packet_Message_t) + ETHERNET_FRAME_SIZE_MAX);
    2262:	96 e0       	ldi	r25, 0x06	; 6
    2264:	a0 e0       	ldi	r26, 0x00	; 0
    2266:	b0 e0       	ldi	r27, 0x00	; 0
    2268:	8c a3       	std	Y+36, r24	; 0x24
    226a:	9d a3       	std	Y+37, r25	; 0x25
    226c:	ae a3       	std	Y+38, r26	; 0x26
    226e:	bf a3       	std	Y+39, r27	; 0x27
    2270:	18 a6       	std	Y+40, r1	; 0x28
			INITIALIZE_Response->PacketAlignmentFactor  = CPU_TO_LE32(0);
    2272:	19 a6       	std	Y+41, r1	; 0x29
    2274:	1a a6       	std	Y+42, r1	; 0x2a
    2276:	1b a6       	std	Y+43, r1	; 0x2b
    2278:	1c a6       	std	Y+44, r1	; 0x2c
			INITIALIZE_Response->AFListOffset           = CPU_TO_LE32(0);
    227a:	1d a6       	std	Y+45, r1	; 0x2d
    227c:	1e a6       	std	Y+46, r1	; 0x2e
    227e:	1f a6       	std	Y+47, r1	; 0x2f
    2280:	18 aa       	std	Y+48, r1	; 0x30
			INITIALIZE_Response->AFListSize             = CPU_TO_LE32(0);
    2282:	19 aa       	std	Y+49, r1	; 0x31
    2284:	1a aa       	std	Y+50, r1	; 0x32
    2286:	1b aa       	std	Y+51, r1	; 0x33
    2288:	25 8f       	std	Z+29, r18	; 0x1d

			RNDISInterfaceInfo->State.CurrRNDISState    = RNDIS_Initialized;
    228a:	ae c1       	rjmp	.+860    	; 0x25e8 <RNDIS_Device_ProcessControlRequest+0x4da>
    228c:	81 e0       	ldi	r24, 0x01	; 1
			MessageHeader->MessageLength                = CPU_TO_LE32(0);

			RNDISInterfaceInfo->State.CurrRNDISState    = RNDIS_Uninitialized;
			break;
		case REMOTE_NDIS_QUERY_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = true;
    228e:	f8 01       	movw	r30, r16
    2290:	84 8f       	std	Z+28, r24	; 0x1c
    2292:	4c 85       	ldd	r20, Y+12	; 0x0c

			RNDIS_Query_Message_t*  QUERY_Message       = (RNDIS_Query_Message_t*)RNDISInterfaceInfo->Config.MessageBuffer;
			RNDIS_Query_Complete_t* QUERY_Response      = (RNDIS_Query_Complete_t*)RNDISInterfaceInfo->Config.MessageBuffer;
			uint32_t                Query_Oid           = CPU_TO_LE32(QUERY_Message->Oid);
    2294:	5d 85       	ldd	r21, Y+13	; 0x0d
    2296:	6e 85       	ldd	r22, Y+14	; 0x0e
    2298:	7f 85       	ldd	r23, Y+15	; 0x0f
    229a:	ce 01       	movw	r24, r28

			void*    QueryData    = &RNDISInterfaceInfo->Config.MessageBuffer[sizeof(RNDIS_Message_Header_t) +
			                                                                  le32_to_cpu(QUERY_Message->InformationBufferOffset)];
			void*    ResponseData = &RNDISInterfaceInfo->Config.MessageBuffer[sizeof(RNDIS_Query_Complete_t)];
    229c:	48 96       	adiw	r24, 0x18	; 24
    229e:	24 e0       	ldi	r18, 0x04	; 4
			uint16_t ResponseSize;

			QUERY_Response->MessageType                 = CPU_TO_LE32(REMOTE_NDIS_QUERY_CMPLT);
    22a0:	c2 2e       	mov	r12, r18
    22a2:	d1 2c       	mov	r13, r1
    22a4:	e1 2c       	mov	r14, r1
    22a6:	20 e8       	ldi	r18, 0x80	; 128
    22a8:	f2 2e       	mov	r15, r18
    22aa:	c8 82       	st	Y, r12
    22ac:	d9 82       	std	Y+1, r13	; 0x01
    22ae:	ea 82       	std	Y+2, r14	; 0x02
    22b0:	fb 82       	std	Y+3, r15	; 0x03
    22b2:	4e 30       	cpi	r20, 0x0E	; 14
                                          uint16_t* const ResponseSize)
{
	(void)QueryData;
	(void)QuerySize;

	switch (OId)
    22b4:	f1 e0       	ldi	r31, 0x01	; 1
    22b6:	5f 07       	cpc	r21, r31
    22b8:	6f 07       	cpc	r22, r31
    22ba:	71 05       	cpc	r23, r1
    22bc:	09 f4       	brne	.+2      	; 0x22c0 <RNDIS_Device_ProcessControlRequest+0x1b2>
    22be:	ba c0       	rjmp	.+372    	; 0x2434 <RNDIS_Device_ProcessControlRequest+0x326>
    22c0:	08 f0       	brcs	.+2      	; 0x22c4 <RNDIS_Device_ProcessControlRequest+0x1b6>
    22c2:	57 c0       	rjmp	.+174    	; 0x2372 <RNDIS_Device_ProcessControlRequest+0x264>
    22c4:	46 30       	cpi	r20, 0x06	; 6
    22c6:	e1 e0       	ldi	r30, 0x01	; 1
    22c8:	5e 07       	cpc	r21, r30
    22ca:	6e 07       	cpc	r22, r30
    22cc:	71 05       	cpc	r23, r1
    22ce:	09 f4       	brne	.+2      	; 0x22d2 <RNDIS_Device_ProcessControlRequest+0x1c4>
    22d0:	a7 c0       	rjmp	.+334    	; 0x2420 <RNDIS_Device_ProcessControlRequest+0x312>
    22d2:	e8 f4       	brcc	.+58     	; 0x230e <RNDIS_Device_ProcessControlRequest+0x200>
    22d4:	42 30       	cpi	r20, 0x02	; 2
    22d6:	21 e0       	ldi	r18, 0x01	; 1
    22d8:	52 07       	cpc	r21, r18
    22da:	62 07       	cpc	r22, r18
    22dc:	71 05       	cpc	r23, r1
    22de:	09 f4       	brne	.+2      	; 0x22e2 <RNDIS_Device_ProcessControlRequest+0x1d4>
    22e0:	af c0       	rjmp	.+350    	; 0x2440 <RNDIS_Device_ProcessControlRequest+0x332>
    22e2:	70 f4       	brcc	.+28     	; 0x2300 <RNDIS_Device_ProcessControlRequest+0x1f2>
    22e4:	41 30       	cpi	r20, 0x01	; 1
    22e6:	51 40       	sbci	r21, 0x01	; 1
    22e8:	61 40       	sbci	r22, 0x01	; 1
    22ea:	71 05       	cpc	r23, r1
    22ec:	09 f0       	breq	.+2      	; 0x22f0 <RNDIS_Device_ProcessControlRequest+0x1e2>
    22ee:	64 c1       	rjmp	.+712    	; 0x25b8 <RNDIS_Device_ProcessControlRequest+0x4aa>
    22f0:	4c e6       	ldi	r20, 0x6C	; 108
	{
		case OID_GEN_SUPPORTED_LIST:
			*ResponseSize = sizeof(AdapterSupportedOIDList);

			memcpy_P(ResponseData, AdapterSupportedOIDList, sizeof(AdapterSupportedOIDList));
    22f2:	50 e0       	ldi	r21, 0x00	; 0
    22f4:	66 eb       	ldi	r22, 0xB6	; 182
    22f6:	73 e0       	ldi	r23, 0x03	; 3
    22f8:	ff d2       	rcall	.+1534   	; 0x28f8 <memcpy_P>
    22fa:	0c e6       	ldi	r16, 0x6C	; 108
    22fc:	10 e0       	ldi	r17, 0x00	; 0
	(void)QuerySize;

	switch (OId)
	{
		case OID_GEN_SUPPORTED_LIST:
			*ResponseSize = sizeof(AdapterSupportedOIDList);
    22fe:	40 c1       	rjmp	.+640    	; 0x2580 <RNDIS_Device_ProcessControlRequest+0x472>
    2300:	45 30       	cpi	r20, 0x05	; 5
    2302:	51 40       	sbci	r21, 0x01	; 1
                                          uint16_t* const ResponseSize)
{
	(void)QueryData;
	(void)QuerySize;

	switch (OId)
    2304:	61 40       	sbci	r22, 0x01	; 1
    2306:	71 05       	cpc	r23, r1
    2308:	08 f4       	brcc	.+2      	; 0x230c <RNDIS_Device_ProcessControlRequest+0x1fe>
    230a:	9a c0       	rjmp	.+308    	; 0x2440 <RNDIS_Device_ProcessControlRequest+0x332>
    230c:	55 c1       	rjmp	.+682    	; 0x25b8 <RNDIS_Device_ProcessControlRequest+0x4aa>
    230e:	4c 30       	cpi	r20, 0x0C	; 12
    2310:	e1 e0       	ldi	r30, 0x01	; 1
    2312:	5e 07       	cpc	r21, r30
    2314:	6e 07       	cpc	r22, r30
    2316:	71 05       	cpc	r23, r1
    2318:	90 f4       	brcc	.+36     	; 0x233e <RNDIS_Device_ProcessControlRequest+0x230>
    231a:	4a 30       	cpi	r20, 0x0A	; 10
    231c:	f1 e0       	ldi	r31, 0x01	; 1
    231e:	5f 07       	cpc	r21, r31
    2320:	6f 07       	cpc	r22, r31
    2322:	71 05       	cpc	r23, r1
    2324:	08 f0       	brcs	.+2      	; 0x2328 <RNDIS_Device_ProcessControlRequest+0x21a>
    2326:	7c c0       	rjmp	.+248    	; 0x2420 <RNDIS_Device_ProcessControlRequest+0x312>
    2328:	47 30       	cpi	r20, 0x07	; 7
    232a:	51 40       	sbci	r21, 0x01	; 1
    232c:	61 40       	sbci	r22, 0x01	; 1
    232e:	71 05       	cpc	r23, r1
    2330:	09 f0       	breq	.+2      	; 0x2334 <RNDIS_Device_ProcessControlRequest+0x226>
    2332:	42 c1       	rjmp	.+644    	; 0x25b8 <RNDIS_Device_ProcessControlRequest+0x4aa>
    2334:	80 ea       	ldi	r24, 0xA0	; 160
    2336:	96 e8       	ldi	r25, 0x86	; 134
			return true;
		case OID_GEN_LINK_SPEED:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate 10Mb/s link speed */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(100000);
    2338:	a1 e0       	ldi	r26, 0x01	; 1
    233a:	b0 e0       	ldi	r27, 0x00	; 0
    233c:	86 c0       	rjmp	.+268    	; 0x244a <RNDIS_Device_ProcessControlRequest+0x33c>
    233e:	4c 30       	cpi	r20, 0x0C	; 12
    2340:	e1 e0       	ldi	r30, 0x01	; 1
                                          uint16_t* const ResponseSize)
{
	(void)QueryData;
	(void)QuerySize;

	switch (OId)
    2342:	5e 07       	cpc	r21, r30
    2344:	6e 07       	cpc	r22, r30
    2346:	71 05       	cpc	r23, r1
    2348:	09 f4       	brne	.+2      	; 0x234c <RNDIS_Device_ProcessControlRequest+0x23e>
    234a:	65 c0       	rjmp	.+202    	; 0x2416 <RNDIS_Device_ProcessControlRequest+0x308>
    234c:	4d 30       	cpi	r20, 0x0D	; 13
    234e:	51 40       	sbci	r21, 0x01	; 1
    2350:	61 40       	sbci	r22, 0x01	; 1
    2352:	71 05       	cpc	r23, r1
    2354:	09 f0       	breq	.+2      	; 0x2358 <RNDIS_Device_ProcessControlRequest+0x24a>
    2356:	30 c1       	rjmp	.+608    	; 0x25b8 <RNDIS_Device_ProcessControlRequest+0x4aa>
    2358:	f8 01       	movw	r30, r16
    235a:	60 89       	ldd	r22, Z+16	; 0x10

			*((uint32_t*)ResponseData) = CPU_TO_LE32(ETHERNET_FRAME_SIZE_MAX);

			return true;
		case OID_GEN_VENDOR_DESCRIPTION:
			*ResponseSize = (strlen(RNDISInterfaceInfo->Config.AdapterVendorDescription) + 1);
    235c:	71 89       	ldd	r23, Z+17	; 0x11
    235e:	fb 01       	movw	r30, r22
    2360:	01 90       	ld	r0, Z+
    2362:	00 20       	and	r0, r0
    2364:	e9 f7       	brne	.-6      	; 0x2360 <RNDIS_Device_ProcessControlRequest+0x252>
    2366:	8f 01       	movw	r16, r30
    2368:	06 1b       	sub	r16, r22
    236a:	17 0b       	sbc	r17, r23
    236c:	a8 01       	movw	r20, r16
    236e:	f9 d2       	rcall	.+1522   	; 0x2962 <memcpy>

			memcpy(ResponseData, RNDISInterfaceInfo->Config.AdapterVendorDescription, *ResponseSize);
    2370:	07 c1       	rjmp	.+526    	; 0x2580 <RNDIS_Device_ProcessControlRequest+0x472>
    2372:	46 30       	cpi	r20, 0x06	; 6
    2374:	21 e0       	ldi	r18, 0x01	; 1
    2376:	52 07       	cpc	r21, r18
                                          uint16_t* const ResponseSize)
{
	(void)QueryData;
	(void)QuerySize;

	switch (OId)
    2378:	22 e0       	ldi	r18, 0x02	; 2
    237a:	62 07       	cpc	r22, r18
    237c:	71 05       	cpc	r23, r1
    237e:	28 f5       	brcc	.+74     	; 0x23ca <RNDIS_Device_ProcessControlRequest+0x2bc>
    2380:	41 30       	cpi	r20, 0x01	; 1
    2382:	81 e0       	ldi	r24, 0x01	; 1
    2384:	58 07       	cpc	r21, r24
    2386:	82 e0       	ldi	r24, 0x02	; 2
    2388:	68 07       	cpc	r22, r24
    238a:	71 05       	cpc	r23, r1
    238c:	08 f0       	brcs	.+2      	; 0x2390 <RNDIS_Device_ProcessControlRequest+0x282>
    238e:	58 c0       	rjmp	.+176    	; 0x2440 <RNDIS_Device_ProcessControlRequest+0x332>
    2390:	44 31       	cpi	r20, 0x14	; 20
    2392:	e1 e0       	ldi	r30, 0x01	; 1
    2394:	5e 07       	cpc	r21, r30
    2396:	6e 07       	cpc	r22, r30
    2398:	71 05       	cpc	r23, r1
    239a:	09 f4       	brne	.+2      	; 0x239e <RNDIS_Device_ProcessControlRequest+0x290>
    239c:	51 c0       	rjmp	.+162    	; 0x2440 <RNDIS_Device_ProcessControlRequest+0x332>
    239e:	42 30       	cpi	r20, 0x02	; 2
    23a0:	f2 e0       	ldi	r31, 0x02	; 2
    23a2:	5f 07       	cpc	r21, r31
    23a4:	f1 e0       	ldi	r31, 0x01	; 1
    23a6:	6f 07       	cpc	r22, r31
    23a8:	71 05       	cpc	r23, r1
    23aa:	09 f4       	brne	.+2      	; 0x23ae <RNDIS_Device_ProcessControlRequest+0x2a0>
    23ac:	49 c0       	rjmp	.+146    	; 0x2440 <RNDIS_Device_ProcessControlRequest+0x332>
    23ae:	41 31       	cpi	r20, 0x11	; 17
    23b0:	51 40       	sbci	r21, 0x01	; 1
    23b2:	61 40       	sbci	r22, 0x01	; 1
    23b4:	71 05       	cpc	r23, r1
    23b6:	09 f0       	breq	.+2      	; 0x23ba <RNDIS_Device_ProcessControlRequest+0x2ac>
    23b8:	ff c0       	rjmp	.+510    	; 0x25b8 <RNDIS_Device_ProcessControlRequest+0x4aa>
    23ba:	f8 01       	movw	r30, r16
    23bc:	82 8d       	ldd	r24, Z+26	; 0x1a
    23be:	93 8d       	ldd	r25, Z+27	; 0x1b
			return true;
		case OID_GEN_MAXIMUM_TOTAL_SIZE:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate maximum overall buffer (Ethernet frame and RNDIS header) the adapter can handle */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(RNDISInterfaceInfo->Config.MessageBufferLength + ETHERNET_FRAME_SIZE_MAX);
    23c0:	84 52       	subi	r24, 0x24	; 36
    23c2:	9a 4f       	sbci	r25, 0xFA	; 250
    23c4:	a0 e0       	ldi	r26, 0x00	; 0
    23c6:	b0 e0       	ldi	r27, 0x00	; 0
    23c8:	40 c0       	rjmp	.+128    	; 0x244a <RNDIS_Device_ProcessControlRequest+0x33c>
    23ca:	44 30       	cpi	r20, 0x04	; 4
    23cc:	e1 e0       	ldi	r30, 0x01	; 1
    23ce:	5e 07       	cpc	r21, r30
                                          uint16_t* const ResponseSize)
{
	(void)QueryData;
	(void)QuerySize;

	switch (OId)
    23d0:	6e 07       	cpc	r22, r30
    23d2:	7e 07       	cpc	r23, r30
    23d4:	51 f1       	breq	.+84     	; 0x242a <RNDIS_Device_ProcessControlRequest+0x31c>
    23d6:	a8 f4       	brcc	.+42     	; 0x2402 <RNDIS_Device_ProcessControlRequest+0x2f4>
    23d8:	41 50       	subi	r20, 0x01	; 1
    23da:	51 40       	sbci	r21, 0x01	; 1
    23dc:	61 40       	sbci	r22, 0x01	; 1
    23de:	71 40       	sbci	r23, 0x01	; 1
    23e0:	42 30       	cpi	r20, 0x02	; 2
    23e2:	51 05       	cpc	r21, r1
    23e4:	61 05       	cpc	r22, r1
    23e6:	71 05       	cpc	r23, r1
    23e8:	08 f0       	brcs	.+2      	; 0x23ec <RNDIS_Device_ProcessControlRequest+0x2de>
    23ea:	e6 c0       	rjmp	.+460    	; 0x25b8 <RNDIS_Device_ProcessControlRequest+0x4aa>
    23ec:	f8 01       	movw	r30, r16
    23ee:	72 96       	adiw	r30, 0x12	; 18
    23f0:	26 e0       	ldi	r18, 0x06	; 6
			return true;
		case OID_802_3_PERMANENT_ADDRESS:
		case OID_802_3_CURRENT_ADDRESS:
			*ResponseSize = sizeof(MAC_Address_t);

			memcpy(ResponseData, &RNDISInterfaceInfo->Config.AdapterMACAddress, sizeof(MAC_Address_t));
    23f2:	dc 01       	movw	r26, r24
    23f4:	01 90       	ld	r0, Z+
    23f6:	0d 92       	st	X+, r0
    23f8:	2a 95       	dec	r18
    23fa:	e1 f7       	brne	.-8      	; 0x23f4 <RNDIS_Device_ProcessControlRequest+0x2e6>
    23fc:	06 e0       	ldi	r16, 0x06	; 6
    23fe:	10 e0       	ldi	r17, 0x00	; 0
    2400:	bf c0       	rjmp	.+382    	; 0x2580 <RNDIS_Device_ProcessControlRequest+0x472>
			*((uint32_t*)ResponseData) = CPU_TO_LE32(100000);

			return true;
		case OID_802_3_PERMANENT_ADDRESS:
		case OID_802_3_CURRENT_ADDRESS:
			*ResponseSize = sizeof(MAC_Address_t);
    2402:	41 50       	subi	r20, 0x01	; 1
    2404:	51 40       	sbci	r21, 0x01	; 1
    2406:	62 40       	sbci	r22, 0x02	; 2
                                          uint16_t* const ResponseSize)
{
	(void)QueryData;
	(void)QuerySize;

	switch (OId)
    2408:	71 40       	sbci	r23, 0x01	; 1
    240a:	43 30       	cpi	r20, 0x03	; 3
    240c:	51 05       	cpc	r21, r1
    240e:	61 05       	cpc	r22, r1
    2410:	71 05       	cpc	r23, r1
    2412:	b0 f0       	brcs	.+44     	; 0x2440 <RNDIS_Device_ProcessControlRequest+0x332>
    2414:	d1 c0       	rjmp	.+418    	; 0x25b8 <RNDIS_Device_ProcessControlRequest+0x4aa>
    2416:	8f ef       	ldi	r24, 0xFF	; 255
    2418:	9f ef       	ldi	r25, 0xFF	; 255
    241a:	af ef       	ldi	r26, 0xFF	; 255
			return true;
		case OID_GEN_VENDOR_ID:
			*ResponseSize = sizeof(uint32_t);

			/* Vendor ID 0x0xFFFFFF is reserved for vendors who have not purchased a NDIS VID */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(0x00FFFFFF);
    241c:	b0 e0       	ldi	r27, 0x00	; 0
    241e:	15 c0       	rjmp	.+42     	; 0x244a <RNDIS_Device_ProcessControlRequest+0x33c>
    2420:	8c ed       	ldi	r24, 0xDC	; 220
    2422:	95 e0       	ldi	r25, 0x05	; 5
    2424:	a0 e0       	ldi	r26, 0x00	; 0
		case OID_GEN_MAXIMUM_FRAME_SIZE:
		case OID_GEN_TRANSMIT_BLOCK_SIZE:
		case OID_GEN_RECEIVE_BLOCK_SIZE:
			*ResponseSize = sizeof(uint32_t);

			*((uint32_t*)ResponseData) = CPU_TO_LE32(ETHERNET_FRAME_SIZE_MAX);
    2426:	b0 e0       	ldi	r27, 0x00	; 0
    2428:	10 c0       	rjmp	.+32     	; 0x244a <RNDIS_Device_ProcessControlRequest+0x33c>
    242a:	81 e0       	ldi	r24, 0x01	; 1
    242c:	90 e0       	ldi	r25, 0x00	; 0
    242e:	a0 e0       	ldi	r26, 0x00	; 0
			return true;
		case OID_802_3_MAXIMUM_LIST_SIZE:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate only one multicast address supported */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(1);
    2430:	b0 e0       	ldi	r27, 0x00	; 0
    2432:	0b c0       	rjmp	.+22     	; 0x244a <RNDIS_Device_ProcessControlRequest+0x33c>
    2434:	f8 01       	movw	r30, r16
    2436:	86 8d       	ldd	r24, Z+30	; 0x1e
    2438:	97 8d       	ldd	r25, Z+31	; 0x1f

			return true;
		case OID_GEN_CURRENT_PACKET_FILTER:
			*ResponseSize = sizeof(uint32_t);

			*((uint32_t*)ResponseData) = cpu_to_le32(RNDISInterfaceInfo->State.CurrPacketFilter);
    243a:	a0 a1       	ldd	r26, Z+32	; 0x20
    243c:	b1 a1       	ldd	r27, Z+33	; 0x21
    243e:	05 c0       	rjmp	.+10     	; 0x244a <RNDIS_Device_ProcessControlRequest+0x33c>
    2440:	18 8e       	std	Y+24, r1	; 0x18
    2442:	19 8e       	std	Y+25, r1	; 0x19
    2444:	1a 8e       	std	Y+26, r1	; 0x1a
		case OID_802_3_XMIT_ONE_COLLISION:
		case OID_802_3_XMIT_MORE_COLLISIONS:
			*ResponseSize = sizeof(uint32_t);

			/* Unused statistic OIDs - always return 0 for each */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(0);
    2446:	1b 8e       	std	Y+27, r1	; 0x1b
    2448:	04 c0       	rjmp	.+8      	; 0x2452 <RNDIS_Device_ProcessControlRequest+0x344>
    244a:	88 8f       	std	Y+24, r24	; 0x18
    244c:	99 8f       	std	Y+25, r25	; 0x19
    244e:	aa 8f       	std	Y+26, r26	; 0x1a
			return true;
		case OID_GEN_MAXIMUM_TOTAL_SIZE:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate maximum overall buffer (Ethernet frame and RNDIS header) the adapter can handle */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(RNDISInterfaceInfo->Config.MessageBufferLength + ETHERNET_FRAME_SIZE_MAX);
    2450:	bb 8f       	std	Y+27, r27	; 0x1b
    2452:	04 e0       	ldi	r16, 0x04	; 4
    2454:	10 e0       	ldi	r17, 0x00	; 0
    2456:	94 c0       	rjmp	.+296    	; 0x2580 <RNDIS_Device_ProcessControlRequest+0x472>
			/* Unused statistic OIDs - always return 0 for each */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(0);

			return true;
		case OID_GEN_MAXIMUM_TOTAL_SIZE:
			*ResponseSize = sizeof(uint32_t);
    2458:	81 e0       	ldi	r24, 0x01	; 1
    245a:	f8 01       	movw	r30, r16
    245c:	84 8f       	std	Z+28, r24	; 0x1c
				QUERY_Response->InformationBufferOffset = CPU_TO_LE32(0);
			}

			break;
		case REMOTE_NDIS_SET_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = true;
    245e:	8c 85       	ldd	r24, Y+12	; 0x0c
    2460:	9d 85       	ldd	r25, Y+13	; 0x0d
    2462:	ae 85       	ldd	r26, Y+14	; 0x0e

			RNDIS_Set_Message_t*  SET_Message           = (RNDIS_Set_Message_t*)RNDISInterfaceInfo->Config.MessageBuffer;
			RNDIS_Set_Complete_t* SET_Response          = (RNDIS_Set_Complete_t*)RNDISInterfaceInfo->Config.MessageBuffer;
			uint32_t              SET_Oid               = le32_to_cpu(SET_Message->Oid);
    2464:	bf 85       	ldd	r27, Y+15	; 0x0f
    2466:	45 e0       	ldi	r20, 0x05	; 5
    2468:	50 e0       	ldi	r21, 0x00	; 0
    246a:	60 e0       	ldi	r22, 0x00	; 0

			SET_Response->MessageType                   = CPU_TO_LE32(REMOTE_NDIS_SET_CMPLT);
    246c:	70 e8       	ldi	r23, 0x80	; 128
    246e:	48 83       	st	Y, r20
    2470:	59 83       	std	Y+1, r21	; 0x01
    2472:	6a 83       	std	Y+2, r22	; 0x02
    2474:	7b 83       	std	Y+3, r23	; 0x03
    2476:	40 e1       	ldi	r20, 0x10	; 16
    2478:	50 e0       	ldi	r21, 0x00	; 0
    247a:	60 e0       	ldi	r22, 0x00	; 0
			SET_Response->MessageLength                 = CPU_TO_LE32(sizeof(RNDIS_Set_Complete_t));
    247c:	70 e0       	ldi	r23, 0x00	; 0
    247e:	4c 83       	std	Y+4, r20	; 0x04
    2480:	5d 83       	std	Y+5, r21	; 0x05
    2482:	6e 83       	std	Y+6, r22	; 0x06
    2484:	7f 83       	std	Y+7, r23	; 0x07
    2486:	20 8d       	ldd	r18, Z+24	; 0x18
    2488:	31 8d       	ldd	r19, Z+25	; 0x19
    248a:	4c 89       	ldd	r20, Y+20	; 0x14
			SET_Response->RequestId                     = SET_Message->RequestId;

			void* SetData = &RNDISInterfaceInfo->Config.MessageBuffer[sizeof(RNDIS_Message_Header_t) +
    248c:	5d 89       	ldd	r21, Y+21	; 0x15
    248e:	6e 89       	ldd	r22, Y+22	; 0x16
			                                                              le32_to_cpu(SET_Message->InformationBufferOffset)];
    2490:	7f 89       	ldd	r23, Y+23	; 0x17
    2492:	8e 30       	cpi	r24, 0x0E	; 14
    2494:	f1 e0       	ldi	r31, 0x01	; 1
    2496:	9f 07       	cpc	r25, r31
                                        const void* SetData,
                                        const uint16_t SetSize)
{
	(void)SetSize;

	switch (OId)
    2498:	af 07       	cpc	r26, r31
    249a:	b1 05       	cpc	r27, r1
    249c:	51 f0       	breq	.+20     	; 0x24b2 <RNDIS_Device_ProcessControlRequest+0x3a4>
    249e:	83 30       	cpi	r24, 0x03	; 3
    24a0:	91 40       	sbci	r25, 0x01	; 1
    24a2:	a1 40       	sbci	r26, 0x01	; 1
    24a4:	b1 40       	sbci	r27, 0x01	; 1
    24a6:	d1 f0       	breq	.+52     	; 0x24dc <RNDIS_Device_ProcessControlRequest+0x3ce>
    24a8:	8b eb       	ldi	r24, 0xBB	; 187
    24aa:	90 e0       	ldi	r25, 0x00	; 0
    24ac:	a0 e0       	ldi	r26, 0x00	; 0
			void* SetData = &RNDISInterfaceInfo->Config.MessageBuffer[sizeof(RNDIS_Message_Header_t) +
			                                                              le32_to_cpu(SET_Message->InformationBufferOffset)];

			SET_Response->Status = RNDIS_Device_ProcessNDISSet(RNDISInterfaceInfo, SET_Oid, SetData,
			                                                   le32_to_cpu(SET_Message->InformationBufferLength)) ?
			                                                   REMOTE_NDIS_STATUS_SUCCESS : REMOTE_NDIS_STATUS_NOT_SUPPORTED;
    24ae:	b0 ec       	ldi	r27, 0xC0	; 192
    24b0:	18 c0       	rjmp	.+48     	; 0x24e2 <RNDIS_Device_ProcessControlRequest+0x3d4>
    24b2:	f9 01       	movw	r30, r18
    24b4:	e4 0f       	add	r30, r20
    24b6:	f5 1f       	adc	r31, r21
	(void)SetSize;

	switch (OId)
	{
		case OID_GEN_CURRENT_PACKET_FILTER:
			RNDISInterfaceInfo->State.CurrPacketFilter = le32_to_cpu(*((uint32_t*)SetData));
    24b8:	80 85       	ldd	r24, Z+8	; 0x08
    24ba:	91 85       	ldd	r25, Z+9	; 0x09
    24bc:	a2 85       	ldd	r26, Z+10	; 0x0a
    24be:	b3 85       	ldd	r27, Z+11	; 0x0b
    24c0:	f8 01       	movw	r30, r16
    24c2:	86 8f       	std	Z+30, r24	; 0x1e
    24c4:	97 8f       	std	Z+31, r25	; 0x1f
    24c6:	a0 a3       	std	Z+32, r26	; 0x20
    24c8:	b1 a3       	std	Z+33, r27	; 0x21
    24ca:	89 2b       	or	r24, r25
    24cc:	8a 2b       	or	r24, r26
    24ce:	8b 2b       	or	r24, r27
			RNDISInterfaceInfo->State.CurrRNDISState   = (RNDISInterfaceInfo->State.CurrPacketFilter) ? RNDIS_Data_Initialized : RNDIS_Initialized;
    24d0:	11 f0       	breq	.+4      	; 0x24d6 <RNDIS_Device_ProcessControlRequest+0x3c8>
    24d2:	82 e0       	ldi	r24, 0x02	; 2
    24d4:	01 c0       	rjmp	.+2      	; 0x24d8 <RNDIS_Device_ProcessControlRequest+0x3ca>
    24d6:	81 e0       	ldi	r24, 0x01	; 1
    24d8:	f8 01       	movw	r30, r16
    24da:	85 8f       	std	Z+29, r24	; 0x1d
    24dc:	80 e0       	ldi	r24, 0x00	; 0
    24de:	90 e0       	ldi	r25, 0x00	; 0
    24e0:	dc 01       	movw	r26, r24
			void* SetData = &RNDISInterfaceInfo->Config.MessageBuffer[sizeof(RNDIS_Message_Header_t) +
			                                                              le32_to_cpu(SET_Message->InformationBufferOffset)];

			SET_Response->Status = RNDIS_Device_ProcessNDISSet(RNDISInterfaceInfo, SET_Oid, SetData,
			                                                   le32_to_cpu(SET_Message->InformationBufferLength)) ?
			                                                   REMOTE_NDIS_STATUS_SUCCESS : REMOTE_NDIS_STATUS_NOT_SUPPORTED;
    24e2:	8c 87       	std	Y+12, r24	; 0x0c
    24e4:	9d 87       	std	Y+13, r25	; 0x0d
    24e6:	ae 87       	std	Y+14, r26	; 0x0e
			SET_Response->RequestId                     = SET_Message->RequestId;

			void* SetData = &RNDISInterfaceInfo->Config.MessageBuffer[sizeof(RNDIS_Message_Header_t) +
			                                                              le32_to_cpu(SET_Message->InformationBufferOffset)];

			SET_Response->Status = RNDIS_Device_ProcessNDISSet(RNDISInterfaceInfo, SET_Oid, SetData,
    24e8:	bf 87       	std	Y+15, r27	; 0x0f
    24ea:	7e c0       	rjmp	.+252    	; 0x25e8 <RNDIS_Device_ProcessControlRequest+0x4da>
    24ec:	81 e0       	ldi	r24, 0x01	; 1
    24ee:	f8 01       	movw	r30, r16
    24f0:	84 8f       	std	Z+28, r24	; 0x1c
			                                                   le32_to_cpu(SET_Message->InformationBufferLength)) ?
			                                                   REMOTE_NDIS_STATUS_SUCCESS : REMOTE_NDIS_STATUS_NOT_SUPPORTED;
			break;
		case REMOTE_NDIS_RESET_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = true;
    24f2:	86 e0       	ldi	r24, 0x06	; 6
    24f4:	90 e0       	ldi	r25, 0x00	; 0
    24f6:	a0 e0       	ldi	r26, 0x00	; 0

			RNDIS_Reset_Complete_t* RESET_Response      = (RNDIS_Reset_Complete_t*)RNDISInterfaceInfo->Config.MessageBuffer;

			RESET_Response->MessageType                 = CPU_TO_LE32(REMOTE_NDIS_RESET_CMPLT);
    24f8:	b0 e8       	ldi	r27, 0x80	; 128
    24fa:	88 83       	st	Y, r24
    24fc:	99 83       	std	Y+1, r25	; 0x01
    24fe:	aa 83       	std	Y+2, r26	; 0x02
    2500:	bb 83       	std	Y+3, r27	; 0x03
    2502:	80 e1       	ldi	r24, 0x10	; 16
    2504:	90 e0       	ldi	r25, 0x00	; 0
    2506:	a0 e0       	ldi	r26, 0x00	; 0
			RESET_Response->MessageLength               = CPU_TO_LE32(sizeof(RNDIS_Reset_Complete_t));
    2508:	b0 e0       	ldi	r27, 0x00	; 0
    250a:	8c 83       	std	Y+4, r24	; 0x04
    250c:	9d 83       	std	Y+5, r25	; 0x05
    250e:	ae 83       	std	Y+6, r26	; 0x06
    2510:	bf 83       	std	Y+7, r27	; 0x07
    2512:	18 86       	std	Y+8, r1	; 0x08
    2514:	19 86       	std	Y+9, r1	; 0x09
    2516:	1a 86       	std	Y+10, r1	; 0x0a
			RESET_Response->Status                      = CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS);
    2518:	1b 86       	std	Y+11, r1	; 0x0b
    251a:	1c 86       	std	Y+12, r1	; 0x0c
    251c:	1d 86       	std	Y+13, r1	; 0x0d
    251e:	1e 86       	std	Y+14, r1	; 0x0e
			                (RNDIS_KeepAlive_Complete_t*)RNDISInterfaceInfo->Config.MessageBuffer;

			KEEPALIVE_Response->MessageType             = CPU_TO_LE32(REMOTE_NDIS_KEEPALIVE_CMPLT);
			KEEPALIVE_Response->MessageLength           = CPU_TO_LE32(sizeof(RNDIS_KeepAlive_Complete_t));
			KEEPALIVE_Response->RequestId               = KEEPALIVE_Message->RequestId;
			KEEPALIVE_Response->Status                  = CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS);
    2520:	1f 86       	std	Y+15, r1	; 0x0f
    2522:	62 c0       	rjmp	.+196    	; 0x25e8 <RNDIS_Device_ProcessControlRequest+0x4da>
    2524:	80 91 47 14 	lds	r24, 0x1447
    2528:	81 3a       	cpi	r24, 0xA1	; 161
				RNDIS_Device_ProcessRNDISControlMessage(RNDISInterfaceInfo);
			}

			break;
		case RNDIS_REQ_GetEncapsulatedResponse:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
    252a:	09 f0       	breq	.+2      	; 0x252e <RNDIS_Device_ProcessControlRequest+0x420>
    252c:	5d c0       	rjmp	.+186    	; 0x25e8 <RNDIS_Device_ProcessControlRequest+0x4da>
    252e:	f8 01       	movw	r30, r16
    2530:	c0 8d       	ldd	r28, Z+24	; 0x18
    2532:	d1 8d       	ldd	r29, Z+25	; 0x19
			{
				RNDIS_Message_Header_t* MessageHeader = (RNDIS_Message_Header_t*)RNDISInterfaceInfo->Config.MessageBuffer;
    2534:	8c 81       	ldd	r24, Y+4	; 0x04
    2536:	9d 81       	ldd	r25, Y+5	; 0x05
    2538:	ae 81       	ldd	r26, Y+6	; 0x06

				if (!(MessageHeader->MessageLength))
    253a:	bf 81       	ldd	r27, Y+7	; 0x07
    253c:	89 2b       	or	r24, r25
    253e:	8a 2b       	or	r24, r26
    2540:	8b 2b       	or	r24, r27
    2542:	49 f4       	brne	.+18     	; 0x2556 <RNDIS_Device_ProcessControlRequest+0x448>
    2544:	18 82       	st	Y, r1
    2546:	81 e0       	ldi	r24, 0x01	; 1
    2548:	90 e0       	ldi	r25, 0x00	; 0
				{
					RNDISInterfaceInfo->Config.MessageBuffer[0] = 0;
    254a:	a0 e0       	ldi	r26, 0x00	; 0
					MessageHeader->MessageLength                = CPU_TO_LE32(1);
    254c:	b0 e0       	ldi	r27, 0x00	; 0
    254e:	8c 83       	std	Y+4, r24	; 0x04
    2550:	9d 83       	std	Y+5, r25	; 0x05
    2552:	ae 83       	std	Y+6, r26	; 0x06
    2554:	bf 83       	std	Y+7, r27	; 0x07
    2556:	80 91 e8 00 	lds	r24, 0x00E8
    255a:	87 7f       	andi	r24, 0xF7	; 247
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    255c:	80 93 e8 00 	sts	0x00E8, r24
    2560:	6c 81       	ldd	r22, Y+4	; 0x04
    2562:	7d 81       	ldd	r23, Y+5	; 0x05
    2564:	f8 01       	movw	r30, r16
				}

				Endpoint_ClearSETUP();
				Endpoint_Write_Control_Stream_LE(RNDISInterfaceInfo->Config.MessageBuffer, le32_to_cpu(MessageHeader->MessageLength));
    2566:	80 8d       	ldd	r24, Z+24	; 0x18
    2568:	91 8d       	ldd	r25, Z+25	; 0x19
    256a:	76 d9       	rcall	.-3348   	; 0x1858 <Endpoint_Write_Control_Stream_LE>
    256c:	80 91 e8 00 	lds	r24, 0x00E8
    2570:	8b 77       	andi	r24, 0x7B	; 123
    2572:	80 93 e8 00 	sts	0x00E8, r24
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    2576:	1c 82       	std	Y+4, r1	; 0x04
    2578:	1d 82       	std	Y+5, r1	; 0x05
    257a:	1e 82       	std	Y+6, r1	; 0x06
    257c:	1f 82       	std	Y+7, r1	; 0x07
				Endpoint_ClearOUT();

				MessageHeader->MessageLength = CPU_TO_LE32(0);
    257e:	34 c0       	rjmp	.+104    	; 0x25e8 <RNDIS_Device_ProcessControlRequest+0x4da>
    2580:	1c 86       	std	Y+12, r1	; 0x0c
    2582:	1d 86       	std	Y+13, r1	; 0x0d
    2584:	1e 86       	std	Y+14, r1	; 0x0e
    2586:	1f 86       	std	Y+15, r1	; 0x0f
			QUERY_Response->MessageType                 = CPU_TO_LE32(REMOTE_NDIS_QUERY_CMPLT);

			if (RNDIS_Device_ProcessNDISQuery(RNDISInterfaceInfo, Query_Oid, QueryData, le32_to_cpu(QUERY_Message->InformationBufferLength),
			                                  ResponseData, &ResponseSize))
			{
				QUERY_Response->Status                  = CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS);
    2588:	c8 01       	movw	r24, r16
    258a:	48 96       	adiw	r24, 0x18	; 24
    258c:	a0 e0       	ldi	r26, 0x00	; 0
    258e:	b0 e0       	ldi	r27, 0x00	; 0
				QUERY_Response->MessageLength           = cpu_to_le32(sizeof(RNDIS_Query_Complete_t) + ResponseSize);
    2590:	8c 83       	std	Y+4, r24	; 0x04
    2592:	9d 83       	std	Y+5, r25	; 0x05
    2594:	ae 83       	std	Y+6, r26	; 0x06
    2596:	bf 83       	std	Y+7, r27	; 0x07
    2598:	a8 01       	movw	r20, r16
    259a:	60 e0       	ldi	r22, 0x00	; 0
    259c:	70 e0       	ldi	r23, 0x00	; 0
    259e:	48 8b       	std	Y+16, r20	; 0x10

				QUERY_Response->InformationBufferLength = CPU_TO_LE32(ResponseSize);
    25a0:	59 8b       	std	Y+17, r21	; 0x11
    25a2:	6a 8b       	std	Y+18, r22	; 0x12
    25a4:	7b 8b       	std	Y+19, r23	; 0x13
    25a6:	80 e1       	ldi	r24, 0x10	; 16
    25a8:	90 e0       	ldi	r25, 0x00	; 0
    25aa:	a0 e0       	ldi	r26, 0x00	; 0
    25ac:	b0 e0       	ldi	r27, 0x00	; 0
				QUERY_Response->InformationBufferOffset = CPU_TO_LE32(sizeof(RNDIS_Query_Complete_t) - sizeof(RNDIS_Message_Header_t));
    25ae:	8c 8b       	std	Y+20, r24	; 0x14
    25b0:	9d 8b       	std	Y+21, r25	; 0x15
    25b2:	ae 8b       	std	Y+22, r26	; 0x16
    25b4:	bf 8b       	std	Y+23, r27	; 0x17
    25b6:	18 c0       	rjmp	.+48     	; 0x25e8 <RNDIS_Device_ProcessControlRequest+0x4da>
    25b8:	8b eb       	ldi	r24, 0xBB	; 187
    25ba:	90 e0       	ldi	r25, 0x00	; 0
    25bc:	a0 e0       	ldi	r26, 0x00	; 0
    25be:	b0 ec       	ldi	r27, 0xC0	; 192
			}
			else
			{
				QUERY_Response->Status                  = CPU_TO_LE32(REMOTE_NDIS_STATUS_NOT_SUPPORTED);
    25c0:	8c 87       	std	Y+12, r24	; 0x0c
    25c2:	9d 87       	std	Y+13, r25	; 0x0d
    25c4:	ae 87       	std	Y+14, r26	; 0x0e
    25c6:	bf 87       	std	Y+15, r27	; 0x0f
    25c8:	88 e1       	ldi	r24, 0x18	; 24
    25ca:	90 e0       	ldi	r25, 0x00	; 0
    25cc:	a0 e0       	ldi	r26, 0x00	; 0
    25ce:	b0 e0       	ldi	r27, 0x00	; 0
				QUERY_Response->MessageLength           = CPU_TO_LE32(sizeof(RNDIS_Query_Complete_t));
    25d0:	8c 83       	std	Y+4, r24	; 0x04
    25d2:	9d 83       	std	Y+5, r25	; 0x05
    25d4:	ae 83       	std	Y+6, r26	; 0x06
    25d6:	bf 83       	std	Y+7, r27	; 0x07
    25d8:	18 8a       	std	Y+16, r1	; 0x10
    25da:	19 8a       	std	Y+17, r1	; 0x11
    25dc:	1a 8a       	std	Y+18, r1	; 0x12
    25de:	1b 8a       	std	Y+19, r1	; 0x13

				QUERY_Response->InformationBufferLength = CPU_TO_LE32(0);
    25e0:	1c 8a       	std	Y+20, r1	; 0x14
    25e2:	1d 8a       	std	Y+21, r1	; 0x15
    25e4:	1e 8a       	std	Y+22, r1	; 0x16
    25e6:	1f 8a       	std	Y+23, r1	; 0x17
				QUERY_Response->InformationBufferOffset = CPU_TO_LE32(0);
    25e8:	df 91       	pop	r29
    25ea:	cf 91       	pop	r28
    25ec:	1f 91       	pop	r17
    25ee:	0f 91       	pop	r16
				MessageHeader->MessageLength = CPU_TO_LE32(0);
			}

			break;
	}
}
    25f0:	ff 90       	pop	r15
    25f2:	ef 90       	pop	r14
    25f4:	df 90       	pop	r13
    25f6:	cf 90       	pop	r12
    25f8:	08 95       	ret

000025fa <RNDIS_Device_ConfigureEndpoints>:
    25fa:	cf 93       	push	r28
    25fc:	df 93       	push	r29
    25fe:	ec 01       	movw	r28, r24
    2600:	fc 01       	movw	r30, r24

bool RNDIS_Device_ConfigureEndpoints(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
	memset(&RNDISInterfaceInfo->State, 0x00, sizeof(RNDISInterfaceInfo->State));
    2602:	7c 96       	adiw	r30, 0x1c	; 28
    2604:	86 e0       	ldi	r24, 0x06	; 6
    2606:	df 01       	movw	r26, r30
    2608:	1d 92       	st	X+, r1
    260a:	8a 95       	dec	r24
    260c:	e9 f7       	brne	.-6      	; 0x2608 <RNDIS_Device_ConfigureEndpoints+0xe>

	RNDISInterfaceInfo->Config.DataINEndpoint.Type       = EP_TYPE_BULK;
    260e:	82 e0       	ldi	r24, 0x02	; 2
    2610:	8c 83       	std	Y+4, r24	; 0x04
	RNDISInterfaceInfo->Config.DataOUTEndpoint.Type      = EP_TYPE_BULK;
    2612:	89 87       	std	Y+9, r24	; 0x09
	RNDISInterfaceInfo->Config.NotificationEndpoint.Type = EP_TYPE_INTERRUPT;
    2614:	83 e0       	ldi	r24, 0x03	; 3
    2616:	8e 87       	std	Y+14, r24	; 0x0e

	if (RNDISInterfaceInfo->Config.MessageBuffer == NULL)
    2618:	88 8d       	ldd	r24, Y+24	; 0x18
    261a:	99 8d       	ldd	r25, Y+25	; 0x19
    261c:	89 2b       	or	r24, r25
    261e:	b9 f0       	breq	.+46     	; 0x264e <RNDIS_Device_ConfigureEndpoints+0x54>
	  return false;

	if (RNDISInterfaceInfo->Config.MessageBufferLength < RNDIS_DEVICE_MIN_MESSAGE_BUFFER_LENGTH)
    2620:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2622:	9b 8d       	ldd	r25, Y+27	; 0x1b
    2624:	84 38       	cpi	r24, 0x84	; 132
    2626:	91 05       	cpc	r25, r1
    2628:	90 f0       	brcs	.+36     	; 0x264e <RNDIS_Device_ConfigureEndpoints+0x54>
	  return false;

	if (!(Endpoint_ConfigureEndpointTable(&RNDISInterfaceInfo->Config.DataINEndpoint, 1)))
    262a:	61 e0       	ldi	r22, 0x01	; 1
    262c:	ce 01       	movw	r24, r28
    262e:	01 96       	adiw	r24, 0x01	; 1
    2630:	43 da       	rcall	.-2938   	; 0x1ab8 <Endpoint_ConfigureEndpointTable>
    2632:	88 23       	and	r24, r24
    2634:	61 f0       	breq	.+24     	; 0x264e <RNDIS_Device_ConfigureEndpoints+0x54>
    2636:	61 e0       	ldi	r22, 0x01	; 1
	  return false;

	if (!(Endpoint_ConfigureEndpointTable(&RNDISInterfaceInfo->Config.DataOUTEndpoint, 1)))
    2638:	ce 01       	movw	r24, r28
    263a:	06 96       	adiw	r24, 0x06	; 6
    263c:	3d da       	rcall	.-2950   	; 0x1ab8 <Endpoint_ConfigureEndpointTable>
    263e:	88 23       	and	r24, r24
    2640:	31 f0       	breq	.+12     	; 0x264e <RNDIS_Device_ConfigureEndpoints+0x54>
    2642:	61 e0       	ldi	r22, 0x01	; 1
    2644:	ce 01       	movw	r24, r28
	  return false;

	if (!(Endpoint_ConfigureEndpointTable(&RNDISInterfaceInfo->Config.NotificationEndpoint, 1)))
    2646:	0b 96       	adiw	r24, 0x0b	; 11
    2648:	df 91       	pop	r29
    264a:	cf 91       	pop	r28
	  return false;

	return true;
}
    264c:	35 ca       	rjmp	.-2966   	; 0x1ab8 <Endpoint_ConfigureEndpointTable>
    264e:	80 e0       	ldi	r24, 0x00	; 0
	  return false;

	if (!(Endpoint_ConfigureEndpointTable(&RNDISInterfaceInfo->Config.DataOUTEndpoint, 1)))
	  return false;

	if (!(Endpoint_ConfigureEndpointTable(&RNDISInterfaceInfo->Config.NotificationEndpoint, 1)))
    2650:	df 91       	pop	r29
    2652:	cf 91       	pop	r28
	  return false;

	return true;
}
    2654:	08 95       	ret

00002656 <RNDIS_Device_USBTask>:
    2656:	0f 93       	push	r16
    2658:	1f 93       	push	r17
    265a:	cf 93       	push	r28

void RNDIS_Device_USBTask(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
    265c:	df 93       	push	r29
    265e:	cd b7       	in	r28, 0x3d	; 61
    2660:	de b7       	in	r29, 0x3e	; 62
    2662:	28 97       	sbiw	r28, 0x08	; 8
    2664:	0f b6       	in	r0, 0x3f	; 63
    2666:	f8 94       	cli
    2668:	de bf       	out	0x3e, r29	; 62
    266a:	0f be       	out	0x3f, r0	; 63
    266c:	cd bf       	out	0x3d, r28	; 61
    266e:	8c 01       	movw	r16, r24
	if (USB_DeviceState != DEVICE_STATE_Configured)
    2670:	80 91 46 14 	lds	r24, 0x1446
    2674:	84 30       	cpi	r24, 0x04	; 4
    2676:	19 f5       	brne	.+70     	; 0x26be <RNDIS_Device_USBTask+0x68>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    2678:	f8 01       	movw	r30, r16
    267a:	83 85       	ldd	r24, Z+11	; 0x0b
    267c:	8f 70       	andi	r24, 0x0F	; 15
    267e:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    2682:	80 91 e8 00 	lds	r24, 0x00E8
	  return;

	Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.NotificationEndpoint.Address);

	if (Endpoint_IsINReady() && RNDISInterfaceInfo->State.ResponseReady)
    2686:	80 ff       	sbrs	r24, 0
    2688:	1a c0       	rjmp	.+52     	; 0x26be <RNDIS_Device_USBTask+0x68>
    268a:	84 8d       	ldd	r24, Z+28	; 0x1c
    268c:	88 23       	and	r24, r24
    268e:	b9 f0       	breq	.+46     	; 0x26be <RNDIS_Device_USBTask+0x68>
	{
		USB_Request_Header_t Notification = (USB_Request_Header_t)
    2690:	88 e0       	ldi	r24, 0x08	; 8
    2692:	e0 e4       	ldi	r30, 0x40	; 64
    2694:	f1 e0       	ldi	r31, 0x01	; 1
    2696:	de 01       	movw	r26, r28
    2698:	11 96       	adiw	r26, 0x01	; 1
    269a:	01 90       	ld	r0, Z+
    269c:	0d 92       	st	X+, r0
    269e:	8a 95       	dec	r24
    26a0:	e1 f7       	brne	.-8      	; 0x269a <RNDIS_Device_USBTask+0x44>
				.wValue        = CPU_TO_LE16(0),
				.wIndex        = CPU_TO_LE16(0),
				.wLength       = CPU_TO_LE16(0),
			};

		Endpoint_Write_Stream_LE(&Notification, sizeof(USB_Request_Header_t), NULL);
    26a2:	40 e0       	ldi	r20, 0x00	; 0
    26a4:	50 e0       	ldi	r21, 0x00	; 0
    26a6:	68 e0       	ldi	r22, 0x08	; 8
    26a8:	70 e0       	ldi	r23, 0x00	; 0
    26aa:	ce 01       	movw	r24, r28
    26ac:	01 96       	adiw	r24, 0x01	; 1
    26ae:	44 d8       	rcall	.-3960   	; 0x1738 <Endpoint_Write_Stream_LE>
    26b0:	80 91 e8 00 	lds	r24, 0x00E8
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    26b4:	8e 77       	andi	r24, 0x7E	; 126
    26b6:	80 93 e8 00 	sts	0x00E8, r24
    26ba:	f8 01       	movw	r30, r16

		Endpoint_ClearIN();

		RNDISInterfaceInfo->State.ResponseReady = false;
    26bc:	14 8e       	std	Z+28, r1	; 0x1c
    26be:	28 96       	adiw	r28, 0x08	; 8
	}
}
    26c0:	0f b6       	in	r0, 0x3f	; 63
    26c2:	f8 94       	cli
    26c4:	de bf       	out	0x3e, r29	; 62
    26c6:	0f be       	out	0x3f, r0	; 63
    26c8:	cd bf       	out	0x3d, r28	; 61
    26ca:	df 91       	pop	r29
    26cc:	cf 91       	pop	r28
    26ce:	1f 91       	pop	r17
    26d0:	0f 91       	pop	r16
    26d2:	08 95       	ret

000026d4 <RNDIS_Device_IsPacketReceived>:
    26d4:	20 91 46 14 	lds	r18, 0x1446
	}
}

bool RNDIS_Device_IsPacketReceived(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
    26d8:	24 30       	cpi	r18, 0x04	; 4
    26da:	71 f4       	brne	.+28     	; 0x26f8 <RNDIS_Device_IsPacketReceived+0x24>
    26dc:	fc 01       	movw	r30, r24
    26de:	25 8d       	ldd	r18, Z+29	; 0x1d
    26e0:	22 30       	cpi	r18, 0x02	; 2
    26e2:	51 f4       	brne	.+20     	; 0x26f8 <RNDIS_Device_IsPacketReceived+0x24>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    26e4:	86 81       	ldd	r24, Z+6	; 0x06
    26e6:	8f 70       	andi	r24, 0x0F	; 15
    26e8:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    26ec:	80 91 e8 00 	lds	r24, 0x00E8
    26f0:	82 fb       	bst	r24, 2
    26f2:	88 27       	eor	r24, r24
    26f4:	80 f9       	bld	r24, 0
	{
		return false;
	}

	Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.DataOUTEndpoint.Address);
	return Endpoint_IsOUTReceived();
    26f6:	08 95       	ret
bool RNDIS_Device_IsPacketReceived(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
	{
		return false;
    26f8:	80 e0       	ldi	r24, 0x00	; 0
	}

	Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.DataOUTEndpoint.Address);
	return Endpoint_IsOUTReceived();
}
    26fa:	08 95       	ret

000026fc <RNDIS_Device_ReadPacket>:

uint8_t RNDIS_Device_ReadPacket(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo,
                                void* Buffer,
                                uint16_t* const PacketLength)
{
    26fc:	ef 92       	push	r14
    26fe:	ff 92       	push	r15
    2700:	0f 93       	push	r16
    2702:	1f 93       	push	r17
    2704:	cf 93       	push	r28
    2706:	df 93       	push	r29
    2708:	cd b7       	in	r28, 0x3d	; 61
    270a:	de b7       	in	r29, 0x3e	; 62
    270c:	ac 97       	sbiw	r28, 0x2c	; 44
    270e:	0f b6       	in	r0, 0x3f	; 63
    2710:	f8 94       	cli
    2712:	de bf       	out	0x3e, r29	; 62
    2714:	0f be       	out	0x3f, r0	; 63
    2716:	cd bf       	out	0x3d, r28	; 61
    2718:	fc 01       	movw	r30, r24
    271a:	7b 01       	movw	r14, r22
    271c:	8a 01       	movw	r16, r20
	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
    271e:	80 91 46 14 	lds	r24, 0x1446
    2722:	84 30       	cpi	r24, 0x04	; 4
    2724:	99 f5       	brne	.+102    	; 0x278c <RNDIS_Device_ReadPacket+0x90>
    2726:	85 8d       	ldd	r24, Z+29	; 0x1d
    2728:	82 30       	cpi	r24, 0x02	; 2
    272a:	81 f5       	brne	.+96     	; 0x278c <RNDIS_Device_ReadPacket+0x90>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    272c:	86 81       	ldd	r24, Z+6	; 0x06
    272e:	8f 70       	andi	r24, 0x0F	; 15
    2730:	80 93 e9 00 	sts	0x00E9, r24
		return ENDPOINT_RWSTREAM_DeviceDisconnected;
	}

	Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.DataOUTEndpoint.Address);

	*PacketLength = 0;
    2734:	fa 01       	movw	r30, r20
    2736:	11 82       	std	Z+1, r1	; 0x01
    2738:	10 82       	st	Z, r1
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    273a:	80 91 e8 00 	lds	r24, 0x00E8

	if (!(Endpoint_IsOUTReceived()))
    273e:	82 ff       	sbrs	r24, 2
    2740:	27 c0       	rjmp	.+78     	; 0x2790 <RNDIS_Device_ReadPacket+0x94>
		return ENDPOINT_RWSTREAM_NoError;

	RNDIS_Packet_Message_t RNDISPacketHeader;
	Endpoint_Read_Stream_LE(&RNDISPacketHeader, sizeof(RNDIS_Packet_Message_t), NULL);
    2742:	40 e0       	ldi	r20, 0x00	; 0
    2744:	50 e0       	ldi	r21, 0x00	; 0
    2746:	6c e2       	ldi	r22, 0x2C	; 44
    2748:	70 e0       	ldi	r23, 0x00	; 0
    274a:	ce 01       	movw	r24, r28
    274c:	01 96       	adiw	r24, 0x01	; 1
    274e:	3c d8       	rcall	.-3976   	; 0x17c8 <Endpoint_Read_Stream_LE>
    2750:	6d 85       	ldd	r22, Y+13	; 0x0d

	if (le32_to_cpu(RNDISPacketHeader.DataLength) > ETHERNET_FRAME_SIZE_MAX)
    2752:	7e 85       	ldd	r23, Y+14	; 0x0e
    2754:	8f 85       	ldd	r24, Y+15	; 0x0f
    2756:	98 89       	ldd	r25, Y+16	; 0x10
    2758:	6d 3d       	cpi	r22, 0xDD	; 221
    275a:	f5 e0       	ldi	r31, 0x05	; 5
    275c:	7f 07       	cpc	r23, r31
    275e:	81 05       	cpc	r24, r1
    2760:	91 05       	cpc	r25, r1
    2762:	38 f0       	brcs	.+14     	; 0x2772 <RNDIS_Device_ReadPacket+0x76>
    2764:	80 91 eb 00 	lds	r24, 0x00EB
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    2768:	80 62       	ori	r24, 0x20	; 32
    276a:	80 93 eb 00 	sts	0x00EB, r24
    276e:	80 e8       	ldi	r24, 0x80	; 128
	{
		Endpoint_StallTransaction();

		return RNDIS_ERROR_LOGICAL_CMD_FAILED;
    2770:	10 c0       	rjmp	.+32     	; 0x2792 <RNDIS_Device_ReadPacket+0x96>
    2772:	f8 01       	movw	r30, r16
	}

	*PacketLength = (uint16_t)le32_to_cpu(RNDISPacketHeader.DataLength);
    2774:	71 83       	std	Z+1, r23	; 0x01
    2776:	60 83       	st	Z, r22
    2778:	40 e0       	ldi	r20, 0x00	; 0

	Endpoint_Read_Stream_LE(Buffer, *PacketLength, NULL);
    277a:	50 e0       	ldi	r21, 0x00	; 0
    277c:	c7 01       	movw	r24, r14
    277e:	24 d8       	rcall	.-4024   	; 0x17c8 <Endpoint_Read_Stream_LE>
    2780:	80 91 e8 00 	lds	r24, 0x00E8
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    2784:	8b 77       	andi	r24, 0x7B	; 123
    2786:	80 93 e8 00 	sts	0x00E8, r24
    278a:	02 c0       	rjmp	.+4      	; 0x2790 <RNDIS_Device_ReadPacket+0x94>
    278c:	82 e0       	ldi	r24, 0x02	; 2
    278e:	01 c0       	rjmp	.+2      	; 0x2792 <RNDIS_Device_ReadPacket+0x96>
                                uint16_t* const PacketLength)
{
	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
	{
		return ENDPOINT_RWSTREAM_DeviceDisconnected;
    2790:	80 e0       	ldi	r24, 0x00	; 0
    2792:	ac 96       	adiw	r28, 0x2c	; 44
	Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.DataOUTEndpoint.Address);

	*PacketLength = 0;

	if (!(Endpoint_IsOUTReceived()))
		return ENDPOINT_RWSTREAM_NoError;
    2794:	0f b6       	in	r0, 0x3f	; 63

	Endpoint_Read_Stream_LE(Buffer, *PacketLength, NULL);
	Endpoint_ClearOUT();

	return ENDPOINT_RWSTREAM_NoError;
}
    2796:	f8 94       	cli
    2798:	de bf       	out	0x3e, r29	; 62
    279a:	0f be       	out	0x3f, r0	; 63
    279c:	cd bf       	out	0x3d, r28	; 61
    279e:	df 91       	pop	r29
    27a0:	cf 91       	pop	r28
    27a2:	1f 91       	pop	r17
    27a4:	0f 91       	pop	r16
    27a6:	ff 90       	pop	r15
    27a8:	ef 90       	pop	r14
    27aa:	08 95       	ret

000027ac <RNDIS_Device_SendPacket>:
    27ac:	cf 92       	push	r12
    27ae:	df 92       	push	r13

uint8_t RNDIS_Device_SendPacket(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo,
                                void* Buffer,
                                const uint16_t PacketLength)
{
    27b0:	ef 92       	push	r14
    27b2:	ff 92       	push	r15
    27b4:	0f 93       	push	r16
    27b6:	1f 93       	push	r17
    27b8:	cf 93       	push	r28
    27ba:	df 93       	push	r29
    27bc:	cd b7       	in	r28, 0x3d	; 61
    27be:	de b7       	in	r29, 0x3e	; 62
    27c0:	ac 97       	sbiw	r28, 0x2c	; 44
    27c2:	0f b6       	in	r0, 0x3f	; 63
    27c4:	f8 94       	cli
    27c6:	de bf       	out	0x3e, r29	; 62
    27c8:	0f be       	out	0x3f, r0	; 63
    27ca:	cd bf       	out	0x3d, r28	; 61
    27cc:	6b 01       	movw	r12, r22
    27ce:	7a 01       	movw	r14, r20
	uint8_t ErrorCode;

	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
    27d0:	20 91 46 14 	lds	r18, 0x1446
    27d4:	24 30       	cpi	r18, 0x04	; 4
    27d6:	09 f0       	breq	.+2      	; 0x27da <RNDIS_Device_SendPacket+0x2e>
    27d8:	46 c0       	rjmp	.+140    	; 0x2866 <RNDIS_Device_SendPacket+0xba>
    27da:	fc 01       	movw	r30, r24
    27dc:	25 8d       	ldd	r18, Z+29	; 0x1d
    27de:	22 30       	cpi	r18, 0x02	; 2
    27e0:	09 f0       	breq	.+2      	; 0x27e4 <RNDIS_Device_SendPacket+0x38>
    27e2:	41 c0       	rjmp	.+130    	; 0x2866 <RNDIS_Device_SendPacket+0xba>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    27e4:	81 81       	ldd	r24, Z+1	; 0x01
    27e6:	8f 70       	andi	r24, 0x0F	; 15
    27e8:	80 93 e9 00 	sts	0x00E9, r24
		return ENDPOINT_RWSTREAM_DeviceDisconnected;
	}

	Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.DataINEndpoint.Address);

	if ((ErrorCode = Endpoint_WaitUntilReady()) != ENDPOINT_READYWAIT_NoError)
    27ec:	c3 d9       	rcall	.-3194   	; 0x1b74 <Endpoint_WaitUntilReady>
    27ee:	81 11       	cpse	r24, r1
    27f0:	3b c0       	rjmp	.+118    	; 0x2868 <RNDIS_Device_SendPacket+0xbc>
    27f2:	ce 01       	movw	r24, r28
	  return ErrorCode;

	RNDIS_Packet_Message_t RNDISPacketHeader;

	memset(&RNDISPacketHeader, 0, sizeof(RNDIS_Packet_Message_t));
    27f4:	01 96       	adiw	r24, 0x01	; 1
    27f6:	2c e2       	ldi	r18, 0x2C	; 44
    27f8:	fc 01       	movw	r30, r24
    27fa:	11 92       	st	Z+, r1
    27fc:	2a 95       	dec	r18
    27fe:	e9 f7       	brne	.-6      	; 0x27fa <RNDIS_Device_SendPacket+0x4e>
    2800:	41 e0       	ldi	r20, 0x01	; 1

	RNDISPacketHeader.MessageType   = CPU_TO_LE32(REMOTE_NDIS_PACKET_MSG);
    2802:	50 e0       	ldi	r21, 0x00	; 0
    2804:	60 e0       	ldi	r22, 0x00	; 0
    2806:	70 e0       	ldi	r23, 0x00	; 0
    2808:	49 83       	std	Y+1, r20	; 0x01
    280a:	5a 83       	std	Y+2, r21	; 0x02
    280c:	6b 83       	std	Y+3, r22	; 0x03
    280e:	7c 83       	std	Y+4, r23	; 0x04
    2810:	a7 01       	movw	r20, r14
	RNDISPacketHeader.MessageLength = cpu_to_le32(sizeof(RNDIS_Packet_Message_t) + PacketLength);
    2812:	44 5d       	subi	r20, 0xD4	; 212
    2814:	5f 4f       	sbci	r21, 0xFF	; 255
    2816:	60 e0       	ldi	r22, 0x00	; 0
    2818:	70 e0       	ldi	r23, 0x00	; 0
    281a:	4d 83       	std	Y+5, r20	; 0x05
    281c:	5e 83       	std	Y+6, r21	; 0x06
    281e:	6f 83       	std	Y+7, r22	; 0x07
    2820:	78 87       	std	Y+8, r23	; 0x08
    2822:	44 e2       	ldi	r20, 0x24	; 36
	RNDISPacketHeader.DataOffset    = CPU_TO_LE32(sizeof(RNDIS_Packet_Message_t) - sizeof(RNDIS_Message_Header_t));
    2824:	50 e0       	ldi	r21, 0x00	; 0
    2826:	60 e0       	ldi	r22, 0x00	; 0
    2828:	70 e0       	ldi	r23, 0x00	; 0
    282a:	49 87       	std	Y+9, r20	; 0x09
    282c:	5a 87       	std	Y+10, r21	; 0x0a
    282e:	6b 87       	std	Y+11, r22	; 0x0b
    2830:	7c 87       	std	Y+12, r23	; 0x0c
    2832:	87 01       	movw	r16, r14
	RNDISPacketHeader.DataLength    = cpu_to_le32(PacketLength);
    2834:	20 e0       	ldi	r18, 0x00	; 0
    2836:	30 e0       	ldi	r19, 0x00	; 0
    2838:	0d 87       	std	Y+13, r16	; 0x0d
    283a:	1e 87       	std	Y+14, r17	; 0x0e
    283c:	2f 87       	std	Y+15, r18	; 0x0f
    283e:	38 8b       	std	Y+16, r19	; 0x10
    2840:	40 e0       	ldi	r20, 0x00	; 0

	Endpoint_Write_Stream_LE(&RNDISPacketHeader, sizeof(RNDIS_Packet_Message_t), NULL);
    2842:	50 e0       	ldi	r21, 0x00	; 0
    2844:	6c e2       	ldi	r22, 0x2C	; 44
    2846:	70 e0       	ldi	r23, 0x00	; 0
    2848:	0e 94 9c 0b 	call	0x1738	; 0x1738 <Endpoint_Write_Stream_LE>
    284c:	40 e0       	ldi	r20, 0x00	; 0
	Endpoint_Write_Stream_LE(Buffer, PacketLength, NULL);
    284e:	50 e0       	ldi	r21, 0x00	; 0
    2850:	b7 01       	movw	r22, r14
    2852:	c6 01       	movw	r24, r12
    2854:	0e 94 9c 0b 	call	0x1738	; 0x1738 <Endpoint_Write_Stream_LE>
    2858:	80 91 e8 00 	lds	r24, 0x00E8
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    285c:	8e 77       	andi	r24, 0x7E	; 126
    285e:	80 93 e8 00 	sts	0x00E8, r24
    2862:	80 e0       	ldi	r24, 0x00	; 0
	Endpoint_ClearIN();

	return ENDPOINT_RWSTREAM_NoError;
    2864:	01 c0       	rjmp	.+2      	; 0x2868 <RNDIS_Device_SendPacket+0xbc>
    2866:	82 e0       	ldi	r24, 0x02	; 2
	uint8_t ErrorCode;

	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
	{
		return ENDPOINT_RWSTREAM_DeviceDisconnected;
    2868:	ac 96       	adiw	r28, 0x2c	; 44
	Endpoint_Write_Stream_LE(&RNDISPacketHeader, sizeof(RNDIS_Packet_Message_t), NULL);
	Endpoint_Write_Stream_LE(Buffer, PacketLength, NULL);
	Endpoint_ClearIN();

	return ENDPOINT_RWSTREAM_NoError;
}
    286a:	0f b6       	in	r0, 0x3f	; 63
    286c:	f8 94       	cli
    286e:	de bf       	out	0x3e, r29	; 62
    2870:	0f be       	out	0x3f, r0	; 63
    2872:	cd bf       	out	0x3d, r28	; 61
    2874:	df 91       	pop	r29
    2876:	cf 91       	pop	r28
    2878:	1f 91       	pop	r17
    287a:	0f 91       	pop	r16
    287c:	ff 90       	pop	r15
    287e:	ef 90       	pop	r14
    2880:	df 90       	pop	r13
    2882:	cf 90       	pop	r12
    2884:	08 95       	ret

00002886 <Serial_putchar>:
    2886:	90 91 c8 00 	lds	r25, 0x00C8
			 *  \param[in] DataByte  Byte to transmit through the USART.
			 */
			static inline void Serial_SendByte(const char DataByte) ATTR_ALWAYS_INLINE;
			static inline void Serial_SendByte(const char DataByte)
			{
				while (!(Serial_IsSendReady()));
    288a:	95 ff       	sbrs	r25, 5
    288c:	fc cf       	rjmp	.-8      	; 0x2886 <Serial_putchar>
				UDR1 = DataByte;
    288e:	80 93 ce 00 	sts	0x00CE, r24
{
	(void)Stream;

	Serial_SendByte(DataByte);
	return 0;
}
    2892:	80 e0       	ldi	r24, 0x00	; 0
    2894:	90 e0       	ldi	r25, 0x00	; 0
    2896:	08 95       	ret

00002898 <Serial_getchar>:
			 *  \return Boolean \c true if a character has been received, \c false otherwise.
			 */
			static inline bool Serial_IsCharReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Serial_IsCharReceived(void)
			{
				return ((UCSR1A & (1 << RXC1)) ? true : false);
    2898:	80 91 c8 00 	lds	r24, 0x00C8

int Serial_getchar(FILE *Stream)
{
	(void)Stream;

	if (!(Serial_IsCharReceived()))
    289c:	87 ff       	sbrs	r24, 7
    289e:	08 c0       	rjmp	.+16     	; 0x28b0 <Serial_getchar+0x18>
    28a0:	80 91 c8 00 	lds	r24, 0x00C8
			 *  \return Next byte received from the USART, or a negative value if no byte has been received.
			 */
			static inline int16_t Serial_ReceiveByte(void) ATTR_ALWAYS_INLINE;
			static inline int16_t Serial_ReceiveByte(void)
			{
				if (!(Serial_IsCharReceived()))
    28a4:	87 ff       	sbrs	r24, 7
    28a6:	07 c0       	rjmp	.+14     	; 0x28b6 <Serial_getchar+0x1e>
				  return -1;

				return UDR1;
    28a8:	80 91 ce 00 	lds	r24, 0x00CE
    28ac:	90 e0       	ldi	r25, 0x00	; 0
    28ae:	08 95       	ret
	  return _FDEV_EOF;
    28b0:	8e ef       	ldi	r24, 0xFE	; 254
    28b2:	9f ef       	ldi	r25, 0xFF	; 255
    28b4:	08 95       	ret
			 */
			static inline int16_t Serial_ReceiveByte(void) ATTR_ALWAYS_INLINE;
			static inline int16_t Serial_ReceiveByte(void)
			{
				if (!(Serial_IsCharReceived()))
				  return -1;
    28b6:	8f ef       	ldi	r24, 0xFF	; 255
    28b8:	9f ef       	ldi	r25, 0xFF	; 255

	return Serial_ReceiveByte();
}
    28ba:	08 95       	ret

000028bc <Serial_CreateStream>:
	while (Length--)
	  Serial_SendByte(*((uint8_t*)Buffer++));
}

void Serial_CreateStream(FILE* Stream)
{
    28bc:	fc 01       	movw	r30, r24
	if (!(Stream))
    28be:	00 97       	sbiw	r24, 0x00	; 0
    28c0:	59 f4       	brne	.+22     	; 0x28d8 <Serial_CreateStream+0x1c>
	{
		Stream = &USARTSerialStream;
		stdin  = Stream;
    28c2:	8f e4       	ldi	r24, 0x4F	; 79
    28c4:	94 e1       	ldi	r25, 0x14	; 20
    28c6:	90 93 5e 14 	sts	0x145E, r25
    28ca:	80 93 5d 14 	sts	0x145D, r24
		stdout = Stream;
    28ce:	90 93 60 14 	sts	0x1460, r25
    28d2:	80 93 5f 14 	sts	0x145F, r24

void Serial_CreateStream(FILE* Stream)
{
	if (!(Stream))
	{
		Stream = &USARTSerialStream;
    28d6:	fc 01       	movw	r30, r24
		stdin  = Stream;
		stdout = Stream;
	}

	*Stream = (FILE)FDEV_SETUP_STREAM(Serial_putchar, Serial_getchar, _FDEV_SETUP_RW);
    28d8:	8e e0       	ldi	r24, 0x0E	; 14
    28da:	df 01       	movw	r26, r30
    28dc:	1d 92       	st	X+, r1
    28de:	8a 95       	dec	r24
    28e0:	e9 f7       	brne	.-6      	; 0x28dc <Serial_CreateStream+0x20>
    28e2:	83 e0       	ldi	r24, 0x03	; 3
    28e4:	83 83       	std	Z+3, r24	; 0x03
    28e6:	83 e4       	ldi	r24, 0x43	; 67
    28e8:	94 e1       	ldi	r25, 0x14	; 20
    28ea:	91 87       	std	Z+9, r25	; 0x09
    28ec:	80 87       	std	Z+8, r24	; 0x08
    28ee:	8c e4       	ldi	r24, 0x4C	; 76
    28f0:	94 e1       	ldi	r25, 0x14	; 20
    28f2:	93 87       	std	Z+11, r25	; 0x0b
    28f4:	82 87       	std	Z+10, r24	; 0x0a
    28f6:	08 95       	ret

000028f8 <memcpy_P>:
    28f8:	fb 01       	movw	r30, r22
    28fa:	dc 01       	movw	r26, r24
    28fc:	02 c0       	rjmp	.+4      	; 0x2902 <memcpy_P+0xa>
    28fe:	05 90       	lpm	r0, Z+
    2900:	0d 92       	st	X+, r0
    2902:	41 50       	subi	r20, 0x01	; 1
    2904:	50 40       	sbci	r21, 0x00	; 0
    2906:	d8 f7       	brcc	.-10     	; 0x28fe <memcpy_P+0x6>
    2908:	08 95       	ret

0000290a <strcpy_P>:
    290a:	fb 01       	movw	r30, r22
    290c:	dc 01       	movw	r26, r24
    290e:	05 90       	lpm	r0, Z+
    2910:	0d 92       	st	X+, r0
    2912:	00 20       	and	r0, r0
    2914:	e1 f7       	brne	.-8      	; 0x290e <strcpy_P+0x4>
    2916:	08 95       	ret

00002918 <__strlen_P>:
    2918:	fc 01       	movw	r30, r24
    291a:	05 90       	lpm	r0, Z+
    291c:	00 20       	and	r0, r0
    291e:	e9 f7       	brne	.-6      	; 0x291a <__strlen_P+0x2>
    2920:	80 95       	com	r24
    2922:	90 95       	com	r25
    2924:	8e 0f       	add	r24, r30
    2926:	9f 1f       	adc	r25, r31
    2928:	08 95       	ret

0000292a <strncpy_P>:
    292a:	fb 01       	movw	r30, r22
    292c:	dc 01       	movw	r26, r24
    292e:	41 50       	subi	r20, 0x01	; 1
    2930:	50 40       	sbci	r21, 0x00	; 0
    2932:	48 f0       	brcs	.+18     	; 0x2946 <strncpy_P+0x1c>
    2934:	05 90       	lpm	r0, Z+
    2936:	0d 92       	st	X+, r0
    2938:	00 20       	and	r0, r0
    293a:	c9 f7       	brne	.-14     	; 0x292e <strncpy_P+0x4>
    293c:	01 c0       	rjmp	.+2      	; 0x2940 <strncpy_P+0x16>
    293e:	1d 92       	st	X+, r1
    2940:	41 50       	subi	r20, 0x01	; 1
    2942:	50 40       	sbci	r21, 0x00	; 0
    2944:	e0 f7       	brcc	.-8      	; 0x293e <strncpy_P+0x14>
    2946:	08 95       	ret

00002948 <memcmp>:
    2948:	fb 01       	movw	r30, r22
    294a:	dc 01       	movw	r26, r24
    294c:	04 c0       	rjmp	.+8      	; 0x2956 <memcmp+0xe>
    294e:	8d 91       	ld	r24, X+
    2950:	01 90       	ld	r0, Z+
    2952:	80 19       	sub	r24, r0
    2954:	21 f4       	brne	.+8      	; 0x295e <memcmp+0x16>
    2956:	41 50       	subi	r20, 0x01	; 1
    2958:	50 40       	sbci	r21, 0x00	; 0
    295a:	c8 f7       	brcc	.-14     	; 0x294e <memcmp+0x6>
    295c:	88 1b       	sub	r24, r24
    295e:	99 0b       	sbc	r25, r25
    2960:	08 95       	ret

00002962 <memcpy>:
    2962:	fb 01       	movw	r30, r22
    2964:	dc 01       	movw	r26, r24
    2966:	02 c0       	rjmp	.+4      	; 0x296c <memcpy+0xa>
    2968:	01 90       	ld	r0, Z+
    296a:	0d 92       	st	X+, r0
    296c:	41 50       	subi	r20, 0x01	; 1
    296e:	50 40       	sbci	r21, 0x00	; 0
    2970:	d8 f7       	brcc	.-10     	; 0x2968 <memcpy+0x6>
    2972:	08 95       	ret

00002974 <memmove>:
    2974:	68 17       	cp	r22, r24
    2976:	79 07       	cpc	r23, r25
    2978:	68 f4       	brcc	.+26     	; 0x2994 <memmove+0x20>
    297a:	fb 01       	movw	r30, r22
    297c:	dc 01       	movw	r26, r24
    297e:	e4 0f       	add	r30, r20
    2980:	f5 1f       	adc	r31, r21
    2982:	a4 0f       	add	r26, r20
    2984:	b5 1f       	adc	r27, r21
    2986:	02 c0       	rjmp	.+4      	; 0x298c <memmove+0x18>
    2988:	02 90       	ld	r0, -Z
    298a:	0e 92       	st	-X, r0
    298c:	41 50       	subi	r20, 0x01	; 1
    298e:	50 40       	sbci	r21, 0x00	; 0
    2990:	d8 f7       	brcc	.-10     	; 0x2988 <memmove+0x14>
    2992:	08 95       	ret
    2994:	e6 cf       	rjmp	.-52     	; 0x2962 <memcpy>

00002996 <strncmp>:
    2996:	fb 01       	movw	r30, r22
    2998:	dc 01       	movw	r26, r24
    299a:	41 50       	subi	r20, 0x01	; 1
    299c:	50 40       	sbci	r21, 0x00	; 0
    299e:	30 f0       	brcs	.+12     	; 0x29ac <strncmp+0x16>
    29a0:	8d 91       	ld	r24, X+
    29a2:	01 90       	ld	r0, Z+
    29a4:	80 19       	sub	r24, r0
    29a6:	19 f4       	brne	.+6      	; 0x29ae <strncmp+0x18>
    29a8:	00 20       	and	r0, r0
    29aa:	b9 f7       	brne	.-18     	; 0x299a <strncmp+0x4>
    29ac:	88 1b       	sub	r24, r24
    29ae:	99 0b       	sbc	r25, r25
    29b0:	08 95       	ret

000029b2 <_exit>:
    29b2:	f8 94       	cli

000029b4 <__stop_program>:
    29b4:	ff cf       	rjmp	.-2      	; 0x29b4 <__stop_program>
