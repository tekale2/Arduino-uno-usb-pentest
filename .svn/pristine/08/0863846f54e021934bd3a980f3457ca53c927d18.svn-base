
RNDISEthernet.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000046  00800100  00002940  000029d4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002940  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000012af  00800146  00800146  00002a1a  2**0
                  ALLOC
  3 .stab         0000120c  00000000  00000000  00002a1c  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000ec8  00000000  00000000  00003c28  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  00004af0  2**0
                  CONTENTS, READONLY
  6 .debug_aranges 00000570  00000000  00000000  00004b01  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   000095b0  00000000  00000000  00005071  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00002982  00000000  00000000  0000e621  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00003815  00000000  00000000  00010fa3  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000e74  00000000  00000000  000147b8  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000037ec  00000000  00000000  0001562c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00005eb1  00000000  00000000  00018e18  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 000006a0  00000000  00000000  0001ecc9  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
#include "HIDParser.h"

uint8_t USB_ProcessHIDReport(const uint8_t* ReportData,
                             uint16_t ReportSize,
                             HID_ReportInfo_t* const ParserData)
{
       0:	1d c2       	rjmp	.+1082   	; 0x43c <__ctors_end>
       2:	00 00       	nop
       4:	39 c2       	rjmp	.+1138   	; 0x478 <__bad_interrupt>
       6:	00 00       	nop
       8:	37 c2       	rjmp	.+1134   	; 0x478 <__bad_interrupt>
       a:	00 00       	nop
       c:	35 c2       	rjmp	.+1130   	; 0x478 <__bad_interrupt>
       e:	00 00       	nop
      10:	33 c2       	rjmp	.+1126   	; 0x478 <__bad_interrupt>
      12:	00 00       	nop
      14:	31 c2       	rjmp	.+1122   	; 0x478 <__bad_interrupt>
      16:	00 00       	nop
      18:	2f c2       	rjmp	.+1118   	; 0x478 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	2d c2       	rjmp	.+1114   	; 0x478 <__bad_interrupt>
      1e:	00 00       	nop
      20:	2b c2       	rjmp	.+1110   	; 0x478 <__bad_interrupt>
      22:	00 00       	nop
      24:	29 c2       	rjmp	.+1106   	; 0x478 <__bad_interrupt>
      26:	00 00       	nop
      28:	0c 94 cb 11 	jmp	0x2396	; 0x2396 <__vector_10>
      2c:	25 c2       	rjmp	.+1098   	; 0x478 <__bad_interrupt>
      2e:	00 00       	nop
      30:	23 c2       	rjmp	.+1094   	; 0x478 <__bad_interrupt>
      32:	00 00       	nop
      34:	21 c2       	rjmp	.+1090   	; 0x478 <__bad_interrupt>
      36:	00 00       	nop
	HID_StateTable_t      StateTable[HID_STATETABLE_STACK_DEPTH];
	HID_StateTable_t*     CurrStateTable     = &StateTable[0];
	HID_CollectionPath_t* CurrCollectionPath = NULL;
	HID_ReportSizeInfo_t* CurrReportIDInfo   = &ParserData->ReportIDSizes[0];
      38:	1f c2       	rjmp	.+1086   	; 0x478 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	1d c2       	rjmp	.+1082   	; 0x478 <__bad_interrupt>
      3e:	00 00       	nop
      40:	1b c2       	rjmp	.+1078   	; 0x478 <__bad_interrupt>
      42:	00 00       	nop
      44:	19 c2       	rjmp	.+1074   	; 0x478 <__bad_interrupt>
	uint16_t              UsageList[HID_USAGE_STACK_DEPTH];
	uint8_t               UsageListSize      = 0;
	HID_MinMax_t          UsageMinMax        = {0, 0};

	memset(ParserData,       0x00, sizeof(HID_ReportInfo_t));
      46:	00 00       	nop
      48:	17 c2       	rjmp	.+1070   	; 0x478 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	15 c2       	rjmp	.+1066   	; 0x478 <__bad_interrupt>
      4e:	00 00       	nop
      50:	13 c2       	rjmp	.+1062   	; 0x478 <__bad_interrupt>
      52:	00 00       	nop
	memset(CurrStateTable,   0x00, sizeof(HID_StateTable_t));
      54:	11 c2       	rjmp	.+1058   	; 0x478 <__bad_interrupt>
      56:	00 00       	nop
      58:	0f c2       	rjmp	.+1054   	; 0x478 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	0d c2       	rjmp	.+1050   	; 0x478 <__bad_interrupt>
      5e:	00 00       	nop
      60:	0b c2       	rjmp	.+1046   	; 0x478 <__bad_interrupt>
	memset(CurrReportIDInfo, 0x00, sizeof(HID_ReportSizeInfo_t));
      62:	00 00       	nop
      64:	09 c2       	rjmp	.+1042   	; 0x478 <__bad_interrupt>
      66:	00 00       	nop
      68:	07 c2       	rjmp	.+1038   	; 0x478 <__bad_interrupt>
      6a:	00 00       	nop

	ParserData->TotalDeviceReports = 1;
      6c:	05 c2       	rjmp	.+1034   	; 0x478 <__bad_interrupt>
      6e:	00 00       	nop
      70:	03 c2       	rjmp	.+1030   	; 0x478 <__bad_interrupt>
      72:	00 00       	nop
      74:	01 c2       	rjmp	.+1026   	; 0x478 <__bad_interrupt>
      76:	00 00       	nop
      78:	ff c1       	rjmp	.+1022   	; 0x478 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	fd c1       	rjmp	.+1018   	; 0x478 <__bad_interrupt>
      7e:	00 00       	nop
	HID_StateTable_t*     CurrStateTable     = &StateTable[0];
	HID_CollectionPath_t* CurrCollectionPath = NULL;
	HID_ReportSizeInfo_t* CurrReportIDInfo   = &ParserData->ReportIDSizes[0];
	uint16_t              UsageList[HID_USAGE_STACK_DEPTH];
	uint8_t               UsageListSize      = 0;
	HID_MinMax_t          UsageMinMax        = {0, 0};
      80:	fb c1       	rjmp	.+1014   	; 0x478 <__bad_interrupt>
      82:	00 00       	nop
      84:	f9 c1       	rjmp	.+1010   	; 0x478 <__bad_interrupt>
      86:	00 00       	nop
      88:	f7 c1       	rjmp	.+1006   	; 0x478 <__bad_interrupt>
      8a:	00 00       	nop
	HID_StateTable_t      StateTable[HID_STATETABLE_STACK_DEPTH];
	HID_StateTable_t*     CurrStateTable     = &StateTable[0];
	HID_CollectionPath_t* CurrCollectionPath = NULL;
	HID_ReportSizeInfo_t* CurrReportIDInfo   = &ParserData->ReportIDSizes[0];
	uint16_t              UsageList[HID_USAGE_STACK_DEPTH];
	uint8_t               UsageListSize      = 0;
      8c:	f5 c1       	rjmp	.+1002   	; 0x478 <__bad_interrupt>
      8e:	00 00       	nop
      90:	f3 c1       	rjmp	.+998    	; 0x478 <__bad_interrupt>
                             uint16_t ReportSize,
                             HID_ReportInfo_t* const ParserData)
{
	HID_StateTable_t      StateTable[HID_STATETABLE_STACK_DEPTH];
	HID_StateTable_t*     CurrStateTable     = &StateTable[0];
	HID_CollectionPath_t* CurrCollectionPath = NULL;
      92:	00 00       	nop
      94:	f1 c1       	rjmp	.+994    	; 0x478 <__bad_interrupt>
      96:	00 00       	nop

00000098 <ProductString>:
      98:	28 03 4c 00 55 00 46 00 41 00 20 00 52 00 4e 00     (.L.U.F.A. .R.N.

					NewReportItem.BitOffset = CurrReportIDInfo->ReportSizeBits[NewReportItem.ItemType];

					CurrReportIDInfo->ReportSizeBits[NewReportItem.ItemType] += CurrStateTable->Attributes.BitSize;

					ParserData->LargestReportSizeBits = MAX(ParserData->LargestReportSizeBits, CurrReportIDInfo->ReportSizeBits[NewReportItem.ItemType]);
      a8:	44 00 49 00 53 00 20 00 43 00 44 00 43 00 20 00     D.I.S. .C.D.C. .

					CurrCollectionPath = &ParserData->CollectionPaths[1];

					while (CurrCollectionPath->Parent != NULL)
					{
						if (CurrCollectionPath == &ParserData->CollectionPaths[HID_MAX_COLLECTIONS - 1])
      b8:	44 00 65 00 6d 00 6f 00 00 00                       D.e.m.o...

000000c2 <ManufacturerString>:
				break;

			case HID_RI_REPORT_ID(0):
				CurrStateTable->ReportID                    = ReportItemData;

				if (ParserData->UsingReportIDs)
      c2:	18 03 44 00 65 00 61 00 6e 00 20 00 43 00 61 00     ..D.e.a.n. .C.a.
				{
					CurrReportIDInfo = NULL;

					for (uint8_t i = 0; i < ParserData->TotalDeviceReports; i++)
      d2:	6d 00 65 00 72 00 61 00 00 00                       m.e.r.a...

000000dc <LanguageString>:
	memset(CurrStateTable,   0x00, sizeof(HID_StateTable_t));
	memset(CurrReportIDInfo, 0x00, sizeof(HID_ReportSizeInfo_t));

	ParserData->TotalDeviceReports = 1;

	while (ReportSize)
      dc:	04 03 09 04                                         ....

000000e0 <ConfigurationDescriptor>:
	{
		uint8_t  HIDReportItem  = *ReportData;
      e0:	09 02 3e 00 02 01 00 c0 32 09 04 00 00 01 02 02     ..>.....2.......
		uint32_t ReportItemData;

		ReportData++;
		ReportSize--;

		switch (HIDReportItem & HID_RI_DATA_SIZE_MASK)
      f0:	ff 00 05 24 00 10 01 04 24 02 00 05 24 06 00 01     ...$....$...$...
	{
		uint8_t  HIDReportItem  = *ReportData;
		uint32_t ReportItemData;

		ReportData++;
		ReportSize--;
     100:	07 05 83 03 08 00 ff 09 04 01 00 02 0a 00 00 00     ................

		switch (HIDReportItem & HID_RI_DATA_SIZE_MASK)
		{
			case HID_RI_DATA_BITS_32:
				ReportItemData  = (((uint32_t)ReportData[3] << 24) | ((uint32_t)ReportData[2] << 16) |
     110:	07 05 02 02 40 00 05 07 05 81 02 40 00 05           ....@......@..

0000011e <DeviceDescriptor>:
     11e:	12 01 10 01 02 00 00 08 eb 03 4c 20 01 00 01 02     ..........L ....
			                       ((uint16_t)ReportData[1] << 8)  | ReportData[0]);
     12e:	00 01                                               ..

00000130 <AdapterSupportedOIDList>:
     130:	01 01 01 00 02 02 01 00 02 01 01 00 03 01 01 00     ................
		ReportSize--;

		switch (HIDReportItem & HID_RI_DATA_SIZE_MASK)
		{
			case HID_RI_DATA_BITS_32:
				ReportItemData  = (((uint32_t)ReportData[3] << 24) | ((uint32_t)ReportData[2] << 16) |
     140:	04 01 01 00 06 01 01 00 11 01 01 00 07 01 01 00     ................
				ReportSize     -= 4;
				ReportData     += 4;
				break;

			case HID_RI_DATA_BITS_16:
				ReportItemData  = (((uint16_t)ReportData[1] << 8) | (ReportData[0]));
     150:	0a 01 01 00 0b 01 01 00 0c 01 01 00 0d 01 01 00     ................
     160:	0e 01 01 00 11 01 01 00 14 01 01 00 01 01 02 00     ................
				ReportSize     -= 2;
				ReportData     += 2;
				break;

			case HID_RI_DATA_BITS_8:
				ReportItemData  = ReportData[0];
     170:	02 01 02 00 03 01 02 00 04 01 02 00 05 01 02 00     ................
				ReportSize     -= 1;
				ReportData     += 1;
     180:	01 01 01 01 02 01 01 01 03 01 01 01 04 01 01 01     ................
			default:
				ReportItemData  = 0;
				break;
		}

		switch (HIDReportItem & (HID_RI_TYPE_MASK | HID_RI_TAG_MASK))
     190:	01 01 02 01 02 01 02 01 03 01 02 01                 ............

0000019c <AdapterVendorDescription>:
     19c:	4c 55 46 41 20 52 4e 44 49 53 20 41 64 61 70 74     LUFA RNDIS Adapt

			case HID_RI_USAGE_PAGE(0):
				if ((HIDReportItem & HID_RI_DATA_SIZE_MASK) == HID_RI_DATA_BITS_32)
				  CurrStateTable->Attributes.Usage.Page = (ReportItemData >> 16);

				CurrStateTable->Attributes.Usage.Page       = ReportItemData;
     1ac:	65 72 00                                            er.

000001af <AdapterMACAddress>:
     1af:	02 00 02 00 02 00                                   ......

000001b5 <HTTPPage>:
				break;
     1b5:	3c 68 74 6d 6c 3e 09 3c 68 65 61 64 3e 09 09 3c     <html>.<head>..<
			default:
				ReportItemData  = 0;
				break;
		}

		switch (HIDReportItem & (HID_RI_TYPE_MASK | HID_RI_TAG_MASK))
     1c5:	74 69 74 6c 65 3e 09 09 09 4c 55 46 41 20 57 65     title>...LUFA We
     1d5:	62 73 65 72 76 65 72 20 44 65 6d 6f 09 09 3c 2f     bserver Demo..</
     1e5:	74 69 74 6c 65 3e 09 3c 2f 68 65 61 64 3e 09 3c     title>.</head>.<
     1f5:	62 6f 64 79 3e 09 09 3c 68 31 3e 48 65 6c 6c 6f     body>..<h1>Hello
			case HID_RI_UNIT(0):
				CurrStateTable->Attributes.Unit.Type        = ReportItemData;
				break;

			case HID_RI_REPORT_SIZE(0):
				CurrStateTable->Attributes.BitSize          = ReportItemData;
     205:	20 66 72 6f 6d 20 79 6f 75 72 20 55 53 42 20 41      from your USB A
			default:
				ReportItemData  = 0;
				break;
		}

		switch (HIDReportItem & (HID_RI_TYPE_MASK | HID_RI_TAG_MASK))
     215:	56 52 21 3c 2f 68 31 3e 09 09 3c 70 3e 09 09 09     VR!</h1>..<p>...
     225:	48 65 6c 6c 6f 21 20 57 65 6c 63 6f 6d 65 20 74     Hello! Welcome t
					  return HID_PARSE_InsufficientReportItems;

					memcpy(&ParserData->ReportItems[ParserData->TotalReportItems],
					       &NewReportItem, sizeof(HID_ReportItem_t));

					if (!(ReportItemData & HID_IOF_CONSTANT) && CALLBACK_HIDParser_FilterHIDReportItem(&NewReportItem))
     235:	6f 20 74 68 65 20 4c 55 46 41 20 52 4e 44 49 53     o the LUFA RNDIS
     245:	20 44 65 6d 6f 20 57 65 62 73 65 72 76 65 72 20      Demo Webserver 
		}

		switch (HIDReportItem & (HID_RI_TYPE_MASK | HID_RI_TAG_MASK))
		{
			case HID_RI_PUSH(0):
				if (CurrStateTable == &StateTable[HID_STATETABLE_STACK_DEPTH - 1])
     255:	74 65 73 74 20 70 61 67 65 2c 20 72 75 6e 6e 69     test page, runni
				  return HID_PARSE_HIDStackOverflow;

				memcpy((CurrStateTable + 1),
     265:	6e 67 20 6f 6e 20 79 6f 75 72 20 55 53 42 20 41     ng on your USB A

				CurrStateTable++;
				break;

			case HID_RI_POP(0):
				if (CurrStateTable == &StateTable[0])
     275:	56 52 20 76 69 61 20 74 68 65 20 4c 55 46 41 20     VR via the LUFA 
				  return HID_PARSE_HIDStackUnderflow;

				CurrStateTable--;
				break;
     285:	6c 69 62 72 61 72 79 2e 20 54 68 69 73 20 64 65     library. This de
			case HID_RI_LOGICAL_MINIMUM(0):
				CurrStateTable->Attributes.Logical.Minimum  = ReportItemData;
				break;

			case HID_RI_LOGICAL_MAXIMUM(0):
				CurrStateTable->Attributes.Logical.Maximum  = ReportItemData;
     295:	6d 6f 6e 73 74 72 61 74 65 73 20 74 68 65 20 48     monstrates the H
				break;

			case HID_RI_PHYSICAL_MINIMUM(0):
				CurrStateTable->Attributes.Physical.Minimum = ReportItemData;
     2a5:	54 54 50 20 77 65 62 73 65 72 76 65 72 2c 20 54     TTP webserver, T
				break;

			case HID_RI_PHYSICAL_MAXIMUM(0):
				CurrStateTable->Attributes.Physical.Maximum = ReportItemData;
     2b5:	43 50 2f 49 50 20 73 74 61 63 6b 20 61 6e 64 20     CP/IP stack and 
			case HID_RI_UNIT_EXPONENT(0):
				CurrStateTable->Attributes.Unit.Exponent    = ReportItemData;
				break;

			case HID_RI_UNIT(0):
				CurrStateTable->Attributes.Unit.Type        = ReportItemData;
     2c5:	52 4e 44 49 53 20 64 65 6d 6f 20 61 6c 6c 20 72     RNDIS demo all r
				CurrStateTable->Attributes.BitSize          = ReportItemData;
				break;

			case HID_RI_REPORT_COUNT(0):
				CurrStateTable->ReportCount                 = ReportItemData;
				break;
     2d5:	75 6e 6e 69 6e 67 20 61 74 6f 70 20 74 68 65 20     unning atop the 

			case HID_RI_REPORT_ID(0):
				CurrStateTable->ReportID                    = ReportItemData;

				if (ParserData->UsingReportIDs)
     2e5:	4c 55 46 41 20 55 53 42 20 73 74 61 63 6b 2e 09     LUFA USB stack..
				{
					CurrReportIDInfo = NULL;

					for (uint8_t i = 0; i < ParserData->TotalDeviceReports; i++)
     2f5:	09 09 3c 62 72 20 2f 3e 3c 62 72 20 2f 3e 09 09     ..<br /><br />..
					{
						if (ParserData->ReportIDSizes[i].ReportID == CurrStateTable->ReportID)
     305:	09 3c 73 6d 61 6c 6c 3e 50 72 6f 6a 65 63 74 20     .<small>Project 
     315:	49 6e 66 6f 72 6d 61 74 69 6f 6e 3a 20 3c 61 20     Information: <a 
						{
							CurrReportIDInfo = &ParserData->ReportIDSizes[i];
     325:	68 72 65 66 3d 22 68 74 74 70 3a 2f 2f 77 77 77     href="http://www
     335:	2e 6c 75 66 61 2d 6c 69 62 2e 6f 72 67 22 3e 68     .lufa-lib.org">h
					if (CurrReportIDInfo == NULL)
					{
						if (ParserData->TotalDeviceReports == HID_MAX_REPORT_IDS)
						  return HID_PARSE_InsufficientReportIDItems;

						CurrReportIDInfo = &ParserData->ReportIDSizes[ParserData->TotalDeviceReports++];
     345:	74 74 70 3a 2f 2f 77 77 77 2e 6c 75 66 61 2d 6c     ttp://www.lufa-l
     355:	69 62 2e 6f 72 67 3c 2f 61 3e 2e 3c 2f 73 6d 61     ib.org</a>.</sma
						memset(CurrReportIDInfo, 0x00, sizeof(HID_ReportSizeInfo_t));
     365:	6c 6c 3e 09 09 09 3c 68 72 20 2f 3e 09 09 09 3c     ll>...<hr />...<
					}
				}

				ParserData->UsingReportIDs = true;
     375:	69 3e 4c 55 46 41 20 56 65 72 73 69 6f 6e 3a 20     i>LUFA Version: 

				CurrReportIDInfo->ReportID = CurrStateTable->ReportID;
     385:	3c 2f 69 3e 31 34 30 39 32 38 09 09 3c 2f 70 3e     </i>140928..</p>
				break;

			case HID_RI_USAGE(0):
				if (UsageListSize == HID_USAGE_STACK_DEPTH)
     395:	09 3c 2f 62 6f 64 79 3e 3c 2f 68 74 6d 6c 3e 00     .</body></html>.

000003a5 <HTTP404Header>:
				  return HID_PARSE_UsageListOverflow;

				UsageList[UsageListSize++] = ReportItemData;
     3a5:	48 54 54 50 2f 31 2e 31 20 34 30 34 20 4e 6f 74     HTTP/1.1 404 Not
			case HID_RI_USAGE_MAXIMUM(0):
				UsageMinMax.Maximum = ReportItemData;
				break;

			case HID_RI_COLLECTION(0):
				if (CurrCollectionPath == NULL)
     3b5:	20 46 6f 75 6e 64 0d 0a 53 65 72 76 65 72 3a 20      Found..Server: 
				{
					CurrCollectionPath = &ParserData->CollectionPaths[0];
     3c5:	4c 55 46 41 20 52 4e 44 49 53 0d 0a 43 6f 6e 6e     LUFA RNDIS..Conn
				{
					HID_CollectionPath_t* ParentCollectionPath = CurrCollectionPath;

					CurrCollectionPath = &ParserData->CollectionPaths[1];

					while (CurrCollectionPath->Parent != NULL)
     3d5:	65 63 74 69 6f 6e 3a 20 63 6c 6f 73 65 0d 0a 0d     ection: close...
					{
						if (CurrCollectionPath == &ParserData->CollectionPaths[HID_MAX_COLLECTIONS - 1])
     3e5:	0a 00                                               ..

000003e7 <HTTP200Header>:
     3e7:	48 54 54 50 2f 31 2e 31 20 32 30 30 20 4f 4b 0d     HTTP/1.1 200 OK.
						  return HID_PARSE_InsufficientCollectionPaths;

						CurrCollectionPath++;
					}

					CurrCollectionPath->Parent = ParentCollectionPath;
     3f7:	0a 53 65 72 76 65 72 3a 20 4c 55 46 41 20 52 4e     .Server: LUFA RN
     407:	44 49 53 0d 0a 43 6f 6e 74 65 6e 74 2d 74 79 70     DIS..Content-typ
				}

				CurrCollectionPath->Type       = ReportItemData;
				CurrCollectionPath->Usage.Page = CurrStateTable->Attributes.Usage.Page;
     417:	65 3a 20 74 65 78 74 2f 68 74 6d 6c 0d 0a 43 6f     e: text/html..Co

				if (UsageListSize)
     427:	6e 6e 65 63 74 69 6f 6e 3a 20 63 6c 6f 73 65 0d     nnection: close.
				{
					CurrCollectionPath->Usage.Usage = UsageList[0];
     437:	0a 0d 0a 00 00                                      .....

0000043c <__ctors_end>:
     43c:	11 24       	eor	r1, r1
     43e:	1f be       	out	0x3f, r1	; 63

					for (uint8_t i = 1; i < UsageListSize; i++)
     440:	cf ef       	ldi	r28, 0xFF	; 255
     442:	d0 e2       	ldi	r29, 0x20	; 32
     444:	de bf       	out	0x3e, r29	; 62
     446:	cd bf       	out	0x3d, r28	; 61

00000448 <__do_copy_data>:
     448:	11 e0       	ldi	r17, 0x01	; 1
     44a:	a0 e0       	ldi	r26, 0x00	; 0
					  UsageList[i - 1] = UsageList[i];
     44c:	b1 e0       	ldi	r27, 0x01	; 1
     44e:	e0 e4       	ldi	r30, 0x40	; 64
     450:	f9 e2       	ldi	r31, 0x29	; 41
     452:	00 e0       	ldi	r16, 0x00	; 0

				if (UsageListSize)
				{
					CurrCollectionPath->Usage.Usage = UsageList[0];

					for (uint8_t i = 1; i < UsageListSize; i++)
     454:	0b bf       	out	0x3b, r16	; 59
     456:	02 c0       	rjmp	.+4      	; 0x45c <__do_copy_data+0x14>
					  UsageList[i - 1] = UsageList[i];

					UsageListSize--;
     458:	07 90       	elpm	r0, Z+
     45a:	0d 92       	st	X+, r0
     45c:	a6 34       	cpi	r26, 0x46	; 70
     45e:	b1 07       	cpc	r27, r17
     460:	d9 f7       	brne	.-10     	; 0x458 <__do_copy_data+0x10>

00000462 <__do_clear_bss>:
				}
				else if (UsageMinMax.Minimum <= UsageMinMax.Maximum)
     462:	13 e1       	ldi	r17, 0x13	; 19
     464:	a6 e4       	ldi	r26, 0x46	; 70
     466:	b1 e0       	ldi	r27, 0x01	; 1
     468:	01 c0       	rjmp	.+2      	; 0x46c <.do_clear_bss_start>

0000046a <.do_clear_bss_loop>:
     46a:	1d 92       	st	X+, r1

0000046c <.do_clear_bss_start>:
     46c:	a5 3f       	cpi	r26, 0xF5	; 245
				{
					CurrCollectionPath->Usage.Usage = UsageMinMax.Minimum++;
     46e:	b1 07       	cpc	r27, r17
     470:	e1 f7       	brne	.-8      	; 0x46a <.do_clear_bss_loop>
     472:	8b d1       	rcall	.+790    	; 0x78a <main>
     474:	0c 94 9e 14 	jmp	0x293c	; 0x293c <_exit>

00000478 <__bad_interrupt>:
     478:	c3 cd       	rjmp	.-1146   	; 0x0 <__vectors>

0000047a <LEDs_SetAllLEDs>:
     47a:	9b b1       	in	r25, 0x0b	; 11
     47c:	9f 70       	andi	r25, 0x0F	; 15
     47e:	98 2b       	or	r25, r24
     480:	9b b9       	out	0x0b, r25	; 11
     482:	08 95       	ret

00000484 <SetupHardware>:
     484:	84 b7       	in	r24, 0x34	; 52
     486:	87 7f       	andi	r24, 0xF7	; 247
     488:	84 bf       	out	0x34, r24	; 52
				}

				break;

			case HID_RI_END_COLLECTION(0):
				if (CurrCollectionPath == NULL)
     48a:	88 e1       	ldi	r24, 0x18	; 24
     48c:	0f b6       	in	r0, 0x3f	; 63
     48e:	f8 94       	cli
     490:	80 93 60 00 	sts	0x0060, r24
     494:	10 92 60 00 	sts	0x0060, r1
     498:	0f be       	out	0x3f, r0	; 63
				  return HID_PARSE_UnexpectedEndCollection;

				CurrCollectionPath = CurrCollectionPath->Parent;
     49a:	90 e0       	ldi	r25, 0x00	; 0
     49c:	80 e8       	ldi	r24, 0x80	; 128
     49e:	0f b6       	in	r0, 0x3f	; 63
     4a0:	f8 94       	cli
     4a2:	80 93 61 00 	sts	0x0061, r24
     4a6:	90 93 61 00 	sts	0x0061, r25
     4aa:	0f be       	out	0x3f, r0	; 63
				break;
     4ac:	8a b1       	in	r24, 0x0a	; 10
					ParserData->LargestReportSizeBits = MAX(ParserData->LargestReportSizeBits, CurrReportIDInfo->ReportSizeBits[NewReportItem.ItemType]);

					if (ParserData->TotalReportItems == HID_MAX_REPORTITEMS)
					  return HID_PARSE_InsufficientReportItems;

					memcpy(&ParserData->ReportItems[ParserData->TotalReportItems],
     4ae:	80 6f       	ori	r24, 0xF0	; 240
     4b0:	8a b9       	out	0x0a, r24	; 10
     4b2:	8b b1       	in	r24, 0x0b	; 11
     4b4:	8f 70       	andi	r24, 0x0F	; 15
     4b6:	8b b9       	out	0x0b, r24	; 11
     4b8:	83 e3       	ldi	r24, 0x33	; 51
     4ba:	90 e0       	ldi	r25, 0x00	; 0
     4bc:	90 93 cd 00 	sts	0x00CD, r25
     4c0:	80 93 cc 00 	sts	0x00CC, r24
     4c4:	86 e0       	ldi	r24, 0x06	; 6
     4c6:	80 93 ca 00 	sts	0x00CA, r24
					       &NewReportItem, sizeof(HID_ReportItem_t));

					if (!(ReportItemData & HID_IOF_CONSTANT) && CALLBACK_HIDParser_FilterHIDReportItem(&NewReportItem))
     4ca:	10 92 c8 00 	sts	0x00C8, r1
     4ce:	88 e1       	ldi	r24, 0x18	; 24
     4d0:	80 93 c9 00 	sts	0x00C9, r24
     4d4:	53 9a       	sbi	0x0a, 3	; 10
     4d6:	5a 9a       	sbi	0x0b, 2	; 11
     4d8:	0e 94 b0 11 	call	0x2360	; 0x2360 <USB_Init>
     4dc:	80 e0       	ldi	r24, 0x00	; 0
     4de:	90 e0       	ldi	r25, 0x00	; 0
     4e0:	0c 94 23 14 	jmp	0x2846	; 0x2846 <Serial_CreateStream>

000004e4 <EVENT_USB_Device_Connect>:
				break;

			case HID_RI_INPUT(0):
			case HID_RI_OUTPUT(0):
			case HID_RI_FEATURE(0):
				for (uint8_t ReportItemNum = 0; ReportItemNum < CurrStateTable->ReportCount; ReportItemNum++)
     4e4:	80 ea       	ldi	r24, 0xA0	; 160
     4e6:	c9 cf       	rjmp	.-110    	; 0x47a <LEDs_SetAllLEDs>

000004e8 <EVENT_USB_Device_Disconnect>:
     4e8:	80 e1       	ldi	r24, 0x10	; 16
     4ea:	c7 cf       	rjmp	.-114    	; 0x47a <LEDs_SetAllLEDs>

000004ec <EVENT_USB_Device_ConfigurationChanged>:
     4ec:	cf 93       	push	r28
     4ee:	df 93       	push	r29
				{
					HID_ReportItem_t NewReportItem;

					memcpy(&NewReportItem.Attributes,
     4f0:	42 e3       	ldi	r20, 0x32	; 50
     4f2:	61 e8       	ldi	r22, 0x81	; 129
     4f4:	81 e0       	ldi	r24, 0x01	; 1
     4f6:	0e 94 e5 10 	call	0x21ca	; 0x21ca <Endpoint_ConfigureEndpoint_Prv>
     4fa:	c8 2f       	mov	r28, r24
     4fc:	42 e3       	ldi	r20, 0x32	; 50
     4fe:	60 e8       	ldi	r22, 0x80	; 128
     500:	82 e0       	ldi	r24, 0x02	; 2
					       &CurrStateTable->Attributes,
					       sizeof(HID_ReportItem_Attributes_t));

					NewReportItem.ItemFlags      = ReportItemData;
     502:	0e 94 e5 10 	call	0x21ca	; 0x21ca <Endpoint_ConfigureEndpoint_Prv>
					NewReportItem.CollectionPath = CurrCollectionPath;
     506:	d8 2f       	mov	r29, r24
     508:	42 e0       	ldi	r20, 0x02	; 2
     50a:	61 ec       	ldi	r22, 0xC1	; 193
     50c:	83 e0       	ldi	r24, 0x03	; 3
     50e:	0e 94 e5 10 	call	0x21ca	; 0x21ca <Endpoint_ConfigureEndpoint_Prv>
     512:	cd 23       	and	r28, r29
     514:	21 f0       	breq	.+8      	; 0x51e <EVENT_USB_Device_ConfigurationChanged+0x32>
					NewReportItem.ReportID       = CurrStateTable->ReportID;
     516:	88 23       	and	r24, r24
     518:	11 f0       	breq	.+4      	; 0x51e <EVENT_USB_Device_ConfigurationChanged+0x32>
     51a:	80 e6       	ldi	r24, 0x60	; 96
     51c:	01 c0       	rjmp	.+2      	; 0x520 <EVENT_USB_Device_ConfigurationChanged+0x34>

					if (UsageListSize)
     51e:	80 e9       	ldi	r24, 0x90	; 144
     520:	df 91       	pop	r29
     522:	cf 91       	pop	r28
     524:	aa cf       	rjmp	.-172    	; 0x47a <LEDs_SetAllLEDs>

00000526 <EVENT_USB_Device_ControlRequest>:
     526:	80 91 da 13 	lds	r24, 0x13DA
					{
						NewReportItem.Attributes.Usage.Usage = UsageList[0];
     52a:	88 23       	and	r24, r24
     52c:	19 f0       	breq	.+6      	; 0x534 <EVENT_USB_Device_ControlRequest+0xe>
     52e:	81 30       	cpi	r24, 0x01	; 1
     530:	c9 f0       	breq	.+50     	; 0x564 <EVENT_USB_Device_ControlRequest+0x3e>
     532:	08 95       	ret
     534:	80 91 d9 13 	lds	r24, 0x13D9
     538:	81 32       	cpi	r24, 0x21	; 33
     53a:	09 f0       	breq	.+2      	; 0x53e <EVENT_USB_Device_ControlRequest+0x18>
     53c:	49 c0       	rjmp	.+146    	; 0x5d0 <EVENT_USB_Device_ControlRequest+0xaa>

						for (uint8_t i = 1; i < UsageListSize; i++)
     53e:	80 91 e8 00 	lds	r24, 0x00E8
     542:	87 7f       	andi	r24, 0xF7	; 247
     544:	80 93 e8 00 	sts	0x00E8, r24
     548:	60 91 df 13 	lds	r22, 0x13DF
						  UsageList[i - 1] = UsageList[i];
     54c:	70 91 e0 13 	lds	r23, 0x13E0
     550:	89 e0       	ldi	r24, 0x09	; 9

					if (UsageListSize)
					{
						NewReportItem.Attributes.Usage.Usage = UsageList[0];

						for (uint8_t i = 1; i < UsageListSize; i++)
     552:	9d e0       	ldi	r25, 0x0D	; 13
     554:	0e 94 47 10 	call	0x208e	; 0x208e <Endpoint_Read_Control_Stream_LE>
						  UsageList[i - 1] = UsageList[i];

						UsageListSize--;
     558:	80 91 e8 00 	lds	r24, 0x00E8
     55c:	8e 77       	andi	r24, 0x7E	; 126
     55e:	80 93 e8 00 	sts	0x00E8, r24
					}
					else if (UsageMinMax.Minimum <= UsageMinMax.Maximum)
     562:	eb c1       	rjmp	.+982    	; 0x93a <ProcessRNDISControlMessage>
     564:	80 91 d9 13 	lds	r24, 0x13D9
     568:	81 3a       	cpi	r24, 0xA1	; 161
					{
						NewReportItem.Attributes.Usage.Usage = UsageMinMax.Minimum++;
     56a:	91 f5       	brne	.+100    	; 0x5d0 <EVENT_USB_Device_ControlRequest+0xaa>
     56c:	e0 91 00 01 	lds	r30, 0x0100
     570:	f0 91 01 01 	lds	r31, 0x0101
     574:	84 81       	ldd	r24, Z+4	; 0x04
     576:	95 81       	ldd	r25, Z+5	; 0x05
     578:	a6 81       	ldd	r26, Z+6	; 0x06
     57a:	b7 81       	ldd	r27, Z+7	; 0x07
					}

					uint8_t ItemTypeTag = (HIDReportItem & (HID_RI_TYPE_MASK | HID_RI_TAG_MASK));

					if (ItemTypeTag == HID_RI_INPUT(0))
     57c:	89 2b       	or	r24, r25
     57e:	8a 2b       	or	r24, r26
					  NewReportItem.ItemType = HID_REPORT_ITEM_In;
     580:	8b 2b       	or	r24, r27
     582:	51 f4       	brne	.+20     	; 0x598 <EVENT_USB_Device_ControlRequest+0x72>
					else if (ItemTypeTag == HID_RI_OUTPUT(0))
     584:	10 92 09 0d 	sts	0x0D09, r1
					  NewReportItem.ItemType = HID_REPORT_ITEM_Out;
     588:	81 e0       	ldi	r24, 0x01	; 1
     58a:	90 e0       	ldi	r25, 0x00	; 0
     58c:	a0 e0       	ldi	r26, 0x00	; 0
					else
					  NewReportItem.ItemType = HID_REPORT_ITEM_Feature;
     58e:	b0 e0       	ldi	r27, 0x00	; 0
     590:	84 83       	std	Z+4, r24	; 0x04

					NewReportItem.BitOffset = CurrReportIDInfo->ReportSizeBits[NewReportItem.ItemType];
     592:	95 83       	std	Z+5, r25	; 0x05
     594:	a6 83       	std	Z+6, r26	; 0x06
     596:	b7 83       	std	Z+7, r27	; 0x07
     598:	80 91 e8 00 	lds	r24, 0x00E8
     59c:	87 7f       	andi	r24, 0xF7	; 247
     59e:	80 93 e8 00 	sts	0x00E8, r24
     5a2:	e0 91 00 01 	lds	r30, 0x0100
     5a6:	f0 91 01 01 	lds	r31, 0x0101
     5aa:	64 81       	ldd	r22, Z+4	; 0x04

					CurrReportIDInfo->ReportSizeBits[NewReportItem.ItemType] += CurrStateTable->Attributes.BitSize;
     5ac:	75 81       	ldd	r23, Z+5	; 0x05
     5ae:	89 e0       	ldi	r24, 0x09	; 9
     5b0:	9d e0       	ldi	r25, 0x0D	; 13
     5b2:	0e 94 ea 0f 	call	0x1fd4	; 0x1fd4 <Endpoint_Write_Control_Stream_LE>
     5b6:	80 91 e8 00 	lds	r24, 0x00E8
     5ba:	8b 77       	andi	r24, 0x7B	; 123

					ParserData->LargestReportSizeBits = MAX(ParserData->LargestReportSizeBits, CurrReportIDInfo->ReportSizeBits[NewReportItem.ItemType]);
     5bc:	80 93 e8 00 	sts	0x00E8, r24
     5c0:	e0 91 00 01 	lds	r30, 0x0100
     5c4:	f0 91 01 01 	lds	r31, 0x0101
     5c8:	14 82       	std	Z+4, r1	; 0x04
     5ca:	15 82       	std	Z+5, r1	; 0x05
     5cc:	16 82       	std	Z+6, r1	; 0x06
     5ce:	17 82       	std	Z+7, r1	; 0x07
     5d0:	08 95       	ret

000005d2 <RNDIS_Task>:
     5d2:	0f 93       	push	r16
     5d4:	1f 93       	push	r17
     5d6:	cf 93       	push	r28
     5d8:	df 93       	push	r29
     5da:	cd b7       	in	r28, 0x3d	; 61
     5dc:	de b7       	in	r29, 0x3e	; 62
     5de:	ac 97       	sbiw	r28, 0x2c	; 44
     5e0:	0f b6       	in	r0, 0x3f	; 63
     5e2:	f8 94       	cli
     5e4:	de bf       	out	0x3e, r29	; 62
     5e6:	0f be       	out	0x3f, r0	; 63
     5e8:	cd bf       	out	0x3d, r28	; 61
     5ea:	83 e0       	ldi	r24, 0x03	; 3
     5ec:	80 93 e9 00 	sts	0x00E9, r24
     5f0:	80 91 e8 00 	lds	r24, 0x00E8

					if (ParserData->TotalReportItems == HID_MAX_REPORTITEMS)
     5f4:	80 ff       	sbrs	r24, 0
     5f6:	1c c0       	rjmp	.+56     	; 0x630 <RNDIS_Task+0x5e>
     5f8:	80 91 4b 01 	lds	r24, 0x014B
     5fc:	88 23       	and	r24, r24
					  return HID_PARSE_InsufficientReportItems;
     5fe:	c1 f0       	breq	.+48     	; 0x630 <RNDIS_Task+0x5e>
     600:	88 e0       	ldi	r24, 0x08	; 8

					memcpy(&ParserData->ReportItems[ParserData->TotalReportItems],
					       &NewReportItem, sizeof(HID_ReportItem_t));

					if (!(ReportItemData & HID_IOF_CONSTANT) && CALLBACK_HIDParser_FilterHIDReportItem(&NewReportItem))
     602:	e2 e0       	ldi	r30, 0x02	; 2
     604:	f1 e0       	ldi	r31, 0x01	; 1
     606:	de 01       	movw	r26, r28
     608:	11 96       	adiw	r26, 0x01	; 1
     60a:	01 90       	ld	r0, Z+
     60c:	0d 92       	st	X+, r0
     60e:	8a 95       	dec	r24
     610:	e1 f7       	brne	.-8      	; 0x60a <RNDIS_Task+0x38>
     612:	40 e0       	ldi	r20, 0x00	; 0
     614:	50 e0       	ldi	r21, 0x00	; 0
     616:	68 e0       	ldi	r22, 0x08	; 8
     618:	70 e0       	ldi	r23, 0x00	; 0
     61a:	ce 01       	movw	r24, r28
     61c:	01 96       	adiw	r24, 0x01	; 1
     61e:	0e 94 5a 0f 	call	0x1eb4	; 0x1eb4 <Endpoint_Write_Stream_LE>
     622:	80 91 e8 00 	lds	r24, 0x00E8
     626:	8e 77       	andi	r24, 0x7E	; 126
     628:	80 93 e8 00 	sts	0x00E8, r24
     62c:	10 92 4b 01 	sts	0x014B, r1
     630:	20 91 4a 01 	lds	r18, 0x014A
     634:	22 30       	cpi	r18, 0x02	; 2
     636:	09 f0       	breq	.+2      	; 0x63a <RNDIS_Task+0x68>
     638:	8d c0       	rjmp	.+282    	; 0x754 <RNDIS_Task+0x182>
     63a:	e0 91 00 01 	lds	r30, 0x0100
     63e:	f0 91 01 01 	lds	r31, 0x0101
     642:	84 81       	ldd	r24, Z+4	; 0x04
     644:	95 81       	ldd	r25, Z+5	; 0x05
     646:	a6 81       	ldd	r26, Z+6	; 0x06
     648:	b7 81       	ldd	r27, Z+7	; 0x07
     64a:	89 2b       	or	r24, r25
     64c:	8a 2b       	or	r24, r26
     64e:	8b 2b       	or	r24, r27
     650:	09 f0       	breq	.+2      	; 0x654 <RNDIS_Task+0x82>
     652:	80 c0       	rjmp	.+256    	; 0x754 <RNDIS_Task+0x182>
     654:	20 93 e9 00 	sts	0x00E9, r18
     658:	80 91 e8 00 	lds	r24, 0x00E8
     65c:	82 ff       	sbrs	r24, 2
     65e:	2f c0       	rjmp	.+94     	; 0x6be <RNDIS_Task+0xec>
     660:	80 91 29 07 	lds	r24, 0x0729
     664:	90 91 2a 07 	lds	r25, 0x072A
     668:	89 2b       	or	r24, r25
     66a:	49 f5       	brne	.+82     	; 0x6be <RNDIS_Task+0xec>
     66c:	40 e0       	ldi	r20, 0x00	; 0
     66e:	50 e0       	ldi	r21, 0x00	; 0
     670:	6c e2       	ldi	r22, 0x2C	; 44
     672:	70 e0       	ldi	r23, 0x00	; 0
     674:	ce 01       	movw	r24, r28
     676:	01 96       	adiw	r24, 0x01	; 1
     678:	0e 94 a2 0f 	call	0x1f44	; 0x1f44 <Endpoint_Read_Stream_LE>
     67c:	6d 85       	ldd	r22, Y+13	; 0x0d
     67e:	7e 85       	ldd	r23, Y+14	; 0x0e
     680:	8f 85       	ldd	r24, Y+15	; 0x0f
     682:	98 89       	ldd	r25, Y+16	; 0x10
     684:	6d 3d       	cpi	r22, 0xDD	; 221
     686:	25 e0       	ldi	r18, 0x05	; 5
					  ParserData->TotalReportItems++;
     688:	72 07       	cpc	r23, r18
     68a:	81 05       	cpc	r24, r1
     68c:	91 05       	cpc	r25, r1
     68e:	30 f0       	brcs	.+12     	; 0x69c <RNDIS_Task+0xca>
     690:	80 91 eb 00 	lds	r24, 0x00EB

			default:
				break;
		}

		if ((HIDReportItem & HID_RI_TYPE_MASK) == HID_RI_TYPE_MAIN)
     694:	80 62       	ori	r24, 0x20	; 32
     696:	80 93 eb 00 	sts	0x00EB, r24
     69a:	5c c0       	rjmp	.+184    	; 0x754 <RNDIS_Task+0x182>
     69c:	40 e0       	ldi	r20, 0x00	; 0
		{
			UsageMinMax.Minimum = 0;
			UsageMinMax.Maximum = 0;
     69e:	50 e0       	ldi	r21, 0x00	; 0
     6a0:	8d e4       	ldi	r24, 0x4D	; 77
     6a2:	91 e0       	ldi	r25, 0x01	; 1
				break;
		}

		if ((HIDReportItem & HID_RI_TYPE_MASK) == HID_RI_TYPE_MAIN)
		{
			UsageMinMax.Minimum = 0;
     6a4:	0e 94 a2 0f 	call	0x1f44	; 0x1f44 <Endpoint_Read_Stream_LE>
     6a8:	80 91 e8 00 	lds	r24, 0x00E8
			UsageMinMax.Maximum = 0;
			UsageListSize       = 0;
     6ac:	8b 77       	andi	r24, 0x7B	; 123
     6ae:	80 93 e8 00 	sts	0x00E8, r24
		}
	}

	if (!(ParserData->TotalReportItems))
     6b2:	8d 85       	ldd	r24, Y+13	; 0x0d
     6b4:	9e 85       	ldd	r25, Y+14	; 0x0e
     6b6:	90 93 2a 07 	sts	0x072A, r25
	  return HID_PARSE_NoUnfilteredReportItems;
     6ba:	80 93 29 07 	sts	0x0729, r24

		switch (HIDReportItem & (HID_RI_TYPE_MASK | HID_RI_TAG_MASK))
		{
			case HID_RI_PUSH(0):
				if (CurrStateTable == &StateTable[HID_STATETABLE_STACK_DEPTH - 1])
				  return HID_PARSE_HIDStackOverflow;
     6be:	81 e0       	ldi	r24, 0x01	; 1
     6c0:	80 93 e9 00 	sts	0x00E9, r24
				CurrStateTable++;
				break;

			case HID_RI_POP(0):
				if (CurrStateTable == &StateTable[0])
				  return HID_PARSE_HIDStackUnderflow;
     6c4:	80 91 e8 00 	lds	r24, 0x00E8
				CurrReportIDInfo->ReportID = CurrStateTable->ReportID;
				break;

			case HID_RI_USAGE(0):
				if (UsageListSize == HID_USAGE_STACK_DEPTH)
				  return HID_PARSE_UsageListOverflow;
     6c8:	80 ff       	sbrs	r24, 0
					CurrCollectionPath = &ParserData->CollectionPaths[1];

					while (CurrCollectionPath->Parent != NULL)
					{
						if (CurrCollectionPath == &ParserData->CollectionPaths[HID_MAX_COLLECTIONS - 1])
						  return HID_PARSE_InsufficientCollectionPaths;
     6ca:	44 c0       	rjmp	.+136    	; 0x754 <RNDIS_Task+0x182>
     6cc:	40 91 07 0d 	lds	r20, 0x0D07

				break;

			case HID_RI_END_COLLECTION(0):
				if (CurrCollectionPath == NULL)
				  return HID_PARSE_UnexpectedEndCollection;
     6d0:	50 91 08 0d 	lds	r21, 0x0D08
	}

	if (!(ParserData->TotalReportItems))
	  return HID_PARSE_NoUnfilteredReportItems;

	return HID_PARSE_Successful;
     6d4:	41 15       	cp	r20, r1
					}

					if (CurrReportIDInfo == NULL)
					{
						if (ParserData->TotalDeviceReports == HID_MAX_REPORT_IDS)
						  return HID_PARSE_InsufficientReportIDItems;
     6d6:	51 05       	cpc	r21, r1

	if (!(ParserData->TotalReportItems))
	  return HID_PARSE_NoUnfilteredReportItems;

	return HID_PARSE_Successful;
}
     6d8:	e9 f1       	breq	.+122    	; 0x754 <RNDIS_Task+0x182>
     6da:	ce 01       	movw	r24, r28
     6dc:	01 96       	adiw	r24, 0x01	; 1
     6de:	2c e2       	ldi	r18, 0x2C	; 44
     6e0:	fc 01       	movw	r30, r24
     6e2:	11 92       	st	Z+, r1
     6e4:	2a 95       	dec	r18
     6e6:	e9 f7       	brne	.-6      	; 0x6e2 <RNDIS_Task+0x110>
     6e8:	01 e0       	ldi	r16, 0x01	; 1
     6ea:	10 e0       	ldi	r17, 0x00	; 0
     6ec:	20 e0       	ldi	r18, 0x00	; 0
     6ee:	30 e0       	ldi	r19, 0x00	; 0
     6f0:	09 83       	std	Y+1, r16	; 0x01
     6f2:	1a 83       	std	Y+2, r17	; 0x02
     6f4:	2b 83       	std	Y+3, r18	; 0x03
     6f6:	3c 83       	std	Y+4, r19	; 0x04
     6f8:	8a 01       	movw	r16, r20
     6fa:	04 5d       	subi	r16, 0xD4	; 212
     6fc:	1f 4f       	sbci	r17, 0xFF	; 255
     6fe:	20 e0       	ldi	r18, 0x00	; 0
     700:	30 e0       	ldi	r19, 0x00	; 0
     702:	0d 83       	std	Y+5, r16	; 0x05
     704:	1e 83       	std	Y+6, r17	; 0x06
     706:	2f 83       	std	Y+7, r18	; 0x07
     708:	38 87       	std	Y+8, r19	; 0x08
     70a:	04 e2       	ldi	r16, 0x24	; 36
			memset(&RNDISPacketHeader, 0, sizeof(RNDIS_Packet_Message_t));

			/* Construct the required packet header fields in the buffer */
			RNDISPacketHeader.MessageType   = REMOTE_NDIS_PACKET_MSG;
			RNDISPacketHeader.MessageLength = (sizeof(RNDIS_Packet_Message_t) + FrameOUT.FrameLength);
			RNDISPacketHeader.DataOffset    = (sizeof(RNDIS_Packet_Message_t) - sizeof(RNDIS_Message_Header_t));
     70c:	10 e0       	ldi	r17, 0x00	; 0
     70e:	20 e0       	ldi	r18, 0x00	; 0
     710:	30 e0       	ldi	r19, 0x00	; 0
     712:	09 87       	std	Y+9, r16	; 0x09
     714:	1a 87       	std	Y+10, r17	; 0x0a
     716:	2b 87       	std	Y+11, r18	; 0x0b
     718:	3c 87       	std	Y+12, r19	; 0x0c
			RNDISPacketHeader.DataLength    = FrameOUT.FrameLength;
     71a:	60 e0       	ldi	r22, 0x00	; 0
     71c:	70 e0       	ldi	r23, 0x00	; 0
     71e:	4d 87       	std	Y+13, r20	; 0x0d
     720:	5e 87       	std	Y+14, r21	; 0x0e
     722:	6f 87       	std	Y+15, r22	; 0x0f
     724:	78 8b       	std	Y+16, r23	; 0x10

			/* Send the packet header to the host */
			Endpoint_Write_Stream_LE(&RNDISPacketHeader, sizeof(RNDIS_Packet_Message_t), NULL);
     726:	40 e0       	ldi	r20, 0x00	; 0
     728:	50 e0       	ldi	r21, 0x00	; 0
     72a:	6c e2       	ldi	r22, 0x2C	; 44
     72c:	70 e0       	ldi	r23, 0x00	; 0
     72e:	0e 94 5a 0f 	call	0x1eb4	; 0x1eb4 <Endpoint_Write_Stream_LE>

			/* Send the Ethernet frame data to the host */
			Endpoint_Write_Stream_LE(FrameOUT.FrameData, RNDISPacketHeader.DataLength, NULL);
     732:	6d 85       	ldd	r22, Y+13	; 0x0d
     734:	7e 85       	ldd	r23, Y+14	; 0x0e
     736:	40 e0       	ldi	r20, 0x00	; 0
     738:	50 e0       	ldi	r21, 0x00	; 0
     73a:	8b e2       	ldi	r24, 0x2B	; 43
     73c:	97 e0       	ldi	r25, 0x07	; 7
     73e:	0e 94 5a 0f 	call	0x1eb4	; 0x1eb4 <Endpoint_Write_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
     742:	80 91 e8 00 	lds	r24, 0x00E8
     746:	8e 77       	andi	r24, 0x7E	; 126
     748:	80 93 e8 00 	sts	0x00E8, r24

			/* Finalize the stream transfer to send the last packet */
			Endpoint_ClearIN();

			/* Indicate Ethernet OUT buffer no longer full */
			FrameOUT.FrameLength = 0;
     74c:	10 92 08 0d 	sts	0x0D08, r1
     750:	10 92 07 0d 	sts	0x0D07, r1
		}
	}
}
     754:	ac 96       	adiw	r28, 0x2c	; 44
     756:	0f b6       	in	r0, 0x3f	; 63
     758:	f8 94       	cli
     75a:	de bf       	out	0x3e, r29	; 62
     75c:	0f be       	out	0x3f, r0	; 63
     75e:	cd bf       	out	0x3d, r28	; 61
     760:	df 91       	pop	r29
     762:	cf 91       	pop	r28
     764:	1f 91       	pop	r17
     766:	0f 91       	pop	r16
     768:	08 95       	ret

0000076a <Ethernet_Task>:
	/* Task for Ethernet processing. Incoming ethernet frames are loaded into the FrameIN structure, and
	   outgoing frames should be loaded into the FrameOUT structure. Both structures can only hold a single
	   Ethernet frame at a time, so the FrameInBuffer bool is used to indicate when the buffers contain data. */

	/* Device must be connected and configured for the task to run */
	if (USB_DeviceState != DEVICE_STATE_Configured)
     76a:	80 91 d8 13 	lds	r24, 0x13D8
     76e:	84 30       	cpi	r24, 0x04	; 4
     770:	59 f4       	brne	.+22     	; 0x788 <Ethernet_Task+0x1e>
	  return;

	/* Check if a frame has been written to the IN frame buffer */
	if (FrameIN.FrameLength)
     772:	80 91 29 07 	lds	r24, 0x0729
     776:	90 91 2a 07 	lds	r25, 0x072A
     77a:	89 2b       	or	r24, r25
     77c:	29 f0       	breq	.+10     	; 0x788 <Ethernet_Task+0x1e>
	{
		/* Indicate packet processing started */
		LEDs_SetAllLEDs(LEDMASK_USB_BUSY);
     77e:	80 e2       	ldi	r24, 0x20	; 32
     780:	7c de       	rcall	.-776    	; 0x47a <LEDs_SetAllLEDs>
     782:	42 d0       	rcall	.+132    	; 0x808 <Ethernet_ProcessPacket>

		/* Process the ethernet frame - replace this with your own Ethernet handler code as desired */
		Ethernet_ProcessPacket();
     784:	80 e6       	ldi	r24, 0x60	; 96
     786:	79 ce       	rjmp	.-782    	; 0x47a <LEDs_SetAllLEDs>

		/* Indicate packet processing complete */
		LEDs_SetAllLEDs(LEDMASK_USB_READY);
     788:	08 95       	ret

0000078a <main>:
     78a:	7c de       	rcall	.-776    	; 0x484 <SetupHardware>
     78c:	3f d5       	rcall	.+2686   	; 0x120c <TCP_Init>
     78e:	0e 94 54 0f 	call	0x1ea8	; 0x1ea8 <Webserver_Init>
{
	SetupHardware();

	/* Webserver Initialization */
	TCP_Init();
	Webserver_Init();
     792:	80 e1       	ldi	r24, 0x10	; 16
     794:	72 de       	rcall	.-796    	; 0x47a <LEDs_SetAllLEDs>

	LEDs_SetAllLEDs(LEDMASK_USB_NOTREADY);
     796:	78 94       	sei
     798:	e8 df       	rcall	.-48     	; 0x76a <Ethernet_Task>
     79a:	1b d4       	rcall	.+2102   	; 0xfd2 <TCP_Task>
			static inline void GlobalInterruptEnable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				sei();
     79c:	1a df       	rcall	.-460    	; 0x5d2 <RNDIS_Task>
	GlobalInterruptEnable();

	for (;;)
	{
		Ethernet_Task();
     79e:	0e 94 ec 13 	call	0x27d8	; 0x27d8 <USB_USBTask>
		TCP_Task();
     7a2:	fa cf       	rjmp	.-12     	; 0x798 <main+0xe>

000007a4 <CALLBACK_USB_GetDescriptor>:
 */
uint16_t CALLBACK_USB_GetDescriptor(const uint16_t wValue,
                                    const uint8_t wIndex,
                                    const void** const DescriptorAddress)
{
	const uint8_t  DescriptorType   = (wValue >> 8);
     7a4:	29 2f       	mov	r18, r25
     7a6:	33 27       	eor	r19, r19
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
	uint16_t    Size    = NO_DESCRIPTOR;

	switch (DescriptorType)
     7a8:	22 30       	cpi	r18, 0x02	; 2
     7aa:	31 05       	cpc	r19, r1
     7ac:	59 f0       	breq	.+22     	; 0x7c4 <CALLBACK_USB_GetDescriptor+0x20>
     7ae:	23 30       	cpi	r18, 0x03	; 3
     7b0:	31 05       	cpc	r19, r1
     7b2:	69 f0       	breq	.+26     	; 0x7ce <CALLBACK_USB_GetDescriptor+0x2a>
     7b4:	21 30       	cpi	r18, 0x01	; 1
     7b6:	31 05       	cpc	r19, r1
     7b8:	f9 f4       	brne	.+62     	; 0x7f8 <CALLBACK_USB_GetDescriptor+0x54>
	{
		case DTYPE_Device:
			Address = &DeviceDescriptor;
			Size    = sizeof(USB_Descriptor_Device_t);
     7ba:	82 e1       	ldi	r24, 0x12	; 18
     7bc:	90 e0       	ldi	r25, 0x00	; 0
	uint16_t    Size    = NO_DESCRIPTOR;

	switch (DescriptorType)
	{
		case DTYPE_Device:
			Address = &DeviceDescriptor;
     7be:	2e e1       	ldi	r18, 0x1E	; 30
     7c0:	31 e0       	ldi	r19, 0x01	; 1
     7c2:	1e c0       	rjmp	.+60     	; 0x800 <CALLBACK_USB_GetDescriptor+0x5c>
			Size    = sizeof(USB_Descriptor_Device_t);
			break;
		case DTYPE_Configuration:
			Address = &ConfigurationDescriptor;
			Size    = sizeof(USB_Descriptor_Configuration_t);
     7c4:	8e e3       	ldi	r24, 0x3E	; 62
     7c6:	90 e0       	ldi	r25, 0x00	; 0
		case DTYPE_Device:
			Address = &DeviceDescriptor;
			Size    = sizeof(USB_Descriptor_Device_t);
			break;
		case DTYPE_Configuration:
			Address = &ConfigurationDescriptor;
     7c8:	20 ee       	ldi	r18, 0xE0	; 224
     7ca:	30 e0       	ldi	r19, 0x00	; 0
			Size    = sizeof(USB_Descriptor_Configuration_t);
			break;
     7cc:	19 c0       	rjmp	.+50     	; 0x800 <CALLBACK_USB_GetDescriptor+0x5c>
     7ce:	99 27       	eor	r25, r25
		case DTYPE_String:
			switch (DescriptorNumber)
     7d0:	81 30       	cpi	r24, 0x01	; 1
     7d2:	91 05       	cpc	r25, r1
     7d4:	41 f0       	breq	.+16     	; 0x7e6 <CALLBACK_USB_GetDescriptor+0x42>
     7d6:	82 30       	cpi	r24, 0x02	; 2
     7d8:	91 05       	cpc	r25, r1
     7da:	41 f0       	breq	.+16     	; 0x7ec <CALLBACK_USB_GetDescriptor+0x48>
     7dc:	89 2b       	or	r24, r25
     7de:	61 f4       	brne	.+24     	; 0x7f8 <CALLBACK_USB_GetDescriptor+0x54>
			{
				case STRING_ID_Language:
					Address = &LanguageString;
					Size    = pgm_read_byte(&LanguageString.Header.Size);
     7e0:	ec ed       	ldi	r30, 0xDC	; 220
     7e2:	f0 e0       	ldi	r31, 0x00	; 0
     7e4:	05 c0       	rjmp	.+10     	; 0x7f0 <CALLBACK_USB_GetDescriptor+0x4c>
					break;
				case STRING_ID_Manufacturer:
					Address = &ManufacturerString;
					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
     7e6:	e2 ec       	ldi	r30, 0xC2	; 194
     7e8:	f0 e0       	ldi	r31, 0x00	; 0
     7ea:	02 c0       	rjmp	.+4      	; 0x7f0 <CALLBACK_USB_GetDescriptor+0x4c>
					break;
				case STRING_ID_Product:
					Address = &ProductString;
					Size    = pgm_read_byte(&ProductString.Header.Size);
     7ec:	e8 e9       	ldi	r30, 0x98	; 152
     7ee:	f0 e0       	ldi	r31, 0x00	; 0
     7f0:	84 91       	lpm	r24, Z
     7f2:	90 e0       	ldi	r25, 0x00	; 0
				case STRING_ID_Manufacturer:
					Address = &ManufacturerString;
					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
					break;
				case STRING_ID_Product:
					Address = &ProductString;
     7f4:	9f 01       	movw	r18, r30
					Size    = pgm_read_byte(&ProductString.Header.Size);
					break;
     7f6:	04 c0       	rjmp	.+8      	; 0x800 <CALLBACK_USB_GetDescriptor+0x5c>
{
	const uint8_t  DescriptorType   = (wValue >> 8);
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
	uint16_t    Size    = NO_DESCRIPTOR;
     7f8:	80 e0       	ldi	r24, 0x00	; 0
     7fa:	90 e0       	ldi	r25, 0x00	; 0
                                    const void** const DescriptorAddress)
{
	const uint8_t  DescriptorType   = (wValue >> 8);
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
     7fc:	20 e0       	ldi	r18, 0x00	; 0
     7fe:	30 e0       	ldi	r19, 0x00	; 0
			}

			break;
	}

	*DescriptorAddress = Address;
     800:	fa 01       	movw	r30, r20
     802:	31 83       	std	Z+1, r19	; 0x01
     804:	20 83       	st	Z, r18
	return Size;
}
     806:	08 95       	ret

00000808 <Ethernet_ProcessPacket>:
/** Processes an incoming Ethernet frame, and writes the appropriate response to the output Ethernet
 *  frame buffer if the sub protocol handlers create a valid response.
 */
void Ethernet_ProcessPacket(void)
{
	DecodeEthernetFrameHeader(FrameIN.FrameData);
     808:	8d e4       	ldi	r24, 0x4D	; 77
     80a:	91 e0       	ldi	r25, 0x01	; 1
     80c:	8f d0       	rcall	.+286    	; 0x92c <DecodeEthernetFrameHeader>
     80e:	46 e0       	ldi	r20, 0x06	; 6
	Ethernet_Frame_Header_t* FrameOUTHeader = (Ethernet_Frame_Header_t*)&FrameOUT.FrameData;

	int16_t                  RetSize        = NO_RESPONSE;

	/* Ensure frame is addressed to either all (broadcast) or the virtual webserver, and is a type II frame */
	if ((MAC_COMPARE(&FrameINHeader->Destination, &ServerMACAddress) ||
     810:	50 e0       	ldi	r21, 0x00	; 0
     812:	6c e1       	ldi	r22, 0x1C	; 28
     814:	71 e0       	ldi	r23, 0x01	; 1
     816:	8d e4       	ldi	r24, 0x4D	; 77
     818:	91 e0       	ldi	r25, 0x01	; 1
     81a:	0e 94 69 14 	call	0x28d2	; 0x28d2 <memcmp>
     81e:	89 2b       	or	r24, r25
     820:	59 f0       	breq	.+22     	; 0x838 <Ethernet_ProcessPacket+0x30>
     822:	46 e0       	ldi	r20, 0x06	; 6
	     MAC_COMPARE(&FrameINHeader->Destination, &BroadcastMACAddress)) &&
     824:	50 e0       	ldi	r21, 0x00	; 0
     826:	62 e1       	ldi	r22, 0x12	; 18
     828:	71 e0       	ldi	r23, 0x01	; 1
     82a:	8d e4       	ldi	r24, 0x4D	; 77
     82c:	91 e0       	ldi	r25, 0x01	; 1
     82e:	0e 94 69 14 	call	0x28d2	; 0x28d2 <memcmp>
     832:	89 2b       	or	r24, r25
	Ethernet_Frame_Header_t* FrameOUTHeader = (Ethernet_Frame_Header_t*)&FrameOUT.FrameData;

	int16_t                  RetSize        = NO_RESPONSE;

	/* Ensure frame is addressed to either all (broadcast) or the virtual webserver, and is a type II frame */
	if ((MAC_COMPARE(&FrameINHeader->Destination, &ServerMACAddress) ||
     834:	09 f0       	breq	.+2      	; 0x838 <Ethernet_ProcessPacket+0x30>
     836:	44 c0       	rjmp	.+136    	; 0x8c0 <Ethernet_ProcessPacket+0xb8>
     838:	80 91 2a 07 	lds	r24, 0x072A

				Temp = Data.Bytes[0];
				Data.Bytes[0] = Data.Bytes[1];
				Data.Bytes[1] = Temp;

				return Data.Word;
     83c:	90 91 29 07 	lds	r25, 0x0729
     840:	81 30       	cpi	r24, 0x01	; 1
	     MAC_COMPARE(&FrameINHeader->Destination, &BroadcastMACAddress)) &&
     842:	96 40       	sbci	r25, 0x06	; 6
     844:	e8 f1       	brcs	.+122    	; 0x8c0 <Ethernet_ProcessPacket+0xb8>
     846:	80 91 5a 01 	lds	r24, 0x015A
     84a:	90 91 59 01 	lds	r25, 0x0159
     84e:	81 15       	cp	r24, r1
		(SwapEndian_16(FrameIN.FrameLength) > ETHERNET_VER2_MINSIZE))
	{
		/* Process the packet depending on its protocol */
		switch (SwapEndian_16(FrameINHeader->EtherType))
     850:	28 e0       	ldi	r18, 0x08	; 8
     852:	92 07       	cpc	r25, r18
     854:	51 f0       	breq	.+20     	; 0x86a <Ethernet_ProcessPacket+0x62>
     856:	86 30       	cpi	r24, 0x06	; 6
     858:	98 40       	sbci	r25, 0x08	; 8
     85a:	91 f5       	brne	.+100    	; 0x8c0 <Ethernet_ProcessPacket+0xb8>
     85c:	69 e3       	ldi	r22, 0x39	; 57
		{
			case ETHERTYPE_ARP:
				RetSize = ARP_ProcessARPPacket(&FrameIN.FrameData[sizeof(Ethernet_Frame_Header_t)],
     85e:	77 e0       	ldi	r23, 0x07	; 7
     860:	8b e5       	ldi	r24, 0x5B	; 91
     862:	91 e0       	ldi	r25, 0x01	; 1
     864:	0e 94 85 0d 	call	0x1b0a	; 0x1b0a <ARP_ProcessARPPacket>
     868:	06 c0       	rjmp	.+12     	; 0x876 <Ethernet_ProcessPacket+0x6e>
				                               &FrameOUT.FrameData[sizeof(Ethernet_Frame_Header_t)]);
				break;
     86a:	69 e3       	ldi	r22, 0x39	; 57
			case ETHERTYPE_IPV4:
				RetSize = IP_ProcessIPPacket(&FrameIN.FrameData[sizeof(Ethernet_Frame_Header_t)],
     86c:	77 e0       	ldi	r23, 0x07	; 7
     86e:	8b e5       	ldi	r24, 0x5B	; 91
     870:	91 e0       	ldi	r25, 0x01	; 1
     872:	0e 94 eb 0d 	call	0x1bd6	; 0x1bd6 <IP_ProcessIPPacket>
     876:	18 16       	cp	r1, r24
				                             &FrameOUT.FrameData[sizeof(Ethernet_Frame_Header_t)]);
				break;
		}

		/* Protocol processing routine has filled a response, complete the ethernet frame header */
		if (RetSize > 0)
     878:	19 06       	cpc	r1, r25
     87a:	04 f5       	brge	.+64     	; 0x8bc <Ethernet_ProcessPacket+0xb4>
     87c:	26 e0       	ldi	r18, 0x06	; 6
		{
			/* Fill out the response Ethernet frame header */
			FrameOUTHeader->Source          = ServerMACAddress;
     87e:	ec e1       	ldi	r30, 0x1C	; 28
     880:	f1 e0       	ldi	r31, 0x01	; 1
     882:	a1 e3       	ldi	r26, 0x31	; 49
     884:	b7 e0       	ldi	r27, 0x07	; 7
     886:	01 90       	ld	r0, Z+
     888:	0d 92       	st	X+, r0
     88a:	2a 95       	dec	r18
     88c:	e1 f7       	brne	.-8      	; 0x886 <Ethernet_ProcessPacket+0x7e>
     88e:	26 e0       	ldi	r18, 0x06	; 6
			FrameOUTHeader->Destination     = FrameINHeader->Source;
     890:	e3 e5       	ldi	r30, 0x53	; 83
     892:	f1 e0       	ldi	r31, 0x01	; 1
     894:	ab e2       	ldi	r26, 0x2B	; 43
     896:	b7 e0       	ldi	r27, 0x07	; 7
     898:	01 90       	ld	r0, Z+
     89a:	0d 92       	st	X+, r0
     89c:	2a 95       	dec	r18
     89e:	e1 f7       	brne	.-8      	; 0x898 <Ethernet_ProcessPacket+0x90>
     8a0:	20 91 59 01 	lds	r18, 0x0159
			FrameOUTHeader->EtherType       = FrameINHeader->EtherType;
     8a4:	30 91 5a 01 	lds	r19, 0x015A
     8a8:	30 93 38 07 	sts	0x0738, r19
     8ac:	20 93 37 07 	sts	0x0737, r18
     8b0:	0e 96       	adiw	r24, 0x0e	; 14

			/* Set the response length in the buffer and indicate that a response is ready to be sent */
			FrameOUT.FrameLength            = (sizeof(Ethernet_Frame_Header_t) + RetSize);
     8b2:	90 93 08 0d 	sts	0x0D08, r25
     8b6:	80 93 07 0d 	sts	0x0D07, r24
     8ba:	02 c0       	rjmp	.+4      	; 0x8c0 <Ethernet_ProcessPacket+0xb8>
     8bc:	01 96       	adiw	r24, 0x01	; 1
		}
	}

	/* Check if the packet was processed */
	if (RetSize != NO_PROCESS)
     8be:	21 f0       	breq	.+8      	; 0x8c8 <Ethernet_ProcessPacket+0xc0>
     8c0:	10 92 2a 07 	sts	0x072A, r1
	{
		/* Clear the frame buffer */
		FrameIN.FrameLength = 0;
     8c4:	10 92 29 07 	sts	0x0729, r1
     8c8:	08 95       	ret

000008ca <Ethernet_Checksum16>:
     8ca:	cf 93       	push	r28
 *
 *  \return A 16-bit Ethernet checksum value
 */
uint16_t Ethernet_Checksum16(void* Data,
                             uint16_t Bytes)
{
     8cc:	df 93       	push	r29
     8ce:	9b 01       	movw	r18, r22
	uint16_t* Words    = (uint16_t*)Data;
	uint32_t  Checksum = 0;

	for (uint16_t CurrWord = 0; CurrWord < (Bytes >> 1); CurrWord++)
     8d0:	36 95       	lsr	r19
     8d2:	27 95       	ror	r18
     8d4:	e0 e0       	ldi	r30, 0x00	; 0
     8d6:	f0 e0       	ldi	r31, 0x00	; 0
 */
uint16_t Ethernet_Checksum16(void* Data,
                             uint16_t Bytes)
{
	uint16_t* Words    = (uint16_t*)Data;
	uint32_t  Checksum = 0;
     8d8:	40 e0       	ldi	r20, 0x00	; 0
     8da:	50 e0       	ldi	r21, 0x00	; 0
     8dc:	ba 01       	movw	r22, r20

	for (uint16_t CurrWord = 0; CurrWord < (Bytes >> 1); CurrWord++)
     8de:	e2 17       	cp	r30, r18
     8e0:	f3 07       	cpc	r31, r19
     8e2:	51 f0       	breq	.+20     	; 0x8f8 <Ethernet_Checksum16+0x2e>
	  Checksum += Words[CurrWord];
     8e4:	ec 01       	movw	r28, r24
     8e6:	a9 91       	ld	r26, Y+
     8e8:	b9 91       	ld	r27, Y+
     8ea:	ce 01       	movw	r24, r28
     8ec:	4a 0f       	add	r20, r26
     8ee:	5b 1f       	adc	r21, r27
     8f0:	61 1d       	adc	r22, r1
     8f2:	71 1d       	adc	r23, r1
                             uint16_t Bytes)
{
	uint16_t* Words    = (uint16_t*)Data;
	uint32_t  Checksum = 0;

	for (uint16_t CurrWord = 0; CurrWord < (Bytes >> 1); CurrWord++)
     8f4:	31 96       	adiw	r30, 0x01	; 1
     8f6:	f3 cf       	rjmp	.-26     	; 0x8de <Ethernet_Checksum16+0x14>
	  Checksum += Words[CurrWord];

	while (Checksum & 0xFFFF0000)
     8f8:	db 01       	movw	r26, r22
     8fa:	ca 01       	movw	r24, r20
     8fc:	88 27       	eor	r24, r24
     8fe:	99 27       	eor	r25, r25
     900:	89 2b       	or	r24, r25
     902:	8a 2b       	or	r24, r26
     904:	8b 2b       	or	r24, r27
     906:	61 f0       	breq	.+24     	; 0x920 <Ethernet_Checksum16+0x56>
	  Checksum = ((Checksum & 0xFFFF) + (Checksum >> 16));
     908:	db 01       	movw	r26, r22
     90a:	ca 01       	movw	r24, r20
     90c:	aa 27       	eor	r26, r26
     90e:	bb 27       	eor	r27, r27
     910:	ab 01       	movw	r20, r22
     912:	66 27       	eor	r22, r22
     914:	77 27       	eor	r23, r23
     916:	48 0f       	add	r20, r24
     918:	59 1f       	adc	r21, r25
     91a:	6a 1f       	adc	r22, r26
     91c:	7b 1f       	adc	r23, r27
     91e:	ec cf       	rjmp	.-40     	; 0x8f8 <Ethernet_Checksum16+0x2e>

	return ~Checksum;
     920:	ca 01       	movw	r24, r20
     922:	80 95       	com	r24
     924:	90 95       	com	r25
}
     926:	df 91       	pop	r29
     928:	cf 91       	pop	r28
     92a:	08 95       	ret

0000092c <DecodeEthernetFrameHeader>:
/** Decodes an Ethernet frame header and prints its contents to through the USART in a human readable format.
 *
 *  \param[in] InDataStart  Pointer to the start of an Ethernet frame header
 */
void DecodeEthernetFrameHeader(void* InDataStart)
{
     92c:	08 95       	ret

0000092e <DecodeARPHeader>:
/** Decodes an ARP header and prints its contents to through the USART in a human readable format.
 *
 *  \param[in] InDataStart  Pointer to the start of an ARP packet header
 */
void DecodeARPHeader(void* InDataStart)
{
     92e:	08 95       	ret

00000930 <DecodeIPHeader>:
/** Decodes an IP header and prints its contents to through the USART in a human readable format.
 *
 *  \param[in] InDataStart  Pointer to the start of an IP packet header
 */
void DecodeIPHeader(void* InDataStart)
{
     930:	08 95       	ret

00000932 <DecodeICMPHeader>:
/** Decodes an ICMP header and prints its contents to through the USART in a human readable format.
 *
 *  \param[in] InDataStart  Pointer to the start of an ICMP packet header
 */
void DecodeICMPHeader(void* InDataStart)
{
     932:	08 95       	ret

00000934 <DecodeTCPHeader>:
/** Decodes a TCP header and prints its contents to through the USART in a human readable format.
 *
 *  \param[in] InDataStart  Pointer to the start of a TCP packet header
 */
void DecodeTCPHeader(void* InDataStart)
{
     934:	08 95       	ret

00000936 <DecodeUDPHeader>:
/** Decodes an UDP header and prints its contents to through the USART in a human readable format.
 *
 *  \param[in] InDataStart  Pointer to the start of a UDP packet header
 */
void DecodeUDPHeader(void* InDataStart)
{
     936:	08 95       	ret

00000938 <DecodeDHCPHeader>:
/** Decodes an DHCP header and prints its contents to through the USART in a human readable format.
 *
 *  \param[in] InDataStart  Pointer to the start of a DHCP packet header
 */
void DecodeDHCPHeader(void* InDataStart)
{
     938:	08 95       	ret

0000093a <ProcessRNDISControlMessage>:
void ProcessRNDISControlMessage(void)
{
	/* Note: Only a single buffer is used for both the received message and its response to save SRAM. Because of
	         this, response bytes should be filled in order so that they do not clobber unread data in the buffer. */

	switch (MessageHeader->MessageType)
     93a:	e0 91 00 01 	lds	r30, 0x0100
     93e:	f0 91 01 01 	lds	r31, 0x0101
     942:	80 81       	ld	r24, Z
     944:	91 81       	ldd	r25, Z+1	; 0x01
     946:	a2 81       	ldd	r26, Z+2	; 0x02
     948:	b3 81       	ldd	r27, Z+3	; 0x03
     94a:	84 30       	cpi	r24, 0x04	; 4
     94c:	91 05       	cpc	r25, r1
     94e:	a1 05       	cpc	r26, r1
     950:	b1 05       	cpc	r27, r1
     952:	09 f4       	brne	.+2      	; 0x956 <ProcessRNDISControlMessage+0x1c>
     954:	99 c0       	rjmp	.+306    	; 0xa88 <ProcessRNDISControlMessage+0x14e>
     956:	58 f4       	brcc	.+22     	; 0x96e <ProcessRNDISControlMessage+0x34>
     958:	82 30       	cpi	r24, 0x02	; 2
     95a:	91 05       	cpc	r25, r1
     95c:	a1 05       	cpc	r26, r1
     95e:	b1 05       	cpc	r27, r1
     960:	a1 f0       	breq	.+40     	; 0x98a <ProcessRNDISControlMessage+0x50>
     962:	03 97       	sbiw	r24, 0x03	; 3
     964:	a1 05       	cpc	r26, r1
     966:	b1 05       	cpc	r27, r1
     968:	09 f4       	brne	.+2      	; 0x96c <ProcessRNDISControlMessage+0x32>
     96a:	85 c0       	rjmp	.+266    	; 0xa76 <ProcessRNDISControlMessage+0x13c>
     96c:	08 95       	ret
     96e:	86 30       	cpi	r24, 0x06	; 6
     970:	91 05       	cpc	r25, r1
     972:	a1 05       	cpc	r26, r1
     974:	b1 05       	cpc	r27, r1
     976:	09 f4       	brne	.+2      	; 0x97a <ProcessRNDISControlMessage+0x40>
     978:	e0 c1       	rjmp	.+960    	; 0xd3a <ProcessRNDISControlMessage+0x400>
     97a:	08 f4       	brcc	.+2      	; 0x97e <ProcessRNDISControlMessage+0x44>
     97c:	82 c1       	rjmp	.+772    	; 0xc82 <ProcessRNDISControlMessage+0x348>
     97e:	08 97       	sbiw	r24, 0x08	; 8
     980:	a1 05       	cpc	r26, r1
     982:	b1 05       	cpc	r27, r1
     984:	09 f4       	brne	.+2      	; 0x988 <ProcessRNDISControlMessage+0x4e>
     986:	fd c1       	rjmp	.+1018   	; 0xd82 <ProcessRNDISControlMessage+0x448>
     988:	08 95       	ret
	{
		case REMOTE_NDIS_INITIALIZE_MSG:
			/* Initialize the adapter - return information about the supported RNDIS version and buffer sizes */

			ResponseReady = true;
     98a:	21 e0       	ldi	r18, 0x01	; 1
     98c:	20 93 4b 01 	sts	0x014B, r18

			RNDIS_Initialize_Message_t*  INITIALIZE_Message  = (RNDIS_Initialize_Message_t*)&RNDISMessageBuffer;
			RNDIS_Initialize_Complete_t* INITIALIZE_Response = (RNDIS_Initialize_Complete_t*)&RNDISMessageBuffer;

			INITIALIZE_Response->MessageType           = REMOTE_NDIS_INITIALIZE_CMPLT;
     990:	82 e0       	ldi	r24, 0x02	; 2
     992:	90 e0       	ldi	r25, 0x00	; 0
     994:	a0 e0       	ldi	r26, 0x00	; 0
     996:	b0 e8       	ldi	r27, 0x80	; 128
     998:	80 93 09 0d 	sts	0x0D09, r24
     99c:	90 93 0a 0d 	sts	0x0D0A, r25
     9a0:	a0 93 0b 0d 	sts	0x0D0B, r26
     9a4:	b0 93 0c 0d 	sts	0x0D0C, r27
			INITIALIZE_Response->MessageLength         = sizeof(RNDIS_Initialize_Complete_t);
     9a8:	84 e3       	ldi	r24, 0x34	; 52
     9aa:	90 e0       	ldi	r25, 0x00	; 0
     9ac:	a0 e0       	ldi	r26, 0x00	; 0
     9ae:	b0 e0       	ldi	r27, 0x00	; 0
     9b0:	80 93 0d 0d 	sts	0x0D0D, r24
     9b4:	90 93 0e 0d 	sts	0x0D0E, r25
     9b8:	a0 93 0f 0d 	sts	0x0D0F, r26
     9bc:	b0 93 10 0d 	sts	0x0D10, r27
			INITIALIZE_Response->RequestId             = INITIALIZE_Message->RequestId;
			INITIALIZE_Response->Status                = REMOTE_NDIS_STATUS_SUCCESS;
     9c0:	10 92 15 0d 	sts	0x0D15, r1
     9c4:	10 92 16 0d 	sts	0x0D16, r1
     9c8:	10 92 17 0d 	sts	0x0D17, r1
     9cc:	10 92 18 0d 	sts	0x0D18, r1

			INITIALIZE_Response->MajorVersion          = REMOTE_NDIS_VERSION_MAJOR;
     9d0:	81 e0       	ldi	r24, 0x01	; 1
     9d2:	90 e0       	ldi	r25, 0x00	; 0
     9d4:	a0 e0       	ldi	r26, 0x00	; 0
     9d6:	b0 e0       	ldi	r27, 0x00	; 0
     9d8:	80 93 19 0d 	sts	0x0D19, r24
     9dc:	90 93 1a 0d 	sts	0x0D1A, r25
     9e0:	a0 93 1b 0d 	sts	0x0D1B, r26
     9e4:	b0 93 1c 0d 	sts	0x0D1C, r27
			INITIALIZE_Response->MinorVersion          = REMOTE_NDIS_VERSION_MINOR;
     9e8:	10 92 1d 0d 	sts	0x0D1D, r1
     9ec:	10 92 1e 0d 	sts	0x0D1E, r1
     9f0:	10 92 1f 0d 	sts	0x0D1F, r1
     9f4:	10 92 20 0d 	sts	0x0D20, r1
			INITIALIZE_Response->DeviceFlags           = REMOTE_NDIS_DF_CONNECTIONLESS;
     9f8:	80 93 21 0d 	sts	0x0D21, r24
     9fc:	90 93 22 0d 	sts	0x0D22, r25
     a00:	a0 93 23 0d 	sts	0x0D23, r26
     a04:	b0 93 24 0d 	sts	0x0D24, r27
			INITIALIZE_Response->Medium                = REMOTE_NDIS_MEDIUM_802_3;
     a08:	10 92 25 0d 	sts	0x0D25, r1
     a0c:	10 92 26 0d 	sts	0x0D26, r1
     a10:	10 92 27 0d 	sts	0x0D27, r1
     a14:	10 92 28 0d 	sts	0x0D28, r1
			INITIALIZE_Response->MaxPacketsPerTransfer = 1;
     a18:	80 93 29 0d 	sts	0x0D29, r24
     a1c:	90 93 2a 0d 	sts	0x0D2A, r25
     a20:	a0 93 2b 0d 	sts	0x0D2B, r26
     a24:	b0 93 2c 0d 	sts	0x0D2C, r27
			INITIALIZE_Response->MaxTransferSize       = (sizeof(RNDIS_Packet_Message_t) + ETHERNET_FRAME_SIZE_MAX);
     a28:	88 e0       	ldi	r24, 0x08	; 8
     a2a:	96 e0       	ldi	r25, 0x06	; 6
     a2c:	a0 e0       	ldi	r26, 0x00	; 0
     a2e:	b0 e0       	ldi	r27, 0x00	; 0
     a30:	80 93 2d 0d 	sts	0x0D2D, r24
     a34:	90 93 2e 0d 	sts	0x0D2E, r25
     a38:	a0 93 2f 0d 	sts	0x0D2F, r26
     a3c:	b0 93 30 0d 	sts	0x0D30, r27
			INITIALIZE_Response->PacketAlignmentFactor = 0;
     a40:	10 92 31 0d 	sts	0x0D31, r1
     a44:	10 92 32 0d 	sts	0x0D32, r1
     a48:	10 92 33 0d 	sts	0x0D33, r1
     a4c:	10 92 34 0d 	sts	0x0D34, r1
			INITIALIZE_Response->AFListOffset          = 0;
     a50:	10 92 35 0d 	sts	0x0D35, r1
     a54:	10 92 36 0d 	sts	0x0D36, r1
     a58:	10 92 37 0d 	sts	0x0D37, r1
     a5c:	10 92 38 0d 	sts	0x0D38, r1
			INITIALIZE_Response->AFListSize            = 0;
     a60:	10 92 39 0d 	sts	0x0D39, r1
     a64:	10 92 3a 0d 	sts	0x0D3A, r1
     a68:	10 92 3b 0d 	sts	0x0D3B, r1
     a6c:	10 92 3c 0d 	sts	0x0D3C, r1

			CurrRNDISState = RNDIS_Initialized;
     a70:	20 93 4a 01 	sts	0x014A, r18

			break;
     a74:	08 95       	ret
		case REMOTE_NDIS_HALT_MSG:
			/* Halt the adapter, reset the adapter state - note that no response should be returned when completed */

			ResponseReady = false;
     a76:	10 92 4b 01 	sts	0x014B, r1
			MessageHeader->MessageLength = 0;
     a7a:	14 82       	std	Z+4, r1	; 0x04
     a7c:	15 82       	std	Z+5, r1	; 0x05
     a7e:	16 82       	std	Z+6, r1	; 0x06
     a80:	17 82       	std	Z+7, r1	; 0x07

			CurrRNDISState = RNDIS_Uninitialized;
     a82:	10 92 4a 01 	sts	0x014A, r1

			break;
     a86:	08 95       	ret
		case REMOTE_NDIS_QUERY_MSG:
			/* Request for information about a parameter about the adapter, specified as an OID token */

			ResponseReady = true;
     a88:	81 e0       	ldi	r24, 0x01	; 1
     a8a:	80 93 4b 01 	sts	0x014B, r24

			RNDIS_Query_Message_t*  QUERY_Message  = (RNDIS_Query_Message_t*)&RNDISMessageBuffer;
			RNDIS_Query_Complete_t* QUERY_Response = (RNDIS_Query_Complete_t*)&RNDISMessageBuffer;
			uint32_t                Query_Oid      = QUERY_Message->Oid;
     a8e:	80 91 15 0d 	lds	r24, 0x0D15
     a92:	90 91 16 0d 	lds	r25, 0x0D16
     a96:	a0 91 17 0d 	lds	r26, 0x0D17
     a9a:	b0 91 18 0d 	lds	r27, 0x0D18
			void*     QueryData                 = &RNDISMessageBuffer[sizeof(RNDIS_Message_Header_t) +
			                                                          QUERY_Message->InformationBufferOffset];
			void*     ResponseData              = &RNDISMessageBuffer[sizeof(RNDIS_Query_Complete_t)];
			uint16_t  ResponseSize;

			QUERY_Response->MessageType         = REMOTE_NDIS_QUERY_CMPLT;
     a9e:	44 e0       	ldi	r20, 0x04	; 4
     aa0:	50 e0       	ldi	r21, 0x00	; 0
     aa2:	60 e0       	ldi	r22, 0x00	; 0
     aa4:	70 e8       	ldi	r23, 0x80	; 128
     aa6:	40 93 09 0d 	sts	0x0D09, r20
     aaa:	50 93 0a 0d 	sts	0x0D0A, r21
     aae:	60 93 0b 0d 	sts	0x0D0B, r22
     ab2:	70 93 0c 0d 	sts	0x0D0C, r23
			QUERY_Response->MessageLength       = sizeof(RNDIS_Query_Complete_t);
     ab6:	48 e1       	ldi	r20, 0x18	; 24
     ab8:	50 e0       	ldi	r21, 0x00	; 0
     aba:	60 e0       	ldi	r22, 0x00	; 0
     abc:	70 e0       	ldi	r23, 0x00	; 0
     abe:	40 93 0d 0d 	sts	0x0D0D, r20
     ac2:	50 93 0e 0d 	sts	0x0D0E, r21
     ac6:	60 93 0f 0d 	sts	0x0D0F, r22
     aca:	70 93 10 0d 	sts	0x0D10, r23
static bool ProcessNDISQuery(const uint32_t OId, void* QueryData, uint16_t QuerySize,
                             void* ResponseData, uint16_t* ResponseSize)
{
	/* Handler for REMOTE_NDIS_QUERY_MSG messages */

	switch (OId)
     ace:	8e 30       	cpi	r24, 0x0E	; 14
     ad0:	21 e0       	ldi	r18, 0x01	; 1
     ad2:	92 07       	cpc	r25, r18
     ad4:	a2 07       	cpc	r26, r18
     ad6:	b1 05       	cpc	r27, r1
     ad8:	09 f4       	brne	.+2      	; 0xadc <ProcessRNDISControlMessage+0x1a2>
     ada:	b6 c0       	rjmp	.+364    	; 0xc48 <ProcessRNDISControlMessage+0x30e>
     adc:	08 f0       	brcs	.+2      	; 0xae0 <ProcessRNDISControlMessage+0x1a6>
     ade:	58 c0       	rjmp	.+176    	; 0xb90 <ProcessRNDISControlMessage+0x256>
     ae0:	86 30       	cpi	r24, 0x06	; 6
     ae2:	21 e0       	ldi	r18, 0x01	; 1
     ae4:	92 07       	cpc	r25, r18
     ae6:	a2 07       	cpc	r26, r18
     ae8:	b1 05       	cpc	r27, r1
     aea:	09 f4       	brne	.+2      	; 0xaee <ProcessRNDISControlMessage+0x1b4>
     aec:	a3 c0       	rjmp	.+326    	; 0xc34 <ProcessRNDISControlMessage+0x2fa>
     aee:	00 f5       	brcc	.+64     	; 0xb30 <ProcessRNDISControlMessage+0x1f6>
     af0:	82 30       	cpi	r24, 0x02	; 2
     af2:	21 e0       	ldi	r18, 0x01	; 1
     af4:	92 07       	cpc	r25, r18
     af6:	a2 07       	cpc	r26, r18
     af8:	b1 05       	cpc	r27, r1
     afa:	09 f4       	brne	.+2      	; 0xafe <ProcessRNDISControlMessage+0x1c4>
     afc:	ae c0       	rjmp	.+348    	; 0xc5a <ProcessRNDISControlMessage+0x320>
     afe:	88 f4       	brcc	.+34     	; 0xb22 <ProcessRNDISControlMessage+0x1e8>
     b00:	81 30       	cpi	r24, 0x01	; 1
     b02:	91 40       	sbci	r25, 0x01	; 1
     b04:	a1 40       	sbci	r26, 0x01	; 1
     b06:	b1 05       	cpc	r27, r1
     b08:	09 f0       	breq	.+2      	; 0xb0c <ProcessRNDISControlMessage+0x1d2>
     b0a:	8a c1       	rjmp	.+788    	; 0xe20 <ProcessRNDISControlMessage+0x4e6>
	{
		case OID_GEN_SUPPORTED_LIST:
			*ResponseSize = sizeof(AdapterSupportedOIDList);

			/* Copy the list of supported NDIS OID tokens to the response buffer */
			memcpy_P(ResponseData, AdapterSupportedOIDList, sizeof(AdapterSupportedOIDList));
     b0c:	4c e6       	ldi	r20, 0x6C	; 108
     b0e:	50 e0       	ldi	r21, 0x00	; 0
     b10:	60 e3       	ldi	r22, 0x30	; 48
     b12:	71 e0       	ldi	r23, 0x01	; 1
     b14:	81 e2       	ldi	r24, 0x21	; 33
     b16:	9d e0       	ldi	r25, 0x0D	; 13
     b18:	0e 94 41 14 	call	0x2882	; 0x2882 <memcpy_P>
	/* Handler for REMOTE_NDIS_QUERY_MSG messages */

	switch (OId)
	{
		case OID_GEN_SUPPORTED_LIST:
			*ResponseSize = sizeof(AdapterSupportedOIDList);
     b1c:	4c e6       	ldi	r20, 0x6C	; 108
     b1e:	50 e0       	ldi	r21, 0x00	; 0
     b20:	4c c1       	rjmp	.+664    	; 0xdba <ProcessRNDISControlMessage+0x480>
static bool ProcessNDISQuery(const uint32_t OId, void* QueryData, uint16_t QuerySize,
                             void* ResponseData, uint16_t* ResponseSize)
{
	/* Handler for REMOTE_NDIS_QUERY_MSG messages */

	switch (OId)
     b22:	85 30       	cpi	r24, 0x05	; 5
     b24:	91 40       	sbci	r25, 0x01	; 1
     b26:	a1 40       	sbci	r26, 0x01	; 1
     b28:	b1 05       	cpc	r27, r1
     b2a:	08 f4       	brcc	.+2      	; 0xb2e <ProcessRNDISControlMessage+0x1f4>
     b2c:	96 c0       	rjmp	.+300    	; 0xc5a <ProcessRNDISControlMessage+0x320>
     b2e:	78 c1       	rjmp	.+752    	; 0xe20 <ProcessRNDISControlMessage+0x4e6>
     b30:	8c 30       	cpi	r24, 0x0C	; 12
     b32:	21 e0       	ldi	r18, 0x01	; 1
     b34:	92 07       	cpc	r25, r18
     b36:	a2 07       	cpc	r26, r18
     b38:	b1 05       	cpc	r27, r1
     b3a:	90 f4       	brcc	.+36     	; 0xb60 <ProcessRNDISControlMessage+0x226>
     b3c:	8a 30       	cpi	r24, 0x0A	; 10
     b3e:	21 e0       	ldi	r18, 0x01	; 1
     b40:	92 07       	cpc	r25, r18
     b42:	a2 07       	cpc	r26, r18
     b44:	b1 05       	cpc	r27, r1
     b46:	08 f0       	brcs	.+2      	; 0xb4a <ProcessRNDISControlMessage+0x210>
     b48:	75 c0       	rjmp	.+234    	; 0xc34 <ProcessRNDISControlMessage+0x2fa>
     b4a:	87 30       	cpi	r24, 0x07	; 7
     b4c:	91 40       	sbci	r25, 0x01	; 1
     b4e:	a1 40       	sbci	r26, 0x01	; 1
     b50:	b1 05       	cpc	r27, r1
     b52:	09 f0       	breq	.+2      	; 0xb56 <ProcessRNDISControlMessage+0x21c>
     b54:	65 c1       	rjmp	.+714    	; 0xe20 <ProcessRNDISControlMessage+0x4e6>
			return true;
		case OID_GEN_LINK_SPEED:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate 10Mb/s link speed */
			*((uint32_t*)ResponseData) = 100000;
     b56:	80 ea       	ldi	r24, 0xA0	; 160
     b58:	96 e8       	ldi	r25, 0x86	; 134
     b5a:	a1 e0       	ldi	r26, 0x01	; 1
     b5c:	b0 e0       	ldi	r27, 0x00	; 0
     b5e:	86 c0       	rjmp	.+268    	; 0xc6c <ProcessRNDISControlMessage+0x332>
static bool ProcessNDISQuery(const uint32_t OId, void* QueryData, uint16_t QuerySize,
                             void* ResponseData, uint16_t* ResponseSize)
{
	/* Handler for REMOTE_NDIS_QUERY_MSG messages */

	switch (OId)
     b60:	8c 30       	cpi	r24, 0x0C	; 12
     b62:	21 e0       	ldi	r18, 0x01	; 1
     b64:	92 07       	cpc	r25, r18
     b66:	a2 07       	cpc	r26, r18
     b68:	b1 05       	cpc	r27, r1
     b6a:	09 f4       	brne	.+2      	; 0xb6e <ProcessRNDISControlMessage+0x234>
     b6c:	5e c0       	rjmp	.+188    	; 0xc2a <ProcessRNDISControlMessage+0x2f0>
     b6e:	8d 30       	cpi	r24, 0x0D	; 13
     b70:	91 40       	sbci	r25, 0x01	; 1
     b72:	a1 40       	sbci	r26, 0x01	; 1
     b74:	b1 05       	cpc	r27, r1
     b76:	09 f0       	breq	.+2      	; 0xb7a <ProcessRNDISControlMessage+0x240>
     b78:	53 c1       	rjmp	.+678    	; 0xe20 <ProcessRNDISControlMessage+0x4e6>
			return true;
		case OID_GEN_VENDOR_DESCRIPTION:
			*ResponseSize = sizeof(AdapterVendorDescription);

			/* Copy vendor description string to the response buffer */
			memcpy_P(ResponseData, AdapterVendorDescription, sizeof(AdapterVendorDescription));
     b7a:	43 e1       	ldi	r20, 0x13	; 19
     b7c:	50 e0       	ldi	r21, 0x00	; 0
     b7e:	6c e9       	ldi	r22, 0x9C	; 156
     b80:	71 e0       	ldi	r23, 0x01	; 1
     b82:	81 e2       	ldi	r24, 0x21	; 33
     b84:	9d e0       	ldi	r25, 0x0D	; 13
     b86:	0e 94 41 14 	call	0x2882	; 0x2882 <memcpy_P>
			/* Indicate that the maximum frame size is the size of the ethernet frame buffer */
			*((uint32_t*)ResponseData) = ETHERNET_FRAME_SIZE_MAX;

			return true;
		case OID_GEN_VENDOR_DESCRIPTION:
			*ResponseSize = sizeof(AdapterVendorDescription);
     b8a:	43 e1       	ldi	r20, 0x13	; 19
     b8c:	50 e0       	ldi	r21, 0x00	; 0
     b8e:	15 c1       	rjmp	.+554    	; 0xdba <ProcessRNDISControlMessage+0x480>
static bool ProcessNDISQuery(const uint32_t OId, void* QueryData, uint16_t QuerySize,
                             void* ResponseData, uint16_t* ResponseSize)
{
	/* Handler for REMOTE_NDIS_QUERY_MSG messages */

	switch (OId)
     b90:	86 30       	cpi	r24, 0x06	; 6
     b92:	21 e0       	ldi	r18, 0x01	; 1
     b94:	92 07       	cpc	r25, r18
     b96:	22 e0       	ldi	r18, 0x02	; 2
     b98:	a2 07       	cpc	r26, r18
     b9a:	b1 05       	cpc	r27, r1
     b9c:	10 f5       	brcc	.+68     	; 0xbe2 <ProcessRNDISControlMessage+0x2a8>
     b9e:	81 30       	cpi	r24, 0x01	; 1
     ba0:	21 e0       	ldi	r18, 0x01	; 1
     ba2:	92 07       	cpc	r25, r18
     ba4:	22 e0       	ldi	r18, 0x02	; 2
     ba6:	a2 07       	cpc	r26, r18
     ba8:	b1 05       	cpc	r27, r1
     baa:	08 f0       	brcs	.+2      	; 0xbae <ProcessRNDISControlMessage+0x274>
     bac:	56 c0       	rjmp	.+172    	; 0xc5a <ProcessRNDISControlMessage+0x320>
     bae:	84 31       	cpi	r24, 0x14	; 20
     bb0:	21 e0       	ldi	r18, 0x01	; 1
     bb2:	92 07       	cpc	r25, r18
     bb4:	a2 07       	cpc	r26, r18
     bb6:	b1 05       	cpc	r27, r1
     bb8:	09 f4       	brne	.+2      	; 0xbbc <ProcessRNDISControlMessage+0x282>
     bba:	4f c0       	rjmp	.+158    	; 0xc5a <ProcessRNDISControlMessage+0x320>
     bbc:	82 30       	cpi	r24, 0x02	; 2
     bbe:	22 e0       	ldi	r18, 0x02	; 2
     bc0:	92 07       	cpc	r25, r18
     bc2:	21 e0       	ldi	r18, 0x01	; 1
     bc4:	a2 07       	cpc	r26, r18
     bc6:	b1 05       	cpc	r27, r1
     bc8:	09 f4       	brne	.+2      	; 0xbcc <ProcessRNDISControlMessage+0x292>
     bca:	47 c0       	rjmp	.+142    	; 0xc5a <ProcessRNDISControlMessage+0x320>
     bcc:	81 31       	cpi	r24, 0x11	; 17
     bce:	91 40       	sbci	r25, 0x01	; 1
     bd0:	a1 40       	sbci	r26, 0x01	; 1
     bd2:	b1 05       	cpc	r27, r1
     bd4:	09 f0       	breq	.+2      	; 0xbd8 <ProcessRNDISControlMessage+0x29e>
     bd6:	24 c1       	rjmp	.+584    	; 0xe20 <ProcessRNDISControlMessage+0x4e6>
			return true;
		case OID_GEN_MAXIMUM_TOTAL_SIZE:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate maximum overall buffer (Ethernet frame and RNDIS header) the adapter can handle */
			*((uint32_t*)ResponseData) = (sizeof(RNDISMessageBuffer) + ETHERNET_FRAME_SIZE_MAX);
     bd8:	80 e6       	ldi	r24, 0x60	; 96
     bda:	96 e0       	ldi	r25, 0x06	; 6
     bdc:	a0 e0       	ldi	r26, 0x00	; 0
     bde:	b0 e0       	ldi	r27, 0x00	; 0
     be0:	45 c0       	rjmp	.+138    	; 0xc6c <ProcessRNDISControlMessage+0x332>
static bool ProcessNDISQuery(const uint32_t OId, void* QueryData, uint16_t QuerySize,
                             void* ResponseData, uint16_t* ResponseSize)
{
	/* Handler for REMOTE_NDIS_QUERY_MSG messages */

	switch (OId)
     be2:	84 30       	cpi	r24, 0x04	; 4
     be4:	21 e0       	ldi	r18, 0x01	; 1
     be6:	92 07       	cpc	r25, r18
     be8:	a2 07       	cpc	r26, r18
     bea:	b2 07       	cpc	r27, r18
     bec:	41 f1       	breq	.+80     	; 0xc3e <ProcessRNDISControlMessage+0x304>
     bee:	a0 f4       	brcc	.+40     	; 0xc18 <ProcessRNDISControlMessage+0x2de>
     bf0:	81 50       	subi	r24, 0x01	; 1
     bf2:	91 40       	sbci	r25, 0x01	; 1
     bf4:	a1 40       	sbci	r26, 0x01	; 1
     bf6:	b1 40       	sbci	r27, 0x01	; 1
     bf8:	02 97       	sbiw	r24, 0x02	; 2
     bfa:	a1 05       	cpc	r26, r1
     bfc:	b1 05       	cpc	r27, r1
     bfe:	08 f0       	brcs	.+2      	; 0xc02 <ProcessRNDISControlMessage+0x2c8>
     c00:	0f c1       	rjmp	.+542    	; 0xe20 <ProcessRNDISControlMessage+0x4e6>
		case OID_802_3_PERMANENT_ADDRESS:
		case OID_802_3_CURRENT_ADDRESS:
			*ResponseSize = sizeof(MAC_Address_t);

			/* Copy over the fixed adapter MAC to the response buffer */
			memcpy_P(ResponseData, &AdapterMACAddress, sizeof(MAC_Address_t));
     c02:	46 e0       	ldi	r20, 0x06	; 6
     c04:	50 e0       	ldi	r21, 0x00	; 0
     c06:	6f ea       	ldi	r22, 0xAF	; 175
     c08:	71 e0       	ldi	r23, 0x01	; 1
     c0a:	81 e2       	ldi	r24, 0x21	; 33
     c0c:	9d e0       	ldi	r25, 0x0D	; 13
     c0e:	0e 94 41 14 	call	0x2882	; 0x2882 <memcpy_P>
			*((uint32_t*)ResponseData) = 100000;

			return true;
		case OID_802_3_PERMANENT_ADDRESS:
		case OID_802_3_CURRENT_ADDRESS:
			*ResponseSize = sizeof(MAC_Address_t);
     c12:	46 e0       	ldi	r20, 0x06	; 6
     c14:	50 e0       	ldi	r21, 0x00	; 0
     c16:	d1 c0       	rjmp	.+418    	; 0xdba <ProcessRNDISControlMessage+0x480>
static bool ProcessNDISQuery(const uint32_t OId, void* QueryData, uint16_t QuerySize,
                             void* ResponseData, uint16_t* ResponseSize)
{
	/* Handler for REMOTE_NDIS_QUERY_MSG messages */

	switch (OId)
     c18:	81 50       	subi	r24, 0x01	; 1
     c1a:	91 40       	sbci	r25, 0x01	; 1
     c1c:	a2 40       	sbci	r26, 0x02	; 2
     c1e:	b1 40       	sbci	r27, 0x01	; 1
     c20:	03 97       	sbiw	r24, 0x03	; 3
     c22:	a1 05       	cpc	r26, r1
     c24:	b1 05       	cpc	r27, r1
     c26:	c8 f0       	brcs	.+50     	; 0xc5a <ProcessRNDISControlMessage+0x320>
     c28:	fb c0       	rjmp	.+502    	; 0xe20 <ProcessRNDISControlMessage+0x4e6>
			return true;
		case OID_GEN_VENDOR_ID:
			*ResponseSize = sizeof(uint32_t);

			/* Vendor ID 0x0xFFFFFF is reserved for vendors who have not purchased a NDIS VID */
			*((uint32_t*)ResponseData) = 0x00FFFFFF;
     c2a:	8f ef       	ldi	r24, 0xFF	; 255
     c2c:	9f ef       	ldi	r25, 0xFF	; 255
     c2e:	af ef       	ldi	r26, 0xFF	; 255
     c30:	b0 e0       	ldi	r27, 0x00	; 0
     c32:	1c c0       	rjmp	.+56     	; 0xc6c <ProcessRNDISControlMessage+0x332>
		case OID_GEN_TRANSMIT_BLOCK_SIZE:
		case OID_GEN_RECEIVE_BLOCK_SIZE:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate that the maximum frame size is the size of the ethernet frame buffer */
			*((uint32_t*)ResponseData) = ETHERNET_FRAME_SIZE_MAX;
     c34:	8c ed       	ldi	r24, 0xDC	; 220
     c36:	95 e0       	ldi	r25, 0x05	; 5
     c38:	a0 e0       	ldi	r26, 0x00	; 0
     c3a:	b0 e0       	ldi	r27, 0x00	; 0
     c3c:	17 c0       	rjmp	.+46     	; 0xc6c <ProcessRNDISControlMessage+0x332>
			return true;
		case OID_802_3_MAXIMUM_LIST_SIZE:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate only one multicast address supported */
			*((uint32_t*)ResponseData) = 1;
     c3e:	81 e0       	ldi	r24, 0x01	; 1
     c40:	90 e0       	ldi	r25, 0x00	; 0
     c42:	a0 e0       	ldi	r26, 0x00	; 0
     c44:	b0 e0       	ldi	r27, 0x00	; 0
     c46:	12 c0       	rjmp	.+36     	; 0xc6c <ProcessRNDISControlMessage+0x332>
			return true;
		case OID_GEN_CURRENT_PACKET_FILTER:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate the current packet filter mask */
			*((uint32_t*)ResponseData) = CurrPacketFilter;
     c48:	80 91 46 01 	lds	r24, 0x0146
     c4c:	90 91 47 01 	lds	r25, 0x0147
     c50:	a0 91 48 01 	lds	r26, 0x0148
     c54:	b0 91 49 01 	lds	r27, 0x0149
     c58:	09 c0       	rjmp	.+18     	; 0xc6c <ProcessRNDISControlMessage+0x332>
		case OID_802_3_XMIT_ONE_COLLISION:
		case OID_802_3_XMIT_MORE_COLLISIONS:
			*ResponseSize = sizeof(uint32_t);

			/* Unused statistic OIDs - always return 0 for each */
			*((uint32_t*)ResponseData) = 0;
     c5a:	10 92 21 0d 	sts	0x0D21, r1
     c5e:	10 92 22 0d 	sts	0x0D22, r1
     c62:	10 92 23 0d 	sts	0x0D23, r1
     c66:	10 92 24 0d 	sts	0x0D24, r1
     c6a:	08 c0       	rjmp	.+16     	; 0xc7c <ProcessRNDISControlMessage+0x342>
			return true;
		case OID_GEN_MAXIMUM_TOTAL_SIZE:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate maximum overall buffer (Ethernet frame and RNDIS header) the adapter can handle */
			*((uint32_t*)ResponseData) = (sizeof(RNDISMessageBuffer) + ETHERNET_FRAME_SIZE_MAX);
     c6c:	80 93 21 0d 	sts	0x0D21, r24
     c70:	90 93 22 0d 	sts	0x0D22, r25
     c74:	a0 93 23 0d 	sts	0x0D23, r26
     c78:	b0 93 24 0d 	sts	0x0D24, r27
			/* Unused statistic OIDs - always return 0 for each */
			*((uint32_t*)ResponseData) = 0;

			return true;
		case OID_GEN_MAXIMUM_TOTAL_SIZE:
			*ResponseSize = sizeof(uint32_t);
     c7c:	44 e0       	ldi	r20, 0x04	; 4
     c7e:	50 e0       	ldi	r21, 0x00	; 0
     c80:	9c c0       	rjmp	.+312    	; 0xdba <ProcessRNDISControlMessage+0x480>

			break;
		case REMOTE_NDIS_SET_MSG:
			/* Request to set a parameter of the adapter, specified as an OID token */

			ResponseReady = true;
     c82:	81 e0       	ldi	r24, 0x01	; 1
     c84:	80 93 4b 01 	sts	0x014B, r24

			RNDIS_Set_Message_t*  SET_Message  = (RNDIS_Set_Message_t*)&RNDISMessageBuffer;
			RNDIS_Set_Complete_t* SET_Response = (RNDIS_Set_Complete_t*)&RNDISMessageBuffer;
			uint32_t              SET_Oid      = SET_Message->Oid;
     c88:	80 91 15 0d 	lds	r24, 0x0D15
     c8c:	90 91 16 0d 	lds	r25, 0x0D16
     c90:	a0 91 17 0d 	lds	r26, 0x0D17
     c94:	b0 91 18 0d 	lds	r27, 0x0D18

			SET_Response->MessageType       = REMOTE_NDIS_SET_CMPLT;
     c98:	45 e0       	ldi	r20, 0x05	; 5
     c9a:	50 e0       	ldi	r21, 0x00	; 0
     c9c:	60 e0       	ldi	r22, 0x00	; 0
     c9e:	70 e8       	ldi	r23, 0x80	; 128
     ca0:	40 93 09 0d 	sts	0x0D09, r20
     ca4:	50 93 0a 0d 	sts	0x0D0A, r21
     ca8:	60 93 0b 0d 	sts	0x0D0B, r22
     cac:	70 93 0c 0d 	sts	0x0D0C, r23
			SET_Response->MessageLength     = sizeof(RNDIS_Set_Complete_t);
     cb0:	40 e1       	ldi	r20, 0x10	; 16
     cb2:	50 e0       	ldi	r21, 0x00	; 0
     cb4:	60 e0       	ldi	r22, 0x00	; 0
     cb6:	70 e0       	ldi	r23, 0x00	; 0
     cb8:	40 93 0d 0d 	sts	0x0D0D, r20
     cbc:	50 93 0e 0d 	sts	0x0D0E, r21
     cc0:	60 93 0f 0d 	sts	0x0D0F, r22
     cc4:	70 93 10 0d 	sts	0x0D10, r23
			SET_Response->RequestId         = SET_Message->RequestId;

			void* SetData                   = &RNDISMessageBuffer[sizeof(RNDIS_Message_Header_t) +
			                                                      SET_Message->InformationBufferOffset];
     cc8:	40 91 1d 0d 	lds	r20, 0x0D1D
     ccc:	50 91 1e 0d 	lds	r21, 0x0D1E
     cd0:	60 91 1f 0d 	lds	r22, 0x0D1F
     cd4:	70 91 20 0d 	lds	r23, 0x0D20
 */
static bool ProcessNDISSet(uint32_t OId, void* SetData, uint16_t SetSize)
{
	/* Handler for REMOTE_NDIS_SET_MSG messages */

	switch (OId)
     cd8:	8e 30       	cpi	r24, 0x0E	; 14
     cda:	21 e0       	ldi	r18, 0x01	; 1
     cdc:	92 07       	cpc	r25, r18
     cde:	a2 07       	cpc	r26, r18
     ce0:	b1 05       	cpc	r27, r1
     ce2:	99 f0       	breq	.+38     	; 0xd0a <ProcessRNDISControlMessage+0x3d0>
     ce4:	83 30       	cpi	r24, 0x03	; 3
     ce6:	91 40       	sbci	r25, 0x01	; 1
     ce8:	a1 40       	sbci	r26, 0x01	; 1
     cea:	b1 40       	sbci	r27, 0x01	; 1
     cec:	09 f4       	brne	.+2      	; 0xcf0 <ProcessRNDISControlMessage+0x3b6>
     cee:	b5 c0       	rjmp	.+362    	; 0xe5a <ProcessRNDISControlMessage+0x520>
			                                                      SET_Message->InformationBufferOffset];

			if (ProcessNDISSet(SET_Oid, SetData, SET_Message->InformationBufferLength))
			  SET_Response->Status        = REMOTE_NDIS_STATUS_SUCCESS;
			else
			  SET_Response->Status        = REMOTE_NDIS_STATUS_NOT_SUPPORTED;
     cf0:	8b eb       	ldi	r24, 0xBB	; 187
     cf2:	90 e0       	ldi	r25, 0x00	; 0
     cf4:	a0 e0       	ldi	r26, 0x00	; 0
     cf6:	b0 ec       	ldi	r27, 0xC0	; 192
     cf8:	80 93 15 0d 	sts	0x0D15, r24
     cfc:	90 93 16 0d 	sts	0x0D16, r25
     d00:	a0 93 17 0d 	sts	0x0D17, r26
     d04:	b0 93 18 0d 	sts	0x0D18, r27
     d08:	08 95       	ret

			SET_Response->MessageType       = REMOTE_NDIS_SET_CMPLT;
			SET_Response->MessageLength     = sizeof(RNDIS_Set_Complete_t);
			SET_Response->RequestId         = SET_Message->RequestId;

			void* SetData                   = &RNDISMessageBuffer[sizeof(RNDIS_Message_Header_t) +
     d0a:	db 01       	movw	r26, r22
     d0c:	ca 01       	movw	r24, r20
     d0e:	08 96       	adiw	r24, 0x08	; 8
     d10:	a1 1d       	adc	r26, r1
     d12:	b1 1d       	adc	r27, r1

	switch (OId)
	{
		case OID_GEN_CURRENT_PACKET_FILTER:
			/* Save the packet filter mask in case the host queries it again later */
			CurrPacketFilter = *((uint32_t*)SetData);
     d14:	fc 01       	movw	r30, r24
     d16:	e7 5f       	subi	r30, 0xF7	; 247
     d18:	f2 4f       	sbci	r31, 0xF2	; 242
     d1a:	80 81       	ld	r24, Z
     d1c:	91 81       	ldd	r25, Z+1	; 0x01
     d1e:	a2 81       	ldd	r26, Z+2	; 0x02
     d20:	b3 81       	ldd	r27, Z+3	; 0x03
     d22:	80 93 46 01 	sts	0x0146, r24
     d26:	90 93 47 01 	sts	0x0147, r25
     d2a:	a0 93 48 01 	sts	0x0148, r26
     d2e:	b0 93 49 01 	sts	0x0149, r27

			/* Set the RNDIS state to initialized if the packet filter is non-zero */
			CurrRNDISState = ((CurrPacketFilter) ? RNDIS_Data_Initialized : RNDIS_Data_Initialized);
     d32:	82 e0       	ldi	r24, 0x02	; 2
     d34:	80 93 4a 01 	sts	0x014A, r24
     d38:	90 c0       	rjmp	.+288    	; 0xe5a <ProcessRNDISControlMessage+0x520>

			break;
		case REMOTE_NDIS_RESET_MSG:
			/* Soft reset the adapter */

			ResponseReady = true;
     d3a:	81 e0       	ldi	r24, 0x01	; 1
     d3c:	80 93 4b 01 	sts	0x014B, r24

			RNDIS_Reset_Complete_t* RESET_Response = (RNDIS_Reset_Complete_t*)&RNDISMessageBuffer;

			RESET_Response->MessageType         = REMOTE_NDIS_RESET_CMPLT;
     d40:	86 e0       	ldi	r24, 0x06	; 6
     d42:	90 e0       	ldi	r25, 0x00	; 0
     d44:	a0 e0       	ldi	r26, 0x00	; 0
     d46:	b0 e8       	ldi	r27, 0x80	; 128
     d48:	80 93 09 0d 	sts	0x0D09, r24
     d4c:	90 93 0a 0d 	sts	0x0D0A, r25
     d50:	a0 93 0b 0d 	sts	0x0D0B, r26
     d54:	b0 93 0c 0d 	sts	0x0D0C, r27
			RESET_Response->MessageLength       = sizeof(RNDIS_Reset_Complete_t);
     d58:	80 e1       	ldi	r24, 0x10	; 16
     d5a:	90 e0       	ldi	r25, 0x00	; 0
     d5c:	a0 e0       	ldi	r26, 0x00	; 0
     d5e:	b0 e0       	ldi	r27, 0x00	; 0
     d60:	80 93 0d 0d 	sts	0x0D0D, r24
     d64:	90 93 0e 0d 	sts	0x0D0E, r25
     d68:	a0 93 0f 0d 	sts	0x0D0F, r26
     d6c:	b0 93 10 0d 	sts	0x0D10, r27
			RESET_Response->Status              = REMOTE_NDIS_STATUS_SUCCESS;
     d70:	10 92 11 0d 	sts	0x0D11, r1
     d74:	10 92 12 0d 	sts	0x0D12, r1
     d78:	10 92 13 0d 	sts	0x0D13, r1
     d7c:	10 92 14 0d 	sts	0x0D14, r1
     d80:	6c c0       	rjmp	.+216    	; 0xe5a <ProcessRNDISControlMessage+0x520>

			break;
		case REMOTE_NDIS_KEEPALIVE_MSG:
			/* Keep alive message sent to the adapter every 5 seconds when idle to ensure it is still responding */

			ResponseReady = true;
     d82:	81 e0       	ldi	r24, 0x01	; 1
     d84:	80 93 4b 01 	sts	0x014B, r24

			RNDIS_KeepAlive_Message_t*  KEEPALIVE_Message  = (RNDIS_KeepAlive_Message_t*)&RNDISMessageBuffer;
			RNDIS_KeepAlive_Complete_t* KEEPALIVE_Response = (RNDIS_KeepAlive_Complete_t*)&RNDISMessageBuffer;

			KEEPALIVE_Response->MessageType     = REMOTE_NDIS_KEEPALIVE_CMPLT;
     d88:	88 e0       	ldi	r24, 0x08	; 8
     d8a:	90 e0       	ldi	r25, 0x00	; 0
     d8c:	a0 e0       	ldi	r26, 0x00	; 0
     d8e:	b0 e8       	ldi	r27, 0x80	; 128
     d90:	80 93 09 0d 	sts	0x0D09, r24
     d94:	90 93 0a 0d 	sts	0x0D0A, r25
     d98:	a0 93 0b 0d 	sts	0x0D0B, r26
     d9c:	b0 93 0c 0d 	sts	0x0D0C, r27
			KEEPALIVE_Response->MessageLength   = sizeof(RNDIS_KeepAlive_Complete_t);
     da0:	80 e1       	ldi	r24, 0x10	; 16
     da2:	90 e0       	ldi	r25, 0x00	; 0
     da4:	a0 e0       	ldi	r26, 0x00	; 0
     da6:	b0 e0       	ldi	r27, 0x00	; 0
     da8:	80 93 0d 0d 	sts	0x0D0D, r24
     dac:	90 93 0e 0d 	sts	0x0D0E, r25
     db0:	a0 93 0f 0d 	sts	0x0D0F, r26
     db4:	b0 93 10 0d 	sts	0x0D10, r27
     db8:	50 c0       	rjmp	.+160    	; 0xe5a <ProcessRNDISControlMessage+0x520>
			QUERY_Response->MessageLength       = sizeof(RNDIS_Query_Complete_t);

			if (ProcessNDISQuery(Query_Oid, QueryData, QUERY_Message->InformationBufferLength,
			                     ResponseData, &ResponseSize))
			{
				QUERY_Response->Status                  = REMOTE_NDIS_STATUS_SUCCESS;
     dba:	10 92 15 0d 	sts	0x0D15, r1
     dbe:	10 92 16 0d 	sts	0x0D16, r1
     dc2:	10 92 17 0d 	sts	0x0D17, r1
     dc6:	10 92 18 0d 	sts	0x0D18, r1
				QUERY_Response->MessageLength          += ResponseSize;
     dca:	60 e0       	ldi	r22, 0x00	; 0
     dcc:	70 e0       	ldi	r23, 0x00	; 0
     dce:	80 91 0d 0d 	lds	r24, 0x0D0D
     dd2:	90 91 0e 0d 	lds	r25, 0x0D0E
     dd6:	a0 91 0f 0d 	lds	r26, 0x0D0F
     dda:	b0 91 10 0d 	lds	r27, 0x0D10
     dde:	84 0f       	add	r24, r20
     de0:	95 1f       	adc	r25, r21
     de2:	a6 1f       	adc	r26, r22
     de4:	b7 1f       	adc	r27, r23
     de6:	80 93 0d 0d 	sts	0x0D0D, r24
     dea:	90 93 0e 0d 	sts	0x0D0E, r25
     dee:	a0 93 0f 0d 	sts	0x0D0F, r26
     df2:	b0 93 10 0d 	sts	0x0D10, r27

				QUERY_Response->InformationBufferLength = ResponseSize;
     df6:	40 93 19 0d 	sts	0x0D19, r20
     dfa:	50 93 1a 0d 	sts	0x0D1A, r21
     dfe:	60 93 1b 0d 	sts	0x0D1B, r22
     e02:	70 93 1c 0d 	sts	0x0D1C, r23
				QUERY_Response->InformationBufferOffset = (sizeof(RNDIS_Query_Complete_t) - sizeof(RNDIS_Message_Header_t));
     e06:	80 e1       	ldi	r24, 0x10	; 16
     e08:	90 e0       	ldi	r25, 0x00	; 0
     e0a:	a0 e0       	ldi	r26, 0x00	; 0
     e0c:	b0 e0       	ldi	r27, 0x00	; 0
     e0e:	80 93 1d 0d 	sts	0x0D1D, r24
     e12:	90 93 1e 0d 	sts	0x0D1E, r25
     e16:	a0 93 1f 0d 	sts	0x0D1F, r26
     e1a:	b0 93 20 0d 	sts	0x0D20, r27
     e1e:	08 95       	ret
			}
			else
			{
				QUERY_Response->Status                  = REMOTE_NDIS_STATUS_NOT_SUPPORTED;
     e20:	8b eb       	ldi	r24, 0xBB	; 187
     e22:	90 e0       	ldi	r25, 0x00	; 0
     e24:	a0 e0       	ldi	r26, 0x00	; 0
     e26:	b0 ec       	ldi	r27, 0xC0	; 192
     e28:	80 93 15 0d 	sts	0x0D15, r24
     e2c:	90 93 16 0d 	sts	0x0D16, r25
     e30:	a0 93 17 0d 	sts	0x0D17, r26
     e34:	b0 93 18 0d 	sts	0x0D18, r27

				QUERY_Response->InformationBufferLength = 0;
     e38:	10 92 19 0d 	sts	0x0D19, r1
     e3c:	10 92 1a 0d 	sts	0x0D1A, r1
     e40:	10 92 1b 0d 	sts	0x0D1B, r1
     e44:	10 92 1c 0d 	sts	0x0D1C, r1
				QUERY_Response->InformationBufferOffset = 0;
     e48:	10 92 1d 0d 	sts	0x0D1D, r1
     e4c:	10 92 1e 0d 	sts	0x0D1E, r1
     e50:	10 92 1f 0d 	sts	0x0D1F, r1
     e54:	10 92 20 0d 	sts	0x0D20, r1
     e58:	08 95       	ret

			void* SetData                   = &RNDISMessageBuffer[sizeof(RNDIS_Message_Header_t) +
			                                                      SET_Message->InformationBufferOffset];

			if (ProcessNDISSet(SET_Oid, SetData, SET_Message->InformationBufferLength))
			  SET_Response->Status        = REMOTE_NDIS_STATUS_SUCCESS;
     e5a:	10 92 15 0d 	sts	0x0D15, r1
     e5e:	10 92 16 0d 	sts	0x0D16, r1
     e62:	10 92 17 0d 	sts	0x0D17, r1
     e66:	10 92 18 0d 	sts	0x0D18, r1
     e6a:	08 95       	ret

00000e6c <ICMP_ProcessICMPPacket>:
 *
 *  \return The number of bytes written to the out Ethernet frame if any, NO_RESPONSE otherwise
 */
int16_t ICMP_ProcessICMPPacket(void* InDataStart,
                               void* OutDataStart)
{
     e6c:	ef 92       	push	r14
     e6e:	ff 92       	push	r15
     e70:	0f 93       	push	r16
     e72:	1f 93       	push	r17
     e74:	cf 93       	push	r28
     e76:	df 93       	push	r29
     e78:	7c 01       	movw	r14, r24
     e7a:	eb 01       	movw	r28, r22
	ICMP_Header_t* ICMPHeaderIN  = (ICMP_Header_t*)InDataStart;
	ICMP_Header_t* ICMPHeaderOUT = (ICMP_Header_t*)OutDataStart;

	DecodeICMPHeader(InDataStart);
     e7c:	5a dd       	rcall	.-1356   	; 0x932 <DecodeICMPHeader>
     e7e:	f7 01       	movw	r30, r14

	/* Determine if the ICMP packet is an echo request (ping) */
	if (ICMPHeaderIN->Type == ICMP_TYPE_ECHOREQUEST)
     e80:	80 81       	ld	r24, Z
     e82:	88 30       	cpi	r24, 0x08	; 8
     e84:	29 f5       	brne	.+74     	; 0xed0 <ICMP_ProcessICMPPacket+0x64>
     e86:	18 82       	st	Y, r1
	{
		/* Fill out the ICMP response packet */
		ICMPHeaderOUT->Type     = ICMP_TYPE_ECHOREPLY;
     e88:	19 82       	std	Y+1, r1	; 0x01
		ICMPHeaderOUT->Code     = 0;
     e8a:	1b 82       	std	Y+3, r1	; 0x03
		ICMPHeaderOUT->Checksum = 0;
     e8c:	1a 82       	std	Y+2, r1	; 0x02
     e8e:	84 81       	ldd	r24, Z+4	; 0x04
		ICMPHeaderOUT->Id       = ICMPHeaderIN->Id;
     e90:	95 81       	ldd	r25, Z+5	; 0x05
     e92:	9d 83       	std	Y+5, r25	; 0x05
     e94:	8c 83       	std	Y+4, r24	; 0x04
     e96:	86 81       	ldd	r24, Z+6	; 0x06
		ICMPHeaderOUT->Sequence = ICMPHeaderIN->Sequence;
     e98:	97 81       	ldd	r25, Z+7	; 0x07
     e9a:	9f 83       	std	Y+7, r25	; 0x07
     e9c:	8e 83       	std	Y+6, r24	; 0x06
     e9e:	00 91 29 07 	lds	r16, 0x0729

		intptr_t DataSize = FrameIN.FrameLength - ((((intptr_t)InDataStart + sizeof(ICMP_Header_t)) - (intptr_t)FrameIN.FrameData));
     ea2:	10 91 2a 07 	lds	r17, 0x072A
     ea6:	0b 5b       	subi	r16, 0xBB	; 187
     ea8:	1e 4f       	sbci	r17, 0xFE	; 254
     eaa:	0e 19       	sub	r16, r14
     eac:	1f 09       	sbc	r17, r15
     eae:	b7 01       	movw	r22, r14

		/* Copy the remaining payload to the response - echo requests should echo back any sent data */
		memmove(&((uint8_t*)OutDataStart)[sizeof(ICMP_Header_t)],
     eb0:	68 5f       	subi	r22, 0xF8	; 248
     eb2:	7f 4f       	sbci	r23, 0xFF	; 255
     eb4:	a8 01       	movw	r20, r16
     eb6:	ce 01       	movw	r24, r28
     eb8:	08 96       	adiw	r24, 0x08	; 8
     eba:	0e 94 7f 14 	call	0x28fe	; 0x28fe <memmove>
     ebe:	08 5f       	subi	r16, 0xF8	; 248
		        &((uint8_t*)InDataStart)[sizeof(ICMP_Header_t)],
			    DataSize);

		ICMPHeaderOUT->Checksum = Ethernet_Checksum16(ICMPHeaderOUT, (DataSize + sizeof(ICMP_Header_t)));
     ec0:	1f 4f       	sbci	r17, 0xFF	; 255
     ec2:	b8 01       	movw	r22, r16
     ec4:	ce 01       	movw	r24, r28
     ec6:	01 dd       	rcall	.-1534   	; 0x8ca <Ethernet_Checksum16>
     ec8:	9b 83       	std	Y+3, r25	; 0x03
     eca:	8a 83       	std	Y+2, r24	; 0x02
     ecc:	c8 01       	movw	r24, r16
     ece:	02 c0       	rjmp	.+4      	; 0xed4 <ICMP_ProcessICMPPacket+0x68>

		/* Return the size of the response so far */
		return (DataSize + sizeof(ICMP_Header_t));
     ed0:	80 e0       	ldi	r24, 0x00	; 0
     ed2:	90 e0       	ldi	r25, 0x00	; 0
	}

	return NO_RESPONSE;
     ed4:	df 91       	pop	r29
     ed6:	cf 91       	pop	r28
}
     ed8:	1f 91       	pop	r17
     eda:	0f 91       	pop	r16
     edc:	ff 90       	pop	r15
     ede:	ef 90       	pop	r14
     ee0:	08 95       	ret

00000ee2 <SwapEndian_32>:
			 *
			 *  \return Input data with the individual bytes reversed.
			 */
			static inline uint32_t SwapEndian_32(const uint32_t DWord) ATTR_WARN_UNUSED_RESULT ATTR_CONST;
			static inline uint32_t SwapEndian_32(const uint32_t DWord)
			{
     ee2:	9b 01       	movw	r18, r22
				Temp = Data.Bytes[1];
				Data.Bytes[1] = Data.Bytes[2];
				Data.Bytes[2] = Temp;

				return Data.DWord;
			}
     ee4:	69 2f       	mov	r22, r25
     ee6:	78 2f       	mov	r23, r24
     ee8:	83 2f       	mov	r24, r19
     eea:	92 2f       	mov	r25, r18
     eec:	08 95       	ret

00000eee <SwapEndian_16.part.1>:
			 *  \param[in] Word  Word of data whose bytes are to be swapped.
			 *
			 *  \return Input data with the individual bytes reversed.
			 */
			static inline uint16_t SwapEndian_16(const uint16_t Word) ATTR_WARN_UNUSED_RESULT ATTR_CONST;
			static inline uint16_t SwapEndian_16(const uint16_t Word)
     eee:	28 2f       	mov	r18, r24
     ef0:	89 2f       	mov	r24, r25
				Temp = Data.Bytes[0];
				Data.Bytes[0] = Data.Bytes[1];
				Data.Bytes[1] = Temp;

				return Data.Word;
			}
     ef2:	92 2f       	mov	r25, r18
     ef4:	08 95       	ret

00000ef6 <TCP_Checksum16>:
 */
static uint16_t TCP_Checksum16(void* TCPHeaderOutStart,
                               const IP_Address_t* SourceAddress,
                               const IP_Address_t* DestinationAddress,
                               uint16_t TCPOutSize)
{
     ef6:	cf 92       	push	r12
     ef8:	df 92       	push	r13
     efa:	ef 92       	push	r14
     efc:	ff 92       	push	r15
     efe:	0f 93       	push	r16
     f00:	1f 93       	push	r17
     f02:	cf 93       	push	r28
     f04:	df 93       	push	r29
     f06:	ec 01       	movw	r28, r24
     f08:	fb 01       	movw	r30, r22
     f0a:	89 01       	movw	r16, r18
	/* TCP/IP checksums are the addition of the one's compliment of each word including the IP pseudo-header,
	   complimented */

	Checksum += ((uint16_t*)SourceAddress)[0];
	Checksum += ((uint16_t*)SourceAddress)[1];
	Checksum += ((uint16_t*)DestinationAddress)[0];
     f0c:	da 01       	movw	r26, r20
     f0e:	8d 91       	ld	r24, X+
     f10:	9c 91       	ld	r25, X
     f12:	11 97       	sbiw	r26, 0x01	; 1
	Checksum += ((uint16_t*)DestinationAddress)[1];
     f14:	12 96       	adiw	r26, 0x02	; 2
     f16:	4d 91       	ld	r20, X+
     f18:	5c 91       	ld	r21, X
     f1a:	13 97       	sbiw	r26, 0x03	; 3
     f1c:	6a 01       	movw	r12, r20
     f1e:	e1 2c       	mov	r14, r1
     f20:	f1 2c       	mov	r15, r1

	/* TCP/IP checksums are the addition of the one's compliment of each word including the IP pseudo-header,
	   complimented */

	Checksum += ((uint16_t*)SourceAddress)[0];
	Checksum += ((uint16_t*)SourceAddress)[1];
     f22:	c8 0e       	add	r12, r24
     f24:	d9 1e       	adc	r13, r25
     f26:	e1 1c       	adc	r14, r1
     f28:	f1 1c       	adc	r15, r1
	Checksum += ((uint16_t*)DestinationAddress)[0];
     f2a:	b6 e0       	ldi	r27, 0x06	; 6
     f2c:	db 0e       	add	r13, r27
     f2e:	e1 1c       	adc	r14, r1
     f30:	f1 1c       	adc	r15, r1
	uint32_t Checksum = 0;

	/* TCP/IP checksums are the addition of the one's compliment of each word including the IP pseudo-header,
	   complimented */

	Checksum += ((uint16_t*)SourceAddress)[0];
     f32:	80 81       	ld	r24, Z
     f34:	91 81       	ldd	r25, Z+1	; 0x01
	Checksum += ((uint16_t*)SourceAddress)[1];
	Checksum += ((uint16_t*)DestinationAddress)[0];
	Checksum += ((uint16_t*)DestinationAddress)[1];
     f36:	c8 0e       	add	r12, r24
     f38:	d9 1e       	adc	r13, r25
     f3a:	e1 1c       	adc	r14, r1
     f3c:	f1 1c       	adc	r15, r1

	/* TCP/IP checksums are the addition of the one's compliment of each word including the IP pseudo-header,
	   complimented */

	Checksum += ((uint16_t*)SourceAddress)[0];
	Checksum += ((uint16_t*)SourceAddress)[1];
     f3e:	82 81       	ldd	r24, Z+2	; 0x02
     f40:	93 81       	ldd	r25, Z+3	; 0x03
	Checksum += ((uint16_t*)DestinationAddress)[0];
	Checksum += ((uint16_t*)DestinationAddress)[1];
	Checksum += SwapEndian_16(PROTOCOL_TCP);
     f42:	c8 0e       	add	r12, r24
     f44:	d9 1e       	adc	r13, r25
     f46:	e1 1c       	adc	r14, r1
     f48:	f1 1c       	adc	r15, r1
     f4a:	c9 01       	movw	r24, r18
     f4c:	d0 df       	rcall	.-96     	; 0xeee <SwapEndian_16.part.1>
     f4e:	b7 01       	movw	r22, r14
	Checksum += SwapEndian_16(TCPOutSize);
     f50:	a6 01       	movw	r20, r12
     f52:	48 0f       	add	r20, r24
     f54:	59 1f       	adc	r21, r25
     f56:	61 1d       	adc	r22, r1
     f58:	71 1d       	adc	r23, r1
     f5a:	c8 01       	movw	r24, r16

	for (uint16_t CurrWord = 0; CurrWord < (TCPOutSize >> 1); CurrWord++)
     f5c:	96 95       	lsr	r25
     f5e:	87 95       	ror	r24
     f60:	de 01       	movw	r26, r28
     f62:	e0 e0       	ldi	r30, 0x00	; 0
     f64:	f0 e0       	ldi	r31, 0x00	; 0
     f66:	e8 17       	cp	r30, r24
     f68:	f9 07       	cpc	r31, r25
     f6a:	41 f0       	breq	.+16     	; 0xf7c <TCP_Checksum16+0x86>
     f6c:	2d 91       	ld	r18, X+
	  Checksum += ((uint16_t*)TCPHeaderOutStart)[CurrWord];
     f6e:	3d 91       	ld	r19, X+
     f70:	42 0f       	add	r20, r18
     f72:	53 1f       	adc	r21, r19
     f74:	61 1d       	adc	r22, r1
     f76:	71 1d       	adc	r23, r1
     f78:	31 96       	adiw	r30, 0x01	; 1
	Checksum += ((uint16_t*)DestinationAddress)[0];
	Checksum += ((uint16_t*)DestinationAddress)[1];
	Checksum += SwapEndian_16(PROTOCOL_TCP);
	Checksum += SwapEndian_16(TCPOutSize);

	for (uint16_t CurrWord = 0; CurrWord < (TCPOutSize >> 1); CurrWord++)
     f7a:	f5 cf       	rjmp	.-22     	; 0xf66 <TCP_Checksum16+0x70>
     f7c:	00 ff       	sbrs	r16, 0
	  Checksum += ((uint16_t*)TCPHeaderOutStart)[CurrWord];

	if (TCPOutSize & 0x01)
     f7e:	09 c0       	rjmp	.+18     	; 0xf92 <TCP_Checksum16+0x9c>
     f80:	ee 0f       	add	r30, r30
	  Checksum += (((uint16_t*)TCPHeaderOutStart)[TCPOutSize >> 1] & 0x00FF);
     f82:	ff 1f       	adc	r31, r31
     f84:	ec 0f       	add	r30, r28
     f86:	fd 1f       	adc	r31, r29
     f88:	80 81       	ld	r24, Z
     f8a:	48 0f       	add	r20, r24
     f8c:	51 1d       	adc	r21, r1
     f8e:	61 1d       	adc	r22, r1
     f90:	71 1d       	adc	r23, r1
     f92:	db 01       	movw	r26, r22

	while (Checksum & 0xFFFF0000)
     f94:	ca 01       	movw	r24, r20
     f96:	88 27       	eor	r24, r24
     f98:	99 27       	eor	r25, r25
     f9a:	89 2b       	or	r24, r25
     f9c:	8a 2b       	or	r24, r26
     f9e:	8b 2b       	or	r24, r27
     fa0:	61 f0       	breq	.+24     	; 0xfba <TCP_Checksum16+0xc4>
     fa2:	db 01       	movw	r26, r22
	  Checksum = ((Checksum & 0xFFFF) + (Checksum >> 16));
     fa4:	ca 01       	movw	r24, r20
     fa6:	aa 27       	eor	r26, r26
     fa8:	bb 27       	eor	r27, r27
     faa:	ab 01       	movw	r20, r22
     fac:	66 27       	eor	r22, r22
     fae:	77 27       	eor	r23, r23
     fb0:	48 0f       	add	r20, r24
     fb2:	59 1f       	adc	r21, r25
     fb4:	6a 1f       	adc	r22, r26
     fb6:	7b 1f       	adc	r23, r27
     fb8:	ec cf       	rjmp	.-40     	; 0xf92 <TCP_Checksum16+0x9c>
     fba:	ca 01       	movw	r24, r20

	return ~Checksum;
     fbc:	80 95       	com	r24
     fbe:	90 95       	com	r25
     fc0:	df 91       	pop	r29
}
     fc2:	cf 91       	pop	r28
     fc4:	1f 91       	pop	r17
     fc6:	0f 91       	pop	r16
     fc8:	ff 90       	pop	r15
     fca:	ef 90       	pop	r14
     fcc:	df 90       	pop	r13
     fce:	cf 90       	pop	r12
     fd0:	08 95       	ret

00000fd2 <TCP_Task>:
     fd2:	af 92       	push	r10
/** Task to handle the calling of each registered application's callback function, to process and generate TCP packets at the application
 *  level. If an application produces a response, this task constructs the appropriate Ethernet frame and places it into the Ethernet OUT
 *  buffer for later transmission.
 */
void TCP_Task(void)
{
     fd4:	bf 92       	push	r11
     fd6:	cf 92       	push	r12
     fd8:	df 92       	push	r13
     fda:	ef 92       	push	r14
     fdc:	ff 92       	push	r15
     fde:	0f 93       	push	r16
     fe0:	1f 93       	push	r17
     fe2:	cf 93       	push	r28
     fe4:	df 93       	push	r29
     fe6:	cd e8       	ldi	r28, 0x8D	; 141
     fe8:	dd e0       	ldi	r29, 0x0D	; 13
	{
		/* Find the corresponding port entry in the port table */
		for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
		{
			/* Run the application handler for the port */
			if ((PortStateTable[PTableEntry].Port  == ConnectionStateTable[CSTableEntry].Port) &&
     fea:	20 91 cf 13 	lds	r18, 0x13CF
     fee:	30 91 d0 13 	lds	r19, 0x13D0
     ff2:	88 81       	ld	r24, Y
     ff4:	99 81       	ldd	r25, Y+1	; 0x01
     ff6:	28 17       	cp	r18, r24
     ff8:	39 07       	cpc	r19, r25
     ffa:	69 f4       	brne	.+26     	; 0x1016 <TCP_Task+0x44>
     ffc:	80 91 d1 13 	lds	r24, 0x13D1
    1000:	81 30       	cpi	r24, 0x01	; 1
    1002:	49 f4       	brne	.+18     	; 0x1016 <TCP_Task+0x44>
			    (PortStateTable[PTableEntry].State == TCP_Port_Open))
			{
				PortStateTable[PTableEntry].ApplicationHandler(&ConnectionStateTable[CSTableEntry],
    1004:	e0 91 d2 13 	lds	r30, 0x13D2
    1008:	f0 91 d3 13 	lds	r31, 0x13D3
    100c:	be 01       	movw	r22, r28
    100e:	60 5f       	subi	r22, 0xF0	; 240
    1010:	7f 4f       	sbci	r23, 0xFF	; 255
    1012:	ce 01       	movw	r24, r28
    1014:	09 95       	icall
    1016:	ca 5e       	subi	r28, 0xEA	; 234
    1018:	dd 4f       	sbci	r29, 0xFD	; 253
 *  buffer for later transmission.
 */
void TCP_Task(void)
{
	/* Run each application in sequence, to process incoming and generate outgoing packets */
	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
    101a:	83 e1       	ldi	r24, 0x13	; 19
    101c:	cf 3c       	cpi	r28, 0xCF	; 207
    101e:	d8 07       	cpc	r29, r24
    1020:	21 f7       	brne	.-56     	; 0xfea <TCP_Task+0x18>
			}
		}
	}

	/* Bail out early if there is already a frame waiting to be sent in the Ethernet OUT buffer */
	if (FrameOUT.FrameLength)
    1022:	80 91 07 0d 	lds	r24, 0x0D07
    1026:	90 91 08 0d 	lds	r25, 0x0D08
    102a:	89 2b       	or	r24, r25
    102c:	09 f0       	breq	.+2      	; 0x1030 <TCP_Task+0x5e>
    102e:	e3 c0       	rjmp	.+454    	; 0x11f6 <TCP_Task+0x224>
    1030:	e0 ea       	ldi	r30, 0xA0	; 160
    1032:	ff e0       	ldi	r31, 0x0F	; 15
    1034:	80 e0       	ldi	r24, 0x00	; 0
    1036:	90 e0       	ldi	r25, 0x00	; 0
    1038:	df 01       	movw	r26, r30
    103a:	11 97       	sbiw	r26, 0x01	; 1

	/* Send response packets from each application as the TCP packet buffers are filled by the applications */
	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* For each completely received packet, pass it along to the listening application */
		if ((ConnectionStateTable[CSTableEntry].Info.Buffer.Direction == TCP_PACKETDIR_OUT) &&
    103c:	2c 91       	ld	r18, X
    103e:	22 23       	and	r18, r18
    1040:	09 f4       	brne	.+2      	; 0x1044 <TCP_Task+0x72>
    1042:	d2 c0       	rjmp	.+420    	; 0x11e8 <TCP_Task+0x216>
    1044:	20 81       	ld	r18, Z
    1046:	22 23       	and	r18, r18
    1048:	09 f4       	brne	.+2      	; 0x104c <TCP_Task+0x7a>
    104a:	ce c0       	rjmp	.+412    	; 0x11e8 <TCP_Task+0x216>
			                                                                             sizeof(IP_Header_t)];
			void*                    TCPDataOUT     = &FrameOUT.FrameData[sizeof(Ethernet_Frame_Header_t) +
			                                                              sizeof(IP_Header_t) +
			                                                              sizeof(TCP_Header_t)];

			uint16_t PacketSize = ConnectionStateTable[CSTableEntry].Info.Buffer.Length;
    104c:	26 e1       	ldi	r18, 0x16	; 22
    104e:	32 e0       	ldi	r19, 0x02	; 2
    1050:	82 9f       	mul	r24, r18
    1052:	50 01       	movw	r10, r0
    1054:	83 9f       	mul	r24, r19
    1056:	b0 0c       	add	r11, r0
    1058:	92 9f       	mul	r25, r18
    105a:	b0 0c       	add	r11, r0
    105c:	11 24       	eor	r1, r1
    105e:	e5 01       	movw	r28, r10
    1060:	c3 57       	subi	r28, 0x73	; 115
    1062:	d2 4f       	sbci	r29, 0xF2	; 242
    1064:	08 89       	ldd	r16, Y+16	; 0x10
    1066:	19 89       	ldd	r17, Y+17	; 0x11

			/* Fill out the TCP data */
			TCPHeaderOUT->SourcePort           = ConnectionStateTable[CSTableEntry].Port;
    1068:	88 81       	ld	r24, Y
    106a:	99 81       	ldd	r25, Y+1	; 0x01
    106c:	90 93 4e 07 	sts	0x074E, r25
    1070:	80 93 4d 07 	sts	0x074D, r24
			TCPHeaderOUT->DestinationPort      = ConnectionStateTable[CSTableEntry].RemotePort;
    1074:	8a 81       	ldd	r24, Y+2	; 0x02
    1076:	9b 81       	ldd	r25, Y+3	; 0x03
    1078:	90 93 50 07 	sts	0x0750, r25
    107c:	80 93 4f 07 	sts	0x074F, r24
			TCPHeaderOUT->SequenceNumber       = SwapEndian_32(ConnectionStateTable[CSTableEntry].Info.SequenceNumberOut);
    1080:	cc 84       	ldd	r12, Y+12	; 0x0c
    1082:	dd 84       	ldd	r13, Y+13	; 0x0d
    1084:	ee 84       	ldd	r14, Y+14	; 0x0e
    1086:	ff 84       	ldd	r15, Y+15	; 0x0f
    1088:	c7 01       	movw	r24, r14
    108a:	b6 01       	movw	r22, r12
    108c:	2a df       	rcall	.-428    	; 0xee2 <SwapEndian_32>
    108e:	60 93 51 07 	sts	0x0751, r22
    1092:	70 93 52 07 	sts	0x0752, r23
    1096:	80 93 53 07 	sts	0x0753, r24
    109a:	90 93 54 07 	sts	0x0754, r25
    109e:	68 85       	ldd	r22, Y+8	; 0x08
			TCPHeaderOUT->AcknowledgmentNumber = SwapEndian_32(ConnectionStateTable[CSTableEntry].Info.SequenceNumberIn);
    10a0:	79 85       	ldd	r23, Y+9	; 0x09
    10a2:	8a 85       	ldd	r24, Y+10	; 0x0a
    10a4:	9b 85       	ldd	r25, Y+11	; 0x0b
    10a6:	1d df       	rcall	.-454    	; 0xee2 <SwapEndian_32>
    10a8:	60 93 55 07 	sts	0x0755, r22
    10ac:	70 93 56 07 	sts	0x0756, r23
    10b0:	80 93 57 07 	sts	0x0757, r24
    10b4:	90 93 58 07 	sts	0x0758, r25
    10b8:	82 e0       	ldi	r24, 0x02	; 2
    10ba:	90 e0       	ldi	r25, 0x00	; 0
			TCPHeaderOUT->DataOffset           = (sizeof(TCP_Header_t) / sizeof(uint32_t));
			TCPHeaderOUT->WindowSize           = SwapEndian_16(TCP_WINDOW_SIZE);
    10bc:	90 93 5c 07 	sts	0x075C, r25
    10c0:	80 93 5b 07 	sts	0x075B, r24
    10c4:	80 e1       	ldi	r24, 0x10	; 16
    10c6:	80 93 5a 07 	sts	0x075A, r24

			TCPHeaderOUT->Flags                = TCP_FLAG_ACK;
    10ca:	10 92 60 07 	sts	0x0760, r1
			TCPHeaderOUT->UrgentPointer        = 0;
    10ce:	10 92 5f 07 	sts	0x075F, r1
    10d2:	10 92 5e 07 	sts	0x075E, r1
			TCPHeaderOUT->Checksum             = 0;
    10d6:	10 92 5d 07 	sts	0x075D, r1
    10da:	80 e5       	ldi	r24, 0x50	; 80
    10dc:	80 93 59 07 	sts	0x0759, r24
			TCPHeaderOUT->Reserved             = 0;
    10e0:	b5 01       	movw	r22, r10
    10e2:	61 56       	subi	r22, 0x61	; 97

			memcpy(TCPDataOUT, ConnectionStateTable[CSTableEntry].Info.Buffer.Data, PacketSize);
    10e4:	72 4f       	sbci	r23, 0xF2	; 242
    10e6:	a8 01       	movw	r20, r16
    10e8:	81 e6       	ldi	r24, 0x61	; 97
    10ea:	97 e0       	ldi	r25, 0x07	; 7
    10ec:	0e 94 76 14 	call	0x28ec	; 0x28ec <memcpy>
    10f0:	c0 0e       	add	r12, r16
    10f2:	d1 1e       	adc	r13, r17

			ConnectionStateTable[CSTableEntry].Info.SequenceNumberOut += PacketSize;
    10f4:	e1 1c       	adc	r14, r1
    10f6:	f1 1c       	adc	r15, r1
    10f8:	cc 86       	std	Y+12, r12	; 0x0c
    10fa:	dd 86       	std	Y+13, r13	; 0x0d
    10fc:	ee 86       	std	Y+14, r14	; 0x0e
    10fe:	ff 86       	std	Y+15, r15	; 0x0f
    1100:	98 01       	movw	r18, r16
    1102:	2c 5e       	subi	r18, 0xEC	; 236

			TCPHeaderOUT->Checksum             = TCP_Checksum16(TCPHeaderOUT, &ServerIPAddress,
    1104:	3f 4f       	sbci	r19, 0xFF	; 255
    1106:	a5 01       	movw	r20, r10
    1108:	4f 56       	subi	r20, 0x6F	; 111
			                                                    &ConnectionStateTable[CSTableEntry].RemoteAddress,
    110a:	52 4f       	sbci	r21, 0xF2	; 242
    110c:	68 e1       	ldi	r22, 0x18	; 24
    110e:	71 e0       	ldi	r23, 0x01	; 1

			memcpy(TCPDataOUT, ConnectionStateTable[CSTableEntry].Info.Buffer.Data, PacketSize);

			ConnectionStateTable[CSTableEntry].Info.SequenceNumberOut += PacketSize;

			TCPHeaderOUT->Checksum             = TCP_Checksum16(TCPHeaderOUT, &ServerIPAddress,
    1110:	8d e4       	ldi	r24, 0x4D	; 77
    1112:	97 e0       	ldi	r25, 0x07	; 7
    1114:	f0 de       	rcall	.-544    	; 0xef6 <TCP_Checksum16>
    1116:	90 93 5e 07 	sts	0x075E, r25
    111a:	80 93 5d 07 	sts	0x075D, r24
    111e:	c8 01       	movw	r24, r16
    1120:	88 96       	adiw	r24, 0x28	; 40
    1122:	e5 de       	rcall	.-566    	; 0xeee <SwapEndian_16.part.1>
    1124:	90 93 3c 07 	sts	0x073C, r25
    1128:	80 93 3b 07 	sts	0x073B, r24
			                                                    (sizeof(TCP_Header_t) + PacketSize));

			PacketSize += sizeof(TCP_Header_t);

			/* Fill out the response IP header */
			IPHeaderOUT->TotalLength        = SwapEndian_16(sizeof(IP_Header_t) + PacketSize);
    112c:	10 92 3a 07 	sts	0x073A, r1
    1130:	85 e4       	ldi	r24, 0x45	; 69
    1132:	80 93 39 07 	sts	0x0739, r24
			IPHeaderOUT->TypeOfService      = 0;
    1136:	10 92 3f 07 	sts	0x073F, r1
			IPHeaderOUT->HeaderLength       = (sizeof(IP_Header_t) / sizeof(uint32_t));
			IPHeaderOUT->Version            = 4;
    113a:	10 92 40 07 	sts	0x0740, r1
			IPHeaderOUT->Flags              = 0;
			IPHeaderOUT->FragmentOffset     = 0;
    113e:	10 92 3e 07 	sts	0x073E, r1
    1142:	10 92 3d 07 	sts	0x073D, r1
			IPHeaderOUT->Identification     = 0;
    1146:	10 92 44 07 	sts	0x0744, r1
    114a:	10 92 43 07 	sts	0x0743, r1
			IPHeaderOUT->HeaderChecksum     = 0;
    114e:	f6 e0       	ldi	r31, 0x06	; 6
    1150:	ff 2e       	mov	r15, r31
    1152:	f0 92 42 07 	sts	0x0742, r15
			IPHeaderOUT->Protocol           = PROTOCOL_TCP;
    1156:	80 e8       	ldi	r24, 0x80	; 128
    1158:	80 93 41 07 	sts	0x0741, r24
    115c:	80 91 18 01 	lds	r24, 0x0118
			IPHeaderOUT->TTL                = DEFAULT_TTL;
    1160:	90 91 19 01 	lds	r25, 0x0119
			IPHeaderOUT->SourceAddress      = ServerIPAddress;
    1164:	a0 91 1a 01 	lds	r26, 0x011A
    1168:	b0 91 1b 01 	lds	r27, 0x011B
    116c:	80 93 45 07 	sts	0x0745, r24
    1170:	90 93 46 07 	sts	0x0746, r25
    1174:	a0 93 47 07 	sts	0x0747, r26
    1178:	b0 93 48 07 	sts	0x0748, r27
    117c:	8c 81       	ldd	r24, Y+4	; 0x04
    117e:	9d 81       	ldd	r25, Y+5	; 0x05
    1180:	ae 81       	ldd	r26, Y+6	; 0x06
    1182:	bf 81       	ldd	r27, Y+7	; 0x07
			IPHeaderOUT->DestinationAddress = ConnectionStateTable[CSTableEntry].RemoteAddress;
    1184:	80 93 49 07 	sts	0x0749, r24
    1188:	90 93 4a 07 	sts	0x074A, r25
    118c:	a0 93 4b 07 	sts	0x074B, r26
    1190:	b0 93 4c 07 	sts	0x074C, r27
    1194:	64 e1       	ldi	r22, 0x14	; 20
    1196:	70 e0       	ldi	r23, 0x00	; 0
    1198:	89 e3       	ldi	r24, 0x39	; 57
    119a:	97 e0       	ldi	r25, 0x07	; 7

			IPHeaderOUT->HeaderChecksum     = Ethernet_Checksum16(IPHeaderOUT, sizeof(IP_Header_t));
    119c:	96 db       	rcall	.-2260   	; 0x8ca <Ethernet_Checksum16>
    119e:	90 93 44 07 	sts	0x0744, r25
    11a2:	80 93 43 07 	sts	0x0743, r24
    11a6:	ec e1       	ldi	r30, 0x1C	; 28
    11a8:	f1 e0       	ldi	r31, 0x01	; 1
    11aa:	a1 e3       	ldi	r26, 0x31	; 49
    11ac:	b7 e0       	ldi	r27, 0x07	; 7
    11ae:	8f 2d       	mov	r24, r15

			PacketSize += sizeof(IP_Header_t);

			/* Fill out the response Ethernet frame header */
			FrameOUTHeader->Source          = ServerMACAddress;
    11b0:	01 90       	ld	r0, Z+
    11b2:	0d 92       	st	X+, r0
    11b4:	8a 95       	dec	r24
    11b6:	e1 f7       	brne	.-8      	; 0x11b0 <TCP_Task+0x1de>
    11b8:	e2 e2       	ldi	r30, 0x22	; 34
    11ba:	f1 e0       	ldi	r31, 0x01	; 1
    11bc:	ab e2       	ldi	r26, 0x2B	; 43
    11be:	b7 e0       	ldi	r27, 0x07	; 7
    11c0:	01 90       	ld	r0, Z+
			FrameOUTHeader->Destination     = (MAC_Address_t){{0x02, 0x00, 0x02, 0x00, 0x02, 0x00}};
    11c2:	0d 92       	st	X+, r0
    11c4:	fa 94       	dec	r15
    11c6:	e1 f7       	brne	.-8      	; 0x11c0 <TCP_Task+0x1ee>
    11c8:	88 e0       	ldi	r24, 0x08	; 8
    11ca:	90 e0       	ldi	r25, 0x00	; 0
    11cc:	90 93 38 07 	sts	0x0738, r25
    11d0:	80 93 37 07 	sts	0x0737, r24
			FrameOUTHeader->EtherType       = SwapEndian_16(ETHERTYPE_IPV4);
    11d4:	0a 5c       	subi	r16, 0xCA	; 202
    11d6:	1f 4f       	sbci	r17, 0xFF	; 255
    11d8:	10 93 08 0d 	sts	0x0D08, r17
    11dc:	00 93 07 0d 	sts	0x0D07, r16

			PacketSize += sizeof(Ethernet_Frame_Header_t);
    11e0:	cd 5e       	subi	r28, 0xED	; 237

			/* Set the response length in the buffer and indicate that a response is ready to be sent */
			FrameOUT.FrameLength            = PacketSize;
    11e2:	dd 4f       	sbci	r29, 0xFD	; 253
    11e4:	18 82       	st	Y, r1
    11e6:	07 c0       	rjmp	.+14     	; 0x11f6 <TCP_Task+0x224>
    11e8:	01 96       	adiw	r24, 0x01	; 1

			ConnectionStateTable[CSTableEntry].Info.Buffer.Ready = false;
    11ea:	ea 5e       	subi	r30, 0xEA	; 234
    11ec:	fd 4f       	sbci	r31, 0xFD	; 253
    11ee:	83 30       	cpi	r24, 0x03	; 3

			break;
    11f0:	91 05       	cpc	r25, r1
    11f2:	09 f0       	breq	.+2      	; 0x11f6 <TCP_Task+0x224>
    11f4:	21 cf       	rjmp	.-446    	; 0x1038 <TCP_Task+0x66>
    11f6:	df 91       	pop	r29
	/* Bail out early if there is already a frame waiting to be sent in the Ethernet OUT buffer */
	if (FrameOUT.FrameLength)
	  return;

	/* Send response packets from each application as the TCP packet buffers are filled by the applications */
	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
    11f8:	cf 91       	pop	r28
    11fa:	1f 91       	pop	r17
    11fc:	0f 91       	pop	r16
    11fe:	ff 90       	pop	r15
			ConnectionStateTable[CSTableEntry].Info.Buffer.Ready = false;

			break;
		}
	}
}
    1200:	ef 90       	pop	r14
    1202:	df 90       	pop	r13
    1204:	cf 90       	pop	r12
    1206:	bf 90       	pop	r11
    1208:	af 90       	pop	r10
    120a:	08 95       	ret

0000120c <TCP_Init>:
    120c:	10 92 d1 13 	sts	0x13D1, r1
    1210:	8a e0       	ldi	r24, 0x0A	; 10
    1212:	80 93 a2 0f 	sts	0x0FA2, r24
	for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
	  PortStateTable[PTableEntry].State = TCP_Port_Closed;

	/* Initialize the connection table with all CLOSED entries */
	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	  ConnectionStateTable[CSTableEntry].State = TCP_Connection_Closed;
    1216:	80 93 b8 11 	sts	0x11B8, r24
    121a:	80 93 ce 13 	sts	0x13CE, r24
    121e:	08 95       	ret

00001220 <TCP_SetPortState>:

	/* Check to see if the port entry is already in the port state table */
	for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
	{
		/* Find existing entry for the port in the table, update it if found */
		if (PortStateTable[PTableEntry].Port == Port)
    1220:	20 91 cf 13 	lds	r18, 0x13CF
    1224:	30 91 d0 13 	lds	r19, 0x13D0
    1228:	28 17       	cp	r18, r24
    122a:	39 07       	cpc	r19, r25
    122c:	51 f0       	breq	.+20     	; 0x1242 <TCP_SetPortState+0x22>
			return true;
		}
	}

	/* Check if trying to open the port -- if so we need to find an unused (closed) entry and replace it */
	if (State == TCP_Port_Open)
    122e:	61 30       	cpi	r22, 0x01	; 1
    1230:	71 f4       	brne	.+28     	; 0x124e <TCP_SetPortState+0x2e>
	{
		for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
		{
			/* Find a closed port entry in the table, change it to the given port and state */
			if (PortStateTable[PTableEntry].State == TCP_Port_Closed)
    1232:	20 91 d1 13 	lds	r18, 0x13D1
    1236:	21 11       	cpse	r18, r1
    1238:	0c c0       	rjmp	.+24     	; 0x1252 <TCP_SetPortState+0x32>
			{
				PortStateTable[PTableEntry].Port  = Port;
    123a:	90 93 d0 13 	sts	0x13D0, r25
    123e:	80 93 cf 13 	sts	0x13CF, r24
				PortStateTable[PTableEntry].State = State;
    1242:	60 93 d1 13 	sts	0x13D1, r22
				PortStateTable[PTableEntry].ApplicationHandler = Handler;
    1246:	50 93 d3 13 	sts	0x13D3, r21
    124a:	40 93 d2 13 	sts	0x13D2, r20
		return false;
	}
	else
	{
		/* Port not in table but trying to close it, so operation successful */
		return true;
    124e:	81 e0       	ldi	r24, 0x01	; 1
    1250:	08 95       	ret
				return true;
			}
		}

		/* Port not in table and no room to add it, return failure */
		return false;
    1252:	80 e0       	ldi	r24, 0x00	; 0
	else
	{
		/* Port not in table but trying to close it, so operation successful */
		return true;
	}
}
    1254:	08 95       	ret

00001256 <TCP_GetPortState>:
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
	{
		/* Find existing entry for the port in the table, return the port status if found */
		if (PortStateTable[PTableEntry].Port == Port)
    1256:	20 91 cf 13 	lds	r18, 0x13CF
    125a:	30 91 d0 13 	lds	r19, 0x13D0
    125e:	28 17       	cp	r18, r24
    1260:	39 07       	cpc	r19, r25
    1262:	19 f4       	brne	.+6      	; 0x126a <TCP_GetPortState+0x14>
		  return PortStateTable[PTableEntry].State;
    1264:	80 91 d1 13 	lds	r24, 0x13D1
    1268:	08 95       	ret
	}

	/* Port not in table, assume closed */
	return TCP_Port_Closed;
    126a:	80 e0       	ldi	r24, 0x00	; 0
}
    126c:	08 95       	ret

0000126e <TCP_SetConnectionState>:
 */
bool TCP_SetConnectionState(const uint16_t Port,
                            const IP_Address_t* RemoteAddress,
                            const uint16_t RemotePort,
                            const uint8_t State)
{
    126e:	8f 92       	push	r8
    1270:	9f 92       	push	r9
    1272:	af 92       	push	r10
    1274:	bf 92       	push	r11
    1276:	cf 92       	push	r12
    1278:	df 92       	push	r13
    127a:	ef 92       	push	r14
    127c:	ff 92       	push	r15
    127e:	0f 93       	push	r16
    1280:	1f 93       	push	r17
    1282:	cf 93       	push	r28
    1284:	df 93       	push	r29
    1286:	1f 92       	push	r1
    1288:	cd b7       	in	r28, 0x3d	; 61
    128a:	de b7       	in	r29, 0x3e	; 62
    128c:	5c 01       	movw	r10, r24
    128e:	6b 01       	movw	r12, r22
    1290:	7a 01       	movw	r14, r20
    1292:	ad e8       	ldi	r26, 0x8D	; 141
    1294:	8a 2e       	mov	r8, r26
    1296:	ad e0       	ldi	r26, 0x0D	; 13
    1298:	9a 2e       	mov	r9, r26
    129a:	00 e0       	ldi	r16, 0x00	; 0
    129c:	10 e0       	ldi	r17, 0x00	; 0
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
    129e:	d4 01       	movw	r26, r8
    12a0:	8d 91       	ld	r24, X+
    12a2:	9c 91       	ld	r25, X
    12a4:	8a 15       	cp	r24, r10
    12a6:	9b 05       	cpc	r25, r11
    12a8:	e9 f4       	brne	.+58     	; 0x12e4 <TCP_SetConnectionState+0x76>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, RemoteAddress) &&
    12aa:	44 e0       	ldi	r20, 0x04	; 4
    12ac:	50 e0       	ldi	r21, 0x00	; 0
    12ae:	b6 01       	movw	r22, r12
    12b0:	c4 01       	movw	r24, r8
    12b2:	04 96       	adiw	r24, 0x04	; 4
    12b4:	29 83       	std	Y+1, r18	; 0x01
    12b6:	0e 94 69 14 	call	0x28d2	; 0x28d2 <memcmp>
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
    12ba:	29 81       	ldd	r18, Y+1	; 0x01
    12bc:	89 2b       	or	r24, r25
    12be:	91 f4       	brne	.+36     	; 0x12e4 <TCP_SetConnectionState+0x76>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, RemoteAddress) &&
    12c0:	f4 01       	movw	r30, r8
    12c2:	82 81       	ldd	r24, Z+2	; 0x02
    12c4:	93 81       	ldd	r25, Z+3	; 0x03
    12c6:	8e 15       	cp	r24, r14
    12c8:	9f 05       	cpc	r25, r15
    12ca:	61 f4       	brne	.+24     	; 0x12e4 <TCP_SetConnectionState+0x76>
			 ConnectionStateTable[CSTableEntry].RemotePort == RemotePort)
		{
			ConnectionStateTable[CSTableEntry].State = State;
    12cc:	86 e1       	ldi	r24, 0x16	; 22
    12ce:	92 e0       	ldi	r25, 0x02	; 2
    12d0:	08 9f       	mul	r16, r24
    12d2:	f0 01       	movw	r30, r0
    12d4:	09 9f       	mul	r16, r25
    12d6:	f0 0d       	add	r31, r0
    12d8:	18 9f       	mul	r17, r24
    12da:	f0 0d       	add	r31, r0
    12dc:	11 24       	eor	r1, r1
    12de:	ee 55       	subi	r30, 0x5E	; 94
    12e0:	f0 4f       	sbci	r31, 0xF0	; 240
    12e2:	37 c0       	rjmp	.+110    	; 0x1352 <TCP_SetConnectionState+0xe4>
    12e4:	0f 5f       	subi	r16, 0xFF	; 255
    12e6:	1f 4f       	sbci	r17, 0xFF	; 255
    12e8:	fa ee       	ldi	r31, 0xEA	; 234
    12ea:	8f 1a       	sub	r8, r31
    12ec:	fd ef       	ldi	r31, 0xFD	; 253
    12ee:	9f 0a       	sbc	r9, r31
                            const uint16_t RemotePort,
                            const uint8_t State)
{
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
    12f0:	03 30       	cpi	r16, 0x03	; 3
    12f2:	11 05       	cpc	r17, r1
    12f4:	a1 f6       	brne	.-88     	; 0x129e <TCP_SetConnectionState+0x30>
	}

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find empty entry in the table */
		if (ConnectionStateTable[CSTableEntry].State == TCP_Connection_Closed)
    12f6:	80 91 a2 0f 	lds	r24, 0x0FA2
    12fa:	8a 30       	cpi	r24, 0x0A	; 10
    12fc:	59 f0       	breq	.+22     	; 0x1314 <TCP_SetConnectionState+0xa6>
    12fe:	80 91 b8 11 	lds	r24, 0x11B8
    1302:	8a 30       	cpi	r24, 0x0A	; 10
    1304:	51 f0       	breq	.+20     	; 0x131a <TCP_SetConnectionState+0xac>
    1306:	80 91 ce 13 	lds	r24, 0x13CE
    130a:	8a 30       	cpi	r24, 0x0A	; 10
    130c:	29 f5       	brne	.+74     	; 0x1358 <TCP_SetConnectionState+0xea>
    130e:	82 e0       	ldi	r24, 0x02	; 2
    1310:	90 e0       	ldi	r25, 0x00	; 0
    1312:	05 c0       	rjmp	.+10     	; 0x131e <TCP_SetConnectionState+0xb0>
    1314:	80 e0       	ldi	r24, 0x00	; 0
    1316:	90 e0       	ldi	r25, 0x00	; 0
    1318:	02 c0       	rjmp	.+4      	; 0x131e <TCP_SetConnectionState+0xb0>
    131a:	81 e0       	ldi	r24, 0x01	; 1
    131c:	90 e0       	ldi	r25, 0x00	; 0
		{
			ConnectionStateTable[CSTableEntry].Port          = Port;
    131e:	46 e1       	ldi	r20, 0x16	; 22
    1320:	52 e0       	ldi	r21, 0x02	; 2
    1322:	84 9f       	mul	r24, r20
    1324:	f0 01       	movw	r30, r0
    1326:	85 9f       	mul	r24, r21
    1328:	f0 0d       	add	r31, r0
    132a:	94 9f       	mul	r25, r20
    132c:	f0 0d       	add	r31, r0
    132e:	11 24       	eor	r1, r1
    1330:	e3 57       	subi	r30, 0x73	; 115
    1332:	f2 4f       	sbci	r31, 0xF2	; 242
    1334:	b1 82       	std	Z+1, r11	; 0x01
    1336:	a0 82       	st	Z, r10
			ConnectionStateTable[CSTableEntry].RemoteAddress = *RemoteAddress;
    1338:	d6 01       	movw	r26, r12
    133a:	4d 91       	ld	r20, X+
    133c:	5d 91       	ld	r21, X+
    133e:	6d 91       	ld	r22, X+
    1340:	7c 91       	ld	r23, X
    1342:	44 83       	std	Z+4, r20	; 0x04
    1344:	55 83       	std	Z+5, r21	; 0x05
    1346:	66 83       	std	Z+6, r22	; 0x06
    1348:	77 83       	std	Z+7, r23	; 0x07
			ConnectionStateTable[CSTableEntry].RemotePort    = RemotePort;
    134a:	f3 82       	std	Z+3, r15	; 0x03
    134c:	e2 82       	std	Z+2, r14	; 0x02
			ConnectionStateTable[CSTableEntry].State         = State;
    134e:	eb 5e       	subi	r30, 0xEB	; 235
    1350:	fd 4f       	sbci	r31, 0xFD	; 253
    1352:	20 83       	st	Z, r18
			return true;
    1354:	81 e0       	ldi	r24, 0x01	; 1
    1356:	01 c0       	rjmp	.+2      	; 0x135a <TCP_SetConnectionState+0xec>
		}
	}

	return false;
    1358:	80 e0       	ldi	r24, 0x00	; 0
}
    135a:	0f 90       	pop	r0
    135c:	df 91       	pop	r29
    135e:	cf 91       	pop	r28
    1360:	1f 91       	pop	r17
    1362:	0f 91       	pop	r16
    1364:	ff 90       	pop	r15
    1366:	ef 90       	pop	r14
    1368:	df 90       	pop	r13
    136a:	cf 90       	pop	r12
    136c:	bf 90       	pop	r11
    136e:	af 90       	pop	r10
    1370:	9f 90       	pop	r9
    1372:	8f 90       	pop	r8
    1374:	08 95       	ret

00001376 <TCP_GetConnectionState>:
 *  \return A value from the \ref TCP_ConnectionStates_t enum
 */
uint8_t TCP_GetConnectionState(const uint16_t Port,
                               const IP_Address_t* RemoteAddress,
                               const uint16_t RemotePort)
{
    1376:	af 92       	push	r10
    1378:	bf 92       	push	r11
    137a:	cf 92       	push	r12
    137c:	df 92       	push	r13
    137e:	ef 92       	push	r14
    1380:	ff 92       	push	r15
    1382:	0f 93       	push	r16
    1384:	1f 93       	push	r17
    1386:	cf 93       	push	r28
    1388:	df 93       	push	r29
    138a:	7c 01       	movw	r14, r24
    138c:	6b 01       	movw	r12, r22
    138e:	5a 01       	movw	r10, r20
    1390:	cd e8       	ldi	r28, 0x8D	; 141
    1392:	dd e0       	ldi	r29, 0x0D	; 13
    1394:	00 e0       	ldi	r16, 0x00	; 0
    1396:	10 e0       	ldi	r17, 0x00	; 0
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
    1398:	88 81       	ld	r24, Y
    139a:	99 81       	ldd	r25, Y+1	; 0x01
    139c:	8e 15       	cp	r24, r14
    139e:	9f 05       	cpc	r25, r15
    13a0:	d9 f4       	brne	.+54     	; 0x13d8 <TCP_GetConnectionState+0x62>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, RemoteAddress) &&
    13a2:	44 e0       	ldi	r20, 0x04	; 4
    13a4:	50 e0       	ldi	r21, 0x00	; 0
    13a6:	b6 01       	movw	r22, r12
    13a8:	ce 01       	movw	r24, r28
    13aa:	04 96       	adiw	r24, 0x04	; 4
    13ac:	0e 94 69 14 	call	0x28d2	; 0x28d2 <memcmp>
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
    13b0:	89 2b       	or	r24, r25
    13b2:	91 f4       	brne	.+36     	; 0x13d8 <TCP_GetConnectionState+0x62>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, RemoteAddress) &&
    13b4:	8a 81       	ldd	r24, Y+2	; 0x02
    13b6:	9b 81       	ldd	r25, Y+3	; 0x03
    13b8:	8a 15       	cp	r24, r10
    13ba:	9b 05       	cpc	r25, r11
    13bc:	69 f4       	brne	.+26     	; 0x13d8 <TCP_GetConnectionState+0x62>
			 ConnectionStateTable[CSTableEntry].RemotePort == RemotePort)

		{
			return ConnectionStateTable[CSTableEntry].State;
    13be:	86 e1       	ldi	r24, 0x16	; 22
    13c0:	92 e0       	ldi	r25, 0x02	; 2
    13c2:	08 9f       	mul	r16, r24
    13c4:	f0 01       	movw	r30, r0
    13c6:	09 9f       	mul	r16, r25
    13c8:	f0 0d       	add	r31, r0
    13ca:	18 9f       	mul	r17, r24
    13cc:	f0 0d       	add	r31, r0
    13ce:	11 24       	eor	r1, r1
    13d0:	ee 55       	subi	r30, 0x5E	; 94
    13d2:	f0 4f       	sbci	r31, 0xF0	; 240
    13d4:	80 81       	ld	r24, Z
    13d6:	08 c0       	rjmp	.+16     	; 0x13e8 <TCP_GetConnectionState+0x72>
    13d8:	0f 5f       	subi	r16, 0xFF	; 255
    13da:	1f 4f       	sbci	r17, 0xFF	; 255
    13dc:	ca 5e       	subi	r28, 0xEA	; 234
    13de:	dd 4f       	sbci	r29, 0xFD	; 253
                               const IP_Address_t* RemoteAddress,
                               const uint16_t RemotePort)
{
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
    13e0:	03 30       	cpi	r16, 0x03	; 3
    13e2:	11 05       	cpc	r17, r1
    13e4:	c9 f6       	brne	.-78     	; 0x1398 <TCP_GetConnectionState+0x22>
		{
			return ConnectionStateTable[CSTableEntry].State;
		}
	}

	return TCP_Connection_Closed;
    13e6:	8a e0       	ldi	r24, 0x0A	; 10
}
    13e8:	df 91       	pop	r29
    13ea:	cf 91       	pop	r28
    13ec:	1f 91       	pop	r17
    13ee:	0f 91       	pop	r16
    13f0:	ff 90       	pop	r15
    13f2:	ef 90       	pop	r14
    13f4:	df 90       	pop	r13
    13f6:	cf 90       	pop	r12
    13f8:	bf 90       	pop	r11
    13fa:	af 90       	pop	r10
    13fc:	08 95       	ret

000013fe <TCP_GetConnectionInfo>:
 *  \return ConnectionInfo structure of the connection if found, NULL otherwise
 */
TCP_ConnectionInfo_t* TCP_GetConnectionInfo(const uint16_t Port,
                                            const IP_Address_t* RemoteAddress,
                                            const uint16_t RemotePort)
{
    13fe:	af 92       	push	r10
    1400:	bf 92       	push	r11
    1402:	cf 92       	push	r12
    1404:	df 92       	push	r13
    1406:	ef 92       	push	r14
    1408:	ff 92       	push	r15
    140a:	0f 93       	push	r16
    140c:	1f 93       	push	r17
    140e:	cf 93       	push	r28
    1410:	df 93       	push	r29
    1412:	7c 01       	movw	r14, r24
    1414:	6b 01       	movw	r12, r22
    1416:	5a 01       	movw	r10, r20
    1418:	cd e8       	ldi	r28, 0x8D	; 141
    141a:	dd e0       	ldi	r29, 0x0D	; 13
    141c:	00 e0       	ldi	r16, 0x00	; 0
    141e:	10 e0       	ldi	r17, 0x00	; 0
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
    1420:	88 81       	ld	r24, Y
    1422:	99 81       	ldd	r25, Y+1	; 0x01
    1424:	8e 15       	cp	r24, r14
    1426:	9f 05       	cpc	r25, r15
    1428:	d1 f4       	brne	.+52     	; 0x145e <TCP_GetConnectionInfo+0x60>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, RemoteAddress) &&
    142a:	44 e0       	ldi	r20, 0x04	; 4
    142c:	50 e0       	ldi	r21, 0x00	; 0
    142e:	b6 01       	movw	r22, r12
    1430:	ce 01       	movw	r24, r28
    1432:	04 96       	adiw	r24, 0x04	; 4
    1434:	0e 94 69 14 	call	0x28d2	; 0x28d2 <memcmp>
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
    1438:	89 2b       	or	r24, r25
    143a:	89 f4       	brne	.+34     	; 0x145e <TCP_GetConnectionInfo+0x60>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, RemoteAddress) &&
    143c:	8a 81       	ldd	r24, Y+2	; 0x02
    143e:	9b 81       	ldd	r25, Y+3	; 0x03
    1440:	8a 15       	cp	r24, r10
    1442:	9b 05       	cpc	r25, r11
    1444:	61 f4       	brne	.+24     	; 0x145e <TCP_GetConnectionInfo+0x60>
			 ConnectionStateTable[CSTableEntry].RemotePort == RemotePort)
		{
			return &ConnectionStateTable[CSTableEntry].Info;
    1446:	26 e1       	ldi	r18, 0x16	; 22
    1448:	32 e0       	ldi	r19, 0x02	; 2
    144a:	02 9f       	mul	r16, r18
    144c:	c0 01       	movw	r24, r0
    144e:	03 9f       	mul	r16, r19
    1450:	90 0d       	add	r25, r0
    1452:	12 9f       	mul	r17, r18
    1454:	90 0d       	add	r25, r0
    1456:	11 24       	eor	r1, r1
    1458:	8b 56       	subi	r24, 0x6B	; 107
    145a:	92 4f       	sbci	r25, 0xF2	; 242
    145c:	09 c0       	rjmp	.+18     	; 0x1470 <TCP_GetConnectionInfo+0x72>
    145e:	0f 5f       	subi	r16, 0xFF	; 255
    1460:	1f 4f       	sbci	r17, 0xFF	; 255
    1462:	ca 5e       	subi	r28, 0xEA	; 234
    1464:	dd 4f       	sbci	r29, 0xFD	; 253
                                            const IP_Address_t* RemoteAddress,
                                            const uint16_t RemotePort)
{
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
    1466:	03 30       	cpi	r16, 0x03	; 3
    1468:	11 05       	cpc	r17, r1
    146a:	d1 f6       	brne	.-76     	; 0x1420 <TCP_GetConnectionInfo+0x22>
		{
			return &ConnectionStateTable[CSTableEntry].Info;
		}
	}

	return NULL;
    146c:	80 e0       	ldi	r24, 0x00	; 0
    146e:	90 e0       	ldi	r25, 0x00	; 0
}
    1470:	df 91       	pop	r29
    1472:	cf 91       	pop	r28
    1474:	1f 91       	pop	r17
    1476:	0f 91       	pop	r16
    1478:	ff 90       	pop	r15
    147a:	ef 90       	pop	r14
    147c:	df 90       	pop	r13
    147e:	cf 90       	pop	r12
    1480:	bf 90       	pop	r11
    1482:	af 90       	pop	r10
    1484:	08 95       	ret

00001486 <TCP_ProcessTCPPacket>:
 *           next Ethernet packet handler iteration
 */
int16_t TCP_ProcessTCPPacket(void* IPHeaderInStart,
                             void* TCPHeaderInStart,
                             void* TCPHeaderOutStart)
{
    1486:	2f 92       	push	r2
    1488:	3f 92       	push	r3
    148a:	4f 92       	push	r4
    148c:	5f 92       	push	r5
    148e:	6f 92       	push	r6
    1490:	7f 92       	push	r7
    1492:	8f 92       	push	r8
    1494:	9f 92       	push	r9
    1496:	af 92       	push	r10
    1498:	bf 92       	push	r11
    149a:	cf 92       	push	r12
    149c:	df 92       	push	r13
    149e:	ef 92       	push	r14
    14a0:	ff 92       	push	r15
    14a2:	0f 93       	push	r16
    14a4:	1f 93       	push	r17
    14a6:	cf 93       	push	r28
    14a8:	df 93       	push	r29
    14aa:	00 d0       	rcall	.+0      	; 0x14ac <TCP_ProcessTCPPacket+0x26>
    14ac:	1f 92       	push	r1
    14ae:	cd b7       	in	r28, 0x3d	; 61
    14b0:	de b7       	in	r29, 0x3e	; 62
    14b2:	5c 01       	movw	r10, r24
    14b4:	7b 83       	std	Y+3, r23	; 0x03
    14b6:	6a 83       	std	Y+2, r22	; 0x02
    14b8:	8a 01       	movw	r16, r20
	TCP_Header_t* TCPHeaderIN  = (TCP_Header_t*)TCPHeaderInStart;
	TCP_Header_t* TCPHeaderOUT = (TCP_Header_t*)TCPHeaderOutStart;

	TCP_ConnectionInfo_t* ConnectionInfo;

	DecodeTCPHeader(TCPHeaderInStart);
    14ba:	cb 01       	movw	r24, r22
    14bc:	3b da       	rcall	.-2954   	; 0x934 <DecodeTCPHeader>
    14be:	aa 81       	ldd	r26, Y+2	; 0x02

	bool PacketResponse = false;

	/* Check if the destination port is open and allows incoming connections */
	if (TCP_GetPortState(TCPHeaderIN->DestinationPort) == TCP_Port_Open)
    14c0:	bb 81       	ldd	r27, Y+3	; 0x03
    14c2:	12 96       	adiw	r26, 0x02	; 2
    14c4:	cd 90       	ld	r12, X+
    14c6:	dc 90       	ld	r13, X
    14c8:	13 97       	sbiw	r26, 0x03	; 3
    14ca:	c6 01       	movw	r24, r12
    14cc:	c4 de       	rcall	.-632    	; 0x1256 <TCP_GetPortState>
    14ce:	f5 01       	movw	r30, r10
    14d0:	3c 96       	adiw	r30, 0x0c	; 12
    14d2:	7f 01       	movw	r14, r30
    14d4:	81 30       	cpi	r24, 0x01	; 1
    14d6:	09 f0       	breq	.+2      	; 0x14da <TCP_ProcessTCPPacket+0x54>
    14d8:	8e c1       	rjmp	.+796    	; 0x17f6 <TCP_ProcessTCPPacket+0x370>
    14da:	aa 81       	ldd	r26, Y+2	; 0x02
    14dc:	bb 81       	ldd	r27, Y+3	; 0x03
	{
		/* Detect SYN from host to start a connection */
		if (TCPHeaderIN->Flags & TCP_FLAG_SYN)
    14de:	1d 96       	adiw	r26, 0x0d	; 13
    14e0:	8c 91       	ld	r24, X
    14e2:	1d 97       	sbiw	r26, 0x0d	; 13
    14e4:	81 ff       	sbrs	r24, 1
    14e6:	06 c0       	rjmp	.+12     	; 0x14f4 <TCP_ProcessTCPPacket+0x6e>
    14e8:	4d 91       	ld	r20, X+
    14ea:	5c 91       	ld	r21, X
		  TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress, TCPHeaderIN->SourcePort, TCP_Connection_Listen);
    14ec:	20 e0       	ldi	r18, 0x00	; 0
    14ee:	bf 01       	movw	r22, r30
    14f0:	c6 01       	movw	r24, r12
    14f2:	bd de       	rcall	.-646    	; 0x126e <TCP_SetConnectionState>
    14f4:	ea 81       	ldd	r30, Y+2	; 0x02
    14f6:	fb 81       	ldd	r31, Y+3	; 0x03
    14f8:	25 85       	ldd	r18, Z+13	; 0x0d

		/* Detect RST from host to abort existing connection */
		if (TCPHeaderIN->Flags & TCP_FLAG_RST)
    14fa:	c2 80       	ldd	r12, Z+2	; 0x02
    14fc:	d3 80       	ldd	r13, Z+3	; 0x03
    14fe:	80 80       	ld	r8, Z
    1500:	91 80       	ldd	r9, Z+1	; 0x01
    1502:	22 ff       	sbrs	r18, 2
    1504:	09 c0       	rjmp	.+18     	; 0x1518 <TCP_ProcessTCPPacket+0x92>
    1506:	2a e0       	ldi	r18, 0x0A	; 10
    1508:	a4 01       	movw	r20, r8
    150a:	b7 01       	movw	r22, r14
		{
			if (TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    150c:	c6 01       	movw	r24, r12
    150e:	af de       	rcall	.-674    	; 0x126e <TCP_SetConnectionState>
    1510:	88 23       	and	r24, r24
    1512:	09 f4       	brne	.+2      	; 0x1516 <TCP_ProcessTCPPacket+0x90>
    1514:	d6 c1       	rjmp	.+940    	; 0x18c2 <TCP_ProcessTCPPacket+0x43c>
    1516:	6f c1       	rjmp	.+734    	; 0x17f6 <TCP_ProcessTCPPacket+0x370>
    1518:	a4 01       	movw	r20, r8
    151a:	b7 01       	movw	r22, r14
    151c:	c6 01       	movw	r24, r12
    151e:	29 83       	std	Y+1, r18	; 0x01
			}
		}
		else
		{
			/* Process the incoming TCP packet based on the current connection state for the sender and port */
			switch (TCP_GetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress, TCPHeaderIN->SourcePort))
    1520:	2a df       	rcall	.-428    	; 0x1376 <TCP_GetConnectionState>
    1522:	29 81       	ldd	r18, Y+1	; 0x01
    1524:	84 30       	cpi	r24, 0x04	; 4
    1526:	09 f4       	brne	.+2      	; 0x152a <TCP_ProcessTCPPacket+0xa4>
    1528:	28 c1       	rjmp	.+592    	; 0x177a <TCP_ProcessTCPPacket+0x2f4>
    152a:	40 f4       	brcc	.+16     	; 0x153c <TCP_ProcessTCPPacket+0xb6>
    152c:	82 30       	cpi	r24, 0x02	; 2
    152e:	09 f4       	brne	.+2      	; 0x1532 <TCP_ProcessTCPPacket+0xac>
    1530:	52 c0       	rjmp	.+164    	; 0x15d6 <TCP_ProcessTCPPacket+0x150>
    1532:	08 f0       	brcs	.+2      	; 0x1536 <TCP_ProcessTCPPacket+0xb0>
    1534:	71 c0       	rjmp	.+226    	; 0x1618 <TCP_ProcessTCPPacket+0x192>
    1536:	88 23       	and	r24, r24
    1538:	d1 f0       	breq	.+52     	; 0x156e <TCP_ProcessTCPPacket+0xe8>
    153a:	c3 c1       	rjmp	.+902    	; 0x18c2 <TCP_ProcessTCPPacket+0x43c>
    153c:	86 30       	cpi	r24, 0x06	; 6
    153e:	09 f4       	brne	.+2      	; 0x1542 <TCP_ProcessTCPPacket+0xbc>
    1540:	51 c1       	rjmp	.+674    	; 0x17e4 <TCP_ProcessTCPPacket+0x35e>
    1542:	08 f4       	brcc	.+2      	; 0x1546 <TCP_ProcessTCPPacket+0xc0>
    1544:	21 c1       	rjmp	.+578    	; 0x1788 <TCP_ProcessTCPPacket+0x302>
    1546:	87 30       	cpi	r24, 0x07	; 7
    1548:	09 f0       	breq	.+2      	; 0x154c <TCP_ProcessTCPPacket+0xc6>
    154a:	bb c1       	rjmp	.+886    	; 0x18c2 <TCP_ProcessTCPPacket+0x43c>
    154c:	a4 01       	movw	r20, r8
    154e:	b7 01       	movw	r22, r14
    1550:	c6 01       	movw	r24, r12
    1552:	55 df       	rcall	.-342    	; 0x13fe <TCP_GetConnectionInfo>
    1554:	21 e1       	ldi	r18, 0x11	; 17
						}
					}

					break;
				case TCP_Connection_Closing:
						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    1556:	f8 01       	movw	r30, r16
    1558:	25 87       	std	Z+13, r18	; 0x0d
    155a:	84 5f       	subi	r24, 0xF4	; 244
    155c:	9d 4f       	sbci	r25, 0xFD	; 253
    155e:	dc 01       	movw	r26, r24
															   TCPHeaderIN->SourcePort);

						TCPHeaderOUT->Flags = (TCP_FLAG_ACK | TCP_FLAG_FIN);
    1560:	1c 92       	st	X, r1
    1562:	ea 81       	ldd	r30, Y+2	; 0x02
    1564:	fb 81       	ldd	r31, Y+3	; 0x03
						PacketResponse      = true;

						ConnectionInfo->Buffer.InUse = false;
    1566:	40 81       	ld	r20, Z
    1568:	51 81       	ldd	r21, Z+1	; 0x01
    156a:	24 e0       	ldi	r18, 0x04	; 4
    156c:	36 c1       	rjmp	.+620    	; 0x17da <TCP_ProcessTCPPacket+0x354>

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    156e:	22 30       	cpi	r18, 0x02	; 2
    1570:	09 f0       	breq	.+2      	; 0x1574 <TCP_ProcessTCPPacket+0xee>
    1572:	a7 c1       	rjmp	.+846    	; 0x18c2 <TCP_ProcessTCPPacket+0x43c>
    1574:	a4 01       	movw	r20, r8
    1576:	b7 01       	movw	r22, r14
    1578:	c6 01       	movw	r24, r12
		{
			/* Process the incoming TCP packet based on the current connection state for the sender and port */
			switch (TCP_GetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress, TCPHeaderIN->SourcePort))
			{
				case TCP_Connection_Listen:
					if (TCPHeaderIN->Flags == TCP_FLAG_SYN)
    157a:	79 de       	rcall	.-782    	; 0x126e <TCP_SetConnectionState>
    157c:	88 23       	and	r24, r24
    157e:	49 f1       	breq	.+82     	; 0x15d2 <TCP_ProcessTCPPacket+0x14c>
					{
						/* SYN connection starts a connection with a peer */
						if (TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    1580:	82 e1       	ldi	r24, 0x12	; 18
    1582:	f8 01       	movw	r30, r16
    1584:	85 87       	std	Z+13, r24	; 0x0d
    1586:	aa 81       	ldd	r26, Y+2	; 0x02
    1588:	bb 81       	ldd	r27, Y+3	; 0x03
    158a:	4d 91       	ld	r20, X+
    158c:	5c 91       	ld	r21, X
						                           TCPHeaderIN->SourcePort, TCP_Connection_SYNReceived))
						{
							TCPHeaderOUT->Flags = (TCP_FLAG_SYN | TCP_FLAG_ACK);
    158e:	11 97       	sbiw	r26, 0x01	; 1
    1590:	b7 01       	movw	r22, r14
    1592:	12 96       	adiw	r26, 0x02	; 2

							ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress, TCPHeaderIN->SourcePort);
    1594:	8d 91       	ld	r24, X+
    1596:	9c 91       	ld	r25, X
    1598:	13 97       	sbiw	r26, 0x03	; 3
    159a:	31 df       	rcall	.-414    	; 0x13fe <TCP_GetConnectionInfo>
    159c:	6c 01       	movw	r12, r24
    159e:	ea 81       	ldd	r30, Y+2	; 0x02
    15a0:	fb 81       	ldd	r31, Y+3	; 0x03
    15a2:	64 81       	ldd	r22, Z+4	; 0x04
    15a4:	75 81       	ldd	r23, Z+5	; 0x05
    15a6:	86 81       	ldd	r24, Z+6	; 0x06
    15a8:	97 81       	ldd	r25, Z+7	; 0x07
    15aa:	9b dc       	rcall	.-1738   	; 0xee2 <SwapEndian_32>
    15ac:	6f 5f       	subi	r22, 0xFF	; 255

							ConnectionInfo->SequenceNumberIn  = (SwapEndian_32(TCPHeaderIN->SequenceNumber) + 1);
    15ae:	7f 4f       	sbci	r23, 0xFF	; 255
    15b0:	8f 4f       	sbci	r24, 0xFF	; 255
    15b2:	9f 4f       	sbci	r25, 0xFF	; 255
    15b4:	d6 01       	movw	r26, r12
    15b6:	6d 93       	st	X+, r22
    15b8:	7d 93       	st	X+, r23
    15ba:	8d 93       	st	X+, r24
    15bc:	9c 93       	st	X, r25
    15be:	13 97       	sbiw	r26, 0x03	; 3
    15c0:	f6 01       	movw	r30, r12
    15c2:	14 82       	std	Z+4, r1	; 0x04
    15c4:	15 82       	std	Z+5, r1	; 0x05
    15c6:	16 82       	std	Z+6, r1	; 0x06
    15c8:	17 82       	std	Z+7, r1	; 0x07
    15ca:	e4 5f       	subi	r30, 0xF4	; 244
    15cc:	fd 4f       	sbci	r31, 0xFD	; 253
    15ce:	10 82       	st	Z, r1
    15d0:	17 c1       	rjmp	.+558    	; 0x1800 <TCP_ProcessTCPPacket+0x37a>
							ConnectionInfo->SequenceNumberOut = 0;
    15d2:	84 e0       	ldi	r24, 0x04	; 4
    15d4:	ce c0       	rjmp	.+412    	; 0x1772 <TCP_ProcessTCPPacket+0x2ec>
    15d6:	20 31       	cpi	r18, 0x10	; 16
    15d8:	09 f0       	breq	.+2      	; 0x15dc <TCP_ProcessTCPPacket+0x156>
    15da:	73 c1       	rjmp	.+742    	; 0x18c2 <TCP_ProcessTCPPacket+0x43c>
							ConnectionInfo->Buffer.InUse      = false;
    15dc:	23 e0       	ldi	r18, 0x03	; 3
    15de:	a4 01       	movw	r20, r8
    15e0:	b7 01       	movw	r22, r14
    15e2:	c6 01       	movw	r24, r12
						}
						else
						{
							TCPHeaderOUT->Flags = TCP_FLAG_RST;
    15e4:	44 de       	rcall	.-888    	; 0x126e <TCP_SetConnectionState>
    15e6:	ea 81       	ldd	r30, Y+2	; 0x02
						PacketResponse      = true;
					}

					break;
				case TCP_Connection_SYNReceived:
					if (TCPHeaderIN->Flags == TCP_FLAG_ACK)
    15e8:	fb 81       	ldd	r31, Y+3	; 0x03
    15ea:	40 81       	ld	r20, Z
    15ec:	51 81       	ldd	r21, Z+1	; 0x01
					{
						/* ACK during the connection process completes the connection to a peer */

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    15ee:	b7 01       	movw	r22, r14
    15f0:	82 81       	ldd	r24, Z+2	; 0x02
    15f2:	93 81       	ldd	r25, Z+3	; 0x03
    15f4:	04 df       	rcall	.-504    	; 0x13fe <TCP_GetConnectionInfo>
    15f6:	dc 01       	movw	r26, r24
    15f8:	14 96       	adiw	r26, 0x04	; 4
											   TCPHeaderIN->SourcePort, TCP_Connection_Established);

						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    15fa:	4d 91       	ld	r20, X+
    15fc:	5d 91       	ld	r21, X+
    15fe:	6d 91       	ld	r22, X+
    1600:	7c 91       	ld	r23, X
    1602:	17 97       	sbiw	r26, 0x07	; 7
    1604:	4f 5f       	subi	r20, 0xFF	; 255
    1606:	5f 4f       	sbci	r21, 0xFF	; 255
    1608:	6f 4f       	sbci	r22, 0xFF	; 255
    160a:	7f 4f       	sbci	r23, 0xFF	; 255
															   TCPHeaderIN->SourcePort);

						ConnectionInfo->SequenceNumberOut++;
    160c:	fc 01       	movw	r30, r24
    160e:	44 83       	std	Z+4, r20	; 0x04
    1610:	55 83       	std	Z+5, r21	; 0x05
    1612:	66 83       	std	Z+6, r22	; 0x06
    1614:	77 83       	std	Z+7, r23	; 0x07
    1616:	55 c1       	rjmp	.+682    	; 0x18c2 <TCP_ProcessTCPPacket+0x43c>
    1618:	21 31       	cpi	r18, 0x11	; 17
    161a:	89 f5       	brne	.+98     	; 0x167e <TCP_ProcessTCPPacket+0x1f8>
    161c:	d8 01       	movw	r26, r16
    161e:	1d 96       	adiw	r26, 0x0d	; 13
    1620:	2c 93       	st	X, r18
    1622:	ea 81       	ldd	r30, Y+2	; 0x02
    1624:	fb 81       	ldd	r31, Y+3	; 0x03
    1626:	40 81       	ld	r20, Z
    1628:	51 81       	ldd	r21, Z+1	; 0x01
    162a:	26 e0       	ldi	r18, 0x06	; 6
    162c:	b7 01       	movw	r22, r14
					}

					break;
				case TCP_Connection_Established:
					if (TCPHeaderIN->Flags == (TCP_FLAG_FIN | TCP_FLAG_ACK))
    162e:	82 81       	ldd	r24, Z+2	; 0x02
    1630:	93 81       	ldd	r25, Z+3	; 0x03
					{
						/* FIN ACK when connected to a peer starts the finalization process */

						TCPHeaderOUT->Flags = (TCP_FLAG_FIN | TCP_FLAG_ACK);
    1632:	1d de       	rcall	.-966    	; 0x126e <TCP_SetConnectionState>
    1634:	aa 81       	ldd	r26, Y+2	; 0x02
    1636:	bb 81       	ldd	r27, Y+3	; 0x03
						PacketResponse      = true;

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    1638:	4d 91       	ld	r20, X+
    163a:	5c 91       	ld	r21, X
    163c:	11 97       	sbiw	r26, 0x01	; 1
    163e:	b7 01       	movw	r22, r14
    1640:	12 96       	adiw	r26, 0x02	; 2
    1642:	8d 91       	ld	r24, X+
    1644:	9c 91       	ld	r25, X
    1646:	13 97       	sbiw	r26, 0x03	; 3
    1648:	da de       	rcall	.-588    	; 0x13fe <TCP_GetConnectionInfo>
    164a:	fc 01       	movw	r30, r24
											   TCPHeaderIN->SourcePort, TCP_Connection_CloseWait);

						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    164c:	40 81       	ld	r20, Z
    164e:	51 81       	ldd	r21, Z+1	; 0x01
    1650:	62 81       	ldd	r22, Z+2	; 0x02
    1652:	73 81       	ldd	r23, Z+3	; 0x03
    1654:	4f 5f       	subi	r20, 0xFF	; 255
    1656:	5f 4f       	sbci	r21, 0xFF	; 255
    1658:	6f 4f       	sbci	r22, 0xFF	; 255
    165a:	7f 4f       	sbci	r23, 0xFF	; 255
    165c:	40 83       	st	Z, r20
    165e:	51 83       	std	Z+1, r21	; 0x01
    1660:	62 83       	std	Z+2, r22	; 0x02
    1662:	73 83       	std	Z+3, r23	; 0x03
    1664:	44 81       	ldd	r20, Z+4	; 0x04
															   TCPHeaderIN->SourcePort);

						ConnectionInfo->SequenceNumberIn++;
    1666:	55 81       	ldd	r21, Z+5	; 0x05
    1668:	66 81       	ldd	r22, Z+6	; 0x06
    166a:	77 81       	ldd	r23, Z+7	; 0x07
    166c:	4f 5f       	subi	r20, 0xFF	; 255
    166e:	5f 4f       	sbci	r21, 0xFF	; 255
    1670:	6f 4f       	sbci	r22, 0xFF	; 255
    1672:	7f 4f       	sbci	r23, 0xFF	; 255
    1674:	44 83       	std	Z+4, r20	; 0x04
    1676:	55 83       	std	Z+5, r21	; 0x05
    1678:	66 83       	std	Z+6, r22	; 0x06
    167a:	77 83       	std	Z+7, r23	; 0x07
    167c:	c1 c0       	rjmp	.+386    	; 0x1800 <TCP_ProcessTCPPacket+0x37a>
						ConnectionInfo->SequenceNumberOut++;
    167e:	27 7f       	andi	r18, 0xF7	; 247
    1680:	20 31       	cpi	r18, 0x10	; 16
    1682:	09 f0       	breq	.+2      	; 0x1686 <TCP_ProcessTCPPacket+0x200>
    1684:	1e c1       	rjmp	.+572    	; 0x18c2 <TCP_ProcessTCPPacket+0x43c>
    1686:	a4 01       	movw	r20, r8
    1688:	b7 01       	movw	r22, r14
    168a:	c6 01       	movw	r24, r12
    168c:	b8 de       	rcall	.-656    	; 0x13fe <TCP_GetConnectionInfo>
    168e:	6c 01       	movw	r12, r24
    1690:	4c 01       	movw	r8, r24
    1692:	b4 ef       	ldi	r27, 0xF4	; 244
    1694:	8b 1a       	sub	r8, r27
    1696:	bd ef       	ldi	r27, 0xFD	; 253
					}
					else if ((TCPHeaderIN->Flags == TCP_FLAG_ACK) || (TCPHeaderIN->Flags == (TCP_FLAG_ACK | TCP_FLAG_PSH)))
    1698:	9b 0a       	sbc	r9, r27
    169a:	f4 01       	movw	r30, r8
    169c:	80 81       	ld	r24, Z
    169e:	f6 01       	movw	r30, r12
					{
						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    16a0:	e6 5f       	subi	r30, 0xF6	; 246
    16a2:	fd 4f       	sbci	r31, 0xFD	; 253
    16a4:	81 11       	cpse	r24, r1
    16a6:	0f c0       	rjmp	.+30     	; 0x16c6 <TCP_ProcessTCPPacket+0x240>
    16a8:	d6 01       	movw	r26, r12
    16aa:	a5 5f       	subi	r26, 0xF5	; 245
															   TCPHeaderIN->SourcePort);

						/* Check if the buffer is currently in use either by a buffered data to send, or receive */
						if ((ConnectionInfo->Buffer.InUse == false) && (ConnectionInfo->Buffer.Ready == false))
    16ac:	bd 4f       	sbci	r27, 0xFD	; 253
    16ae:	8c 91       	ld	r24, X
    16b0:	81 11       	cpse	r24, r1
    16b2:	09 c0       	rjmp	.+18     	; 0x16c6 <TCP_ProcessTCPPacket+0x240>
    16b4:	10 82       	st	Z, r1
    16b6:	81 e0       	ldi	r24, 0x01	; 1
    16b8:	d4 01       	movw	r26, r8
    16ba:	8c 93       	st	X, r24
    16bc:	d6 01       	movw	r26, r12
    16be:	19 96       	adiw	r26, 0x09	; 9
    16c0:	1c 92       	st	X, r1
    16c2:	1e 92       	st	-X, r1
    16c4:	18 97       	sbiw	r26, 0x08	; 8
    16c6:	80 81       	ld	r24, Z
    16c8:	81 11       	cpse	r24, r1
    16ca:	97 c0       	rjmp	.+302    	; 0x17fa <TCP_ProcessTCPPacket+0x374>
    16cc:	f6 01       	movw	r30, r12
    16ce:	40 84       	ldd	r4, Z+8	; 0x08
						{
							ConnectionInfo->Buffer.Direction = TCP_PACKETDIR_IN;
    16d0:	51 84       	ldd	r5, Z+9	; 0x09
							ConnectionInfo->Buffer.InUse     = true;
    16d2:	41 14       	cp	r4, r1
    16d4:	f2 e0       	ldi	r31, 0x02	; 2
    16d6:	5f 06       	cpc	r5, r31
							ConnectionInfo->Buffer.Length    = 0;
    16d8:	09 f4       	brne	.+2      	; 0x16dc <TCP_ProcessTCPPacket+0x256>
    16da:	8f c0       	rjmp	.+286    	; 0x17fa <TCP_ProcessTCPPacket+0x374>
    16dc:	d5 01       	movw	r26, r10
    16de:	8c 91       	ld	r24, X
    16e0:	8f 70       	andi	r24, 0x0F	; 15
						}

						/* Check if the buffer has been claimed by us to read in data from the peer */
						if ((ConnectionInfo->Buffer.Direction == TCP_PACKETDIR_IN) &&
    16e2:	b4 e0       	ldi	r27, 0x04	; 4
    16e4:	8b 9f       	mul	r24, r27
    16e6:	30 01       	movw	r6, r0
							(ConnectionInfo->Buffer.Length != TCP_WINDOW_SIZE))
    16e8:	11 24       	eor	r1, r1
    16ea:	ea 81       	ldd	r30, Y+2	; 0x02
    16ec:	fb 81       	ldd	r31, Y+3	; 0x03
							ConnectionInfo->Buffer.InUse     = true;
							ConnectionInfo->Buffer.Length    = 0;
						}

						/* Check if the buffer has been claimed by us to read in data from the peer */
						if ((ConnectionInfo->Buffer.Direction == TCP_PACKETDIR_IN) &&
    16ee:	24 84       	ldd	r2, Z+12	; 0x0c
    16f0:	22 94       	swap	r2
    16f2:	bf e0       	ldi	r27, 0x0F	; 15
    16f4:	2b 22       	and	r2, r27
    16f6:	f4 e0       	ldi	r31, 0x04	; 4
							(ConnectionInfo->Buffer.Length != TCP_WINDOW_SIZE))
						{
							uint16_t IPOffset   = (IPHeaderIN->HeaderLength * sizeof(uint32_t));
    16f8:	2f 9e       	mul	r2, r31
    16fa:	10 01       	movw	r2, r0
    16fc:	11 24       	eor	r1, r1
    16fe:	d5 01       	movw	r26, r10
    1700:	12 96       	adiw	r26, 0x02	; 2
    1702:	8d 91       	ld	r24, X+
    1704:	9c 91       	ld	r25, X
							uint16_t TCPOffset  = (TCPHeaderIN->DataOffset * sizeof(uint32_t));
    1706:	13 97       	sbiw	r26, 0x03	; 3
    1708:	f2 db       	rcall	.-2076   	; 0xeee <SwapEndian_16.part.1>
    170a:	86 19       	sub	r24, r6
    170c:	97 09       	sbc	r25, r7
    170e:	3c 01       	movw	r6, r24
    1710:	62 18       	sub	r6, r2
    1712:	73 08       	sbc	r7, r3
    1714:	c2 01       	movw	r24, r4
    1716:	0a 96       	adiw	r24, 0x0a	; 10
    1718:	6a 81       	ldd	r22, Y+2	; 0x02
    171a:	7b 81       	ldd	r23, Y+3	; 0x03
    171c:	62 0d       	add	r22, r2
    171e:	73 1d       	adc	r23, r3
    1720:	a3 01       	movw	r20, r6
    1722:	8c 0d       	add	r24, r12
    1724:	9d 1d       	adc	r25, r13
    1726:	0e 94 76 14 	call	0x28ec	; 0x28ec <memcpy>
							uint16_t DataLength = (SwapEndian_16(IPHeaderIN->TotalLength) - IPOffset - TCPOffset);
    172a:	f6 01       	movw	r30, r12
    172c:	80 81       	ld	r24, Z
    172e:	91 81       	ldd	r25, Z+1	; 0x01
    1730:	a2 81       	ldd	r26, Z+2	; 0x02

							/* Copy the packet data into the buffer */
							memcpy(&ConnectionInfo->Buffer.Data[ConnectionInfo->Buffer.Length],
    1732:	b3 81       	ldd	r27, Z+3	; 0x03
    1734:	86 0d       	add	r24, r6
    1736:	97 1d       	adc	r25, r7
    1738:	a1 1d       	adc	r26, r1
    173a:	b1 1d       	adc	r27, r1
    173c:	80 83       	st	Z, r24
    173e:	91 83       	std	Z+1, r25	; 0x01
    1740:	a2 83       	std	Z+2, r26	; 0x02
    1742:	b3 83       	std	Z+3, r27	; 0x03
    1744:	80 85       	ldd	r24, Z+8	; 0x08
    1746:	91 85       	ldd	r25, Z+9	; 0x09
								   &((uint8_t*)TCPHeaderInStart)[TCPOffset],
								   DataLength);

							ConnectionInfo->SequenceNumberIn += DataLength;
    1748:	86 0d       	add	r24, r6
    174a:	97 1d       	adc	r25, r7
    174c:	91 87       	std	Z+9, r25	; 0x09
    174e:	80 87       	std	Z+8, r24	; 0x08
    1750:	81 15       	cp	r24, r1
    1752:	92 40       	sbci	r25, 0x02	; 2
    1754:	31 f0       	breq	.+12     	; 0x1762 <TCP_ProcessTCPPacket+0x2dc>
    1756:	aa 81       	ldd	r26, Y+2	; 0x02
    1758:	bb 81       	ldd	r27, Y+3	; 0x03
    175a:	1d 96       	adiw	r26, 0x0d	; 13
    175c:	8c 91       	ld	r24, X
    175e:	83 ff       	sbrs	r24, 3
    1760:	b0 c0       	rjmp	.+352    	; 0x18c2 <TCP_ProcessTCPPacket+0x43c>
							ConnectionInfo->Buffer.Length    += DataLength;
    1762:	f4 01       	movw	r30, r8
    1764:	10 82       	st	Z, r1
    1766:	f6 01       	movw	r30, r12
    1768:	e5 5f       	subi	r30, 0xF5	; 245
    176a:	fd 4f       	sbci	r31, 0xFD	; 253
    176c:	81 e0       	ldi	r24, 0x01	; 1

							/* Check if the buffer is full or if the PSH flag is set, if so indicate buffer ready */
							if ((!(TCP_WINDOW_SIZE - ConnectionInfo->Buffer.Length)) || (TCPHeaderIN->Flags & TCP_FLAG_PSH))
    176e:	80 83       	st	Z, r24
    1770:	80 e1       	ldi	r24, 0x10	; 16
    1772:	d8 01       	movw	r26, r16
    1774:	1d 96       	adiw	r26, 0x0d	; 13
    1776:	8c 93       	st	X, r24
    1778:	43 c0       	rjmp	.+134    	; 0x1800 <TCP_ProcessTCPPacket+0x37a>
    177a:	21 31       	cpi	r18, 0x11	; 17
    177c:	41 f0       	breq	.+16     	; 0x178e <TCP_ProcessTCPPacket+0x308>
    177e:	20 31       	cpi	r18, 0x10	; 16
							{
								ConnectionInfo->Buffer.InUse = false;
    1780:	09 f0       	breq	.+2      	; 0x1784 <TCP_ProcessTCPPacket+0x2fe>
    1782:	9f c0       	rjmp	.+318    	; 0x18c2 <TCP_ProcessTCPPacket+0x43c>
								ConnectionInfo->Buffer.Ready = true;
    1784:	25 e0       	ldi	r18, 0x05	; 5
    1786:	32 c0       	rjmp	.+100    	; 0x17ec <TCP_ProcessTCPPacket+0x366>
    1788:	21 31       	cpi	r18, 0x11	; 17
    178a:	09 f0       	breq	.+2      	; 0x178e <TCP_ProcessTCPPacket+0x308>
    178c:	9a c0       	rjmp	.+308    	; 0x18c2 <TCP_ProcessTCPPacket+0x43c>

								TCPHeaderOUT->Flags = TCP_FLAG_ACK;
    178e:	a4 01       	movw	r20, r8
    1790:	b7 01       	movw	r22, r14
    1792:	c6 01       	movw	r24, r12
    1794:	34 de       	rcall	.-920    	; 0x13fe <TCP_GetConnectionInfo>
    1796:	fc 01       	movw	r30, r24
						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
											   TCPHeaderIN->SourcePort, TCP_Connection_FINWait1);

					break;
				case TCP_Connection_FINWait1:
					if (TCPHeaderIN->Flags == (TCP_FLAG_FIN | TCP_FLAG_ACK))
    1798:	80 e1       	ldi	r24, 0x10	; 16
    179a:	d8 01       	movw	r26, r16
						ConnectionInfo->SequenceNumberOut++;

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
											   TCPHeaderIN->SourcePort, TCP_Connection_Closed);
					}
					else if (TCPHeaderIN->Flags == TCP_FLAG_ACK)
    179c:	1d 96       	adiw	r26, 0x0d	; 13
    179e:	8c 93       	st	X, r24
    17a0:	40 81       	ld	r20, Z
					{
						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    17a2:	51 81       	ldd	r21, Z+1	; 0x01
    17a4:	62 81       	ldd	r22, Z+2	; 0x02
											   TCPHeaderIN->SourcePort, TCP_Connection_FINWait2);
					}

					break;
				case TCP_Connection_FINWait2:
					if (TCPHeaderIN->Flags == (TCP_FLAG_FIN | TCP_FLAG_ACK))
    17a6:	73 81       	ldd	r23, Z+3	; 0x03
    17a8:	4f 5f       	subi	r20, 0xFF	; 255
    17aa:	5f 4f       	sbci	r21, 0xFF	; 255
					{
						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    17ac:	6f 4f       	sbci	r22, 0xFF	; 255
    17ae:	7f 4f       	sbci	r23, 0xFF	; 255
    17b0:	40 83       	st	Z, r20
    17b2:	51 83       	std	Z+1, r21	; 0x01
    17b4:	62 83       	std	Z+2, r22	; 0x02
    17b6:	73 83       	std	Z+3, r23	; 0x03
															   TCPHeaderIN->SourcePort);

						TCPHeaderOUT->Flags = TCP_FLAG_ACK;
    17b8:	44 81       	ldd	r20, Z+4	; 0x04
    17ba:	55 81       	ldd	r21, Z+5	; 0x05
    17bc:	66 81       	ldd	r22, Z+6	; 0x06
    17be:	77 81       	ldd	r23, Z+7	; 0x07
						PacketResponse      = true;

						ConnectionInfo->SequenceNumberIn++;
    17c0:	4f 5f       	subi	r20, 0xFF	; 255
    17c2:	5f 4f       	sbci	r21, 0xFF	; 255
    17c4:	6f 4f       	sbci	r22, 0xFF	; 255
    17c6:	7f 4f       	sbci	r23, 0xFF	; 255
    17c8:	44 83       	std	Z+4, r20	; 0x04
    17ca:	55 83       	std	Z+5, r21	; 0x05
    17cc:	66 83       	std	Z+6, r22	; 0x06
    17ce:	77 83       	std	Z+7, r23	; 0x07
    17d0:	ea 81       	ldd	r30, Y+2	; 0x02
    17d2:	fb 81       	ldd	r31, Y+3	; 0x03
    17d4:	40 81       	ld	r20, Z
    17d6:	51 81       	ldd	r21, Z+1	; 0x01
						ConnectionInfo->SequenceNumberOut++;
    17d8:	2a e0       	ldi	r18, 0x0A	; 10
    17da:	b7 01       	movw	r22, r14
    17dc:	82 81       	ldd	r24, Z+2	; 0x02
    17de:	93 81       	ldd	r25, Z+3	; 0x03
    17e0:	46 dd       	rcall	.-1396   	; 0x126e <TCP_SetConnectionState>
    17e2:	0e c0       	rjmp	.+28     	; 0x1800 <TCP_ProcessTCPPacket+0x37a>
    17e4:	20 31       	cpi	r18, 0x10	; 16
    17e6:	09 f0       	breq	.+2      	; 0x17ea <TCP_ProcessTCPPacket+0x364>
    17e8:	6c c0       	rjmp	.+216    	; 0x18c2 <TCP_ProcessTCPPacket+0x43c>
    17ea:	2a e0       	ldi	r18, 0x0A	; 10
    17ec:	a4 01       	movw	r20, r8
    17ee:	b7 01       	movw	r22, r14

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    17f0:	c6 01       	movw	r24, r12
    17f2:	3d dd       	rcall	.-1414   	; 0x126e <TCP_SetConnectionState>
    17f4:	66 c0       	rjmp	.+204    	; 0x18c2 <TCP_ProcessTCPPacket+0x43c>
    17f6:	84 e1       	ldi	r24, 0x14	; 20
    17f8:	bc cf       	rjmp	.-136    	; 0x1772 <TCP_ProcessTCPPacket+0x2ec>
    17fa:	8f ef       	ldi	r24, 0xFF	; 255
    17fc:	9f ef       	ldi	r25, 0xFF	; 255
    17fe:	63 c0       	rjmp	.+198    	; 0x18c6 <TCP_ProcessTCPPacket+0x440>
    1800:	aa 81       	ldd	r26, Y+2	; 0x02
    1802:	bb 81       	ldd	r27, Y+3	; 0x03
    1804:	12 96       	adiw	r26, 0x02	; 2
											   TCPHeaderIN->SourcePort, TCP_Connection_Closed);
					}

					break;
				case TCP_Connection_CloseWait:
					if (TCPHeaderIN->Flags == TCP_FLAG_ACK)
    1806:	8d 90       	ld	r8, X+
    1808:	9c 90       	ld	r9, X
    180a:	13 97       	sbiw	r26, 0x03	; 3
					{
						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    180c:	4d 91       	ld	r20, X+
    180e:	5c 91       	ld	r21, X
    1810:	b7 01       	movw	r22, r14
    1812:	c4 01       	movw	r24, r8
    1814:	f4 dd       	rcall	.-1048   	; 0x13fe <TCP_GetConnectionInfo>
    1816:	6c 01       	movw	r12, r24
    1818:	f8 01       	movw	r30, r16
		}
	}
	else
	{
		/* Port is not open, indicate via a RST/ACK response to the sender */
		TCPHeaderOUT->Flags = (TCP_FLAG_RST | TCP_FLAG_ACK);
    181a:	91 82       	std	Z+1, r9	; 0x01
    181c:	80 82       	st	Z, r8
							}
						}
						else
						{
							/* Buffer is currently in use by the application, defer processing of the incoming packet */
							return NO_PROCESS;
    181e:	aa 81       	ldd	r26, Y+2	; 0x02
    1820:	bb 81       	ldd	r27, Y+3	; 0x03
    1822:	8d 91       	ld	r24, X+
	}

	/* Check if we need to respond to the sent packet */
	if (PacketResponse)
	{
		ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    1824:	9c 91       	ld	r25, X
    1826:	93 83       	std	Z+3, r25	; 0x03
    1828:	82 83       	std	Z+2, r24	; 0x02
    182a:	f6 01       	movw	r30, r12
    182c:	64 81       	ldd	r22, Z+4	; 0x04
    182e:	75 81       	ldd	r23, Z+5	; 0x05
    1830:	86 81       	ldd	r24, Z+6	; 0x06
    1832:	97 81       	ldd	r25, Z+7	; 0x07
    1834:	56 db       	rcall	.-2388   	; 0xee2 <SwapEndian_32>
    1836:	d8 01       	movw	r26, r16
    1838:	14 96       	adiw	r26, 0x04	; 4
    183a:	6d 93       	st	X+, r22
    183c:	7d 93       	st	X+, r23
		                                       TCPHeaderIN->SourcePort);

		TCPHeaderOUT->SourcePort           = TCPHeaderIN->DestinationPort;
    183e:	8d 93       	st	X+, r24
    1840:	9c 93       	st	X, r25
    1842:	17 97       	sbiw	r26, 0x07	; 7
		TCPHeaderOUT->DestinationPort      = TCPHeaderIN->SourcePort;
    1844:	f6 01       	movw	r30, r12
    1846:	60 81       	ld	r22, Z
    1848:	71 81       	ldd	r23, Z+1	; 0x01
    184a:	82 81       	ldd	r24, Z+2	; 0x02
    184c:	93 81       	ldd	r25, Z+3	; 0x03
    184e:	49 db       	rcall	.-2414   	; 0xee2 <SwapEndian_32>
		TCPHeaderOUT->SequenceNumber       = SwapEndian_32(ConnectionInfo->SequenceNumberOut);
    1850:	d8 01       	movw	r26, r16
    1852:	18 96       	adiw	r26, 0x08	; 8
    1854:	6d 93       	st	X+, r22
    1856:	7d 93       	st	X+, r23
    1858:	8d 93       	st	X+, r24
    185a:	9c 93       	st	X, r25
    185c:	1b 97       	sbiw	r26, 0x0b	; 11
    185e:	1c 96       	adiw	r26, 0x0c	; 12
    1860:	8c 91       	ld	r24, X
    1862:	1c 97       	sbiw	r26, 0x0c	; 12
    1864:	8f 70       	andi	r24, 0x0F	; 15
    1866:	80 65       	ori	r24, 0x50	; 80
    1868:	1c 96       	adiw	r26, 0x0c	; 12
    186a:	8c 93       	st	X, r24
		TCPHeaderOUT->AcknowledgmentNumber = SwapEndian_32(ConnectionInfo->SequenceNumberIn);
    186c:	f6 01       	movw	r30, r12
    186e:	e4 5f       	subi	r30, 0xF4	; 244
    1870:	fd 4f       	sbci	r31, 0xFD	; 253
    1872:	80 81       	ld	r24, Z
    1874:	81 11       	cpse	r24, r1
    1876:	03 c0       	rjmp	.+6      	; 0x187e <TCP_ProcessTCPPacket+0x3f8>
    1878:	82 e0       	ldi	r24, 0x02	; 2
    187a:	90 e0       	ldi	r25, 0x00	; 0
    187c:	0a c0       	rjmp	.+20     	; 0x1892 <TCP_ProcessTCPPacket+0x40c>
    187e:	d6 01       	movw	r26, r12
    1880:	18 96       	adiw	r26, 0x08	; 8
    1882:	2d 91       	ld	r18, X+
    1884:	3c 91       	ld	r19, X
    1886:	19 97       	sbiw	r26, 0x09	; 9
		TCPHeaderOUT->DataOffset           = (sizeof(TCP_Header_t) / sizeof(uint32_t));
    1888:	80 e0       	ldi	r24, 0x00	; 0
    188a:	92 e0       	ldi	r25, 0x02	; 2
    188c:	82 1b       	sub	r24, r18
    188e:	93 0b       	sbc	r25, r19
    1890:	2e db       	rcall	.-2468   	; 0xeee <SwapEndian_16.part.1>
    1892:	f8 01       	movw	r30, r16
    1894:	97 87       	std	Z+15, r25	; 0x0f

		if (!(ConnectionInfo->Buffer.InUse))
    1896:	86 87       	std	Z+14, r24	; 0x0e
    1898:	13 8a       	std	Z+19, r1	; 0x13
    189a:	12 8a       	std	Z+18, r1	; 0x12
    189c:	11 8a       	std	Z+17, r1	; 0x11
    189e:	10 8a       	std	Z+16, r1	; 0x10
    18a0:	84 85       	ldd	r24, Z+12	; 0x0c
		  TCPHeaderOUT->WindowSize         = SwapEndian_16(TCP_WINDOW_SIZE);
    18a2:	80 7f       	andi	r24, 0xF0	; 240
    18a4:	84 87       	std	Z+12, r24	; 0x0c
    18a6:	b5 01       	movw	r22, r10
		else
		  TCPHeaderOUT->WindowSize         = SwapEndian_16(TCP_WINDOW_SIZE - ConnectionInfo->Buffer.Length);
    18a8:	60 5f       	subi	r22, 0xF0	; 240
    18aa:	7f 4f       	sbci	r23, 0xFF	; 255
    18ac:	24 e1       	ldi	r18, 0x14	; 20
    18ae:	30 e0       	ldi	r19, 0x00	; 0
    18b0:	a7 01       	movw	r20, r14
    18b2:	c8 01       	movw	r24, r16
    18b4:	20 db       	rcall	.-2496   	; 0xef6 <TCP_Checksum16>
    18b6:	f8 01       	movw	r30, r16
    18b8:	91 8b       	std	Z+17, r25	; 0x11
    18ba:	80 8b       	std	Z+16, r24	; 0x10
    18bc:	84 e1       	ldi	r24, 0x14	; 20
    18be:	90 e0       	ldi	r25, 0x00	; 0
    18c0:	02 c0       	rjmp	.+4      	; 0x18c6 <TCP_ProcessTCPPacket+0x440>
    18c2:	80 e0       	ldi	r24, 0x00	; 0

		TCPHeaderOUT->UrgentPointer        = 0;
    18c4:	90 e0       	ldi	r25, 0x00	; 0
    18c6:	0f 90       	pop	r0
		TCPHeaderOUT->Checksum             = 0;
    18c8:	0f 90       	pop	r0
    18ca:	0f 90       	pop	r0
		TCPHeaderOUT->Reserved             = 0;
    18cc:	df 91       	pop	r29
    18ce:	cf 91       	pop	r28
    18d0:	1f 91       	pop	r17

		TCPHeaderOUT->Checksum             = TCP_Checksum16(TCPHeaderOUT, &IPHeaderIN->DestinationAddress,
    18d2:	0f 91       	pop	r16
    18d4:	ff 90       	pop	r15
    18d6:	ef 90       	pop	r14
    18d8:	df 90       	pop	r13
    18da:	cf 90       	pop	r12
    18dc:	bf 90       	pop	r11
    18de:	af 90       	pop	r10
    18e0:	9f 90       	pop	r9
    18e2:	8f 90       	pop	r8
    18e4:	7f 90       	pop	r7
    18e6:	6f 90       	pop	r6
    18e8:	5f 90       	pop	r5
		                                                    &IPHeaderIN->SourceAddress, sizeof(TCP_Header_t));

		return sizeof(TCP_Header_t);
    18ea:	4f 90       	pop	r4
    18ec:	3f 90       	pop	r3
    18ee:	2f 90       	pop	r2
	}

	return NO_RESPONSE;
    18f0:	08 95       	ret

000018f2 <UDP_ProcessUDPPacket>:
 *  \return The number of bytes written to the out Ethernet frame if any, NO_RESPONSE otherwise
 */
int16_t UDP_ProcessUDPPacket(void* IPHeaderInStart,
                             void* UDPHeaderInStart,
                             void* UDPHeaderOutStart)
{
    18f2:	ef 92       	push	r14
    18f4:	ff 92       	push	r15
    18f6:	0f 93       	push	r16
    18f8:	1f 93       	push	r17
    18fa:	cf 93       	push	r28
    18fc:	df 93       	push	r29
    18fe:	7c 01       	movw	r14, r24
    1900:	8b 01       	movw	r16, r22
    1902:	ea 01       	movw	r28, r20
	UDP_Header_t* UDPHeaderIN  = (UDP_Header_t*)UDPHeaderInStart;
	UDP_Header_t* UDPHeaderOUT = (UDP_Header_t*)UDPHeaderOutStart;

	int16_t RetSize = NO_RESPONSE;

	DecodeUDPHeader(UDPHeaderInStart);
    1904:	cb 01       	movw	r24, r22
    1906:	17 d8       	rcall	.-4050   	; 0x936 <DecodeUDPHeader>
    1908:	f8 01       	movw	r30, r16

				Temp = Data.Bytes[0];
				Data.Bytes[0] = Data.Bytes[1];
				Data.Bytes[1] = Temp;

				return Data.Word;
    190a:	23 81       	ldd	r18, Z+3	; 0x03
    190c:	32 81       	ldd	r19, Z+2	; 0x02
    190e:	23 34       	cpi	r18, 0x43	; 67

	switch (SwapEndian_16(UDPHeaderIN->DestinationPort))
    1910:	31 05       	cpc	r19, r1
    1912:	e9 f4       	brne	.+58     	; 0x194e <UDP_ProcessUDPPacket+0x5c>
    1914:	ae 01       	movw	r20, r28
	{
		case UDP_PORT_DHCP_REQUEST:
			RetSize = DHCP_ProcessDHCPPacket(IPHeaderInStart,
    1916:	48 5f       	subi	r20, 0xF8	; 248
    1918:	5f 4f       	sbci	r21, 0xFF	; 255
    191a:	b8 01       	movw	r22, r16
    191c:	68 5f       	subi	r22, 0xF8	; 248
    191e:	7f 4f       	sbci	r23, 0xFF	; 255
    1920:	c7 01       	movw	r24, r14
    1922:	1e d0       	rcall	.+60     	; 0x1960 <DHCP_ProcessDHCPPacket>
    1924:	18 16       	cp	r1, r24
    1926:	19 06       	cpc	r1, r25
		                                     &((uint8_t*)UDPHeaderOutStart)[sizeof(UDP_Header_t)]);
			break;
	}

	/* Check to see if the protocol processing routine has filled out a response */
	if (RetSize > 0)
    1928:	94 f4       	brge	.+36     	; 0x194e <UDP_ProcessUDPPacket+0x5c>
    192a:	f8 01       	movw	r30, r16
    192c:	22 81       	ldd	r18, Z+2	; 0x02
	{
		/* Fill out the response UDP packet header */
		UDPHeaderOUT->SourcePort      = UDPHeaderIN->DestinationPort;
    192e:	33 81       	ldd	r19, Z+3	; 0x03
    1930:	39 83       	std	Y+1, r19	; 0x01
    1932:	28 83       	st	Y, r18
    1934:	20 81       	ld	r18, Z
    1936:	31 81       	ldd	r19, Z+1	; 0x01
		UDPHeaderOUT->DestinationPort = UDPHeaderIN->SourcePort;
    1938:	3b 83       	std	Y+3, r19	; 0x03
    193a:	2a 83       	std	Y+2, r18	; 0x02
    193c:	1f 82       	std	Y+7, r1	; 0x07
    193e:	1e 82       	std	Y+6, r1	; 0x06
		UDPHeaderOUT->Checksum        = 0;
    1940:	9c 01       	movw	r18, r24
    1942:	28 5f       	subi	r18, 0xF8	; 248
		UDPHeaderOUT->Length          = SwapEndian_16(sizeof(UDP_Header_t) + RetSize);
    1944:	3f 4f       	sbci	r19, 0xFF	; 255
    1946:	3c 83       	std	Y+4, r19	; 0x04
    1948:	2d 83       	std	Y+5, r18	; 0x05
    194a:	c9 01       	movw	r24, r18
    194c:	02 c0       	rjmp	.+4      	; 0x1952 <UDP_ProcessUDPPacket+0x60>

		/* Return the size of the response so far */
		return (sizeof(UDP_Header_t) + RetSize);
    194e:	80 e0       	ldi	r24, 0x00	; 0
    1950:	90 e0       	ldi	r25, 0x00	; 0
	}

	return NO_RESPONSE;
    1952:	df 91       	pop	r29
    1954:	cf 91       	pop	r28
}
    1956:	1f 91       	pop	r17
    1958:	0f 91       	pop	r16
    195a:	ff 90       	pop	r15
    195c:	ef 90       	pop	r14
    195e:	08 95       	ret

00001960 <DHCP_ProcessDHCPPacket>:
 *  \return The number of bytes written to the out Ethernet frame if any, NO_RESPONSE otherwise
 */
int16_t DHCP_ProcessDHCPPacket(void* IPHeaderInStart,
                               void* DHCPHeaderInStart,
                               void* DHCPHeaderOutStart)
{
    1960:	8f 92       	push	r8
    1962:	9f 92       	push	r9
    1964:	af 92       	push	r10
    1966:	bf 92       	push	r11
    1968:	cf 92       	push	r12
    196a:	df 92       	push	r13
    196c:	ef 92       	push	r14
    196e:	ff 92       	push	r15
    1970:	0f 93       	push	r16
    1972:	1f 93       	push	r17
    1974:	cf 93       	push	r28
    1976:	df 93       	push	r29
    1978:	5c 01       	movw	r10, r24
    197a:	4b 01       	movw	r8, r22
    197c:	ea 01       	movw	r28, r20
	IP_Header_t*   IPHeaderIN    = (IP_Header_t*)IPHeaderInStart;
	DHCP_Header_t* DHCPHeaderIN  = (DHCP_Header_t*)DHCPHeaderInStart;
	DHCP_Header_t* DHCPHeaderOUT = (DHCP_Header_t*)DHCPHeaderOutStart;

	uint8_t* DHCPOptionsINStart  = (uint8_t*)(DHCPHeaderInStart  + sizeof(DHCP_Header_t));
    197e:	8b 01       	movw	r16, r22
    1980:	00 51       	subi	r16, 0x10	; 16
    1982:	1f 4f       	sbci	r17, 0xFF	; 255
	uint8_t* DHCPOptionsOUTStart = (uint8_t*)(DHCPHeaderOutStart + sizeof(DHCP_Header_t));

	DecodeDHCPHeader(DHCPHeaderInStart);
    1984:	cb 01       	movw	r24, r22
    1986:	0e 94 9c 04 	call	0x938	; 0x938 <DecodeDHCPHeader>

	/* Zero out the response DHCP packet, as much of it is legacy and left at 0 */
	memset(DHCPHeaderOUT, 0, sizeof(DHCP_Header_t));
    198a:	80 ef       	ldi	r24, 0xF0	; 240
    198c:	fe 01       	movw	r30, r28
    198e:	11 92       	st	Z+, r1
    1990:	8a 95       	dec	r24
    1992:	e9 f7       	brne	.-6      	; 0x198e <DHCP_ProcessDHCPPacket+0x2e>

	/* Fill out the response DHCP packet */
	DHCPHeaderOUT->HardwareType          = DHCPHeaderIN->HardwareType;
    1994:	f4 01       	movw	r30, r8
    1996:	81 81       	ldd	r24, Z+1	; 0x01
    1998:	89 83       	std	Y+1, r24	; 0x01
	DHCPHeaderOUT->Operation             = DHCP_OP_BOOTREPLY;
    199a:	82 e0       	ldi	r24, 0x02	; 2
    199c:	88 83       	st	Y, r24
	DHCPHeaderOUT->HardwareAddressLength = DHCPHeaderIN->HardwareAddressLength;
    199e:	82 81       	ldd	r24, Z+2	; 0x02
    19a0:	8a 83       	std	Y+2, r24	; 0x02
	DHCPHeaderOUT->Hops                  = 0;
    19a2:	1b 82       	std	Y+3, r1	; 0x03
	DHCPHeaderOUT->TransactionID         = DHCPHeaderIN->TransactionID;
    19a4:	84 81       	ldd	r24, Z+4	; 0x04
    19a6:	95 81       	ldd	r25, Z+5	; 0x05
    19a8:	a6 81       	ldd	r26, Z+6	; 0x06
    19aa:	b7 81       	ldd	r27, Z+7	; 0x07
    19ac:	8c 83       	std	Y+4, r24	; 0x04
    19ae:	9d 83       	std	Y+5, r25	; 0x05
    19b0:	ae 83       	std	Y+6, r26	; 0x06
    19b2:	bf 83       	std	Y+7, r27	; 0x07
	DHCPHeaderOUT->ElapsedSeconds        = 0;
    19b4:	19 86       	std	Y+9, r1	; 0x09
    19b6:	18 86       	std	Y+8, r1	; 0x08
	DHCPHeaderOUT->Flags                 = DHCPHeaderIN->Flags;
    19b8:	82 85       	ldd	r24, Z+10	; 0x0a
    19ba:	93 85       	ldd	r25, Z+11	; 0x0b
    19bc:	9b 87       	std	Y+11, r25	; 0x0b
    19be:	8a 87       	std	Y+10, r24	; 0x0a
	DHCPHeaderOUT->YourIP                = ClientIPAddress;
    19c0:	c0 90 0a 01 	lds	r12, 0x010A
    19c4:	d0 90 0b 01 	lds	r13, 0x010B
    19c8:	e0 90 0c 01 	lds	r14, 0x010C
    19cc:	f0 90 0d 01 	lds	r15, 0x010D
    19d0:	c8 8a       	std	Y+16, r12	; 0x10
    19d2:	d9 8a       	std	Y+17, r13	; 0x11
    19d4:	ea 8a       	std	Y+18, r14	; 0x12
    19d6:	fb 8a       	std	Y+19, r15	; 0x13
	memmove(&DHCPHeaderOUT->ClientHardwareAddress, &DHCPHeaderIN->ClientHardwareAddress, sizeof(MAC_Address_t));
    19d8:	b4 01       	movw	r22, r8
    19da:	64 5e       	subi	r22, 0xE4	; 228
    19dc:	7f 4f       	sbci	r23, 0xFF	; 255
    19de:	46 e0       	ldi	r20, 0x06	; 6
    19e0:	50 e0       	ldi	r21, 0x00	; 0
    19e2:	ce 01       	movw	r24, r28
    19e4:	4c 96       	adiw	r24, 0x1c	; 28
    19e6:	8b d7       	rcall	.+3862   	; 0x28fe <memmove>
    19e8:	fe 01       	movw	r30, r28
	DHCPHeaderOUT->Cookie                = SwapEndian_32(DHCP_MAGIC_COOKIE);
    19ea:	e4 51       	subi	r30, 0x14	; 20
    19ec:	ff 4f       	sbci	r31, 0xFF	; 255
    19ee:	83 e6       	ldi	r24, 0x63	; 99
    19f0:	92 e8       	ldi	r25, 0x82	; 130
    19f2:	a3 e5       	ldi	r26, 0x53	; 83
    19f4:	b3 e6       	ldi	r27, 0x63	; 99
    19f6:	80 83       	st	Z, r24
    19f8:	91 83       	std	Z+1, r25	; 0x01
    19fa:	a2 83       	std	Z+2, r26	; 0x02
    19fc:	b3 83       	std	Z+3, r27	; 0x03
    19fe:	f5 01       	movw	r30, r10

	/* Alter the incoming IP packet header so that the corrected IP source and destinations are used - this means that
	   when the response IP header is generated, it will use the corrected addresses and not the null/broatcast addresses */
	IPHeaderIN->SourceAddress      = ClientIPAddress;
    1a00:	c4 86       	std	Z+12, r12	; 0x0c
    1a02:	d5 86       	std	Z+13, r13	; 0x0d
    1a04:	e6 86       	std	Z+14, r14	; 0x0e
    1a06:	f7 86       	std	Z+15, r15	; 0x0f
    1a08:	80 91 18 01 	lds	r24, 0x0118
	IPHeaderIN->DestinationAddress = ServerIPAddress;
    1a0c:	90 91 19 01 	lds	r25, 0x0119
    1a10:	a0 91 1a 01 	lds	r26, 0x011A
    1a14:	b0 91 1b 01 	lds	r27, 0x011B
    1a18:	80 8b       	std	Z+16, r24	; 0x10
    1a1a:	91 8b       	std	Z+17, r25	; 0x11
    1a1c:	a2 8b       	std	Z+18, r26	; 0x12
    1a1e:	b3 8b       	std	Z+19, r27	; 0x13
    1a20:	f8 01       	movw	r30, r16

	/* Process the incoming DHCP packet options */
	while (DHCPOptionsINStart[0] != DHCP_OPTION_END)
    1a22:	80 81       	ld	r24, Z
    1a24:	8f 3f       	cpi	r24, 0xFF	; 255
    1a26:	09 f4       	brne	.+2      	; 0x1a2a <DHCP_ProcessDHCPPacket+0xca>
    1a28:	61 c0       	rjmp	.+194    	; 0x1aec <DHCP_ProcessDHCPPacket+0x18c>
    1a2a:	85 33       	cpi	r24, 0x35	; 53
	{
		/* Find the Message Type DHCP option, to determine the type of DHCP packet */
		if (DHCPOptionsINStart[0] == DHCP_OPTION_MESSAGETYPE)
    1a2c:	09 f0       	breq	.+2      	; 0x1a30 <DHCP_ProcessDHCPPacket+0xd0>
    1a2e:	52 c0       	rjmp	.+164    	; 0x1ad4 <DHCP_ProcessDHCPPacket+0x174>
    1a30:	f8 01       	movw	r30, r16
		{
			if ((DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_DISCOVER) || (DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_REQUEST))
    1a32:	92 81       	ldd	r25, Z+2	; 0x02
    1a34:	9d 7f       	andi	r25, 0xFD	; 253
    1a36:	91 30       	cpi	r25, 0x01	; 1
    1a38:	09 f0       	breq	.+2      	; 0x1a3c <DHCP_ProcessDHCPPacket+0xdc>
    1a3a:	4e c0       	rjmp	.+156    	; 0x1ad8 <DHCP_ProcessDHCPPacket+0x178>
    1a3c:	fe 01       	movw	r30, r28
			{
				/* Fill out the response DHCP packet options for a DHCP OFFER or ACK response */

				*(DHCPOptionsOUTStart++) = DHCP_OPTION_MESSAGETYPE;
    1a3e:	e0 51       	subi	r30, 0x10	; 16
    1a40:	ff 4f       	sbci	r31, 0xFF	; 255
    1a42:	80 83       	st	Z, r24
    1a44:	fe 01       	movw	r30, r28
				*(DHCPOptionsOUTStart++) = 1;
    1a46:	ef 50       	subi	r30, 0x0F	; 15
    1a48:	ff 4f       	sbci	r31, 0xFF	; 255
    1a4a:	90 83       	st	Z, r25
    1a4c:	f8 01       	movw	r30, r16
				*(DHCPOptionsOUTStart++) = (DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_DISCOVER) ? DHCP_MESSAGETYPE_OFFER
    1a4e:	82 81       	ldd	r24, Z+2	; 0x02
    1a50:	81 30       	cpi	r24, 0x01	; 1
    1a52:	11 f4       	brne	.+4      	; 0x1a58 <DHCP_ProcessDHCPPacket+0xf8>
    1a54:	82 e0       	ldi	r24, 0x02	; 2
    1a56:	01 c0       	rjmp	.+2      	; 0x1a5a <DHCP_ProcessDHCPPacket+0xfa>
    1a58:	85 e0       	ldi	r24, 0x05	; 5
    1a5a:	fe 01       	movw	r30, r28
    1a5c:	ee 50       	subi	r30, 0x0E	; 14
    1a5e:	ff 4f       	sbci	r31, 0xFF	; 255
    1a60:	80 83       	st	Z, r24
    1a62:	fe 01       	movw	r30, r28
																								: DHCP_MESSAGETYPE_ACK;

				*(DHCPOptionsOUTStart++) = DHCP_OPTION_SUBNETMASK;
    1a64:	ed 50       	subi	r30, 0x0D	; 13
    1a66:	ff 4f       	sbci	r31, 0xFF	; 255
    1a68:	81 e0       	ldi	r24, 0x01	; 1
    1a6a:	80 83       	st	Z, r24
    1a6c:	fe 01       	movw	r30, r28
				*(DHCPOptionsOUTStart++) = 4;
    1a6e:	ec 50       	subi	r30, 0x0C	; 12
    1a70:	ff 4f       	sbci	r31, 0xFF	; 255
    1a72:	84 e0       	ldi	r24, 0x04	; 4
    1a74:	80 83       	st	Z, r24
    1a76:	fe 01       	movw	r30, r28
				*(DHCPOptionsOUTStart++) = 0xFF;
    1a78:	eb 50       	subi	r30, 0x0B	; 11
    1a7a:	ff 4f       	sbci	r31, 0xFF	; 255
    1a7c:	2f ef       	ldi	r18, 0xFF	; 255
    1a7e:	20 83       	st	Z, r18
    1a80:	fe 01       	movw	r30, r28
				*(DHCPOptionsOUTStart++) = 0xFF;
    1a82:	ea 50       	subi	r30, 0x0A	; 10
    1a84:	ff 4f       	sbci	r31, 0xFF	; 255
    1a86:	20 83       	st	Z, r18
    1a88:	fe 01       	movw	r30, r28
				*(DHCPOptionsOUTStart++) = 0xFF;
    1a8a:	e9 50       	subi	r30, 0x09	; 9
    1a8c:	ff 4f       	sbci	r31, 0xFF	; 255
    1a8e:	20 83       	st	Z, r18
    1a90:	fe 01       	movw	r30, r28
				*(DHCPOptionsOUTStart++) = 0x00;
    1a92:	e8 50       	subi	r30, 0x08	; 8
    1a94:	ff 4f       	sbci	r31, 0xFF	; 255
    1a96:	10 82       	st	Z, r1
    1a98:	fe 01       	movw	r30, r28

				*(DHCPOptionsOUTStart++) = DHCP_OPTION_DHCPSERVER;
    1a9a:	e7 50       	subi	r30, 0x07	; 7
    1a9c:	ff 4f       	sbci	r31, 0xFF	; 255
    1a9e:	96 e3       	ldi	r25, 0x36	; 54
    1aa0:	90 83       	st	Z, r25
    1aa2:	fe 01       	movw	r30, r28
				*(DHCPOptionsOUTStart++) = sizeof(IP_Address_t);
    1aa4:	e6 50       	subi	r30, 0x06	; 6
    1aa6:	ff 4f       	sbci	r31, 0xFF	; 255
    1aa8:	80 83       	st	Z, r24
    1aaa:	fe 01       	movw	r30, r28
				memcpy(DHCPOptionsOUTStart, &ServerIPAddress, sizeof(IP_Address_t));
    1aac:	e5 50       	subi	r30, 0x05	; 5
    1aae:	ff 4f       	sbci	r31, 0xFF	; 255
    1ab0:	80 91 18 01 	lds	r24, 0x0118
    1ab4:	90 91 19 01 	lds	r25, 0x0119
    1ab8:	a0 91 1a 01 	lds	r26, 0x011A
    1abc:	b0 91 1b 01 	lds	r27, 0x011B
    1ac0:	80 83       	st	Z, r24
    1ac2:	91 83       	std	Z+1, r25	; 0x01
    1ac4:	a2 83       	std	Z+2, r26	; 0x02
    1ac6:	b3 83       	std	Z+3, r27	; 0x03
    1ac8:	c1 50       	subi	r28, 0x01	; 1
				DHCPOptionsOUTStart     += sizeof(IP_Address_t);

				*(DHCPOptionsOUTStart++) = DHCP_OPTION_END;
    1aca:	df 4f       	sbci	r29, 0xFF	; 255
    1acc:	28 83       	st	Y, r18
    1ace:	80 e0       	ldi	r24, 0x00	; 0

				return (sizeof(DHCP_Header_t) + 12 + sizeof(IP_Address_t));
    1ad0:	91 e0       	ldi	r25, 0x01	; 1
    1ad2:	0e c0       	rjmp	.+28     	; 0x1af0 <DHCP_ProcessDHCPPacket+0x190>
    1ad4:	88 23       	and	r24, r24
			}
		}

		/* Go to the next DHCP option - skip one byte if option is a padding byte, else skip the complete option's size */
		DHCPOptionsINStart += ((DHCPOptionsINStart[0] == DHCP_OPTION_PAD) ? 1 : (DHCPOptionsINStart[1] + 2));
    1ad6:	29 f0       	breq	.+10     	; 0x1ae2 <DHCP_ProcessDHCPPacket+0x182>
    1ad8:	f8 01       	movw	r30, r16
    1ada:	81 81       	ldd	r24, Z+1	; 0x01
    1adc:	90 e0       	ldi	r25, 0x00	; 0
    1ade:	02 96       	adiw	r24, 0x02	; 2
    1ae0:	02 c0       	rjmp	.+4      	; 0x1ae6 <DHCP_ProcessDHCPPacket+0x186>
    1ae2:	81 e0       	ldi	r24, 0x01	; 1
    1ae4:	90 e0       	ldi	r25, 0x00	; 0
    1ae6:	08 0f       	add	r16, r24
    1ae8:	19 1f       	adc	r17, r25
    1aea:	9a cf       	rjmp	.-204    	; 0x1a20 <DHCP_ProcessDHCPPacket+0xc0>
    1aec:	80 e0       	ldi	r24, 0x00	; 0
	}

	return NO_RESPONSE;
    1aee:	90 e0       	ldi	r25, 0x00	; 0
    1af0:	df 91       	pop	r29
}
    1af2:	cf 91       	pop	r28
    1af4:	1f 91       	pop	r17
    1af6:	0f 91       	pop	r16
    1af8:	ff 90       	pop	r15
    1afa:	ef 90       	pop	r14
    1afc:	df 90       	pop	r13
    1afe:	cf 90       	pop	r12
    1b00:	bf 90       	pop	r11
    1b02:	af 90       	pop	r10
    1b04:	9f 90       	pop	r9
    1b06:	8f 90       	pop	r8
    1b08:	08 95       	ret

00001b0a <ARP_ProcessARPPacket>:
 *
 *  \return The number of bytes written to the out Ethernet frame if any, NO_RESPONSE otherwise
 */
int16_t ARP_ProcessARPPacket(void* InDataStart,
                             void* OutDataStart)
{
    1b0a:	0f 93       	push	r16
    1b0c:	1f 93       	push	r17
    1b0e:	cf 93       	push	r28
    1b10:	df 93       	push	r29
    1b12:	8c 01       	movw	r16, r24
    1b14:	eb 01       	movw	r28, r22
	DecodeARPHeader(InDataStart);
    1b16:	0e 94 97 04 	call	0x92e	; 0x92e <DecodeARPHeader>

				Temp = Data.Bytes[0];
				Data.Bytes[0] = Data.Bytes[1];
				Data.Bytes[1] = Temp;

				return Data.Word;
    1b1a:	f8 01       	movw	r30, r16
    1b1c:	83 81       	ldd	r24, Z+3	; 0x03
    1b1e:	92 81       	ldd	r25, Z+2	; 0x02

	ARP_Header_t* ARPHeaderIN  = (ARP_Header_t*)InDataStart;
	ARP_Header_t* ARPHeaderOUT = (ARP_Header_t*)OutDataStart;

	/* Ensure that the ARP request is a IPv4 request packet */
	if ((SwapEndian_16(ARPHeaderIN->ProtocolType) == ETHERTYPE_IPV4) &&
    1b20:	81 15       	cp	r24, r1
    1b22:	98 40       	sbci	r25, 0x08	; 8
    1b24:	19 f0       	breq	.+6      	; 0x1b2c <ARP_ProcessARPPacket+0x22>
			/* Return the size of the response so far */
			return sizeof(ARP_Header_t);
		}
	}

	return NO_RESPONSE;
    1b26:	80 e0       	ldi	r24, 0x00	; 0
    1b28:	90 e0       	ldi	r25, 0x00	; 0
    1b2a:	50 c0       	rjmp	.+160    	; 0x1bcc <ARP_ProcessARPPacket+0xc2>
    1b2c:	f8 01       	movw	r30, r16
    1b2e:	87 81       	ldd	r24, Z+7	; 0x07
    1b30:	96 81       	ldd	r25, Z+6	; 0x06

	ARP_Header_t* ARPHeaderIN  = (ARP_Header_t*)InDataStart;
	ARP_Header_t* ARPHeaderOUT = (ARP_Header_t*)OutDataStart;

	/* Ensure that the ARP request is a IPv4 request packet */
	if ((SwapEndian_16(ARPHeaderIN->ProtocolType) == ETHERTYPE_IPV4) &&
    1b32:	01 97       	sbiw	r24, 0x01	; 1
    1b34:	c1 f7       	brne	.-16     	; 0x1b26 <ARP_ProcessARPPacket+0x1c>
	    (SwapEndian_16(ARPHeaderIN->Operation) == ARP_OPERATION_REQUEST))
	{
		/* If the ARP packet is requesting the MAC or IP of the virtual webserver, return the response */
		if (IP_COMPARE(&ARPHeaderIN->TPA, &ServerIPAddress) ||
    1b36:	44 e0       	ldi	r20, 0x04	; 4
    1b38:	50 e0       	ldi	r21, 0x00	; 0
    1b3a:	68 e1       	ldi	r22, 0x18	; 24
    1b3c:	71 e0       	ldi	r23, 0x01	; 1
    1b3e:	c8 01       	movw	r24, r16
    1b40:	48 96       	adiw	r24, 0x18	; 24
    1b42:	c7 d6       	rcall	.+3470   	; 0x28d2 <memcmp>
    1b44:	89 2b       	or	r24, r25
    1b46:	49 f0       	breq	.+18     	; 0x1b5a <ARP_ProcessARPPacket+0x50>
    1b48:	46 e0       	ldi	r20, 0x06	; 6
		    MAC_COMPARE(&ARPHeaderIN->THA, &ServerMACAddress))
    1b4a:	50 e0       	ldi	r21, 0x00	; 0
    1b4c:	6c e1       	ldi	r22, 0x1C	; 28
    1b4e:	71 e0       	ldi	r23, 0x01	; 1
    1b50:	c8 01       	movw	r24, r16
    1b52:	42 96       	adiw	r24, 0x12	; 18
    1b54:	be d6       	rcall	.+3452   	; 0x28d2 <memcmp>
    1b56:	89 2b       	or	r24, r25
    1b58:	31 f7       	brne	.-52     	; 0x1b26 <ARP_ProcessARPPacket+0x1c>
	/* Ensure that the ARP request is a IPv4 request packet */
	if ((SwapEndian_16(ARPHeaderIN->ProtocolType) == ETHERTYPE_IPV4) &&
	    (SwapEndian_16(ARPHeaderIN->Operation) == ARP_OPERATION_REQUEST))
	{
		/* If the ARP packet is requesting the MAC or IP of the virtual webserver, return the response */
		if (IP_COMPARE(&ARPHeaderIN->TPA, &ServerIPAddress) ||
    1b5a:	f8 01       	movw	r30, r16
    1b5c:	80 81       	ld	r24, Z
		    MAC_COMPARE(&ARPHeaderIN->THA, &ServerMACAddress))
		{
			/* Fill out the ARP response header */
			ARPHeaderOUT->HardwareType = ARPHeaderIN->HardwareType;
    1b5e:	91 81       	ldd	r25, Z+1	; 0x01
    1b60:	99 83       	std	Y+1, r25	; 0x01
    1b62:	88 83       	st	Y, r24
    1b64:	82 81       	ldd	r24, Z+2	; 0x02
    1b66:	93 81       	ldd	r25, Z+3	; 0x03
			ARPHeaderOUT->ProtocolType = ARPHeaderIN->ProtocolType;
    1b68:	9b 83       	std	Y+3, r25	; 0x03
    1b6a:	8a 83       	std	Y+2, r24	; 0x02
    1b6c:	84 81       	ldd	r24, Z+4	; 0x04
    1b6e:	8c 83       	std	Y+4, r24	; 0x04
			ARPHeaderOUT->HLEN         = ARPHeaderIN->HLEN;
    1b70:	85 81       	ldd	r24, Z+5	; 0x05
    1b72:	8d 83       	std	Y+5, r24	; 0x05
			ARPHeaderOUT->PLEN         = ARPHeaderIN->PLEN;
    1b74:	80 e0       	ldi	r24, 0x00	; 0
    1b76:	92 e0       	ldi	r25, 0x02	; 2
			ARPHeaderOUT->Operation    = SwapEndian_16(ARP_OPERATION_REPLY);
    1b78:	9f 83       	std	Y+7, r25	; 0x07
    1b7a:	8e 83       	std	Y+6, r24	; 0x06
    1b7c:	86 e0       	ldi	r24, 0x06	; 6
    1b7e:	38 96       	adiw	r30, 0x08	; 8

			/* Copy over the sender MAC/IP to the target fields for the response */
			ARPHeaderOUT->THA = ARPHeaderIN->SHA;
    1b80:	de 01       	movw	r26, r28
    1b82:	52 96       	adiw	r26, 0x12	; 18
    1b84:	01 90       	ld	r0, Z+
    1b86:	0d 92       	st	X+, r0
    1b88:	8a 95       	dec	r24
    1b8a:	e1 f7       	brne	.-8      	; 0x1b84 <ARP_ProcessARPPacket+0x7a>
    1b8c:	f8 01       	movw	r30, r16
    1b8e:	86 85       	ldd	r24, Z+14	; 0x0e
			ARPHeaderOUT->TPA = ARPHeaderIN->SPA;
    1b90:	97 85       	ldd	r25, Z+15	; 0x0f
    1b92:	a0 89       	ldd	r26, Z+16	; 0x10
    1b94:	b1 89       	ldd	r27, Z+17	; 0x11
    1b96:	88 8f       	std	Y+24, r24	; 0x18
    1b98:	99 8f       	std	Y+25, r25	; 0x19
    1b9a:	aa 8f       	std	Y+26, r26	; 0x1a
    1b9c:	bb 8f       	std	Y+27, r27	; 0x1b
    1b9e:	86 e0       	ldi	r24, 0x06	; 6
    1ba0:	ec e1       	ldi	r30, 0x1C	; 28

			/* Copy over the new sender MAC/IP - MAC and IP addresses of the virtual webserver */
			ARPHeaderOUT->SHA = ServerMACAddress;
    1ba2:	f1 e0       	ldi	r31, 0x01	; 1
    1ba4:	de 01       	movw	r26, r28
    1ba6:	18 96       	adiw	r26, 0x08	; 8
    1ba8:	01 90       	ld	r0, Z+
    1baa:	0d 92       	st	X+, r0
    1bac:	8a 95       	dec	r24
    1bae:	e1 f7       	brne	.-8      	; 0x1ba8 <ARP_ProcessARPPacket+0x9e>
    1bb0:	80 91 18 01 	lds	r24, 0x0118
			ARPHeaderOUT->SPA = ServerIPAddress;
    1bb4:	90 91 19 01 	lds	r25, 0x0119
    1bb8:	a0 91 1a 01 	lds	r26, 0x011A
    1bbc:	b0 91 1b 01 	lds	r27, 0x011B
    1bc0:	8e 87       	std	Y+14, r24	; 0x0e
    1bc2:	9f 87       	std	Y+15, r25	; 0x0f
    1bc4:	a8 8b       	std	Y+16, r26	; 0x10
    1bc6:	b9 8b       	std	Y+17, r27	; 0x11
    1bc8:	8c e1       	ldi	r24, 0x1C	; 28
    1bca:	90 e0       	ldi	r25, 0x00	; 0

			/* Return the size of the response so far */
			return sizeof(ARP_Header_t);
    1bcc:	df 91       	pop	r29
    1bce:	cf 91       	pop	r28
		}
	}

	return NO_RESPONSE;
}
    1bd0:	1f 91       	pop	r17
    1bd2:	0f 91       	pop	r16
    1bd4:	08 95       	ret

00001bd6 <IP_ProcessIPPacket>:
 *           response was generated, NO_PROCESS if the packet processing was deferred until the
 *           next Ethernet packet handler iteration
 */
int16_t IP_ProcessIPPacket(void* InDataStart,
                           void* OutDataStart)
{
    1bd6:	cf 92       	push	r12
    1bd8:	df 92       	push	r13
    1bda:	ef 92       	push	r14
    1bdc:	ff 92       	push	r15
    1bde:	0f 93       	push	r16
    1be0:	1f 93       	push	r17
    1be2:	cf 93       	push	r28
    1be4:	df 93       	push	r29
    1be6:	7c 01       	movw	r14, r24
    1be8:	eb 01       	movw	r28, r22
	DecodeIPHeader(InDataStart);
    1bea:	0e 94 98 04 	call	0x930	; 0x930 <DecodeIPHeader>

	IP_Header_t* IPHeaderIN  = (IP_Header_t*)InDataStart;
	IP_Header_t* IPHeaderOUT = (IP_Header_t*)OutDataStart;

	/* Header length is specified in number of longs in the packet header, convert to bytes */
	uint16_t HeaderLengthBytes = (IPHeaderIN->HeaderLength * sizeof(uint32_t));
    1bee:	f7 01       	movw	r30, r14
    1bf0:	00 81       	ld	r16, Z
    1bf2:	0f 70       	andi	r16, 0x0F	; 15
    1bf4:	f4 e0       	ldi	r31, 0x04	; 4
    1bf6:	0f 9f       	mul	r16, r31
    1bf8:	80 01       	movw	r16, r0
    1bfa:	11 24       	eor	r1, r1

	int16_t  RetSize = NO_RESPONSE;

	/* Check to ensure the IP packet is addressed to the virtual webserver's IP or the broadcast IP address */
	if (!(IP_COMPARE(&IPHeaderIN->DestinationAddress, &ServerIPAddress)) &&
    1bfc:	67 01       	movw	r12, r14
    1bfe:	80 e1       	ldi	r24, 0x10	; 16
    1c00:	c8 0e       	add	r12, r24
    1c02:	d1 1c       	adc	r13, r1
    1c04:	44 e0       	ldi	r20, 0x04	; 4
    1c06:	50 e0       	ldi	r21, 0x00	; 0
    1c08:	68 e1       	ldi	r22, 0x18	; 24
    1c0a:	71 e0       	ldi	r23, 0x01	; 1
    1c0c:	c6 01       	movw	r24, r12
    1c0e:	61 d6       	rcall	.+3266   	; 0x28d2 <memcmp>
    1c10:	89 2b       	or	r24, r25
    1c12:	49 f0       	breq	.+18     	; 0x1c26 <IP_ProcessIPPacket+0x50>
    1c14:	44 e0       	ldi	r20, 0x04	; 4
	    !(IP_COMPARE(&IPHeaderIN->DestinationAddress, &BroadcastIPAddress)))
    1c16:	50 e0       	ldi	r21, 0x00	; 0
    1c18:	6e e0       	ldi	r22, 0x0E	; 14
    1c1a:	71 e0       	ldi	r23, 0x01	; 1
    1c1c:	c6 01       	movw	r24, r12
    1c1e:	59 d6       	rcall	.+3250   	; 0x28d2 <memcmp>
    1c20:	89 2b       	or	r24, r25
    1c22:	09 f0       	breq	.+2      	; 0x1c26 <IP_ProcessIPPacket+0x50>
	uint16_t HeaderLengthBytes = (IPHeaderIN->HeaderLength * sizeof(uint32_t));

	int16_t  RetSize = NO_RESPONSE;

	/* Check to ensure the IP packet is addressed to the virtual webserver's IP or the broadcast IP address */
	if (!(IP_COMPARE(&IPHeaderIN->DestinationAddress, &ServerIPAddress)) &&
    1c24:	51 c0       	rjmp	.+162    	; 0x1cc8 <IP_ProcessIPPacket+0xf2>
    1c26:	f7 01       	movw	r30, r14
    1c28:	81 85       	ldd	r24, Z+9	; 0x09
	{
		return NO_RESPONSE;
	}

	/* Pass off the IP payload to the appropriate protocol processing routine */
	switch (IPHeaderIN->Protocol)
    1c2a:	86 30       	cpi	r24, 0x06	; 6
    1c2c:	69 f0       	breq	.+26     	; 0x1c48 <IP_ProcessIPPacket+0x72>
    1c2e:	81 31       	cpi	r24, 0x11	; 17
    1c30:	a1 f0       	breq	.+40     	; 0x1c5a <IP_ProcessIPPacket+0x84>
    1c32:	81 30       	cpi	r24, 0x01	; 1
    1c34:	09 f0       	breq	.+2      	; 0x1c38 <IP_ProcessIPPacket+0x62>
    1c36:	48 c0       	rjmp	.+144    	; 0x1cc8 <IP_ProcessIPPacket+0xf2>
    1c38:	be 01       	movw	r22, r28
    1c3a:	6c 5e       	subi	r22, 0xEC	; 236
	{
		case PROTOCOL_ICMP:
			RetSize = ICMP_ProcessICMPPacket(&((uint8_t*)InDataStart)[HeaderLengthBytes],
    1c3c:	7f 4f       	sbci	r23, 0xFF	; 255
    1c3e:	c7 01       	movw	r24, r14
    1c40:	80 0f       	add	r24, r16
    1c42:	91 1f       	adc	r25, r17
    1c44:	13 d9       	rcall	.-3546   	; 0xe6c <ICMP_ProcessICMPPacket>
    1c46:	11 c0       	rjmp	.+34     	; 0x1c6a <IP_ProcessIPPacket+0x94>
    1c48:	b7 01       	movw	r22, r14
    1c4a:	60 0f       	add	r22, r16
			                                 &((uint8_t*)OutDataStart)[sizeof(IP_Header_t)]);
			break;
    1c4c:	71 1f       	adc	r23, r17
		case PROTOCOL_TCP:
			RetSize = TCP_ProcessTCPPacket(InDataStart,
    1c4e:	ae 01       	movw	r20, r28
    1c50:	4c 5e       	subi	r20, 0xEC	; 236
    1c52:	5f 4f       	sbci	r21, 0xFF	; 255
    1c54:	c7 01       	movw	r24, r14
    1c56:	17 dc       	rcall	.-2002   	; 0x1486 <TCP_ProcessTCPPacket>
    1c58:	08 c0       	rjmp	.+16     	; 0x1c6a <IP_ProcessIPPacket+0x94>
    1c5a:	b7 01       	movw	r22, r14
    1c5c:	60 0f       	add	r22, r16
    1c5e:	71 1f       	adc	r23, r17
			                               &((uint8_t*)InDataStart)[HeaderLengthBytes],
			                               &((uint8_t*)OutDataStart)[sizeof(IP_Header_t)]);
			break;
    1c60:	ae 01       	movw	r20, r28
		case PROTOCOL_UDP:
			RetSize = UDP_ProcessUDPPacket(InDataStart,
    1c62:	4c 5e       	subi	r20, 0xEC	; 236
    1c64:	5f 4f       	sbci	r21, 0xFF	; 255
    1c66:	c7 01       	movw	r24, r14
    1c68:	44 de       	rcall	.-888    	; 0x18f2 <UDP_ProcessUDPPacket>
    1c6a:	18 16       	cp	r1, r24
    1c6c:	19 06       	cpc	r1, r25
    1c6e:	74 f5       	brge	.+92     	; 0x1ccc <IP_ProcessIPPacket+0xf6>
    1c70:	8c 01       	movw	r16, r24
    1c72:	0c 5e       	subi	r16, 0xEC	; 236
			                               &((uint8_t*)OutDataStart)[sizeof(IP_Header_t)]);
			break;
	}

	/* Check to see if the protocol processing routine has filled out a response */
	if (RetSize > 0)
    1c74:	1f 4f       	sbci	r17, 0xFF	; 255
    1c76:	1a 83       	std	Y+2, r17	; 0x02
    1c78:	0b 83       	std	Y+3, r16	; 0x03
	{
		/* Fill out the response IP packet header */
		IPHeaderOUT->TotalLength        = SwapEndian_16(sizeof(IP_Header_t) + RetSize);
    1c7a:	19 82       	std	Y+1, r1	; 0x01
    1c7c:	85 e4       	ldi	r24, 0x45	; 69
    1c7e:	88 83       	st	Y, r24
    1c80:	1e 82       	std	Y+6, r1	; 0x06
    1c82:	1f 82       	std	Y+7, r1	; 0x07
		IPHeaderOUT->TypeOfService      = 0;
    1c84:	1d 82       	std	Y+5, r1	; 0x05
		IPHeaderOUT->HeaderLength       = (sizeof(IP_Header_t) / sizeof(uint32_t));
		IPHeaderOUT->Version            = 4;
    1c86:	1c 82       	std	Y+4, r1	; 0x04
    1c88:	1b 86       	std	Y+11, r1	; 0x0b
		IPHeaderOUT->Flags              = 0;
		IPHeaderOUT->FragmentOffset     = 0;
    1c8a:	1a 86       	std	Y+10, r1	; 0x0a
    1c8c:	f7 01       	movw	r30, r14
		IPHeaderOUT->Identification     = 0;
    1c8e:	81 85       	ldd	r24, Z+9	; 0x09
    1c90:	89 87       	std	Y+9, r24	; 0x09
		IPHeaderOUT->HeaderChecksum     = 0;
    1c92:	80 e8       	ldi	r24, 0x80	; 128
    1c94:	88 87       	std	Y+8, r24	; 0x08
		IPHeaderOUT->Protocol           = IPHeaderIN->Protocol;
    1c96:	40 89       	ldd	r20, Z+16	; 0x10
    1c98:	51 89       	ldd	r21, Z+17	; 0x11
    1c9a:	62 89       	ldd	r22, Z+18	; 0x12
		IPHeaderOUT->TTL                = DEFAULT_TTL;
    1c9c:	73 89       	ldd	r23, Z+19	; 0x13
    1c9e:	4c 87       	std	Y+12, r20	; 0x0c
		IPHeaderOUT->SourceAddress      = IPHeaderIN->DestinationAddress;
    1ca0:	5d 87       	std	Y+13, r21	; 0x0d
    1ca2:	6e 87       	std	Y+14, r22	; 0x0e
    1ca4:	7f 87       	std	Y+15, r23	; 0x0f
    1ca6:	44 85       	ldd	r20, Z+12	; 0x0c
    1ca8:	55 85       	ldd	r21, Z+13	; 0x0d
    1caa:	66 85       	ldd	r22, Z+14	; 0x0e
    1cac:	77 85       	ldd	r23, Z+15	; 0x0f
    1cae:	48 8b       	std	Y+16, r20	; 0x10
		IPHeaderOUT->DestinationAddress = IPHeaderIN->SourceAddress;
    1cb0:	59 8b       	std	Y+17, r21	; 0x11
    1cb2:	6a 8b       	std	Y+18, r22	; 0x12
    1cb4:	7b 8b       	std	Y+19, r23	; 0x13
    1cb6:	64 e1       	ldi	r22, 0x14	; 20
    1cb8:	70 e0       	ldi	r23, 0x00	; 0
    1cba:	ce 01       	movw	r24, r28
    1cbc:	0e 94 65 04 	call	0x8ca	; 0x8ca <Ethernet_Checksum16>

		IPHeaderOUT->HeaderChecksum     = Ethernet_Checksum16(IPHeaderOUT, sizeof(IP_Header_t));
    1cc0:	9b 87       	std	Y+11, r25	; 0x0b
    1cc2:	8a 87       	std	Y+10, r24	; 0x0a
    1cc4:	c8 01       	movw	r24, r16
    1cc6:	02 c0       	rjmp	.+4      	; 0x1ccc <IP_ProcessIPPacket+0xf6>
    1cc8:	80 e0       	ldi	r24, 0x00	; 0
    1cca:	90 e0       	ldi	r25, 0x00	; 0
    1ccc:	df 91       	pop	r29

		/* Return the size of the response so far */
		return (sizeof(IP_Header_t) + RetSize);
    1cce:	cf 91       	pop	r28
    1cd0:	1f 91       	pop	r17
	IP_Header_t* IPHeaderOUT = (IP_Header_t*)OutDataStart;

	/* Header length is specified in number of longs in the packet header, convert to bytes */
	uint16_t HeaderLengthBytes = (IPHeaderIN->HeaderLength * sizeof(uint32_t));

	int16_t  RetSize = NO_RESPONSE;
    1cd2:	0f 91       	pop	r16
    1cd4:	ff 90       	pop	r15
		/* Return the size of the response so far */
		return (sizeof(IP_Header_t) + RetSize);
	}

	return RetSize;
}
    1cd6:	ef 90       	pop	r14
    1cd8:	df 90       	pop	r13
    1cda:	cf 90       	pop	r12
    1cdc:	08 95       	ret

00001cde <IsHTTPCommand>:
 */
static bool IsHTTPCommand(uint8_t* RequestHeader,
                          char* Command)
{
	/* Returns true if the non null terminated string in RequestHeader matches the null terminated string Command */
	return (strncmp((char*)RequestHeader, Command, strlen(Command)) == 0);
    1cde:	fb 01       	movw	r30, r22
    1ce0:	01 90       	ld	r0, Z+
    1ce2:	00 20       	and	r0, r0
    1ce4:	e9 f7       	brne	.-6      	; 0x1ce0 <IsHTTPCommand+0x2>
    1ce6:	af 01       	movw	r20, r30
    1ce8:	41 50       	subi	r20, 0x01	; 1
    1cea:	51 09       	sbc	r21, r1
    1cec:	46 1b       	sub	r20, r22
    1cee:	57 0b       	sbc	r21, r23
    1cf0:	17 d6       	rcall	.+3118   	; 0x2920 <strncmp>
    1cf2:	21 e0       	ldi	r18, 0x01	; 1
    1cf4:	89 2b       	or	r24, r25
    1cf6:	09 f0       	breq	.+2      	; 0x1cfa <IsHTTPCommand+0x1c>
    1cf8:	20 e0       	ldi	r18, 0x00	; 0
    1cfa:	82 2f       	mov	r24, r18
}
    1cfc:	08 95       	ret

00001cfe <Webserver_ApplicationCallback>:
    1cfe:	4f 92       	push	r4
 *  \param[in] ConnectionState  Pointer to a TCP Connection State structure giving connection information
 *  \param[in,out] Buffer       Pointer to the application's send/receive packet buffer
 */
void Webserver_ApplicationCallback(TCP_ConnectionState_t* const ConnectionState,
                                   TCP_ConnectionBuffer_t* const Buffer)
{
    1d00:	5f 92       	push	r5
    1d02:	6f 92       	push	r6
    1d04:	7f 92       	push	r7
    1d06:	8f 92       	push	r8
    1d08:	9f 92       	push	r9
    1d0a:	af 92       	push	r10
    1d0c:	bf 92       	push	r11
    1d0e:	cf 92       	push	r12
    1d10:	df 92       	push	r13
    1d12:	ef 92       	push	r14
    1d14:	ff 92       	push	r15
    1d16:	0f 93       	push	r16
    1d18:	1f 93       	push	r17
    1d1a:	cf 93       	push	r28
    1d1c:	df 93       	push	r29
    1d1e:	00 d0       	rcall	.+0      	; 0x1d20 <Webserver_ApplicationCallback+0x22>
    1d20:	cd b7       	in	r28, 0x3d	; 61
    1d22:	de b7       	in	r29, 0x3e	; 62
    1d24:	5c 01       	movw	r10, r24
    1d26:	8b 01       	movw	r16, r22
	char*          BufferDataStr = (char*)Buffer->Data;
    1d28:	2b 01       	movw	r4, r22
    1d2a:	82 e0       	ldi	r24, 0x02	; 2
    1d2c:	48 0e       	add	r4, r24
    1d2e:	51 1c       	adc	r5, r1
	static uint8_t PageBlock     = 0;

	/* Check to see if a packet has been received on the HTTP port from a remote host */
	if (TCP_APP_HAS_RECEIVED_PACKET(Buffer))
    1d30:	7b 01       	movw	r14, r22
    1d32:	ad ef       	ldi	r26, 0xFD	; 253
    1d34:	ea 1a       	sub	r14, r26
    1d36:	fa 0a       	sbc	r15, r26
    1d38:	f7 01       	movw	r30, r14
    1d3a:	80 81       	ld	r24, Z
    1d3c:	6b 01       	movw	r12, r22
    1d3e:	88 23       	and	r24, r24
    1d40:	09 f4       	brne	.+2      	; 0x1d44 <Webserver_ApplicationCallback+0x46>
    1d42:	5f c0       	rjmp	.+190    	; 0x1e02 <Webserver_ApplicationCallback+0x104>
    1d44:	f2 e0       	ldi	r31, 0x02	; 2
    1d46:	cf 0e       	add	r12, r31
    1d48:	df 1e       	adc	r13, r31
    1d4a:	d6 01       	movw	r26, r12
    1d4c:	8c 91       	ld	r24, X
    1d4e:	81 11       	cpse	r24, r1
    1d50:	98 c0       	rjmp	.+304    	; 0x1e82 <Webserver_ApplicationCallback+0x184>
	{
		if (IsHTTPCommand(Buffer->Data, "GET"))
    1d52:	68 e2       	ldi	r22, 0x28	; 40
    1d54:	71 e0       	ldi	r23, 0x01	; 1
    1d56:	c2 01       	movw	r24, r4
    1d58:	c2 df       	rcall	.-124    	; 0x1cde <IsHTTPCommand>
    1d5a:	88 23       	and	r24, r24
    1d5c:	f9 f0       	breq	.+62     	; 0x1d9c <Webserver_ApplicationCallback+0x9e>
    1d5e:	6c e2       	ldi	r22, 0x2C	; 44
		{
			if (IsHTTPCommand(Buffer->Data, "GET / "))
    1d60:	71 e0       	ldi	r23, 0x01	; 1
    1d62:	c2 01       	movw	r24, r4
    1d64:	bc df       	rcall	.-136    	; 0x1cde <IsHTTPCommand>
    1d66:	88 23       	and	r24, r24
    1d68:	41 f1       	breq	.+80     	; 0x1dba <Webserver_ApplicationCallback+0xbc>
    1d6a:	10 92 4c 01 	sts	0x014C, r1
			{
				PageBlock = 0;
    1d6e:	67 ee       	ldi	r22, 0xE7	; 231
    1d70:	73 e0       	ldi	r23, 0x03	; 3

				/* Copy the HTTP 200 response header into the packet buffer */
				strcpy_P(BufferDataStr, HTTP200Header);
    1d72:	c2 01       	movw	r24, r4
    1d74:	8f d5       	rcall	.+2846   	; 0x2894 <strcpy_P>
    1d76:	81 e0       	ldi	r24, 0x01	; 1
    1d78:	f6 01       	movw	r30, r12
    1d7a:	80 83       	st	Z, r24

				/* Send the buffer contents to the host */
				TCP_APP_SEND_BUFFER(Buffer, strlen(BufferDataStr));
    1d7c:	f2 01       	movw	r30, r4
    1d7e:	01 90       	ld	r0, Z+
    1d80:	00 20       	and	r0, r0
    1d82:	e9 f7       	brne	.-6      	; 0x1d7e <Webserver_ApplicationCallback+0x80>
    1d84:	31 97       	sbiw	r30, 0x01	; 1
    1d86:	e4 19       	sub	r30, r4
    1d88:	f5 09       	sbc	r31, r5
    1d8a:	d8 01       	movw	r26, r16
    1d8c:	ed 93       	st	X+, r30
    1d8e:	fc 93       	st	X, r31
    1d90:	f7 01       	movw	r30, r14
    1d92:	80 83       	st	Z, r24
    1d94:	f8 01       	movw	r30, r16
    1d96:	ec 5f       	subi	r30, 0xFC	; 252
    1d98:	fd 4f       	sbci	r31, 0xFD	; 253

				/* Lock the buffer to Device->Host transmissions only while we send the page contents */
				TCP_APP_CAPTURE_BUFFER(Buffer);
    1d9a:	72 c0       	rjmp	.+228    	; 0x1e80 <Webserver_ApplicationCallback+0x182>
    1d9c:	63 e3       	ldi	r22, 0x33	; 51
    1d9e:	71 e0       	ldi	r23, 0x01	; 1
    1da0:	c2 01       	movw	r24, r4

				/* All data sent, close the connection */
				TCP_APP_CLOSECONNECTION(ConnectionState);
			}
		}
		else if (IsHTTPCommand(Buffer->Data, "HEAD"))
    1da2:	9d df       	rcall	.-198    	; 0x1cde <IsHTTPCommand>
    1da4:	88 23       	and	r24, r24
    1da6:	e9 f0       	breq	.+58     	; 0x1de2 <Webserver_ApplicationCallback+0xe4>
    1da8:	68 e3       	ldi	r22, 0x38	; 56
    1daa:	71 e0       	ldi	r23, 0x01	; 1
    1dac:	c2 01       	movw	r24, r4
    1dae:	97 df       	rcall	.-210    	; 0x1cde <IsHTTPCommand>
		{
			if (IsHTTPCommand(Buffer->Data, "HEAD / "))
    1db0:	88 23       	and	r24, r24
    1db2:	19 f0       	breq	.+6      	; 0x1dba <Webserver_ApplicationCallback+0xbc>
    1db4:	67 ee       	ldi	r22, 0xE7	; 231
    1db6:	73 e0       	ldi	r23, 0x03	; 3
    1db8:	02 c0       	rjmp	.+4      	; 0x1dbe <Webserver_ApplicationCallback+0xc0>
    1dba:	65 ea       	ldi	r22, 0xA5	; 165
    1dbc:	73 e0       	ldi	r23, 0x03	; 3
			{
				/* Copy the HTTP response header into the packet buffer */
				strcpy_P(BufferDataStr, HTTP200Header);
    1dbe:	c2 01       	movw	r24, r4
    1dc0:	69 d5       	rcall	.+2770   	; 0x2894 <strcpy_P>
    1dc2:	81 e0       	ldi	r24, 0x01	; 1
				TCP_APP_SEND_BUFFER(Buffer, strlen(BufferDataStr));
			}
			else
			{
				/* Copy the HTTP response header into the packet buffer */
				strcpy_P(BufferDataStr, HTTP404Header);
    1dc4:	d6 01       	movw	r26, r12
    1dc6:	8c 93       	st	X, r24
    1dc8:	f2 01       	movw	r30, r4
    1dca:	01 90       	ld	r0, Z+
    1dcc:	00 20       	and	r0, r0

				/* Send the buffer contents to the host */
				TCP_APP_SEND_BUFFER(Buffer, strlen(BufferDataStr));
    1dce:	e9 f7       	brne	.-6      	; 0x1dca <Webserver_ApplicationCallback+0xcc>
    1dd0:	31 97       	sbiw	r30, 0x01	; 1
    1dd2:	e4 19       	sub	r30, r4
    1dd4:	f5 09       	sbc	r31, r5
    1dd6:	d8 01       	movw	r26, r16
    1dd8:	ed 93       	st	X+, r30
    1dda:	fc 93       	st	X, r31
    1ddc:	f7 01       	movw	r30, r14
    1dde:	80 83       	st	Z, r24
    1de0:	4b c0       	rjmp	.+150    	; 0x1e78 <Webserver_ApplicationCallback+0x17a>
    1de2:	60 e4       	ldi	r22, 0x40	; 64
    1de4:	71 e0       	ldi	r23, 0x01	; 1
    1de6:	c2 01       	movw	r24, r4
    1de8:	7a df       	rcall	.-268    	; 0x1cde <IsHTTPCommand>
    1dea:	88 23       	and	r24, r24
    1dec:	21 f0       	breq	.+8      	; 0x1df6 <Webserver_ApplicationCallback+0xf8>
			}

			/* All data sent, close the connection */
			TCP_APP_CLOSECONNECTION(ConnectionState);
		}
		else if (IsHTTPCommand(Buffer->Data, "TRACE"))
    1dee:	81 e0       	ldi	r24, 0x01	; 1
    1df0:	d6 01       	movw	r26, r12
    1df2:	8c 93       	st	X, r24
    1df4:	f3 cf       	rjmp	.-26     	; 0x1ddc <Webserver_ApplicationCallback+0xde>
    1df6:	d7 01       	movw	r26, r14
    1df8:	1c 92       	st	X, r1
    1dfa:	f8 01       	movw	r30, r16
		{
			/* Echo the host's query back to the host */
			TCP_APP_SEND_BUFFER(Buffer, Buffer->Length);
    1dfc:	11 82       	std	Z+1, r1	; 0x01
    1dfe:	10 82       	st	Z, r1
    1e00:	40 c0       	rjmp	.+128    	; 0x1e82 <Webserver_ApplicationCallback+0x184>
    1e02:	fc ef       	ldi	r31, 0xFC	; 252
			TCP_APP_CLOSECONNECTION(ConnectionState);
		}
		else
		{
			/* Unknown request, just clear the buffer (drop the packet) */
			TCP_APP_CLEAR_BUFFER(Buffer);
    1e04:	cf 1a       	sub	r12, r31
    1e06:	fd ef       	ldi	r31, 0xFD	; 253
    1e08:	df 0a       	sbc	r13, r31
    1e0a:	d6 01       	movw	r26, r12
    1e0c:	8c 91       	ld	r24, X
    1e0e:	88 23       	and	r24, r24
		}
	}
	else if (TCP_APP_HAVE_CAPTURED_BUFFER(Buffer))
    1e10:	c1 f1       	breq	.+112    	; 0x1e82 <Webserver_ApplicationCallback+0x184>
    1e12:	4b 01       	movw	r8, r22
    1e14:	b2 e0       	ldi	r27, 0x02	; 2
    1e16:	8b 0e       	add	r8, r27
    1e18:	9b 1e       	adc	r9, r27
    1e1a:	f4 01       	movw	r30, r8
    1e1c:	80 81       	ld	r24, Z
    1e1e:	88 23       	and	r24, r24
    1e20:	81 f1       	breq	.+96     	; 0x1e82 <Webserver_ApplicationCallback+0x184>
    1e22:	60 91 4c 01 	lds	r22, 0x014C
    1e26:	f0 e8       	ldi	r31, 0x80	; 128
    1e28:	6f 9f       	mul	r22, r31
    1e2a:	b0 01       	movw	r22, r0
    1e2c:	11 24       	eor	r1, r1
    1e2e:	6b 54       	subi	r22, 0x4B	; 75
	{
		uint16_t RemLength = strlen_P(&HTTPPage[PageBlock * HTTP_REPLY_BLOCK_SIZE]);
    1e30:	7e 4f       	sbci	r23, 0xFE	; 254
    1e32:	cb 01       	movw	r24, r22
    1e34:	69 83       	std	Y+1, r22	; 0x01
    1e36:	7a 83       	std	Y+2, r23	; 0x02
    1e38:	34 d5       	rcall	.+2664   	; 0x28a2 <__strlen_P>
    1e3a:	3c 01       	movw	r6, r24
    1e3c:	69 81       	ldd	r22, Y+1	; 0x01
    1e3e:	7a 81       	ldd	r23, Y+2	; 0x02


__attribute__((__always_inline__)) static inline size_t strlen_P(const char * s);
static inline size_t strlen_P(const char *s) {
  return __builtin_constant_p(__builtin_strlen(s))
     ? __builtin_strlen(s) : __strlen_P(s);
    1e40:	81 e8       	ldi	r24, 0x81	; 129
    1e42:	68 16       	cp	r6, r24
    1e44:	71 04       	cpc	r7, r1
    1e46:	18 f0       	brcs	.+6      	; 0x1e4e <Webserver_ApplicationCallback+0x150>
    1e48:	80 e8       	ldi	r24, 0x80	; 128
    1e4a:	68 2e       	mov	r6, r24
		uint16_t Length;

		/* Determine the length of the loaded block */
		Length = MIN(RemLength, HTTP_REPLY_BLOCK_SIZE);
    1e4c:	71 2c       	mov	r7, r1
    1e4e:	a3 01       	movw	r20, r6
    1e50:	c2 01       	movw	r24, r4
    1e52:	30 d5       	rcall	.+2656   	; 0x28b4 <strncpy_P>
    1e54:	81 e0       	ldi	r24, 0x01	; 1
    1e56:	d4 01       	movw	r26, r8
    1e58:	8c 93       	st	X, r24
    1e5a:	f8 01       	movw	r30, r16
    1e5c:	71 82       	std	Z+1, r7	; 0x01

		/* Copy the next buffer sized block of the page to the packet buffer */
		strncpy_P(BufferDataStr, &HTTPPage[PageBlock * HTTP_REPLY_BLOCK_SIZE], Length);
    1e5e:	60 82       	st	Z, r6
    1e60:	d7 01       	movw	r26, r14
    1e62:	8c 93       	st	X, r24
    1e64:	80 91 4c 01 	lds	r24, 0x014C

		/* Send the buffer contents to the host */
		TCP_APP_SEND_BUFFER(Buffer, Length);
    1e68:	91 e0       	ldi	r25, 0x01	; 1
    1e6a:	98 0f       	add	r25, r24
    1e6c:	90 93 4c 01 	sts	0x014C, r25
    1e70:	83 30       	cpi	r24, 0x03	; 3
    1e72:	39 f4       	brne	.+14     	; 0x1e82 <Webserver_ApplicationCallback+0x184>
    1e74:	f6 01       	movw	r30, r12

		/* Check to see if the entire page has been sent */
		if (PageBlock++ == (sizeof(HTTPPage) / HTTP_REPLY_BLOCK_SIZE))
    1e76:	10 82       	st	Z, r1
    1e78:	f5 01       	movw	r30, r10
    1e7a:	eb 5e       	subi	r30, 0xEB	; 235
    1e7c:	fd 4f       	sbci	r31, 0xFD	; 253
    1e7e:	87 e0       	ldi	r24, 0x07	; 7
    1e80:	80 83       	st	Z, r24
    1e82:	0f 90       	pop	r0
    1e84:	0f 90       	pop	r0
		{
			/* Unlock the buffer so that the host can fill it with future packets */
			TCP_APP_RELEASE_BUFFER(Buffer);
    1e86:	df 91       	pop	r29
    1e88:	cf 91       	pop	r28

			/* Close the connection to the host */
			TCP_APP_CLOSECONNECTION(ConnectionState);
    1e8a:	1f 91       	pop	r17
    1e8c:	0f 91       	pop	r16
    1e8e:	ff 90       	pop	r15
    1e90:	ef 90       	pop	r14
    1e92:	df 90       	pop	r13
		}
	}
}
    1e94:	cf 90       	pop	r12
    1e96:	bf 90       	pop	r11
    1e98:	af 90       	pop	r10
    1e9a:	9f 90       	pop	r9
    1e9c:	8f 90       	pop	r8
    1e9e:	7f 90       	pop	r7
    1ea0:	6f 90       	pop	r6
    1ea2:	5f 90       	pop	r5
    1ea4:	4f 90       	pop	r4
    1ea6:	08 95       	ret

00001ea8 <Webserver_Init>:
    1ea8:	4f e7       	ldi	r20, 0x7F	; 127
    1eaa:	5e e0       	ldi	r21, 0x0E	; 14
    1eac:	61 e0       	ldi	r22, 0x01	; 1
    1eae:	80 e0       	ldi	r24, 0x00	; 0
    1eb0:	90 e5       	ldi	r25, 0x50	; 80
    1eb2:	b6 c9       	rjmp	.-3220   	; 0x1220 <TCP_SetPortState>

00001eb4 <Endpoint_Write_Stream_LE>:
    1eb4:	cf 92       	push	r12
    1eb6:	df 92       	push	r13
    1eb8:	ef 92       	push	r14
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
    1eba:	ff 92       	push	r15
    1ebc:	0f 93       	push	r16
    1ebe:	1f 93       	push	r17
    1ec0:	cf 93       	push	r28
    1ec2:	df 93       	push	r29
    1ec4:	7c 01       	movw	r14, r24
    1ec6:	8b 01       	movw	r16, r22
    1ec8:	ea 01       	movw	r28, r20
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	uint16_t BytesInTransfer = 0;
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
    1eca:	d5 d1       	rcall	.+938    	; 0x2276 <Endpoint_WaitUntilReady>
    1ecc:	81 11       	cpse	r24, r1
    1ece:	31 c0       	rjmp	.+98     	; 0x1f32 <Endpoint_Write_Stream_LE+0x7e>
    1ed0:	20 97       	sbiw	r28, 0x00	; 0
	  return ErrorCode;

	if (BytesProcessed != NULL)
    1ed2:	31 f0       	breq	.+12     	; 0x1ee0 <Endpoint_Write_Stream_LE+0x2c>
    1ed4:	88 81       	ld	r24, Y
	{
		Length -= *BytesProcessed;
    1ed6:	99 81       	ldd	r25, Y+1	; 0x01
    1ed8:	08 1b       	sub	r16, r24
    1eda:	19 0b       	sbc	r17, r25
    1edc:	e8 0e       	add	r14, r24
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
    1ede:	f9 1e       	adc	r15, r25
    1ee0:	c1 2c       	mov	r12, r1

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    1ee2:	d1 2c       	mov	r13, r1
    1ee4:	01 15       	cp	r16, r1
	{
		Length -= *BytesProcessed;
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
    1ee6:	11 05       	cpc	r17, r1
    1ee8:	19 f1       	breq	.+70     	; 0x1f30 <Endpoint_Write_Stream_LE+0x7c>
    1eea:	80 91 e8 00 	lds	r24, 0x00E8
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    1eee:	85 fd       	sbrc	r24, 5
	{
		if (!(Endpoint_IsReadWriteAllowed()))
    1ef0:	14 c0       	rjmp	.+40     	; 0x1f1a <Endpoint_Write_Stream_LE+0x66>
    1ef2:	80 91 e8 00 	lds	r24, 0x00E8
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    1ef6:	8e 77       	andi	r24, 0x7E	; 126
    1ef8:	80 93 e8 00 	sts	0x00E8, r24
    1efc:	6d d4       	rcall	.+2266   	; 0x27d8 <USB_USBTask>
		{
			TEMPLATE_CLEAR_ENDPOINT();

			#if !defined(INTERRUPT_CONTROL_ENDPOINT)
			USB_USBTask();
    1efe:	20 97       	sbiw	r28, 0x00	; 0
    1f00:	41 f0       	breq	.+16     	; 0x1f12 <Endpoint_Write_Stream_LE+0x5e>
			#endif

			if (BytesProcessed != NULL)
    1f02:	88 81       	ld	r24, Y
    1f04:	99 81       	ldd	r25, Y+1	; 0x01
			{
				*BytesProcessed += BytesInTransfer;
    1f06:	8c 0d       	add	r24, r12
    1f08:	9d 1d       	adc	r25, r13
    1f0a:	99 83       	std	Y+1, r25	; 0x01
    1f0c:	88 83       	st	Y, r24
    1f0e:	85 e0       	ldi	r24, 0x05	; 5
    1f10:	10 c0       	rjmp	.+32     	; 0x1f32 <Endpoint_Write_Stream_LE+0x7e>
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
    1f12:	b1 d1       	rcall	.+866    	; 0x2276 <Endpoint_WaitUntilReady>
    1f14:	88 23       	and	r24, r24
			}

			if ((ErrorCode = Endpoint_WaitUntilReady()))
    1f16:	31 f3       	breq	.-52     	; 0x1ee4 <Endpoint_Write_Stream_LE+0x30>
    1f18:	0c c0       	rjmp	.+24     	; 0x1f32 <Endpoint_Write_Stream_LE+0x7e>
    1f1a:	f7 01       	movw	r30, r14
    1f1c:	81 91       	ld	r24, Z+
    1f1e:	7f 01       	movw	r14, r30
			  return ErrorCode;
		}
		else
		{
			TEMPLATE_TRANSFER_BYTE(DataStream);
    1f20:	80 93 f1 00 	sts	0x00F1, r24
    1f24:	01 50       	subi	r16, 0x01	; 1
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    1f26:	11 09       	sbc	r17, r1
    1f28:	ff ef       	ldi	r31, 0xFF	; 255
			TEMPLATE_BUFFER_MOVE(DataStream, 1);
			Length--;
    1f2a:	cf 1a       	sub	r12, r31
    1f2c:	df 0a       	sbc	r13, r31
			BytesInTransfer++;
    1f2e:	da cf       	rjmp	.-76     	; 0x1ee4 <Endpoint_Write_Stream_LE+0x30>
    1f30:	80 e0       	ldi	r24, 0x00	; 0
    1f32:	df 91       	pop	r29
    1f34:	cf 91       	pop	r28
		}
	}

	return ENDPOINT_RWSTREAM_NoError;
    1f36:	1f 91       	pop	r17
}
    1f38:	0f 91       	pop	r16
    1f3a:	ff 90       	pop	r15
    1f3c:	ef 90       	pop	r14
    1f3e:	df 90       	pop	r13
    1f40:	cf 90       	pop	r12
    1f42:	08 95       	ret

00001f44 <Endpoint_Read_Stream_LE>:
    1f44:	cf 92       	push	r12
    1f46:	df 92       	push	r13
    1f48:	ef 92       	push	r14
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
    1f4a:	ff 92       	push	r15
    1f4c:	0f 93       	push	r16
    1f4e:	1f 93       	push	r17
    1f50:	cf 93       	push	r28
    1f52:	df 93       	push	r29
    1f54:	7c 01       	movw	r14, r24
    1f56:	8b 01       	movw	r16, r22
    1f58:	ea 01       	movw	r28, r20
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	uint16_t BytesInTransfer = 0;
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
    1f5a:	8d d1       	rcall	.+794    	; 0x2276 <Endpoint_WaitUntilReady>
    1f5c:	81 11       	cpse	r24, r1
    1f5e:	31 c0       	rjmp	.+98     	; 0x1fc2 <Endpoint_Read_Stream_LE+0x7e>
    1f60:	20 97       	sbiw	r28, 0x00	; 0
	  return ErrorCode;

	if (BytesProcessed != NULL)
    1f62:	31 f0       	breq	.+12     	; 0x1f70 <Endpoint_Read_Stream_LE+0x2c>
    1f64:	88 81       	ld	r24, Y
	{
		Length -= *BytesProcessed;
    1f66:	99 81       	ldd	r25, Y+1	; 0x01
    1f68:	08 1b       	sub	r16, r24
    1f6a:	19 0b       	sbc	r17, r25
    1f6c:	e8 0e       	add	r14, r24
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
    1f6e:	f9 1e       	adc	r15, r25
    1f70:	c1 2c       	mov	r12, r1

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    1f72:	d1 2c       	mov	r13, r1
    1f74:	01 15       	cp	r16, r1
	{
		Length -= *BytesProcessed;
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
    1f76:	11 05       	cpc	r17, r1
    1f78:	19 f1       	breq	.+70     	; 0x1fc0 <Endpoint_Read_Stream_LE+0x7c>
    1f7a:	80 91 e8 00 	lds	r24, 0x00E8
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    1f7e:	85 fd       	sbrc	r24, 5
	{
		if (!(Endpoint_IsReadWriteAllowed()))
    1f80:	14 c0       	rjmp	.+40     	; 0x1faa <Endpoint_Read_Stream_LE+0x66>
    1f82:	80 91 e8 00 	lds	r24, 0x00E8
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    1f86:	8b 77       	andi	r24, 0x7B	; 123
    1f88:	80 93 e8 00 	sts	0x00E8, r24
    1f8c:	25 d4       	rcall	.+2122   	; 0x27d8 <USB_USBTask>
		{
			TEMPLATE_CLEAR_ENDPOINT();

			#if !defined(INTERRUPT_CONTROL_ENDPOINT)
			USB_USBTask();
    1f8e:	20 97       	sbiw	r28, 0x00	; 0
    1f90:	41 f0       	breq	.+16     	; 0x1fa2 <Endpoint_Read_Stream_LE+0x5e>
			#endif

			if (BytesProcessed != NULL)
    1f92:	88 81       	ld	r24, Y
    1f94:	99 81       	ldd	r25, Y+1	; 0x01
			{
				*BytesProcessed += BytesInTransfer;
    1f96:	8c 0d       	add	r24, r12
    1f98:	9d 1d       	adc	r25, r13
    1f9a:	99 83       	std	Y+1, r25	; 0x01
    1f9c:	88 83       	st	Y, r24
    1f9e:	85 e0       	ldi	r24, 0x05	; 5
    1fa0:	10 c0       	rjmp	.+32     	; 0x1fc2 <Endpoint_Read_Stream_LE+0x7e>
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
    1fa2:	69 d1       	rcall	.+722    	; 0x2276 <Endpoint_WaitUntilReady>
    1fa4:	88 23       	and	r24, r24
			}

			if ((ErrorCode = Endpoint_WaitUntilReady()))
    1fa6:	31 f3       	breq	.-52     	; 0x1f74 <Endpoint_Read_Stream_LE+0x30>
    1fa8:	0c c0       	rjmp	.+24     	; 0x1fc2 <Endpoint_Read_Stream_LE+0x7e>
    1faa:	80 91 f1 00 	lds	r24, 0x00F1
    1fae:	f7 01       	movw	r30, r14
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    1fb0:	81 93       	st	Z+, r24
    1fb2:	7f 01       	movw	r14, r30
			  return ErrorCode;
		}
		else
		{
			TEMPLATE_TRANSFER_BYTE(DataStream);
    1fb4:	01 50       	subi	r16, 0x01	; 1
    1fb6:	11 09       	sbc	r17, r1
    1fb8:	ff ef       	ldi	r31, 0xFF	; 255
			TEMPLATE_BUFFER_MOVE(DataStream, 1);
			Length--;
    1fba:	cf 1a       	sub	r12, r31
    1fbc:	df 0a       	sbc	r13, r31
			BytesInTransfer++;
    1fbe:	da cf       	rjmp	.-76     	; 0x1f74 <Endpoint_Read_Stream_LE+0x30>
    1fc0:	80 e0       	ldi	r24, 0x00	; 0
    1fc2:	df 91       	pop	r29
    1fc4:	cf 91       	pop	r28
		}
	}

	return ENDPOINT_RWSTREAM_NoError;
    1fc6:	1f 91       	pop	r17
}
    1fc8:	0f 91       	pop	r16
    1fca:	ff 90       	pop	r15
    1fcc:	ef 90       	pop	r14
    1fce:	df 90       	pop	r13
    1fd0:	cf 90       	pop	r12
    1fd2:	08 95       	ret

00001fd4 <Endpoint_Write_Control_Stream_LE>:
    1fd4:	20 91 df 13 	lds	r18, 0x13DF
    1fd8:	30 91 e0 13 	lds	r19, 0x13E0
                            uint16_t Length)
{
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
    1fdc:	26 17       	cp	r18, r22
    1fde:	37 07       	cpc	r19, r23
    1fe0:	48 f0       	brcs	.+18     	; 0x1ff4 <Endpoint_Write_Control_Stream_LE+0x20>
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
    1fe2:	61 15       	cp	r22, r1
    1fe4:	71 05       	cpc	r23, r1
    1fe6:	39 f4       	brne	.+14     	; 0x1ff6 <Endpoint_Write_Control_Stream_LE+0x22>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    1fe8:	20 91 e8 00 	lds	r18, 0x00E8
    1fec:	2e 77       	andi	r18, 0x7E	; 126
    1fee:	20 93 e8 00 	sts	0x00E8, r18
    1ff2:	01 c0       	rjmp	.+2      	; 0x1ff6 <Endpoint_Write_Control_Stream_LE+0x22>
    1ff4:	b9 01       	movw	r22, r18
    1ff6:	fc 01       	movw	r30, r24
    1ff8:	20 e0       	ldi	r18, 0x00	; 0
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    1ffa:	61 15       	cp	r22, r1
    1ffc:	71 05       	cpc	r23, r1
    1ffe:	99 f1       	breq	.+102    	; 0x2066 <Endpoint_Write_Control_Stream_LE+0x92>
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    2000:	80 91 d8 13 	lds	r24, 0x13D8

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    2004:	88 23       	and	r24, r24
    2006:	e9 f1       	breq	.+122    	; 0x2082 <Endpoint_Write_Control_Stream_LE+0xae>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    2008:	85 30       	cpi	r24, 0x05	; 5
    200a:	e9 f1       	breq	.+122    	; 0x2086 <Endpoint_Write_Control_Stream_LE+0xb2>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    200c:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    2010:	83 fd       	sbrc	r24, 3
    2012:	3b c0       	rjmp	.+118    	; 0x208a <Endpoint_Write_Control_Stream_LE+0xb6>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    2014:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
    2018:	82 ff       	sbrs	r24, 2
    201a:	06 c0       	rjmp	.+12     	; 0x2028 <Endpoint_Write_Control_Stream_LE+0x54>
    201c:	80 91 e8 00 	lds	r24, 0x00E8
			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}

	while (!(Endpoint_IsOUTReceived()))
    2020:	82 ff       	sbrs	r24, 2
    2022:	24 c0       	rjmp	.+72     	; 0x206c <Endpoint_Write_Control_Stream_LE+0x98>
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
	}

	return ENDPOINT_RWCSTREAM_NoError;
    2024:	80 e0       	ldi	r24, 0x00	; 0
    2026:	08 95       	ret
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    2028:	80 91 e8 00 	lds	r24, 0x00E8
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
		  break;

		if (Endpoint_IsINReady())
    202c:	80 ff       	sbrs	r24, 0
    202e:	e5 cf       	rjmp	.-54     	; 0x1ffa <Endpoint_Write_Control_Stream_LE+0x26>
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					return UEBCX;
    2030:	80 91 f2 00 	lds	r24, 0x00F2
    2034:	90 91 f3 00 	lds	r25, 0x00F3
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    2038:	61 15       	cp	r22, r1
    203a:	71 05       	cpc	r23, r1
    203c:	51 f0       	breq	.+20     	; 0x2052 <Endpoint_Write_Control_Stream_LE+0x7e>
    203e:	88 30       	cpi	r24, 0x08	; 8
    2040:	91 05       	cpc	r25, r1
    2042:	38 f4       	brcc	.+14     	; 0x2052 <Endpoint_Write_Control_Stream_LE+0x7e>
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    2044:	21 91       	ld	r18, Z+
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    2046:	20 93 f1 00 	sts	0x00F1, r18
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
    204a:	61 50       	subi	r22, 0x01	; 1
    204c:	71 09       	sbc	r23, r1
				BytesInEndpoint++;
    204e:	01 96       	adiw	r24, 0x01	; 1
    2050:	f3 cf       	rjmp	.-26     	; 0x2038 <Endpoint_Write_Control_Stream_LE+0x64>
			}

			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
    2052:	21 e0       	ldi	r18, 0x01	; 1
    2054:	08 97       	sbiw	r24, 0x08	; 8
    2056:	09 f0       	breq	.+2      	; 0x205a <Endpoint_Write_Control_Stream_LE+0x86>
    2058:	20 e0       	ldi	r18, 0x00	; 0
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    205a:	80 91 e8 00 	lds	r24, 0x00E8
    205e:	8e 77       	andi	r24, 0x7E	; 126
    2060:	80 93 e8 00 	sts	0x00E8, r24
    2064:	ca cf       	rjmp	.-108    	; 0x1ffa <Endpoint_Write_Control_Stream_LE+0x26>
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    2066:	21 11       	cpse	r18, r1
    2068:	cb cf       	rjmp	.-106    	; 0x2000 <Endpoint_Write_Control_Stream_LE+0x2c>
    206a:	d8 cf       	rjmp	.-80     	; 0x201c <Endpoint_Write_Control_Stream_LE+0x48>
		}
	}

	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    206c:	80 91 d8 13 	lds	r24, 0x13D8

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    2070:	88 23       	and	r24, r24
    2072:	39 f0       	breq	.+14     	; 0x2082 <Endpoint_Write_Control_Stream_LE+0xae>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    2074:	85 30       	cpi	r24, 0x05	; 5
    2076:	39 f0       	breq	.+14     	; 0x2086 <Endpoint_Write_Control_Stream_LE+0xb2>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    2078:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    207c:	83 ff       	sbrs	r24, 3
    207e:	ce cf       	rjmp	.-100    	; 0x201c <Endpoint_Write_Control_Stream_LE+0x48>
    2080:	04 c0       	rjmp	.+8      	; 0x208a <Endpoint_Write_Control_Stream_LE+0xb6>
	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
    2082:	82 e0       	ldi	r24, 0x02	; 2
    2084:	08 95       	ret
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    2086:	83 e0       	ldi	r24, 0x03	; 3
    2088:	08 95       	ret
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
    208a:	81 e0       	ldi	r24, 0x01	; 1
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    208c:	08 95       	ret

0000208e <Endpoint_Read_Control_Stream_LE>:
uint8_t TEMPLATE_FUNC_NAME (void* const Buffer,
                            uint16_t Length)
{
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));

	if (!(Length))
    208e:	61 15       	cp	r22, r1
    2090:	71 05       	cpc	r23, r1
    2092:	29 f4       	brne	.+10     	; 0x209e <Endpoint_Read_Control_Stream_LE+0x10>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    2094:	20 91 e8 00 	lds	r18, 0x00E8
    2098:	2b 77       	andi	r18, 0x7B	; 123
    209a:	20 93 e8 00 	sts	0x00E8, r18
	  Endpoint_ClearOUT();

	while (Length)
    209e:	61 15       	cp	r22, r1
    20a0:	71 05       	cpc	r23, r1
    20a2:	31 f1       	breq	.+76     	; 0x20f0 <Endpoint_Read_Control_Stream_LE+0x62>
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    20a4:	20 91 d8 13 	lds	r18, 0x13D8

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    20a8:	22 23       	and	r18, r18
    20aa:	59 f1       	breq	.+86     	; 0x2102 <__stack+0x3>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    20ac:	25 30       	cpi	r18, 0x05	; 5
    20ae:	59 f1       	breq	.+86     	; 0x2106 <__stack+0x7>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    20b0:	20 91 e8 00 	lds	r18, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    20b4:	23 fd       	sbrc	r18, 3
    20b6:	21 c0       	rjmp	.+66     	; 0x20fa <Endpoint_Read_Control_Stream_LE+0x6c>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    20b8:	20 91 e8 00 	lds	r18, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;

		if (Endpoint_IsOUTReceived())
    20bc:	22 ff       	sbrs	r18, 2
    20be:	f2 cf       	rjmp	.-28     	; 0x20a4 <Endpoint_Read_Control_Stream_LE+0x16>
    20c0:	fc 01       	movw	r30, r24
    20c2:	cf 01       	movw	r24, r30
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					return UEBCX;
    20c4:	20 91 f2 00 	lds	r18, 0x00F2
    20c8:	30 91 f3 00 	lds	r19, 0x00F3
		{
			while (Length && Endpoint_BytesInEndpoint())
    20cc:	23 2b       	or	r18, r19
    20ce:	11 f3       	breq	.-60     	; 0x2094 <Endpoint_Read_Control_Stream_LE+0x6>
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    20d0:	80 91 f1 00 	lds	r24, 0x00F1
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    20d4:	81 93       	st	Z+, r24
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
    20d6:	cf 01       	movw	r24, r30
				Length--;
    20d8:	61 50       	subi	r22, 0x01	; 1
    20da:	71 09       	sbc	r23, r1
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;

		if (Endpoint_IsOUTReceived())
		{
			while (Length && Endpoint_BytesInEndpoint())
    20dc:	61 15       	cp	r22, r1
    20de:	71 05       	cpc	r23, r1
    20e0:	81 f7       	brne	.-32     	; 0x20c2 <Endpoint_Read_Control_Stream_LE+0x34>
    20e2:	d8 cf       	rjmp	.-80     	; 0x2094 <Endpoint_Read_Control_Stream_LE+0x6>
		}
	}

	while (!(Endpoint_IsINReady()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    20e4:	80 91 d8 13 	lds	r24, 0x13D8

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    20e8:	88 23       	and	r24, r24
    20ea:	59 f0       	breq	.+22     	; 0x2102 <__stack+0x3>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    20ec:	85 30       	cpi	r24, 0x05	; 5
    20ee:	59 f0       	breq	.+22     	; 0x2106 <__stack+0x7>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    20f0:	80 91 e8 00 	lds	r24, 0x00E8

			Endpoint_ClearOUT();
		}
	}

	while (!(Endpoint_IsINReady()))
    20f4:	80 ff       	sbrs	r24, 0
    20f6:	f6 cf       	rjmp	.-20     	; 0x20e4 <Endpoint_Read_Control_Stream_LE+0x56>
    20f8:	02 c0       	rjmp	.+4      	; 0x20fe <Endpoint_Read_Control_Stream_LE+0x70>
		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
    20fa:	81 e0       	ldi	r24, 0x01	; 1
    20fc:	08 95       	ret
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
    20fe:	80 e0       	ldi	r24, 0x00	; 0
    2100:	08 95       	ret
	while (Length)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
    2102:	82 e0       	ldi	r24, 0x02	; 2
    2104:	08 95       	ret
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    2106:	83 e0       	ldi	r24, 0x03	; 3
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    2108:	08 95       	ret

0000210a <Endpoint_Write_Control_PStream_LE>:
                            uint16_t Length)
{
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
    210a:	20 91 df 13 	lds	r18, 0x13DF
    210e:	30 91 e0 13 	lds	r19, 0x13E0
    2112:	26 17       	cp	r18, r22
    2114:	37 07       	cpc	r19, r23
    2116:	48 f0       	brcs	.+18     	; 0x212a <Endpoint_Write_Control_PStream_LE+0x20>
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
    2118:	61 15       	cp	r22, r1
    211a:	71 05       	cpc	r23, r1
    211c:	39 f4       	brne	.+14     	; 0x212c <Endpoint_Write_Control_PStream_LE+0x22>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    211e:	20 91 e8 00 	lds	r18, 0x00E8
    2122:	2e 77       	andi	r18, 0x7E	; 126
    2124:	20 93 e8 00 	sts	0x00E8, r18
    2128:	01 c0       	rjmp	.+2      	; 0x212c <Endpoint_Write_Control_PStream_LE+0x22>
    212a:	b9 01       	movw	r22, r18
    212c:	fc 01       	movw	r30, r24
    212e:	20 e0       	ldi	r18, 0x00	; 0
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    2130:	61 15       	cp	r22, r1
    2132:	71 05       	cpc	r23, r1
    2134:	b1 f1       	breq	.+108    	; 0x21a2 <Endpoint_Write_Control_PStream_LE+0x98>
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    2136:	80 91 d8 13 	lds	r24, 0x13D8

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    213a:	88 23       	and	r24, r24
    213c:	09 f4       	brne	.+2      	; 0x2140 <Endpoint_Write_Control_PStream_LE+0x36>
    213e:	3f c0       	rjmp	.+126    	; 0x21be <Endpoint_Write_Control_PStream_LE+0xb4>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    2140:	85 30       	cpi	r24, 0x05	; 5
    2142:	09 f4       	brne	.+2      	; 0x2146 <Endpoint_Write_Control_PStream_LE+0x3c>
    2144:	3e c0       	rjmp	.+124    	; 0x21c2 <Endpoint_Write_Control_PStream_LE+0xb8>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    2146:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    214a:	83 fd       	sbrc	r24, 3
    214c:	3c c0       	rjmp	.+120    	; 0x21c6 <Endpoint_Write_Control_PStream_LE+0xbc>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    214e:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
    2152:	82 ff       	sbrs	r24, 2
    2154:	06 c0       	rjmp	.+12     	; 0x2162 <Endpoint_Write_Control_PStream_LE+0x58>
    2156:	80 91 e8 00 	lds	r24, 0x00E8
			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}

	while (!(Endpoint_IsOUTReceived()))
    215a:	82 ff       	sbrs	r24, 2
    215c:	25 c0       	rjmp	.+74     	; 0x21a8 <Endpoint_Write_Control_PStream_LE+0x9e>
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
	}

	return ENDPOINT_RWCSTREAM_NoError;
    215e:	80 e0       	ldi	r24, 0x00	; 0
    2160:	08 95       	ret
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    2162:	80 91 e8 00 	lds	r24, 0x00E8
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
		  break;

		if (Endpoint_IsINReady())
    2166:	80 ff       	sbrs	r24, 0
    2168:	e3 cf       	rjmp	.-58     	; 0x2130 <Endpoint_Write_Control_PStream_LE+0x26>
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					return UEBCX;
    216a:	80 91 f2 00 	lds	r24, 0x00F2
    216e:	90 91 f3 00 	lds	r25, 0x00F3
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    2172:	61 15       	cp	r22, r1
    2174:	71 05       	cpc	r23, r1
    2176:	59 f0       	breq	.+22     	; 0x218e <Endpoint_Write_Control_PStream_LE+0x84>
    2178:	88 30       	cpi	r24, 0x08	; 8
    217a:	91 05       	cpc	r25, r1
    217c:	40 f4       	brcc	.+16     	; 0x218e <Endpoint_Write_Control_PStream_LE+0x84>
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    217e:	24 91       	lpm	r18, Z
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    2180:	20 93 f1 00 	sts	0x00F1, r18
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
    2184:	31 96       	adiw	r30, 0x01	; 1
				Length--;
    2186:	61 50       	subi	r22, 0x01	; 1
    2188:	71 09       	sbc	r23, r1
				BytesInEndpoint++;
    218a:	01 96       	adiw	r24, 0x01	; 1
    218c:	f2 cf       	rjmp	.-28     	; 0x2172 <Endpoint_Write_Control_PStream_LE+0x68>
			}

			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
    218e:	21 e0       	ldi	r18, 0x01	; 1
    2190:	08 97       	sbiw	r24, 0x08	; 8
    2192:	09 f0       	breq	.+2      	; 0x2196 <Endpoint_Write_Control_PStream_LE+0x8c>
    2194:	20 e0       	ldi	r18, 0x00	; 0
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    2196:	80 91 e8 00 	lds	r24, 0x00E8
    219a:	8e 77       	andi	r24, 0x7E	; 126
    219c:	80 93 e8 00 	sts	0x00E8, r24
    21a0:	c7 cf       	rjmp	.-114    	; 0x2130 <Endpoint_Write_Control_PStream_LE+0x26>
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    21a2:	21 11       	cpse	r18, r1
    21a4:	c8 cf       	rjmp	.-112    	; 0x2136 <Endpoint_Write_Control_PStream_LE+0x2c>
    21a6:	d7 cf       	rjmp	.-82     	; 0x2156 <Endpoint_Write_Control_PStream_LE+0x4c>
		}
	}

	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    21a8:	80 91 d8 13 	lds	r24, 0x13D8

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    21ac:	88 23       	and	r24, r24
    21ae:	39 f0       	breq	.+14     	; 0x21be <Endpoint_Write_Control_PStream_LE+0xb4>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    21b0:	85 30       	cpi	r24, 0x05	; 5
    21b2:	39 f0       	breq	.+14     	; 0x21c2 <Endpoint_Write_Control_PStream_LE+0xb8>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    21b4:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    21b8:	83 ff       	sbrs	r24, 3
    21ba:	cd cf       	rjmp	.-102    	; 0x2156 <Endpoint_Write_Control_PStream_LE+0x4c>
    21bc:	04 c0       	rjmp	.+8      	; 0x21c6 <Endpoint_Write_Control_PStream_LE+0xbc>
	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
    21be:	82 e0       	ldi	r24, 0x02	; 2
    21c0:	08 95       	ret
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    21c2:	83 e0       	ldi	r24, 0x03	; 3
    21c4:	08 95       	ret
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
    21c6:	81 e0       	ldi	r24, 0x01	; 1
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    21c8:	08 95       	ret

000021ca <Endpoint_ConfigureEndpoint_Prv>:
	UECFG0X = UECFG0XData;
	UECFG1X = UECFG1XData;

	return Endpoint_IsConfigured();
#else
	for (uint8_t EPNum = Number; EPNum < ENDPOINT_TOTAL_ENDPOINTS; EPNum++)
    21ca:	98 2f       	mov	r25, r24
    21cc:	97 30       	cpi	r25, 0x07	; 7
    21ce:	58 f5       	brcc	.+86     	; 0x2226 <Endpoint_ConfigureEndpoint_Prv+0x5c>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    21d0:	90 93 e9 00 	sts	0x00E9, r25
		uint8_t UECFG1XTemp;
		uint8_t UEIENXTemp;

		Endpoint_SelectEndpoint(EPNum);

		if (EPNum == Number)
    21d4:	98 17       	cp	r25, r24
    21d6:	39 f0       	breq	.+14     	; 0x21e6 <Endpoint_ConfigureEndpoint_Prv+0x1c>
			UECFG1XTemp = UECFG1XData;
			UEIENXTemp  = 0;
		}
		else
		{
			UECFG0XTemp = UECFG0X;
    21d8:	70 91 ec 00 	lds	r23, 0x00EC
			UECFG1XTemp = UECFG1X;
    21dc:	20 91 ed 00 	lds	r18, 0x00ED
			UEIENXTemp  = UEIENX;
    21e0:	50 91 f0 00 	lds	r21, 0x00F0
    21e4:	03 c0       	rjmp	.+6      	; 0x21ec <Endpoint_ConfigureEndpoint_Prv+0x22>
		Endpoint_SelectEndpoint(EPNum);

		if (EPNum == Number)
		{
			UECFG0XTemp = UECFG0XData;
			UECFG1XTemp = UECFG1XData;
    21e6:	24 2f       	mov	r18, r20

		Endpoint_SelectEndpoint(EPNum);

		if (EPNum == Number)
		{
			UECFG0XTemp = UECFG0XData;
    21e8:	76 2f       	mov	r23, r22
			UECFG1XTemp = UECFG1XData;
			UEIENXTemp  = 0;
    21ea:	50 e0       	ldi	r21, 0x00	; 0
			UECFG0XTemp = UECFG0X;
			UECFG1XTemp = UECFG1X;
			UEIENXTemp  = UEIENX;
		}

		if (!(UECFG1XTemp & (1 << ALLOC)))
    21ec:	21 ff       	sbrs	r18, 1
    21ee:	19 c0       	rjmp	.+50     	; 0x2222 <Endpoint_ConfigureEndpoint_Prv+0x58>
			 *  to and from a host.
			 */
			static inline void Endpoint_DisableEndpoint(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_DisableEndpoint(void)
			{
				UECONX &= ~(1 << EPEN);
    21f0:	30 91 eb 00 	lds	r19, 0x00EB
    21f4:	3e 7f       	andi	r19, 0xFE	; 254
    21f6:	30 93 eb 00 	sts	0x00EB, r19
		  continue;

		Endpoint_DisableEndpoint();
		UECFG1X &= ~(1 << ALLOC);
    21fa:	30 91 ed 00 	lds	r19, 0x00ED
    21fe:	3d 7f       	andi	r19, 0xFD	; 253
    2200:	30 93 ed 00 	sts	0x00ED, r19
			 *  \note Endpoints must first be configured properly via \ref Endpoint_ConfigureEndpoint().
			 */
			static inline void Endpoint_EnableEndpoint(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_EnableEndpoint(void)
			{
				UECONX |= (1 << EPEN);
    2204:	30 91 eb 00 	lds	r19, 0x00EB
    2208:	31 60       	ori	r19, 0x01	; 1
    220a:	30 93 eb 00 	sts	0x00EB, r19

		Endpoint_EnableEndpoint();
		UECFG0X = UECFG0XTemp;
    220e:	70 93 ec 00 	sts	0x00EC, r23
		UECFG1X = UECFG1XTemp;
    2212:	20 93 ed 00 	sts	0x00ED, r18
		UEIENX  = UEIENXTemp;
    2216:	50 93 f0 00 	sts	0x00F0, r21
			 *  \return Boolean \c true if the currently selected endpoint has been configured, \c false otherwise.
			 */
			static inline bool Endpoint_IsConfigured(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsConfigured(void)
			{
				return ((UESTA0X & (1 << CFGOK)) ? true : false);
    221a:	20 91 ee 00 	lds	r18, 0x00EE

		if (!(Endpoint_IsConfigured()))
    221e:	27 ff       	sbrs	r18, 7
    2220:	07 c0       	rjmp	.+14     	; 0x2230 <Endpoint_ConfigureEndpoint_Prv+0x66>
	UECFG0X = UECFG0XData;
	UECFG1X = UECFG1XData;

	return Endpoint_IsConfigured();
#else
	for (uint8_t EPNum = Number; EPNum < ENDPOINT_TOTAL_ENDPOINTS; EPNum++)
    2222:	9f 5f       	subi	r25, 0xFF	; 255
    2224:	d3 cf       	rjmp	.-90     	; 0x21cc <Endpoint_ConfigureEndpoint_Prv+0x2>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    2226:	8f 70       	andi	r24, 0x0F	; 15
    2228:	80 93 e9 00 	sts	0x00E9, r24
		if (!(Endpoint_IsConfigured()))
		  return false;
	}

	Endpoint_SelectEndpoint(Number);
	return true;
    222c:	81 e0       	ldi	r24, 0x01	; 1
    222e:	08 95       	ret
		UECFG0X = UECFG0XTemp;
		UECFG1X = UECFG1XTemp;
		UEIENX  = UEIENXTemp;

		if (!(Endpoint_IsConfigured()))
		  return false;
    2230:	80 e0       	ldi	r24, 0x00	; 0
	}

	Endpoint_SelectEndpoint(Number);
	return true;
#endif
}
    2232:	08 95       	ret

00002234 <Endpoint_ClearStatusStage>:
	}
}

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
    2234:	80 91 d9 13 	lds	r24, 0x13D9
    2238:	87 fd       	sbrc	r24, 7
    223a:	05 c0       	rjmp	.+10     	; 0x2246 <Endpoint_ClearStatusStage+0x12>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    223c:	80 91 e8 00 	lds	r24, 0x00E8

		Endpoint_ClearOUT();
	}
	else
	{
		while (!(Endpoint_IsINReady()))
    2240:	80 ff       	sbrs	r24, 0
    2242:	0e c0       	rjmp	.+28     	; 0x2260 <Endpoint_ClearStatusStage+0x2c>
    2244:	12 c0       	rjmp	.+36     	; 0x226a <Endpoint_ClearStatusStage+0x36>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    2246:	80 91 e8 00 	lds	r24, 0x00E8

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
	{
		while (!(Endpoint_IsOUTReceived()))
    224a:	82 fd       	sbrc	r24, 2
    224c:	05 c0       	rjmp	.+10     	; 0x2258 <Endpoint_ClearStatusStage+0x24>
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    224e:	80 91 d8 13 	lds	r24, 0x13D8
    2252:	81 11       	cpse	r24, r1
    2254:	f8 cf       	rjmp	.-16     	; 0x2246 <Endpoint_ClearStatusStage+0x12>
    2256:	08 95       	ret
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    2258:	80 91 e8 00 	lds	r24, 0x00E8
    225c:	8b 77       	andi	r24, 0x7B	; 123
    225e:	08 c0       	rjmp	.+16     	; 0x2270 <Endpoint_ClearStatusStage+0x3c>
	}
	else
	{
		while (!(Endpoint_IsINReady()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    2260:	80 91 d8 13 	lds	r24, 0x13D8
    2264:	81 11       	cpse	r24, r1
    2266:	ea cf       	rjmp	.-44     	; 0x223c <Endpoint_ClearStatusStage+0x8>
    2268:	08 95       	ret
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    226a:	80 91 e8 00 	lds	r24, 0x00E8
    226e:	8e 77       	andi	r24, 0x7E	; 126
    2270:	80 93 e8 00 	sts	0x00E8, r24
    2274:	08 95       	ret

00002276 <Endpoint_WaitUntilReady>:
			 *  \return Current USB frame number from the USB controller.
			 */
			static inline uint16_t USB_Device_GetFrameNumber(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint16_t USB_Device_GetFrameNumber(void)
			{
				return UDFNUM;
    2276:	80 91 e4 00 	lds	r24, 0x00E4
    227a:	90 91 e5 00 	lds	r25, 0x00E5
    227e:	45 e6       	ldi	r20, 0x65	; 101
			 *  \return The currently selected endpoint's direction, as a \c ENDPOINT_DIR_* mask.
			 */
			static inline uint8_t Endpoint_GetEndpointDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetEndpointDirection(void)
			{
				return (UECFG0X & (1 << EPDIR)) ? ENDPOINT_DIR_IN : ENDPOINT_DIR_OUT;
    2280:	20 91 ec 00 	lds	r18, 0x00EC
    2284:	20 ff       	sbrs	r18, 0
    2286:	21 c0       	rjmp	.+66     	; 0x22ca <Endpoint_WaitUntilReady+0x54>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    2288:	20 91 e8 00 	lds	r18, 0x00E8

	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
		{
			if (Endpoint_IsINReady())
    228c:	20 fd       	sbrc	r18, 0
    228e:	21 c0       	rjmp	.+66     	; 0x22d2 <Endpoint_WaitUntilReady+0x5c>
		{
			if (Endpoint_IsOUTReceived())
			  return ENDPOINT_READYWAIT_NoError;
		}

		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    2290:	20 91 d8 13 	lds	r18, 0x13D8

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    2294:	22 23       	and	r18, r18
    2296:	89 f0       	breq	.+34     	; 0x22ba <Endpoint_WaitUntilReady+0x44>
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    2298:	25 30       	cpi	r18, 0x05	; 5
    229a:	89 f0       	breq	.+34     	; 0x22be <Endpoint_WaitUntilReady+0x48>
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    229c:	20 91 eb 00 	lds	r18, 0x00EB
		  return ENDPOINT_READYWAIT_BusSuspended;
		else if (Endpoint_IsStalled())
    22a0:	25 fd       	sbrc	r18, 5
    22a2:	0f c0       	rjmp	.+30     	; 0x22c2 <Endpoint_WaitUntilReady+0x4c>
    22a4:	20 91 e4 00 	lds	r18, 0x00E4
    22a8:	30 91 e5 00 	lds	r19, 0x00E5
		  return ENDPOINT_READYWAIT_EndpointStalled;

		uint16_t CurrentFrameNumber = USB_Device_GetFrameNumber();

		if (CurrentFrameNumber != PreviousFrameNumber)
    22ac:	28 17       	cp	r18, r24
    22ae:	39 07       	cpc	r19, r25
    22b0:	39 f3       	breq	.-50     	; 0x2280 <Endpoint_WaitUntilReady+0xa>
    22b2:	41 50       	subi	r20, 0x01	; 1
		{
			PreviousFrameNumber = CurrentFrameNumber;

			if (!(TimeoutMSRem--))
    22b4:	41 f0       	breq	.+16     	; 0x22c6 <Endpoint_WaitUntilReady+0x50>
    22b6:	c9 01       	movw	r24, r18
    22b8:	e3 cf       	rjmp	.-58     	; 0x2280 <Endpoint_WaitUntilReady+0xa>
		}

		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
    22ba:	82 e0       	ldi	r24, 0x02	; 2
    22bc:	08 95       	ret
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_READYWAIT_BusSuspended;
    22be:	83 e0       	ldi	r24, 0x03	; 3
    22c0:	08 95       	ret
		else if (Endpoint_IsStalled())
		  return ENDPOINT_READYWAIT_EndpointStalled;
    22c2:	81 e0       	ldi	r24, 0x01	; 1
    22c4:	08 95       	ret
		if (CurrentFrameNumber != PreviousFrameNumber)
		{
			PreviousFrameNumber = CurrentFrameNumber;

			if (!(TimeoutMSRem--))
			  return ENDPOINT_READYWAIT_Timeout;
    22c6:	84 e0       	ldi	r24, 0x04	; 4
    22c8:	08 95       	ret
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    22ca:	20 91 e8 00 	lds	r18, 0x00E8
			if (Endpoint_IsINReady())
			  return ENDPOINT_READYWAIT_NoError;
		}
		else
		{
			if (Endpoint_IsOUTReceived())
    22ce:	22 ff       	sbrs	r18, 2
    22d0:	df cf       	rjmp	.-66     	; 0x2290 <Endpoint_WaitUntilReady+0x1a>
	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
		{
			if (Endpoint_IsINReady())
			  return ENDPOINT_READYWAIT_NoError;
    22d2:	80 e0       	ldi	r24, 0x00	; 0
    22d4:	08 95       	ret

000022d6 <USB_ResetInterface>:

	USB_IsInitialized = false;
}

void USB_ResetInterface(void)
{
    22d6:	0f 93       	push	r16
    22d8:	1f 93       	push	r17
    22da:	cf 93       	push	r28
    22dc:	df 93       	push	r29
	#if defined(USB_CAN_BE_BOTH)
	bool UIDModeSelectEnabled = ((UHWCON & (1 << UIDE)) != 0);
	#endif

	USB_INT_DisableAllInterrupts();
    22de:	4e d0       	rcall	.+156    	; 0x237c <USB_INT_DisableAllInterrupts>
    22e0:	55 d0       	rcall	.+170    	; 0x238c <USB_INT_ClearAllInterrupts>
	USB_INT_ClearAllInterrupts();
    22e2:	c8 ed       	ldi	r28, 0xD8	; 216
    22e4:	d0 e0       	ldi	r29, 0x00	; 0
			}

			static inline void USB_Controller_Reset(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Controller_Reset(void)
			{
				USBCON &= ~(1 << USBE);
    22e6:	88 81       	ld	r24, Y
    22e8:	8f 77       	andi	r24, 0x7F	; 127
    22ea:	88 83       	st	Y, r24
    22ec:	88 81       	ld	r24, Y
    22ee:	80 68       	ori	r24, 0x80	; 128
				USBCON |=  (1 << USBE);
    22f0:	88 83       	st	Y, r24
    22f2:	88 81       	ld	r24, Y
    22f4:	8f 7d       	andi	r24, 0xDF	; 223
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON &= ~(1 << FRZCLK);
    22f6:	88 83       	st	Y, r24
    22f8:	e7 ed       	ldi	r30, 0xD7	; 215
    22fa:	f0 e0       	ldi	r31, 0x00	; 0

	if (USB_CurrentMode == USB_MODE_Device)
	{
		#if defined(USB_CAN_BE_DEVICE)
		#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
		UHWCON |=  (1 << UIMOD);
    22fc:	80 81       	ld	r24, Z
    22fe:	80 68       	ori	r24, 0x80	; 128
    2300:	80 83       	st	Z, r24
    2302:	19 bc       	out	0x29, r1	; 41
    2304:	10 92 d8 13 	sts	0x13D8, r1
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_Init_Device(void)
{
	USB_DeviceState                 = DEVICE_STATE_Unattached;
    2308:	10 92 d4 13 	sts	0x13D4, r1
	USB_Device_ConfigurationNumber  = 0;
    230c:	10 92 d6 13 	sts	0x13D6, r1

	#if !defined(NO_DEVICE_REMOTE_WAKEUP)
	USB_Device_RemoteWakeupEnabled  = false;
    2310:	10 92 d5 13 	sts	0x13D5, r1
	#endif

	#if !defined(NO_DEVICE_SELF_POWER)
	USB_Device_CurrentlySelfPowered = false;
    2314:	00 ee       	ldi	r16, 0xE0	; 224
    2316:	10 e0       	ldi	r17, 0x00	; 0
			}

			static inline void USB_Device_SetFullSpeed(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetFullSpeed(void)
			{
				UDCON &= ~(1 << LSM);
    2318:	f8 01       	movw	r30, r16
    231a:	80 81       	ld	r24, Z
    231c:	8b 7f       	andi	r24, 0xFB	; 251
    231e:	80 83       	st	Z, r24
    2320:	88 81       	ld	r24, Y
    2322:	81 60       	ori	r24, 0x01	; 1
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						USBCON |= (1 << VBUSTE);
    2324:	88 83       	st	Y, r24
    2326:	42 e0       	ldi	r20, 0x02	; 2
    2328:	60 e0       	ldi	r22, 0x00	; 0
				uint8_t Number = (Address & ENDPOINT_EPNUM_MASK);

				if (Number >= ENDPOINT_TOTAL_ENDPOINTS)
				  return false;

				return Endpoint_ConfigureEndpoint_Prv(Number,
    232a:	80 e0       	ldi	r24, 0x00	; 0
    232c:	4e df       	rcall	.-356    	; 0x21ca <Endpoint_ConfigureEndpoint_Prv>
    232e:	e1 ee       	ldi	r30, 0xE1	; 225
    2330:	f0 e0       	ldi	r31, 0x00	; 0
    2332:	80 81       	ld	r24, Z
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
    2334:	8e 7f       	andi	r24, 0xFE	; 254
    2336:	80 83       	st	Z, r24
    2338:	e2 ee       	ldi	r30, 0xE2	; 226
    233a:	f0 e0       	ldi	r31, 0x00	; 0
    233c:	80 81       	ld	r24, Z
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  |= (1 << SUSPE);
    233e:	81 60       	ori	r24, 0x01	; 1
    2340:	80 83       	st	Z, r24
    2342:	80 81       	ld	r24, Z
    2344:	88 60       	ori	r24, 0x08	; 8
    2346:	80 83       	st	Z, r24
						break;
					case USB_INT_EORSTI:
						UDIEN  |= (1 << EORSTE);
    2348:	f8 01       	movw	r30, r16
    234a:	80 81       	ld	r24, Z
    234c:	8e 7f       	andi	r24, 0xFE	; 254
			 *  register and despite the datasheet making no mention of its requirement in host mode.
			 */
			static inline void USB_Attach(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Attach(void)
			{
				UDCON  &= ~(1 << DETACH);
    234e:	80 83       	st	Z, r24
    2350:	88 81       	ld	r24, Y
    2352:	80 61       	ori	r24, 0x10	; 16
    2354:	88 83       	st	Y, r24

			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
			static inline void USB_OTGPAD_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_OTGPAD_On(void)
			{
				USBCON |=  (1 << OTGPADE);
    2356:	df 91       	pop	r29
    2358:	cf 91       	pop	r28
    235a:	1f 91       	pop	r17
	}

	#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
	USB_OTGPAD_On();
	#endif
}
    235c:	0f 91       	pop	r16
    235e:	08 95       	ret

00002360 <USB_Init>:
    2360:	e8 ed       	ldi	r30, 0xD8	; 216
    2362:	f0 e0       	ldi	r31, 0x00	; 0
    2364:	80 81       	ld	r24, Z
			}

			static inline void USB_OTGPAD_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_OTGPAD_Off(void)
			{
				USBCON &= ~(1 << OTGPADE);
    2366:	8f 7e       	andi	r24, 0xEF	; 239
    2368:	80 83       	st	Z, r24

			static inline void USB_REG_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_REG_On(void)
			{
			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
				UHWCON |=  (1 << UVREGE);
    236a:	e7 ed       	ldi	r30, 0xD7	; 215
    236c:	f0 e0       	ldi	r31, 0x00	; 0
    236e:	80 81       	ld	r24, Z
    2370:	81 60       	ori	r24, 0x01	; 1
    2372:	80 83       	st	Z, r24
		UHWCON &= ~(1 << UIDE);
		USB_CurrentMode = Mode;
	}
	#endif

	USB_IsInitialized = true;
    2374:	81 e0       	ldi	r24, 0x01	; 1
    2376:	80 93 d7 13 	sts	0x13D7, r24

	USB_ResetInterface();
    237a:	ad cf       	rjmp	.-166    	; 0x22d6 <USB_ResetInterface>

0000237c <USB_INT_DisableAllInterrupts>:
    237c:	e8 ed       	ldi	r30, 0xD8	; 216
#include "../USBInterrupt.h"

void USB_INT_DisableAllInterrupts(void)
{
	#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBCON &= ~((1 << VBUSTE) | (1 << IDTE));
    237e:	f0 e0       	ldi	r31, 0x00	; 0
    2380:	80 81       	ld	r24, Z
    2382:	8c 7f       	andi	r24, 0xFC	; 252
    2384:	80 83       	st	Z, r24
	#if defined(USB_CAN_BE_HOST)
	UHIEN   = 0;
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDIEN   = 0;
    2386:	10 92 e2 00 	sts	0x00E2, r1
    238a:	08 95       	ret

0000238c <USB_INT_ClearAllInterrupts>:
}

void USB_INT_ClearAllInterrupts(void)
{
	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBINT = 0;
    238c:	10 92 da 00 	sts	0x00DA, r1
	#if defined(USB_CAN_BE_HOST)
	UHINT  = 0;
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDINT  = 0;
    2390:	10 92 e1 00 	sts	0x00E1, r1
    2394:	08 95       	ret

00002396 <__vector_10>:
	#endif
}

ISR(USB_GEN_vect, ISR_BLOCK)
{
    2396:	1f 92       	push	r1
    2398:	0f 92       	push	r0
    239a:	0f b6       	in	r0, 0x3f	; 63
    239c:	0f 92       	push	r0
    239e:	11 24       	eor	r1, r1
    23a0:	0b b6       	in	r0, 0x3b	; 59
    23a2:	0f 92       	push	r0
    23a4:	2f 93       	push	r18
    23a6:	3f 93       	push	r19
    23a8:	4f 93       	push	r20
    23aa:	5f 93       	push	r21
    23ac:	6f 93       	push	r22
    23ae:	7f 93       	push	r23
    23b0:	8f 93       	push	r24
    23b2:	9f 93       	push	r25
    23b4:	af 93       	push	r26
    23b6:	bf 93       	push	r27
    23b8:	ef 93       	push	r30
    23ba:	ff 93       	push	r31
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
					case USB_INT_EORSTI:
						return (UDINT  & (1 << EORSTI));
					case USB_INT_SOFI:
						return (UDINT  & (1 << SOFI));
    23bc:	80 91 e1 00 	lds	r24, 0x00E1
	#if defined(USB_CAN_BE_DEVICE)
	#if !defined(NO_SOF_EVENTS)
	if (USB_INT_HasOccurred(USB_INT_SOFI) && USB_INT_IsEnabled(USB_INT_SOFI))
    23c0:	82 ff       	sbrs	r24, 2
    23c2:	0a c0       	rjmp	.+20     	; 0x23d8 <__vector_10+0x42>
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
					case USB_INT_EORSTI:
						return (UDIEN  & (1 << EORSTE));
					case USB_INT_SOFI:
						return (UDIEN  & (1 << SOFE));
    23c4:	80 91 e2 00 	lds	r24, 0x00E2
    23c8:	82 ff       	sbrs	r24, 2
    23ca:	06 c0       	rjmp	.+12     	; 0x23d8 <__vector_10+0x42>
						break;
					case USB_INT_EORSTI:
						UDINT  &= ~(1 << EORSTI);
						break;
					case USB_INT_SOFI:
						UDINT  &= ~(1 << SOFI);
    23cc:	80 91 e1 00 	lds	r24, 0x00E1
    23d0:	8b 7f       	andi	r24, 0xFB	; 251
    23d2:	80 93 e1 00 	sts	0x00E1, r24
	{
		USB_INT_Clear(USB_INT_SOFI);

		EVENT_USB_Device_StartOfFrame();
    23d6:	ff d1       	rcall	.+1022   	; 0x27d6 <USB_Event_Stub>
    23d8:	80 91 da 00 	lds	r24, 0x00DA
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						return (USBINT & (1 << VBUSTI));
    23dc:	80 ff       	sbrs	r24, 0
	}
	#endif

	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	if (USB_INT_HasOccurred(USB_INT_VBUSTI) && USB_INT_IsEnabled(USB_INT_VBUSTI))
    23de:	1f c0       	rjmp	.+62     	; 0x241e <__vector_10+0x88>
    23e0:	80 91 d8 00 	lds	r24, 0x00D8
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						return (USBCON & (1 << VBUSTE));
    23e4:	80 ff       	sbrs	r24, 0
    23e6:	1b c0       	rjmp	.+54     	; 0x241e <__vector_10+0x88>
    23e8:	80 91 da 00 	lds	r24, 0x00DA
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						USBINT &= ~(1 << VBUSTI);
    23ec:	8e 7f       	andi	r24, 0xFE	; 254
    23ee:	80 93 da 00 	sts	0x00DA, r24
    23f2:	80 91 d9 00 	lds	r24, 0x00D9
				 *  \return Boolean \c true if the VBUS line is currently detecting power from a host, \c false otherwise.
				 */
				static inline bool USB_VBUS_GetStatus(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
				static inline bool USB_VBUS_GetStatus(void)
				{
					return ((USBSTA & (1 << VBUS)) ? true : false);
    23f6:	80 ff       	sbrs	r24, 0
	{
		USB_INT_Clear(USB_INT_VBUSTI);

		if (USB_VBUS_GetStatus())
    23f8:	0d c0       	rjmp	.+26     	; 0x2414 <__vector_10+0x7e>
    23fa:	8c e0       	ldi	r24, 0x0C	; 12

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR = USB_PLL_PSC;
    23fc:	89 bd       	out	0x29, r24	; 41
    23fe:	8e e0       	ldi	r24, 0x0E	; 14
				PLLCSR = (USB_PLL_PSC | (1 << PLLE));
    2400:	89 bd       	out	0x29, r24	; 41
    2402:	09 b4       	in	r0, 0x29	; 41
		{
			if (!(USB_Options & USB_OPT_MANUAL_PLL))
			{
				USB_PLL_On();
				while (!(USB_PLL_IsReady()));
    2404:	00 fe       	sbrs	r0, 0
    2406:	fd cf       	rjmp	.-6      	; 0x2402 <__vector_10+0x6c>
    2408:	81 e0       	ldi	r24, 0x01	; 1
			}

			USB_DeviceState = DEVICE_STATE_Powered;
    240a:	80 93 d8 13 	sts	0x13D8, r24
    240e:	0e 94 72 02 	call	0x4e4	; 0x4e4 <EVENT_USB_Device_Connect>
			EVENT_USB_Device_Connect();
    2412:	05 c0       	rjmp	.+10     	; 0x241e <__vector_10+0x88>
    2414:	19 bc       	out	0x29, r1	; 41
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    2416:	10 92 d8 13 	sts	0x13D8, r1
		else
		{
			if (!(USB_Options & USB_OPT_MANUAL_PLL))
			  USB_PLL_Off();

			USB_DeviceState = DEVICE_STATE_Unattached;
    241a:	0e 94 74 02 	call	0x4e8	; 0x4e8 <EVENT_USB_Device_Disconnect>
			EVENT_USB_Device_Disconnect();
    241e:	80 91 e1 00 	lds	r24, 0x00E1
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
    2422:	80 ff       	sbrs	r24, 0
		}
	}
	#endif

	if (USB_INT_HasOccurred(USB_INT_SUSPI) && USB_INT_IsEnabled(USB_INT_SUSPI))
    2424:	18 c0       	rjmp	.+48     	; 0x2456 <__vector_10+0xc0>
    2426:	80 91 e2 00 	lds	r24, 0x00E2
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
    242a:	80 ff       	sbrs	r24, 0
    242c:	14 c0       	rjmp	.+40     	; 0x2456 <__vector_10+0xc0>
    242e:	80 91 e2 00 	lds	r24, 0x00E2
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  &= ~(1 << SUSPE);
    2432:	8e 7f       	andi	r24, 0xFE	; 254
    2434:	80 93 e2 00 	sts	0x00E2, r24
    2438:	80 91 e2 00 	lds	r24, 0x00E2
						USBCON |= (1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
    243c:	80 61       	ori	r24, 0x10	; 16
    243e:	80 93 e2 00 	sts	0x00E2, r24
    2442:	80 91 d8 00 	lds	r24, 0x00D8
			#endif

			static inline void USB_CLK_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Freeze(void)
			{
				USBCON |=  (1 << FRZCLK);
    2446:	80 62       	ori	r24, 0x20	; 32
    2448:	80 93 d8 00 	sts	0x00D8, r24
    244c:	19 bc       	out	0x29, r1	; 41
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    244e:	85 e0       	ldi	r24, 0x05	; 5

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		USB_DeviceState = DEVICE_STATE_Unattached;
		EVENT_USB_Device_Disconnect();
		#else
		USB_DeviceState = DEVICE_STATE_Suspended;
    2450:	80 93 d8 13 	sts	0x13D8, r24
    2454:	c0 d1       	rcall	.+896    	; 0x27d6 <USB_Event_Stub>
		EVENT_USB_Device_Suspend();
    2456:	80 91 e1 00 	lds	r24, 0x00E1
					case USB_INT_IDTI:
						return (USBINT & (1 << IDTI));
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
    245a:	84 ff       	sbrs	r24, 4
    245c:	2f c0       	rjmp	.+94     	; 0x24bc <__vector_10+0x126>
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_WAKEUPI) && USB_INT_IsEnabled(USB_INT_WAKEUPI))
    245e:	80 91 e2 00 	lds	r24, 0x00E2
					case USB_INT_IDTI:
						return (USBCON & (1 << IDTE));
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
    2462:	84 ff       	sbrs	r24, 4
    2464:	2b c0       	rjmp	.+86     	; 0x24bc <__vector_10+0x126>
    2466:	8c e0       	ldi	r24, 0x0C	; 12
    2468:	89 bd       	out	0x29, r24	; 41

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR = USB_PLL_PSC;
    246a:	8e e0       	ldi	r24, 0x0E	; 14
    246c:	89 bd       	out	0x29, r24	; 41
				PLLCSR = (USB_PLL_PSC | (1 << PLLE));
    246e:	09 b4       	in	r0, 0x29	; 41
    2470:	00 fe       	sbrs	r0, 0
	{
		if (!(USB_Options & USB_OPT_MANUAL_PLL))
		{
			USB_PLL_On();
			while (!(USB_PLL_IsReady()));
    2472:	fd cf       	rjmp	.-6      	; 0x246e <__vector_10+0xd8>
    2474:	80 91 d8 00 	lds	r24, 0x00D8
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON &= ~(1 << FRZCLK);
    2478:	8f 7d       	andi	r24, 0xDF	; 223
    247a:	80 93 d8 00 	sts	0x00D8, r24
    247e:	80 91 e1 00 	lds	r24, 0x00E1
						USBINT &= ~(1 << IDTI);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
    2482:	8f 7e       	andi	r24, 0xEF	; 239
    2484:	80 93 e1 00 	sts	0x00E1, r24
    2488:	80 91 e2 00 	lds	r24, 0x00E2
						USBCON &= ~(1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
    248c:	8f 7e       	andi	r24, 0xEF	; 239
    248e:	80 93 e2 00 	sts	0x00E2, r24
    2492:	80 91 e2 00 	lds	r24, 0x00E2
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  |= (1 << SUSPE);
    2496:	81 60       	ori	r24, 0x01	; 1
    2498:	80 93 e2 00 	sts	0x00E2, r24
    249c:	80 91 d4 13 	lds	r24, 0x13D4
		USB_INT_Clear(USB_INT_WAKEUPI);

		USB_INT_Disable(USB_INT_WAKEUPI);
		USB_INT_Enable(USB_INT_SUSPI);

		if (USB_Device_ConfigurationNumber)
    24a0:	88 23       	and	r24, r24
    24a2:	11 f0       	breq	.+4      	; 0x24a8 <__vector_10+0x112>
    24a4:	84 e0       	ldi	r24, 0x04	; 4
    24a6:	07 c0       	rjmp	.+14     	; 0x24b6 <__vector_10+0x120>
		  USB_DeviceState = DEVICE_STATE_Configured;
    24a8:	80 91 e3 00 	lds	r24, 0x00E3
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
    24ac:	87 ff       	sbrs	r24, 7
    24ae:	02 c0       	rjmp	.+4      	; 0x24b4 <__vector_10+0x11e>
		else
		  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Addressed : DEVICE_STATE_Powered;
    24b0:	83 e0       	ldi	r24, 0x03	; 3
    24b2:	01 c0       	rjmp	.+2      	; 0x24b6 <__vector_10+0x120>
    24b4:	81 e0       	ldi	r24, 0x01	; 1
    24b6:	80 93 d8 13 	sts	0x13D8, r24
    24ba:	8d d1       	rcall	.+794    	; 0x27d6 <USB_Event_Stub>
    24bc:	80 91 e1 00 	lds	r24, 0x00E1

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		EVENT_USB_Device_Connect();
		#else
		EVENT_USB_Device_WakeUp();
    24c0:	83 ff       	sbrs	r24, 3
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
					case USB_INT_EORSTI:
						return (UDINT  & (1 << EORSTI));
    24c2:	22 c0       	rjmp	.+68     	; 0x2508 <__vector_10+0x172>
    24c4:	80 91 e2 00 	lds	r24, 0x00E2
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_EORSTI) && USB_INT_IsEnabled(USB_INT_EORSTI))
    24c8:	83 ff       	sbrs	r24, 3
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
					case USB_INT_EORSTI:
						return (UDIEN  & (1 << EORSTE));
    24ca:	1e c0       	rjmp	.+60     	; 0x2508 <__vector_10+0x172>
    24cc:	80 91 e1 00 	lds	r24, 0x00E1
    24d0:	87 7f       	andi	r24, 0xF7	; 247
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
						break;
					case USB_INT_EORSTI:
						UDINT  &= ~(1 << EORSTI);
    24d2:	80 93 e1 00 	sts	0x00E1, r24
    24d6:	82 e0       	ldi	r24, 0x02	; 2
    24d8:	80 93 d8 13 	sts	0x13D8, r24
	{
		USB_INT_Clear(USB_INT_EORSTI);

		USB_DeviceState                = DEVICE_STATE_Default;
    24dc:	10 92 d4 13 	sts	0x13D4, r1
    24e0:	80 91 e1 00 	lds	r24, 0x00E1
		USB_Device_ConfigurationNumber = 0;
    24e4:	8e 7f       	andi	r24, 0xFE	; 254
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
    24e6:	80 93 e1 00 	sts	0x00E1, r24
    24ea:	80 91 e2 00 	lds	r24, 0x00E2
    24ee:	8e 7f       	andi	r24, 0xFE	; 254
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  &= ~(1 << SUSPE);
    24f0:	80 93 e2 00 	sts	0x00E2, r24
    24f4:	80 91 e2 00 	lds	r24, 0x00E2
    24f8:	80 61       	ori	r24, 0x10	; 16
						USBCON |= (1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
    24fa:	80 93 e2 00 	sts	0x00E2, r24
    24fe:	42 e0       	ldi	r20, 0x02	; 2
    2500:	60 e0       	ldi	r22, 0x00	; 0
    2502:	80 e0       	ldi	r24, 0x00	; 0
				uint8_t Number = (Address & ENDPOINT_EPNUM_MASK);

				if (Number >= ENDPOINT_TOTAL_ENDPOINTS)
				  return false;

				return Endpoint_ConfigureEndpoint_Prv(Number,
    2504:	62 de       	rcall	.-828    	; 0x21ca <Endpoint_ConfigureEndpoint_Prv>
    2506:	67 d1       	rcall	.+718    	; 0x27d6 <USB_Event_Stub>
    2508:	ff 91       	pop	r31
    250a:	ef 91       	pop	r30
    250c:	bf 91       	pop	r27

		#if defined(INTERRUPT_CONTROL_ENDPOINT)
		USB_INT_Enable(USB_INT_RXSTPI);
		#endif

		EVENT_USB_Device_Reset();
    250e:	af 91       	pop	r26
    2510:	9f 91       	pop	r25
		USB_ResetInterface();

		EVENT_USB_UIDChange();
	}
	#endif
}
    2512:	8f 91       	pop	r24
    2514:	7f 91       	pop	r23
    2516:	6f 91       	pop	r22
    2518:	5f 91       	pop	r21
    251a:	4f 91       	pop	r20
    251c:	3f 91       	pop	r19
    251e:	2f 91       	pop	r18
    2520:	0f 90       	pop	r0
    2522:	0b be       	out	0x3b, r0	; 59
    2524:	0f 90       	pop	r0
    2526:	0f be       	out	0x3f, r0	; 63
    2528:	0f 90       	pop	r0
    252a:	1f 90       	pop	r1
    252c:	18 95       	reti

0000252e <USB_Device_ProcessControlRequest>:
    252e:	1f 93       	push	r17
    2530:	cf 93       	push	r28
    2532:	df 93       	push	r29
    2534:	cd b7       	in	r28, 0x3d	; 61
    2536:	de b7       	in	r29, 0x3e	; 62
#if !defined(NO_DEVICE_REMOTE_WAKEUP)
bool    USB_Device_RemoteWakeupEnabled;
#endif

void USB_Device_ProcessControlRequest(void)
{
    2538:	aa 97       	sbiw	r28, 0x2a	; 42
    253a:	0f b6       	in	r0, 0x3f	; 63
    253c:	f8 94       	cli
    253e:	de bf       	out	0x3e, r29	; 62
    2540:	0f be       	out	0x3f, r0	; 63
    2542:	cd bf       	out	0x3d, r28	; 61
    2544:	e9 ed       	ldi	r30, 0xD9	; 217
    2546:	f3 e1       	ldi	r31, 0x13	; 19
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    2548:	80 91 f1 00 	lds	r24, 0x00F1
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
	  *(RequestHeader++) = Endpoint_Read_8();
    254c:	81 93       	st	Z+, r24
	USB_ControlRequest.wIndex        = Endpoint_Read_16_LE();
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
    254e:	23 e1       	ldi	r18, 0x13	; 19
    2550:	e1 3e       	cpi	r30, 0xE1	; 225
    2552:	f2 07       	cpc	r31, r18
    2554:	c9 f7       	brne	.-14     	; 0x2548 <USB_Device_ProcessControlRequest+0x1a>
	  *(RequestHeader++) = Endpoint_Read_8();
	#endif

	EVENT_USB_Device_ControlRequest();
    2556:	0e 94 93 02 	call	0x526	; 0x526 <EVENT_USB_Device_ControlRequest>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    255a:	80 91 e8 00 	lds	r24, 0x00E8

	if (Endpoint_IsSETUPReceived())
    255e:	83 ff       	sbrs	r24, 3
    2560:	22 c1       	rjmp	.+580    	; 0x27a6 <USB_Device_ProcessControlRequest+0x278>
	{
		uint8_t bmRequestType = USB_ControlRequest.bmRequestType;
    2562:	90 91 d9 13 	lds	r25, 0x13D9

		switch (USB_ControlRequest.bRequest)
    2566:	80 91 da 13 	lds	r24, 0x13DA
    256a:	85 30       	cpi	r24, 0x05	; 5
    256c:	09 f4       	brne	.+2      	; 0x2570 <USB_Device_ProcessControlRequest+0x42>
    256e:	77 c0       	rjmp	.+238    	; 0x265e <USB_Device_ProcessControlRequest+0x130>
    2570:	30 f4       	brcc	.+12     	; 0x257e <USB_Device_ProcessControlRequest+0x50>
    2572:	81 30       	cpi	r24, 0x01	; 1
    2574:	81 f1       	breq	.+96     	; 0x25d6 <USB_Device_ProcessControlRequest+0xa8>
    2576:	68 f0       	brcs	.+26     	; 0x2592 <USB_Device_ProcessControlRequest+0x64>
    2578:	83 30       	cpi	r24, 0x03	; 3
    257a:	69 f1       	breq	.+90     	; 0x25d6 <USB_Device_ProcessControlRequest+0xa8>
    257c:	14 c1       	rjmp	.+552    	; 0x27a6 <USB_Device_ProcessControlRequest+0x278>
    257e:	88 30       	cpi	r24, 0x08	; 8
    2580:	09 f4       	brne	.+2      	; 0x2584 <USB_Device_ProcessControlRequest+0x56>
    2582:	e2 c0       	rjmp	.+452    	; 0x2748 <USB_Device_ProcessControlRequest+0x21a>
    2584:	89 30       	cpi	r24, 0x09	; 9
    2586:	09 f4       	brne	.+2      	; 0x258a <USB_Device_ProcessControlRequest+0x5c>
    2588:	f1 c0       	rjmp	.+482    	; 0x276c <USB_Device_ProcessControlRequest+0x23e>
    258a:	86 30       	cpi	r24, 0x06	; 6
    258c:	09 f0       	breq	.+2      	; 0x2590 <USB_Device_ProcessControlRequest+0x62>
    258e:	0b c1       	rjmp	.+534    	; 0x27a6 <USB_Device_ProcessControlRequest+0x278>
    2590:	88 c0       	rjmp	.+272    	; 0x26a2 <USB_Device_ProcessControlRequest+0x174>
		{
			case REQ_GetStatus:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    2592:	90 38       	cpi	r25, 0x80	; 128
    2594:	81 f0       	breq	.+32     	; 0x25b6 <USB_Device_ProcessControlRequest+0x88>
    2596:	92 38       	cpi	r25, 0x82	; 130
    2598:	09 f0       	breq	.+2      	; 0x259c <USB_Device_ProcessControlRequest+0x6e>
    259a:	05 c1       	rjmp	.+522    	; 0x27a6 <USB_Device_ProcessControlRequest+0x278>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    259c:	80 91 dd 13 	lds	r24, 0x13DD
    25a0:	8f 70       	andi	r24, 0x0F	; 15
    25a2:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    25a6:	80 91 eb 00 	lds	r24, 0x00EB
    25aa:	85 fb       	bst	r24, 5
    25ac:	88 27       	eor	r24, r24
    25ae:	80 f9       	bld	r24, 0
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    25b0:	10 92 e9 00 	sts	0x00E9, r1
    25b4:	06 c0       	rjmp	.+12     	; 0x25c2 <USB_Device_ProcessControlRequest+0x94>
	Endpoint_ClearOUT();
}

static void USB_Device_GetStatus(void)
{
	uint8_t CurrentStatus = 0;
    25b6:	80 91 d5 13 	lds	r24, 0x13D5
			if (USB_Device_CurrentlySelfPowered)
			  CurrentStatus |= FEATURE_SELFPOWERED_ENABLED;
			#endif

			#if !defined(NO_DEVICE_REMOTE_WAKEUP)
			if (USB_Device_RemoteWakeupEnabled)
    25ba:	90 91 d6 13 	lds	r25, 0x13D6
    25be:	91 11       	cpse	r25, r1
			  CurrentStatus |= FEATURE_REMOTE_WAKEUP_ENABLED;
    25c0:	82 60       	ori	r24, 0x02	; 2
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    25c2:	90 91 e8 00 	lds	r25, 0x00E8
    25c6:	97 7f       	andi	r25, 0xF7	; 247
    25c8:	90 93 e8 00 	sts	0x00E8, r25
			 *  \param[in] Data  Data to write to the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_16_LE(const uint16_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_16_LE(const uint16_t Data)
			{
				UEDATX = (Data & 0xFF);
    25cc:	80 93 f1 00 	sts	0x00F1, r24
				UEDATX = (Data >> 8);
    25d0:	10 92 f1 00 	sts	0x00F1, r1
    25d4:	c4 c0       	rjmp	.+392    	; 0x275e <USB_Device_ProcessControlRequest+0x230>
				}

				break;
			case REQ_ClearFeature:
			case REQ_SetFeature:
				if ((bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    25d6:	29 2f       	mov	r18, r25
    25d8:	2d 7f       	andi	r18, 0xFD	; 253
    25da:	09 f0       	breq	.+2      	; 0x25de <USB_Device_ProcessControlRequest+0xb0>
    25dc:	e4 c0       	rjmp	.+456    	; 0x27a6 <USB_Device_ProcessControlRequest+0x278>
	Endpoint_ClearStatusStage();
}

static void USB_Device_ClearSetFeature(void)
{
	switch (USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_RECIPIENT)
    25de:	99 23       	and	r25, r25
    25e0:	19 f0       	breq	.+6      	; 0x25e8 <USB_Device_ProcessControlRequest+0xba>
    25e2:	92 30       	cpi	r25, 0x02	; 2
    25e4:	61 f0       	breq	.+24     	; 0x25fe <USB_Device_ProcessControlRequest+0xd0>
    25e6:	df c0       	rjmp	.+446    	; 0x27a6 <USB_Device_ProcessControlRequest+0x278>
	{
		#if !defined(NO_DEVICE_REMOTE_WAKEUP)
		case REQREC_DEVICE:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_DeviceRemoteWakeup)
    25e8:	90 91 db 13 	lds	r25, 0x13DB
    25ec:	91 30       	cpi	r25, 0x01	; 1
    25ee:	09 f0       	breq	.+2      	; 0x25f2 <USB_Device_ProcessControlRequest+0xc4>
    25f0:	da c0       	rjmp	.+436    	; 0x27a6 <USB_Device_ProcessControlRequest+0x278>
			  USB_Device_RemoteWakeupEnabled = (USB_ControlRequest.bRequest == REQ_SetFeature);
    25f2:	83 30       	cpi	r24, 0x03	; 3
    25f4:	09 f0       	breq	.+2      	; 0x25f8 <USB_Device_ProcessControlRequest+0xca>
    25f6:	90 e0       	ldi	r25, 0x00	; 0
    25f8:	90 93 d6 13 	sts	0x13D6, r25
    25fc:	2a c0       	rjmp	.+84     	; 0x2652 <USB_Device_ProcessControlRequest+0x124>

			break;
		#endif
		#if !defined(CONTROL_ONLY_DEVICE)
		case REQREC_ENDPOINT:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_EndpointHalt)
    25fe:	90 91 db 13 	lds	r25, 0x13DB
    2602:	91 11       	cpse	r25, r1
    2604:	26 c0       	rjmp	.+76     	; 0x2652 <USB_Device_ProcessControlRequest+0x124>
			{
				uint8_t EndpointIndex = ((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
    2606:	20 91 dd 13 	lds	r18, 0x13DD
    260a:	2f 70       	andi	r18, 0x0F	; 15

				if (EndpointIndex == ENDPOINT_CONTROLEP)
    260c:	09 f4       	brne	.+2      	; 0x2610 <USB_Device_ProcessControlRequest+0xe2>
    260e:	cb c0       	rjmp	.+406    	; 0x27a6 <USB_Device_ProcessControlRequest+0x278>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    2610:	20 93 e9 00 	sts	0x00E9, r18
			 * \return Boolean \c true if the currently selected endpoint is enabled, \c false otherwise.
			 */
			static inline bool Endpoint_IsEnabled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsEnabled(void)
			{
				return ((UECONX & (1 << EPEN)) ? true : false);
    2614:	90 91 eb 00 	lds	r25, 0x00EB
				  return;

				Endpoint_SelectEndpoint(EndpointIndex);

				if (Endpoint_IsEnabled())
    2618:	90 ff       	sbrs	r25, 0
    261a:	1b c0       	rjmp	.+54     	; 0x2652 <USB_Device_ProcessControlRequest+0x124>
				{
					if (USB_ControlRequest.bRequest == REQ_SetFeature)
    261c:	83 30       	cpi	r24, 0x03	; 3
    261e:	21 f4       	brne	.+8      	; 0x2628 <USB_Device_ProcessControlRequest+0xfa>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    2620:	80 91 eb 00 	lds	r24, 0x00EB
    2624:	80 62       	ori	r24, 0x20	; 32
    2626:	13 c0       	rjmp	.+38     	; 0x264e <USB_Device_ProcessControlRequest+0x120>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearStall(void)
			{
				UECONX |= (1 << STALLRQC);
    2628:	80 91 eb 00 	lds	r24, 0x00EB
    262c:	80 61       	ori	r24, 0x10	; 16
    262e:	80 93 eb 00 	sts	0x00EB, r24
			 *  \param[in] Address  Endpoint address whose FIFO buffers are to be reset.
			 */
			static inline void Endpoint_ResetEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetEndpoint(const uint8_t Address)
			{
				UERST = (1 << (Address & ENDPOINT_EPNUM_MASK));
    2632:	81 e0       	ldi	r24, 0x01	; 1
    2634:	90 e0       	ldi	r25, 0x00	; 0
    2636:	02 2e       	mov	r0, r18
    2638:	01 c0       	rjmp	.+2      	; 0x263c <USB_Device_ProcessControlRequest+0x10e>
    263a:	88 0f       	add	r24, r24
    263c:	0a 94       	dec	r0
    263e:	ea f7       	brpl	.-6      	; 0x263a <USB_Device_ProcessControlRequest+0x10c>
    2640:	80 93 ea 00 	sts	0x00EA, r24
				UERST = 0;
    2644:	10 92 ea 00 	sts	0x00EA, r1

			/** Resets the data toggle of the currently selected endpoint. */
			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetDataToggle(void)
			{
				UECONX |= (1 << RSTDT);
    2648:	80 91 eb 00 	lds	r24, 0x00EB
    264c:	88 60       	ori	r24, 0x08	; 8
    264e:	80 93 eb 00 	sts	0x00EB, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    2652:	10 92 e9 00 	sts	0x00E9, r1
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2656:	80 91 e8 00 	lds	r24, 0x00E8
    265a:	87 7f       	andi	r24, 0xF7	; 247
    265c:	83 c0       	rjmp	.+262    	; 0x2764 <USB_Device_ProcessControlRequest+0x236>
					USB_Device_ClearSetFeature();
				}

				break;
			case REQ_SetAddress:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    265e:	91 11       	cpse	r25, r1
    2660:	a2 c0       	rjmp	.+324    	; 0x27a6 <USB_Device_ProcessControlRequest+0x278>
	}
}

static void USB_Device_SetAddress(void)
{
	uint8_t DeviceAddress = (USB_ControlRequest.wValue & 0x7F);
    2662:	10 91 db 13 	lds	r17, 0x13DB
    2666:	1f 77       	andi	r17, 0x7F	; 127
			#endif

			static inline void USB_Device_SetDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetDeviceAddress(const uint8_t Address)
			{
				UDADDR = (UDADDR & (1 << ADDEN)) | (Address & 0x7F);
    2668:	80 91 e3 00 	lds	r24, 0x00E3
    266c:	80 78       	andi	r24, 0x80	; 128
    266e:	81 2b       	or	r24, r17
    2670:	80 93 e3 00 	sts	0x00E3, r24
    2674:	80 91 e8 00 	lds	r24, 0x00E8
    2678:	87 7f       	andi	r24, 0xF7	; 247
    267a:	80 93 e8 00 	sts	0x00E8, r24

	USB_Device_SetDeviceAddress(DeviceAddress);

	Endpoint_ClearSETUP();

	Endpoint_ClearStatusStage();
    267e:	da dd       	rcall	.-1100   	; 0x2234 <Endpoint_ClearStatusStage>
    2680:	80 91 e8 00 	lds	r24, 0x00E8
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    2684:	80 ff       	sbrs	r24, 0

	while (!(Endpoint_IsINReady()));
    2686:	fc cf       	rjmp	.-8      	; 0x2680 <USB_Device_ProcessControlRequest+0x152>
    2688:	80 91 e3 00 	lds	r24, 0x00E3
			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address)
			{
				(void)Address;

				UDADDR |= (1 << ADDEN);
    268c:	80 68       	ori	r24, 0x80	; 128
    268e:	80 93 e3 00 	sts	0x00E3, r24
    2692:	11 23       	and	r17, r17

	USB_Device_EnableDeviceAddress(DeviceAddress);

	USB_DeviceState = (DeviceAddress) ? DEVICE_STATE_Addressed : DEVICE_STATE_Default;
    2694:	11 f0       	breq	.+4      	; 0x269a <USB_Device_ProcessControlRequest+0x16c>
    2696:	83 e0       	ldi	r24, 0x03	; 3
    2698:	01 c0       	rjmp	.+2      	; 0x269c <USB_Device_ProcessControlRequest+0x16e>
    269a:	82 e0       	ldi	r24, 0x02	; 2
    269c:	80 93 d8 13 	sts	0x13D8, r24
    26a0:	82 c0       	rjmp	.+260    	; 0x27a6 <USB_Device_ProcessControlRequest+0x278>
    26a2:	90 58       	subi	r25, 0x80	; 128
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_SetAddress();

				break;
			case REQ_GetDescriptor:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    26a4:	92 30       	cpi	r25, 0x02	; 2
    26a6:	08 f0       	brcs	.+2      	; 0x26aa <USB_Device_ProcessControlRequest+0x17c>
    26a8:	7e c0       	rjmp	.+252    	; 0x27a6 <USB_Device_ProcessControlRequest+0x278>
    26aa:	80 91 db 13 	lds	r24, 0x13DB
	    !(defined(USE_FLASH_DESCRIPTORS) || defined(USE_EEPROM_DESCRIPTORS) || defined(USE_RAM_DESCRIPTORS))
	uint8_t DescriptorAddressSpace;
	#endif

	#if !defined(NO_INTERNAL_SERIAL) && (USE_INTERNAL_SERIAL != NO_DESCRIPTOR)
	if (USB_ControlRequest.wValue == ((DTYPE_String << 8) | USE_INTERNAL_SERIAL))
    26ae:	90 91 dc 13 	lds	r25, 0x13DC
    26b2:	8c 3d       	cpi	r24, 0xDC	; 220
    26b4:	23 e0       	ldi	r18, 0x03	; 3
    26b6:	92 07       	cpc	r25, r18
    26b8:	71 f5       	brne	.+92     	; 0x2716 <USB_Device_ProcessControlRequest+0x1e8>
    26ba:	83 e0       	ldi	r24, 0x03	; 3
	{
		USB_Descriptor_Header_t Header;
		uint16_t                UnicodeString[INTERNAL_SERIAL_LENGTH_BITS / 4];
	} SignatureDescriptor;

	SignatureDescriptor.Header.Type = DTYPE_String;
    26bc:	8a 83       	std	Y+2, r24	; 0x02
    26be:	8a e2       	ldi	r24, 0x2A	; 42
	SignatureDescriptor.Header.Size = USB_STRING_LEN(INTERNAL_SERIAL_LENGTH_BITS / 4);
    26c0:	89 83       	std	Y+1, r24	; 0x01
    26c2:	4f b7       	in	r20, 0x3f	; 63
			static inline uint_reg_t GetGlobalInterruptMask(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				return SREG;
    26c4:	f8 94       	cli
			static inline void GlobalInterruptDisable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				cli();
    26c6:	de 01       	movw	r26, r28
				__builtin_ssrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				cli();
				#endif

				GCC_MEMORY_BARRIER();
    26c8:	13 96       	adiw	r26, 0x03	; 3
    26ca:	20 e0       	ldi	r18, 0x00	; 0
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
    26cc:	3e e0       	ldi	r19, 0x0E	; 14
			static inline void USB_Device_GetSerialString(uint16_t* const UnicodeString)
			{
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;
    26ce:	51 e2       	ldi	r21, 0x21	; 33

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
				{
					uint8_t SerialByte = boot_signature_byte_get(SigReadAddress);
    26d0:	e3 2f       	mov	r30, r19
    26d2:	f0 e0       	ldi	r31, 0x00	; 0
    26d4:	50 93 57 00 	sts	0x0057, r21
    26d8:	e4 91       	lpm	r30, Z
    26da:	20 ff       	sbrs	r18, 0

					if (SerialCharNum & 0x01)
    26dc:	03 c0       	rjmp	.+6      	; 0x26e4 <USB_Device_ProcessControlRequest+0x1b6>
    26de:	e2 95       	swap	r30
					{
						SerialByte >>= 4;
    26e0:	ef 70       	andi	r30, 0x0F	; 15
    26e2:	3f 5f       	subi	r19, 0xFF	; 255
						SigReadAddress++;
    26e4:	ef 70       	andi	r30, 0x0F	; 15
					}

					SerialByte &= 0x0F;
    26e6:	8e 2f       	mov	r24, r30
    26e8:	90 e0       	ldi	r25, 0x00	; 0
    26ea:	ea 30       	cpi	r30, 0x0A	; 10

					UnicodeString[SerialCharNum] = cpu_to_le16((SerialByte >= 10) ?
    26ec:	10 f0       	brcs	.+4      	; 0x26f2 <USB_Device_ProcessControlRequest+0x1c4>
    26ee:	c7 96       	adiw	r24, 0x37	; 55
    26f0:	01 c0       	rjmp	.+2      	; 0x26f4 <USB_Device_ProcessControlRequest+0x1c6>
    26f2:	c0 96       	adiw	r24, 0x30	; 48
    26f4:	8d 93       	st	X+, r24
    26f6:	9d 93       	st	X+, r25
    26f8:	2f 5f       	subi	r18, 0xFF	; 255
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
    26fa:	24 31       	cpi	r18, 0x14	; 20
    26fc:	49 f7       	brne	.-46     	; 0x26d0 <USB_Device_ProcessControlRequest+0x1a2>
    26fe:	4f bf       	out	0x3f, r20	; 63
			static inline void SetGlobalInterruptMask(const uint_reg_t GlobalIntState)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				SREG = GlobalIntState;
    2700:	80 91 e8 00 	lds	r24, 0x00E8
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2704:	87 7f       	andi	r24, 0xF7	; 247
    2706:	80 93 e8 00 	sts	0x00E8, r24
    270a:	6a e2       	ldi	r22, 0x2A	; 42

	USB_Device_GetSerialString(SignatureDescriptor.UnicodeString);

	Endpoint_ClearSETUP();

	Endpoint_Write_Control_Stream_LE(&SignatureDescriptor, sizeof(SignatureDescriptor));
    270c:	70 e0       	ldi	r23, 0x00	; 0
    270e:	ce 01       	movw	r24, r28
    2710:	01 96       	adiw	r24, 0x01	; 1
    2712:	60 dc       	rcall	.-1856   	; 0x1fd4 <Endpoint_Write_Control_Stream_LE>
    2714:	13 c0       	rjmp	.+38     	; 0x273c <USB_Device_ProcessControlRequest+0x20e>
    2716:	ae 01       	movw	r20, r28
    2718:	4f 5f       	subi	r20, 0xFF	; 255
		USB_Device_GetInternalSerialDescriptor();
		return;
	}
	#endif

	if ((DescriptorSize = CALLBACK_USB_GetDescriptor(USB_ControlRequest.wValue, USB_ControlRequest.wIndex,
    271a:	5f 4f       	sbci	r21, 0xFF	; 255
    271c:	60 91 dd 13 	lds	r22, 0x13DD
    2720:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <CALLBACK_USB_GetDescriptor>
    2724:	00 97       	sbiw	r24, 0x00	; 0
    2726:	09 f4       	brne	.+2      	; 0x272a <USB_Device_ProcessControlRequest+0x1fc>
    2728:	3e c0       	rjmp	.+124    	; 0x27a6 <USB_Device_ProcessControlRequest+0x278>
    272a:	20 91 e8 00 	lds	r18, 0x00E8
    272e:	27 7f       	andi	r18, 0xF7	; 247
    2730:	20 93 e8 00 	sts	0x00E8, r18
    2734:	bc 01       	movw	r22, r24
    2736:	89 81       	ldd	r24, Y+1	; 0x01
	#if defined(USE_RAM_DESCRIPTORS) || !defined(ARCH_HAS_MULTI_ADDRESS_SPACE)
	Endpoint_Write_Control_Stream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_EEPROM_DESCRIPTORS)
	Endpoint_Write_Control_EStream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_FLASH_DESCRIPTORS)
	Endpoint_Write_Control_PStream_LE(DescriptorPointer, DescriptorSize);
    2738:	9a 81       	ldd	r25, Y+2	; 0x02
    273a:	e7 dc       	rcall	.-1586   	; 0x210a <Endpoint_Write_Control_PStream_LE>
    273c:	80 91 e8 00 	lds	r24, 0x00E8
    2740:	8b 77       	andi	r24, 0x7B	; 123
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    2742:	80 93 e8 00 	sts	0x00E8, r24
    2746:	2f c0       	rjmp	.+94     	; 0x27a6 <USB_Device_ProcessControlRequest+0x278>
    2748:	90 38       	cpi	r25, 0x80	; 128
    274a:	69 f5       	brne	.+90     	; 0x27a6 <USB_Device_ProcessControlRequest+0x278>
    274c:	80 91 e8 00 	lds	r24, 0x00E8
					USB_Device_GetDescriptor();
				}

				break;
			case REQ_GetConfiguration:
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
    2750:	87 7f       	andi	r24, 0xF7	; 247
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2752:	80 93 e8 00 	sts	0x00E8, r24
    2756:	80 91 d4 13 	lds	r24, 0x13D4
    275a:	80 93 f1 00 	sts	0x00F1, r24

static void USB_Device_GetConfiguration(void)
{
	Endpoint_ClearSETUP();

	Endpoint_Write_8(USB_Device_ConfigurationNumber);
    275e:	80 91 e8 00 	lds	r24, 0x00E8
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    2762:	8e 77       	andi	r24, 0x7E	; 126
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    2764:	80 93 e8 00 	sts	0x00E8, r24
    2768:	65 dd       	rcall	.-1334   	; 0x2234 <Endpoint_ClearStatusStage>
    276a:	1d c0       	rjmp	.+58     	; 0x27a6 <USB_Device_ProcessControlRequest+0x278>
    276c:	91 11       	cpse	r25, r1
	Endpoint_ClearIN();

	Endpoint_ClearStatusStage();
    276e:	1b c0       	rjmp	.+54     	; 0x27a6 <USB_Device_ProcessControlRequest+0x278>
    2770:	90 91 db 13 	lds	r25, 0x13DB
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_GetConfiguration();

				break;
			case REQ_SetConfiguration:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    2774:	92 30       	cpi	r25, 0x02	; 2
    2776:	b8 f4       	brcc	.+46     	; 0x27a6 <USB_Device_ProcessControlRequest+0x278>
}

static void USB_Device_SetConfiguration(void)
{
	#if defined(FIXED_NUM_CONFIGURATIONS)
	if ((uint8_t)USB_ControlRequest.wValue > FIXED_NUM_CONFIGURATIONS)
    2778:	80 91 e8 00 	lds	r24, 0x00E8
    277c:	87 7f       	andi	r24, 0xF7	; 247
    277e:	80 93 e8 00 	sts	0x00E8, r24
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2782:	90 93 d4 13 	sts	0x13D4, r25
    2786:	56 dd       	rcall	.-1364   	; 0x2234 <Endpoint_ClearStatusStage>
    2788:	80 91 d4 13 	lds	r24, 0x13D4
	#endif
	#endif

	Endpoint_ClearSETUP();

	USB_Device_ConfigurationNumber = (uint8_t)USB_ControlRequest.wValue;
    278c:	81 11       	cpse	r24, r1

	Endpoint_ClearStatusStage();
    278e:	04 c0       	rjmp	.+8      	; 0x2798 <USB_Device_ProcessControlRequest+0x26a>
    2790:	80 91 e3 00 	lds	r24, 0x00E3

	if (USB_Device_ConfigurationNumber)
    2794:	87 ff       	sbrs	r24, 7
    2796:	02 c0       	rjmp	.+4      	; 0x279c <USB_Device_ProcessControlRequest+0x26e>
    2798:	84 e0       	ldi	r24, 0x04	; 4
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
    279a:	01 c0       	rjmp	.+2      	; 0x279e <USB_Device_ProcessControlRequest+0x270>
    279c:	81 e0       	ldi	r24, 0x01	; 1
	  USB_DeviceState = DEVICE_STATE_Configured;
	else
	  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
    279e:	80 93 d8 13 	sts	0x13D8, r24
    27a2:	0e 94 76 02 	call	0x4ec	; 0x4ec <EVENT_USB_Device_ConfigurationChanged>
    27a6:	80 91 e8 00 	lds	r24, 0x00E8
    27aa:	83 ff       	sbrs	r24, 3

	EVENT_USB_Device_ConfigurationChanged();
    27ac:	0a c0       	rjmp	.+20     	; 0x27c2 <USB_Device_ProcessControlRequest+0x294>
    27ae:	80 91 e8 00 	lds	r24, 0x00E8
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    27b2:	87 7f       	andi	r24, 0xF7	; 247
			default:
				break;
		}
	}

	if (Endpoint_IsSETUPReceived())
    27b4:	80 93 e8 00 	sts	0x00E8, r24
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    27b8:	80 91 eb 00 	lds	r24, 0x00EB
    27bc:	80 62       	ori	r24, 0x20	; 32
    27be:	80 93 eb 00 	sts	0x00EB, r24
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    27c2:	aa 96       	adiw	r28, 0x2a	; 42
    27c4:	0f b6       	in	r0, 0x3f	; 63
    27c6:	f8 94       	cli
    27c8:	de bf       	out	0x3e, r29	; 62
    27ca:	0f be       	out	0x3f, r0	; 63
	{
		Endpoint_ClearSETUP();
		Endpoint_StallTransaction();
	}
}
    27cc:	cd bf       	out	0x3d, r28	; 61
    27ce:	df 91       	pop	r29
    27d0:	cf 91       	pop	r28
    27d2:	1f 91       	pop	r17
    27d4:	08 95       	ret

000027d6 <USB_Event_Stub>:
    27d6:	08 95       	ret

000027d8 <USB_USBTask>:
    27d8:	cf 93       	push	r28
    27da:	80 91 d8 13 	lds	r24, 0x13D8
    27de:	88 23       	and	r24, r24
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_DeviceTask(void)
{
	if (USB_DeviceState == DEVICE_STATE_Unattached)
    27e0:	a9 f0       	breq	.+42     	; 0x280c <USB_USBTask+0x34>
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return ((UENUM & ENDPOINT_EPNUM_MASK) | Endpoint_GetEndpointDirection());
    27e2:	80 91 e9 00 	lds	r24, 0x00E9
    27e6:	8f 70       	andi	r24, 0x0F	; 15
			 *  \return The currently selected endpoint's direction, as a \c ENDPOINT_DIR_* mask.
			 */
			static inline uint8_t Endpoint_GetEndpointDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetEndpointDirection(void)
			{
				return (UECFG0X & (1 << EPDIR)) ? ENDPOINT_DIR_IN : ENDPOINT_DIR_OUT;
    27e8:	90 91 ec 00 	lds	r25, 0x00EC
    27ec:	90 ff       	sbrs	r25, 0
    27ee:	02 c0       	rjmp	.+4      	; 0x27f4 <USB_USBTask+0x1c>
    27f0:	90 e8       	ldi	r25, 0x80	; 128
    27f2:	01 c0       	rjmp	.+2      	; 0x27f6 <USB_USBTask+0x1e>
    27f4:	90 e0       	ldi	r25, 0x00	; 0
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return ((UENUM & ENDPOINT_EPNUM_MASK) | Endpoint_GetEndpointDirection());
    27f6:	c9 2f       	mov	r28, r25
    27f8:	c8 2b       	or	r28, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    27fa:	10 92 e9 00 	sts	0x00E9, r1
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    27fe:	80 91 e8 00 	lds	r24, 0x00E8

	uint8_t PrevEndpoint = Endpoint_GetCurrentEndpoint();

	Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);

	if (Endpoint_IsSETUPReceived())
    2802:	83 fd       	sbrc	r24, 3
	  USB_Device_ProcessControlRequest();
    2804:	94 de       	rcall	.-728    	; 0x252e <USB_Device_ProcessControlRequest>
    2806:	cf 70       	andi	r28, 0x0F	; 15
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    2808:	c0 93 e9 00 	sts	0x00E9, r28
    280c:	cf 91       	pop	r28
	#elif defined(USB_CAN_BE_HOST)
		USB_HostTask();
	#elif defined(USB_CAN_BE_DEVICE)
		USB_DeviceTask();
	#endif
}
    280e:	08 95       	ret

00002810 <Serial_putchar>:
    2810:	90 91 c8 00 	lds	r25, 0x00C8
			 *  \param[in] DataByte  Byte to transmit through the USART.
			 */
			static inline void Serial_SendByte(const char DataByte) ATTR_ALWAYS_INLINE;
			static inline void Serial_SendByte(const char DataByte)
			{
				while (!(Serial_IsSendReady()));
    2814:	95 ff       	sbrs	r25, 5
    2816:	fc cf       	rjmp	.-8      	; 0x2810 <Serial_putchar>
				UDR1 = DataByte;
    2818:	80 93 ce 00 	sts	0x00CE, r24
{
	(void)Stream;

	Serial_SendByte(DataByte);
	return 0;
}
    281c:	80 e0       	ldi	r24, 0x00	; 0
    281e:	90 e0       	ldi	r25, 0x00	; 0
    2820:	08 95       	ret

00002822 <Serial_getchar>:
			 *  \return Boolean \c true if a character has been received, \c false otherwise.
			 */
			static inline bool Serial_IsCharReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Serial_IsCharReceived(void)
			{
				return ((UCSR1A & (1 << RXC1)) ? true : false);
    2822:	80 91 c8 00 	lds	r24, 0x00C8

int Serial_getchar(FILE *Stream)
{
	(void)Stream;

	if (!(Serial_IsCharReceived()))
    2826:	87 ff       	sbrs	r24, 7
    2828:	08 c0       	rjmp	.+16     	; 0x283a <Serial_getchar+0x18>
    282a:	80 91 c8 00 	lds	r24, 0x00C8
			 *  \return Next byte received from the USART, or a negative value if no byte has been received.
			 */
			static inline int16_t Serial_ReceiveByte(void) ATTR_ALWAYS_INLINE;
			static inline int16_t Serial_ReceiveByte(void)
			{
				if (!(Serial_IsCharReceived()))
    282e:	87 ff       	sbrs	r24, 7
    2830:	07 c0       	rjmp	.+14     	; 0x2840 <Serial_getchar+0x1e>
				  return -1;

				return UDR1;
    2832:	80 91 ce 00 	lds	r24, 0x00CE
    2836:	90 e0       	ldi	r25, 0x00	; 0
    2838:	08 95       	ret
	  return _FDEV_EOF;
    283a:	8e ef       	ldi	r24, 0xFE	; 254
    283c:	9f ef       	ldi	r25, 0xFF	; 255
    283e:	08 95       	ret
			 */
			static inline int16_t Serial_ReceiveByte(void) ATTR_ALWAYS_INLINE;
			static inline int16_t Serial_ReceiveByte(void)
			{
				if (!(Serial_IsCharReceived()))
				  return -1;
    2840:	8f ef       	ldi	r24, 0xFF	; 255
    2842:	9f ef       	ldi	r25, 0xFF	; 255

	return Serial_ReceiveByte();
}
    2844:	08 95       	ret

00002846 <Serial_CreateStream>:
	while (Length--)
	  Serial_SendByte(*((uint8_t*)Buffer++));
}

void Serial_CreateStream(FILE* Stream)
{
    2846:	fc 01       	movw	r30, r24
	if (!(Stream))
    2848:	00 97       	sbiw	r24, 0x00	; 0
    284a:	59 f4       	brne	.+22     	; 0x2862 <Serial_CreateStream+0x1c>
	{
		Stream = &USARTSerialStream;
		stdin  = Stream;
    284c:	81 ee       	ldi	r24, 0xE1	; 225
    284e:	93 e1       	ldi	r25, 0x13	; 19
    2850:	90 93 f0 13 	sts	0x13F0, r25
    2854:	80 93 ef 13 	sts	0x13EF, r24
		stdout = Stream;
    2858:	90 93 f2 13 	sts	0x13F2, r25
    285c:	80 93 f1 13 	sts	0x13F1, r24

void Serial_CreateStream(FILE* Stream)
{
	if (!(Stream))
	{
		Stream = &USARTSerialStream;
    2860:	fc 01       	movw	r30, r24
		stdin  = Stream;
		stdout = Stream;
	}

	*Stream = (FILE)FDEV_SETUP_STREAM(Serial_putchar, Serial_getchar, _FDEV_SETUP_RW);
    2862:	8e e0       	ldi	r24, 0x0E	; 14
    2864:	df 01       	movw	r26, r30
    2866:	1d 92       	st	X+, r1
    2868:	8a 95       	dec	r24
    286a:	e9 f7       	brne	.-6      	; 0x2866 <Serial_CreateStream+0x20>
    286c:	83 e0       	ldi	r24, 0x03	; 3
    286e:	83 83       	std	Z+3, r24	; 0x03
    2870:	88 e0       	ldi	r24, 0x08	; 8
    2872:	94 e1       	ldi	r25, 0x14	; 20
    2874:	91 87       	std	Z+9, r25	; 0x09
    2876:	80 87       	std	Z+8, r24	; 0x08
    2878:	81 e1       	ldi	r24, 0x11	; 17
    287a:	94 e1       	ldi	r25, 0x14	; 20
    287c:	93 87       	std	Z+11, r25	; 0x0b
    287e:	82 87       	std	Z+10, r24	; 0x0a
    2880:	08 95       	ret

00002882 <memcpy_P>:
    2882:	fb 01       	movw	r30, r22
    2884:	dc 01       	movw	r26, r24
    2886:	02 c0       	rjmp	.+4      	; 0x288c <memcpy_P+0xa>
    2888:	05 90       	lpm	r0, Z+
    288a:	0d 92       	st	X+, r0
    288c:	41 50       	subi	r20, 0x01	; 1
    288e:	50 40       	sbci	r21, 0x00	; 0
    2890:	d8 f7       	brcc	.-10     	; 0x2888 <memcpy_P+0x6>
    2892:	08 95       	ret

00002894 <strcpy_P>:
    2894:	fb 01       	movw	r30, r22
    2896:	dc 01       	movw	r26, r24
    2898:	05 90       	lpm	r0, Z+
    289a:	0d 92       	st	X+, r0
    289c:	00 20       	and	r0, r0
    289e:	e1 f7       	brne	.-8      	; 0x2898 <strcpy_P+0x4>
    28a0:	08 95       	ret

000028a2 <__strlen_P>:
    28a2:	fc 01       	movw	r30, r24
    28a4:	05 90       	lpm	r0, Z+
    28a6:	00 20       	and	r0, r0
    28a8:	e9 f7       	brne	.-6      	; 0x28a4 <__strlen_P+0x2>
    28aa:	80 95       	com	r24
    28ac:	90 95       	com	r25
    28ae:	8e 0f       	add	r24, r30
    28b0:	9f 1f       	adc	r25, r31
    28b2:	08 95       	ret

000028b4 <strncpy_P>:
    28b4:	fb 01       	movw	r30, r22
    28b6:	dc 01       	movw	r26, r24
    28b8:	41 50       	subi	r20, 0x01	; 1
    28ba:	50 40       	sbci	r21, 0x00	; 0
    28bc:	48 f0       	brcs	.+18     	; 0x28d0 <strncpy_P+0x1c>
    28be:	05 90       	lpm	r0, Z+
    28c0:	0d 92       	st	X+, r0
    28c2:	00 20       	and	r0, r0
    28c4:	c9 f7       	brne	.-14     	; 0x28b8 <strncpy_P+0x4>
    28c6:	01 c0       	rjmp	.+2      	; 0x28ca <strncpy_P+0x16>
    28c8:	1d 92       	st	X+, r1
    28ca:	41 50       	subi	r20, 0x01	; 1
    28cc:	50 40       	sbci	r21, 0x00	; 0
    28ce:	e0 f7       	brcc	.-8      	; 0x28c8 <strncpy_P+0x14>
    28d0:	08 95       	ret

000028d2 <memcmp>:
    28d2:	fb 01       	movw	r30, r22
    28d4:	dc 01       	movw	r26, r24
    28d6:	04 c0       	rjmp	.+8      	; 0x28e0 <memcmp+0xe>
    28d8:	8d 91       	ld	r24, X+
    28da:	01 90       	ld	r0, Z+
    28dc:	80 19       	sub	r24, r0
    28de:	21 f4       	brne	.+8      	; 0x28e8 <memcmp+0x16>
    28e0:	41 50       	subi	r20, 0x01	; 1
    28e2:	50 40       	sbci	r21, 0x00	; 0
    28e4:	c8 f7       	brcc	.-14     	; 0x28d8 <memcmp+0x6>
    28e6:	88 1b       	sub	r24, r24
    28e8:	99 0b       	sbc	r25, r25
    28ea:	08 95       	ret

000028ec <memcpy>:
    28ec:	fb 01       	movw	r30, r22
    28ee:	dc 01       	movw	r26, r24
    28f0:	02 c0       	rjmp	.+4      	; 0x28f6 <memcpy+0xa>
    28f2:	01 90       	ld	r0, Z+
    28f4:	0d 92       	st	X+, r0
    28f6:	41 50       	subi	r20, 0x01	; 1
    28f8:	50 40       	sbci	r21, 0x00	; 0
    28fa:	d8 f7       	brcc	.-10     	; 0x28f2 <memcpy+0x6>
    28fc:	08 95       	ret

000028fe <memmove>:
    28fe:	68 17       	cp	r22, r24
    2900:	79 07       	cpc	r23, r25
    2902:	68 f4       	brcc	.+26     	; 0x291e <memmove+0x20>
    2904:	fb 01       	movw	r30, r22
    2906:	dc 01       	movw	r26, r24
    2908:	e4 0f       	add	r30, r20
    290a:	f5 1f       	adc	r31, r21
    290c:	a4 0f       	add	r26, r20
    290e:	b5 1f       	adc	r27, r21
    2910:	02 c0       	rjmp	.+4      	; 0x2916 <memmove+0x18>
    2912:	02 90       	ld	r0, -Z
    2914:	0e 92       	st	-X, r0
    2916:	41 50       	subi	r20, 0x01	; 1
    2918:	50 40       	sbci	r21, 0x00	; 0
    291a:	d8 f7       	brcc	.-10     	; 0x2912 <memmove+0x14>
    291c:	08 95       	ret
    291e:	e6 cf       	rjmp	.-52     	; 0x28ec <memcpy>

00002920 <strncmp>:
    2920:	fb 01       	movw	r30, r22
    2922:	dc 01       	movw	r26, r24
    2924:	41 50       	subi	r20, 0x01	; 1
    2926:	50 40       	sbci	r21, 0x00	; 0
    2928:	30 f0       	brcs	.+12     	; 0x2936 <strncmp+0x16>
    292a:	8d 91       	ld	r24, X+
    292c:	01 90       	ld	r0, Z+
    292e:	80 19       	sub	r24, r0
    2930:	19 f4       	brne	.+6      	; 0x2938 <strncmp+0x18>
    2932:	00 20       	and	r0, r0
    2934:	b9 f7       	brne	.-18     	; 0x2924 <strncmp+0x4>
    2936:	88 1b       	sub	r24, r24
    2938:	99 0b       	sbc	r25, r25
    293a:	08 95       	ret

0000293c <_exit>:
    293c:	f8 94       	cli

0000293e <__stop_program>:
    293e:	ff cf       	rjmp	.-2      	; 0x293e <__stop_program>
