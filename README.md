# Arduino-uno-usb-pentest

So we decided to do our final project on USB Pen-testing using an arduino uno. There have

have been may hacks posted with Teensy, but they lack many features like OS detection and 

stealth. So our project focused on OS detection, techniques in hiding the payload deployment 

and deploying persistent payloads. 

   There is a reason why we chose Arduino uno. There is USB keyboard protocol 

supported by the Atmega16u2 that performs all the USB communication with the computer, 

while the Atmega328 mcu is free to run the User code. With the LUFA project and 

http://hunt.net.nz/users/darran/ support we were successful in tweaking the usb firmware that 

distinguishes Windows computers from the rest. This was the toughest challenge for us, as 

USB protocol are one of the most complex communication protocol that exist today, and we 

spent most of our time finding the hack and making it successful.

For Usb 2.0 devices and above the windows (xp sp3 to win 8.1) issued an OS specific 

string descriptor at offset 0xEE, i.e (wvalue = 0x03EE). Hence during the enumeration 

process, we needed to lookout for this descriptor and set appropriate Boolean flag. The 

second challenge was to convey the Atmega328 about this change. The hack lies the 

keyboardâ€™s response received to keys: num lock , scroll lock  and caps lock, which held the 

data to turn on the respective LEDs. Hence in the LED packets, we sent the Boolean value 1 

if we detected a windows OS or else 0 if it was a Linux OS. Although I completely crushed 

the led report packet (8 bits in size), we could use the 4th bit in 8 bit value for the OS report 

(bits 0,1,2,3 are used for Led indicators).

Some of the stealth techniques that we discovered were that we could able to open up a 

terminal and the command that hid everything that was typed or printed on that terminal. So 

when we plugged in the USB, it would open up a terminal and setup a reverse SSH protocol 

combined with a python keylogger that the USB typed out and executed. The process did not 

end when the terminal was shut and also was added to the startup of the computer.

I could explain and type up the whole process to build the firmware, burn it, load the 

sketch, but there is already a great write-up at http://hunt.net.nz/users/darran/  for this 

process. With this project we are including the all the necessary source files, hex files and the 

pde files to replicate our project.
